/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON$3 = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals$a(a, b) {
  return Math.abs(a - b) <= EPSILON$3 * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

var common$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ARRAY_TYPE () { return ARRAY_TYPE; },
  EPSILON: EPSILON$3,
  RANDOM: RANDOM,
  equals: equals$a,
  setMatrixArrayType: setMatrixArrayType,
  toRadian: toRadian
});

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create$8() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone$8(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy$8(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity$5(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues$8(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set$9(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose$2(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert$6(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint$2(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant$3(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply$9(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate$4(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale$9(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation$4(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling$3(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str$8(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob$3(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add$9(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract$7(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals$8(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals$9(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar$3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd$3(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul$8 = multiply$9;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub$6 = subtract$7;

var mat2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LDU: LDU,
  add: add$9,
  adjoint: adjoint$2,
  clone: clone$8,
  copy: copy$8,
  create: create$8,
  determinant: determinant$3,
  equals: equals$9,
  exactEquals: exactEquals$8,
  frob: frob$3,
  fromRotation: fromRotation$4,
  fromScaling: fromScaling$3,
  fromValues: fromValues$8,
  identity: identity$5,
  invert: invert$6,
  mul: mul$8,
  multiply: multiply$9,
  multiplyScalar: multiplyScalar$3,
  multiplyScalarAndAdd: multiplyScalarAndAdd$3,
  rotate: rotate$4,
  scale: scale$9,
  set: set$9,
  str: str$8,
  sub: sub$6,
  subtract: subtract$7,
  transpose: transpose$2
});

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create$7() {
  var out = new ARRAY_TYPE(6);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone$7(a) {
  var out = new ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy$7(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity$4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues$7(a, b, c, d, tx, ty) {
  var out = new ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set$8(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert$5(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant$2(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply$8(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate$3(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale$8(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate$3(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation$3(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling$2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation$3(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str$7(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob$2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add$8(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract$6(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar$2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd$2(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals$7(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals$8(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul$7 = multiply$8;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub$5 = subtract$6;

var mat2d = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$8,
  clone: clone$7,
  copy: copy$7,
  create: create$7,
  determinant: determinant$2,
  equals: equals$8,
  exactEquals: exactEquals$7,
  frob: frob$2,
  fromRotation: fromRotation$3,
  fromScaling: fromScaling$2,
  fromTranslation: fromTranslation$3,
  fromValues: fromValues$7,
  identity: identity$4,
  invert: invert$5,
  mul: mul$7,
  multiply: multiply$8,
  multiplyScalar: multiplyScalar$2,
  multiplyScalarAndAdd: multiplyScalarAndAdd$2,
  rotate: rotate$3,
  scale: scale$8,
  set: set$8,
  str: str$7,
  sub: sub$5,
  subtract: subtract$6,
  translate: translate$3
});

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create$6() {
  var out = new ARRAY_TYPE(9);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone$6(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy$6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues$6(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set$7(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity$3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose$1(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert$4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint$1(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant$1(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply$7(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate$2(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate$2(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale$7(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation$2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation$2(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling$1(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat$1(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str$6(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob$1(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add$7(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract$5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar$1(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd$1(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals$6(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals$7(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$3 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$3 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON$3 * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul$6 = multiply$7;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub$4 = subtract$5;

var mat3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$7,
  adjoint: adjoint$1,
  clone: clone$6,
  copy: copy$6,
  create: create$6,
  determinant: determinant$1,
  equals: equals$7,
  exactEquals: exactEquals$6,
  frob: frob$1,
  fromMat2d: fromMat2d,
  fromMat4: fromMat4$1,
  fromQuat: fromQuat$1,
  fromRotation: fromRotation$2,
  fromScaling: fromScaling$1,
  fromTranslation: fromTranslation$2,
  fromValues: fromValues$6,
  identity: identity$3,
  invert: invert$4,
  mul: mul$6,
  multiply: multiply$7,
  multiplyScalar: multiplyScalar$1,
  multiplyScalarAndAdd: multiplyScalarAndAdd$1,
  normalFromMat4: normalFromMat4,
  projection: projection,
  rotate: rotate$2,
  scale: scale$7,
  set: set$7,
  str: str$6,
  sub: sub$4,
  subtract: subtract$5,
  translate: translate$2,
  transpose: transpose$1
});

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create$5() {
  var out = new ARRAY_TYPE(16);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone$5(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy$5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set$6(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity$2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert$3(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply$6(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate$1(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale$6(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate$1(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < EPSILON$3) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation$1(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation$1(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < EPSILON$3) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation$1(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation$1(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation$1(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON$3 && Math.abs(eyey - centery) < EPSILON$3 && Math.abs(eyez - centerz) < EPSILON$3) {
    return identity$2(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str$5(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add$6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract$4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals$5(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals$6(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$3 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$3 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON$3 * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON$3 * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON$3 * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON$3 * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON$3 * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON$3 * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON$3 * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON$3 * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul$5 = multiply$6;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub$3 = subtract$4;

var mat4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$6,
  adjoint: adjoint,
  clone: clone$5,
  copy: copy$5,
  create: create$5,
  determinant: determinant,
  equals: equals$6,
  exactEquals: exactEquals$5,
  frob: frob,
  fromQuat: fromQuat,
  fromQuat2: fromQuat2,
  fromRotation: fromRotation$1,
  fromRotationTranslation: fromRotationTranslation$1,
  fromRotationTranslationScale: fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
  fromScaling: fromScaling,
  fromTranslation: fromTranslation$1,
  fromValues: fromValues$5,
  fromXRotation: fromXRotation,
  fromYRotation: fromYRotation,
  fromZRotation: fromZRotation,
  frustum: frustum,
  getRotation: getRotation,
  getScaling: getScaling,
  getTranslation: getTranslation$1,
  identity: identity$2,
  invert: invert$3,
  lookAt: lookAt,
  mul: mul$5,
  multiply: multiply$6,
  multiplyScalar: multiplyScalar,
  multiplyScalarAndAdd: multiplyScalarAndAdd,
  ortho: ortho,
  orthoNO: orthoNO,
  orthoZO: orthoZO,
  perspective: perspective,
  perspectiveFromFieldOfView: perspectiveFromFieldOfView,
  perspectiveNO: perspectiveNO,
  perspectiveZO: perspectiveZO,
  rotate: rotate$1,
  rotateX: rotateX$3,
  rotateY: rotateY$3,
  rotateZ: rotateZ$3,
  scale: scale$6,
  set: set$6,
  str: str$5,
  sub: sub$3,
  subtract: subtract$4,
  targetTo: targetTo,
  translate: translate$1,
  transpose: transpose
});

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$4() {
  var out = new ARRAY_TYPE(3);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone$4(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length$5(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues$4(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy$4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set$5(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add$5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract$3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply$5(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide$3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil$3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor$3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min$3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max$3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round$2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale$5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd$2(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance$3(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate$2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse$2(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize$5(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot$4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross$2(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp$5(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random$5(out, scale) {
  scale = scale || 1.0;
  var r = RANDOM() * 2.0 * Math.PI;
  var z = RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4$2(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3$1(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat$1(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX$2(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY$2(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ$2(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle$1(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot$4(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero$4(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str$4(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals$4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals$5(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub$2 = subtract$3;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul$4 = multiply$5;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div$2 = divide$3;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist$2 = distance$3;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist$2 = squaredDistance$2;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len$4 = length$5;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen$4 = squaredLength$4;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach$2 = function () {
  var vec = create$4();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

var vec3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$5,
  angle: angle$1,
  bezier: bezier,
  ceil: ceil$3,
  clone: clone$4,
  copy: copy$4,
  create: create$4,
  cross: cross$2,
  dist: dist$2,
  distance: distance$3,
  div: div$2,
  divide: divide$3,
  dot: dot$4,
  equals: equals$5,
  exactEquals: exactEquals$4,
  floor: floor$3,
  forEach: forEach$2,
  fromValues: fromValues$4,
  hermite: hermite,
  inverse: inverse$2,
  len: len$4,
  length: length$5,
  lerp: lerp$5,
  max: max$3,
  min: min$3,
  mul: mul$4,
  multiply: multiply$5,
  negate: negate$2,
  normalize: normalize$5,
  random: random$5,
  rotateX: rotateX$2,
  rotateY: rotateY$2,
  rotateZ: rotateZ$2,
  round: round$2,
  scale: scale$5,
  scaleAndAdd: scaleAndAdd$2,
  set: set$5,
  sqrDist: sqrDist$2,
  sqrLen: sqrLen$4,
  squaredDistance: squaredDistance$2,
  squaredLength: squaredLength$4,
  str: str$4,
  sub: sub$2,
  subtract: subtract$3,
  transformMat3: transformMat3$1,
  transformMat4: transformMat4$2,
  transformQuat: transformQuat$1,
  zero: zero$4
});

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create$3() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone$3(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues$3(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy$3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set$4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add$4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract$2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply$4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide$2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil$2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor$2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min$2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max$2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round$1(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale$4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd$1(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance$1(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength$3(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate$1(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse$1(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize$4(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot$3(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross$1(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp$4(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random$4(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4$1(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero$3(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str$3(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals$3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals$4(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub$1 = subtract$2;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul$3 = multiply$4;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div$1 = divide$2;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist$1 = distance$2;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist$1 = squaredDistance$1;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len$3 = length$4;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen$3 = squaredLength$3;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach$1 = function () {
  var vec = create$3();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

var vec4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$4,
  ceil: ceil$2,
  clone: clone$3,
  copy: copy$3,
  create: create$3,
  cross: cross$1,
  dist: dist$1,
  distance: distance$2,
  div: div$1,
  divide: divide$2,
  dot: dot$3,
  equals: equals$4,
  exactEquals: exactEquals$3,
  floor: floor$2,
  forEach: forEach$1,
  fromValues: fromValues$3,
  inverse: inverse$1,
  len: len$3,
  length: length$4,
  lerp: lerp$4,
  max: max$2,
  min: min$2,
  mul: mul$3,
  multiply: multiply$4,
  negate: negate$1,
  normalize: normalize$4,
  random: random$4,
  round: round$1,
  scale: scale$4,
  scaleAndAdd: scaleAndAdd$1,
  set: set$4,
  sqrDist: sqrDist$1,
  sqrLen: sqrLen$3,
  squaredDistance: squaredDistance$1,
  squaredLength: squaredLength$3,
  str: str$3,
  sub: sub$1,
  subtract: subtract$2,
  transformMat4: transformMat4$1,
  transformQuat: transformQuat,
  zero: zero$3
});

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create$2() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity$1(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > EPSILON$3) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot$2(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply$3(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX$1(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY$1(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ$1(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp$1(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow$1(out, a, b) {
  ln(out, a);
  scale$3(out, out, b);
  exp$1(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON$3) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random$3(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert$2(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate$1(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str$2(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone$2 = clone$3;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues$2 = fromValues$3;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy$2 = copy$3;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set$3 = set$4;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add$3 = add$4;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul$2 = multiply$3;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale$3 = scale$4;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot$2 = dot$3;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp$3 = lerp$4;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length$3 = length$4;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len$2 = length$3;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength$2 = squaredLength$3;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen$2 = squaredLength$2;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize$3 = normalize$4;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals$2 = exactEquals$3;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals$3 = equals$4;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = create$4();
  var xUnitVec3 = fromValues$4(1, 0, 0);
  var yUnitVec3 = fromValues$4(0, 1, 0);
  return function (out, a, b) {
    var dot = dot$4(a, b);

    if (dot < -0.999999) {
      cross$2(tmpvec3, xUnitVec3, a);
      if (len$4(tmpvec3) < 0.000001) cross$2(tmpvec3, yUnitVec3, a);
      normalize$5(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize$3(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create$2();
  var temp2 = create$2();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = create$6();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$3(out, fromMat3(out, matr));
  };
}();

var quat = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$3,
  calculateW: calculateW,
  clone: clone$2,
  conjugate: conjugate$1,
  copy: copy$2,
  create: create$2,
  dot: dot$2,
  equals: equals$3,
  exactEquals: exactEquals$2,
  exp: exp$1,
  fromEuler: fromEuler,
  fromMat3: fromMat3,
  fromValues: fromValues$2,
  getAngle: getAngle,
  getAxisAngle: getAxisAngle,
  identity: identity$1,
  invert: invert$2,
  len: len$2,
  length: length$3,
  lerp: lerp$3,
  ln: ln,
  mul: mul$2,
  multiply: multiply$3,
  normalize: normalize$3,
  pow: pow$1,
  random: random$3,
  rotateX: rotateX$1,
  rotateY: rotateY$1,
  rotateZ: rotateZ$1,
  rotationTo: rotationTo,
  scale: scale$3,
  set: set$3,
  setAxes: setAxes,
  setAxisAngle: setAxisAngle,
  slerp: slerp,
  sqlerp: sqlerp,
  sqrLen: sqrLen$2,
  squaredLength: squaredLength$2,
  str: str$2
});

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create$1() {
  var dq = new ARRAY_TYPE(8);

  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone$1(a) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues$1(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = create$2();
  getRotation(outer, a);
  var t = new ARRAY_TYPE(3);
  getTranslation$1(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set$2(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = copy$2;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = copy$2;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateX$1(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateY$1(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateZ$1(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < EPSILON$3) {
    return copy$1(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add$2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply$2(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul$1 = multiply$2;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale$2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot$1 = dot$2;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp$2(out, a, b, t) {
  var mt = 1 - t;
  if (dot$1(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert$1(out, a) {
  var sqlen = squaredLength$1(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length$2 = length$3;
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len$1 = length$2;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength$1 = squaredLength$2;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen$1 = squaredLength$1;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize$2(out, a) {
  var magnitude = squaredLength$1(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str$1(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals$1(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals$2(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$3 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$3 * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

var quat2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$2,
  clone: clone$1,
  conjugate: conjugate,
  copy: copy$1,
  create: create$1,
  dot: dot$1,
  equals: equals$2,
  exactEquals: exactEquals$1,
  fromMat4: fromMat4,
  fromRotation: fromRotation,
  fromRotationTranslation: fromRotationTranslation,
  fromRotationTranslationValues: fromRotationTranslationValues,
  fromTranslation: fromTranslation,
  fromValues: fromValues$1,
  getDual: getDual,
  getReal: getReal,
  getTranslation: getTranslation,
  identity: identity,
  invert: invert$1,
  len: len$1,
  length: length$2,
  lerp: lerp$2,
  mul: mul$1,
  multiply: multiply$2,
  normalize: normalize$2,
  rotateAroundAxis: rotateAroundAxis,
  rotateByQuatAppend: rotateByQuatAppend,
  rotateByQuatPrepend: rotateByQuatPrepend,
  rotateX: rotateX,
  rotateY: rotateY,
  rotateZ: rotateZ,
  scale: scale$2,
  set: set$2,
  setDual: setDual,
  setReal: setReal,
  sqrLen: sqrLen$1,
  squaredLength: squaredLength$1,
  str: str$1,
  translate: translate
});

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new ARRAY_TYPE(2);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set$1(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract$1(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply$1(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide$1(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil$1(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor$1(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min$1(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max$1(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale$1(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance$1(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length$1(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize$1(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp$1(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random$2(out, scale) {
  scale = scale || 1.0;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero$2(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals$1(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length$1;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract$1;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply$1;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide$1;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance$1;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

var vec2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add$1,
  angle: angle,
  ceil: ceil$1,
  clone: clone,
  copy: copy,
  create: create,
  cross: cross,
  dist: dist,
  distance: distance$1,
  div: div,
  divide: divide$1,
  dot: dot,
  equals: equals$1,
  exactEquals: exactEquals,
  floor: floor$1,
  forEach: forEach,
  fromValues: fromValues,
  inverse: inverse,
  len: len,
  length: length$1,
  lerp: lerp$1,
  max: max$1,
  min: min$1,
  mul: mul,
  multiply: multiply$1,
  negate: negate,
  normalize: normalize$1,
  random: random$2,
  rotate: rotate,
  round: round,
  scale: scale$1,
  scaleAndAdd: scaleAndAdd,
  set: set$1,
  sqrDist: sqrDist,
  sqrLen: sqrLen,
  squaredDistance: squaredDistance,
  squaredLength: squaredLength,
  str: str,
  sub: sub,
  subtract: subtract$1,
  transformMat2: transformMat2,
  transformMat2d: transformMat2d,
  transformMat3: transformMat3,
  transformMat4: transformMat4,
  zero: zero$2
});

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  glMatrix: common$1,
  mat2: mat2,
  mat2d: mat2d,
  mat3: mat3,
  mat4: mat4,
  quat: quat,
  quat2: quat2,
  vec2: vec2,
  vec3: vec3,
  vec4: vec4
});

function setTimeoutPromise(timeout, signal) {
    return new Promise((resolve, reject) => {
        const timeoutID = setTimeout(resolve, timeout);
        if (signal) {
            if (signal.aborted) {
                clearTimeout(timeoutID);
                reject('aborted');
            }
            else {
                signal.addEventListener('abort', () => {
                    clearTimeout(timeoutID);
                    reject('aborted');
                });
            }
        }
    });
}

function rgbToHsl(r, g, b) {
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s, l = (max + min) / 2;
    if (max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return [h, s, l];
}
function hslToRgb(h, s, l) {
    var r, g, b;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        function hue2rgb(p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return [r, g, b];
}
let Color$1 = class Color {
    #rgba = [];
    constructor({ red = 0, green = 0, blue = 0, alpha = 1, hex = '' } = {}) {
        this.#rgba[0] = red;
        this.#rgba[1] = green;
        this.#rgba[2] = blue;
        this.#rgba[3] = alpha;
        if (hex) {
            this.setHex(hex);
        }
    }
    setHue(hue) {
        const hsl = rgbToHsl(this.#rgba[0], this.#rgba[1], this.#rgba[2]);
        const rgb = hslToRgb(hue, hsl[1], hsl[2]);
        this.#rgba[0] = rgb[0];
        this.#rgba[1] = rgb[1];
        this.#rgba[2] = rgb[2];
    }
    setSatLum(sat, lum) {
        const hsl = rgbToHsl(this.#rgba[0], this.#rgba[1], this.#rgba[2]);
        const rgb = hslToRgb(hsl[0], sat, lum);
        this.#rgba[0] = rgb[0];
        this.#rgba[1] = rgb[1];
        this.#rgba[2] = rgb[2];
    }
    setHex(hex) {
        hex = (hex.startsWith('#') ? hex.slice(1) : hex)
            .replace(/^(\w{3})$/, '$1F') //987      -> 987F
            .replace(/^(\w)(\w)(\w)(\w)$/, '$1$1$2$2$3$3$4$4') //9876     -> 99887766
            .replace(/^(\w{6})$/, '$1FF'); //987654   -> 987654FF
        if (!hex.match(/^([0-9a-fA-F]{8})$/)) {
            throw new Error('Unknown hex color; ' + hex);
        }
        const rgba = hex
            .match(/^(\w\w)(\w\w)(\w\w)(\w\w)$/)?.slice(1) //98765432 -> 98 76 54 32
            .map(x => parseInt(x, 16)); //Hex to decimal
        if (rgba) {
            this.#rgba[0] = rgba[0] / 255;
            this.#rgba[1] = rgba[1] / 255;
            this.#rgba[2] = rgba[2] / 255;
            this.#rgba[3] = rgba[3] / 255;
        }
    }
    getHex() {
        const hex = this.#rgba.map(x => Math.round(x * 255).toString(16));
        return '#' + hex.map(x => x.padStart(2, '0')).join('');
    }
    getHue() {
        return rgbToHsl(this.#rgba[0], this.#rgba[1], this.#rgba[2])[0];
    }
    getHsl() {
        return rgbToHsl(this.#rgba[0], this.#rgba[1], this.#rgba[2]);
    }
    getRgba() {
        return this.#rgba;
    }
    set red(red) {
        this.#rgba[0] = red;
    }
    get red() {
        return this.#rgba[0];
    }
    set green(green) {
        this.#rgba[1] = green;
    }
    get green() {
        return this.#rgba[1];
    }
    set blue(blue) {
        this.#rgba[2] = blue;
    }
    get blue() {
        return this.#rgba[2];
    }
    set alpha(alpha) {
        this.#rgba[3] = alpha;
    }
    get alpha() {
        return this.#rgba[3];
    }
    getLuminance() {
        return 0.2126 * this.#rgba[0] + 0.7152 * this.#rgba[1] + 0.0722 * this.#rgba[2];
    }
};

const checkOutlineSVG = '<svg xmlns="http://www.w3.org/2000/svg"  height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="m 381,-240 424,-424 -57,-56 -368,367 -169,-170 -57,57 z m 0,113 -339,-339 169,-170 170,170 366,-367 172,168 z"/><path fill="#ffffff" d="m 381,-240 424,-424 -57,-56 -368,367 -169,-170 -57,57 z m 366,-593 c -498,-84.66667 -249,-42.33333 0,0 z"/></svg>';

const closeSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg>';

const contentCopySVG = '<svg height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"/></svg>';

const dragPanSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-80 310-250l57-57 73 73v-206H235l73 72-58 58L80-480l169-169 57 57-72 72h206v-206l-73 73-57-57 170-170 170 170-57 57-73-73v206h205l-73-72 58-58 170 170-170 170-57-57 73-73H520v205l72-73 58 58L480-80Z"/></svg>';

const folderOpenSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h240l80 80h320q33 0 56.5 23.5T880-640H447l-80-80H160v480l96-320h684L837-217q-8 26-29.5 41.5T760-160H160Zm84-80h516l72-240H316l-72 240Zm0 0 72-240-72 240Zm-84-400v-80 80Z"/></svg>';

const infoSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>';

const lockSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"/></svg>';

const lockOpenRightSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M240-160h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Zm0 80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h280v-80q0-83 58.5-141.5T720-920q83 0 141.5 58.5T920-720h-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80h120q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Z"/></svg>';

const panZoomSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M120-120v-240h80v104l124-124 56 56-124 124h104v80H120Zm516-460-56-56 124-124H600v-80h240v240h-80v-104L636-580Z"/></svg>';

const pauseSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="M560-200v-560h160v560H560Zm-320 0v-560h160v560H240Z"/></svg>';

const playSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="M320-200v-560l440 280-440 280Z"/></svg>';

const repeatSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentcolor"><path d="M280-80 120-240l160-160 56 58-62 62h406v-160h80v240H274l62 62-56 58Zm-80-440v-240h486l-62-62 56-58 160 160-160 160-56-58 62-62H280v160h-80Z"/></svg>';

const repeatOnSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentcolor"><path d="M120-40q-33 0-56.5-23.5T40-120v-720q0-33 23.5-56.5T120-920h720q33 0 56.5 23.5T920-840v720q0 33-23.5 56.5T840-40H120Zm160-40 56-58-62-62h486v-240h-80v160H274l62-62-56-58-160 160L280-80Zm-80-440h80v-160h406l-62 62 56 58 160-160-160-160-56 58 62 62H200v240Z"/></svg>';

const restartSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M440-122q-121-15-200.5-105.5T160-440q0-66 26-126.5T260-672l57 57q-38 34-57.5 79T240-440q0 88 56 155.5T440-202v80Zm80 0v-80q87-16 143.5-83T720-440q0-100-70-170t-170-70h-3l44 44-56 56-140-140 140-140 56 56-44 44h3q134 0 227 93t93 227q0 121-79.5 211.5T520-122Z"/></svg>';

const rotateSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M482-160q-134 0-228-93t-94-227v-7l-64 64-56-56 160-160 160 160-56 56-64-64v7q0 100 70.5 170T482-240q26 0 51-6t49-18l60 60q-38 22-78 33t-82 11Zm278-161L600-481l56-56 64 64v-7q0-100-70.5-170T478-720q-26 0-51 6t-49 18l-60-60q38-22 78-33t82-11q134 0 228 93t94 227v7l64-64 56 56-160 160Z"/></svg>';

const runSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px"  fill="currentColor"><path d="M520-40v-240l-84-80-40 176-276-56 16-80 192 40 64-324-72 28v136h-80v-188l158-68q35-15 51.5-19.5T480-720q21 0 39 11t29 29l40 64q26 42 70.5 69T760-520v80q-66 0-123.5-27.5T540-540l-24 120 84 80v300h-80Zm20-700q-33 0-56.5-23.5T460-820q0-33 23.5-56.5T540-900q33 0 56.5 23.5T620-820q0 33-23.5 56.5T540-740Z"/></svg>';

const visibilityOffSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0z" fill="none"/><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>';

const visibilityOnSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>';

const walkSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="m280-40 112-564-72 28v136h-80v-188l202-86q14-6 29.5-7t29.5 4q14 5 26.5 14t20.5 23l40 64q26 42 70.5 69T760-520v80q-70 0-125-29t-94-74l-25 123 84 80v300h-80v-260l-84-64-72 324h-84Zm260-700q-33 0-56.5-23.5T460-820q0-33 23.5-56.5T540-900q33 0 56.5 23.5T620-820q0 33-23.5 56.5T540-740Z"/></svg>';

const zoomInSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Zm-40-60v-80h-80v-80h80v-80h80v80h80v80h-80v80h-80Z"/></svg>';

const zoomOutSVG = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor"><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400ZM280-540v-80h200v80H280Z"/></svg>';

function cloneEvent(event) {
    return new event.constructor(event.type, event);
}

async function documentStyle(cssText) {
    return await shadowRootStyle(document, cssText);
}
function documentStyleSync(cssText) {
    return shadowRootStyleSync(document, cssText);
}
async function shadowRootStyle(shadowRoot, cssText) {
    const sheet = new CSSStyleSheet;
    await sheet.replace(cssText);
    shadowRoot.adoptedStyleSheets.push(sheet);
}
function shadowRootStyleSync(shadowRoot, cssText) {
    const sheet = new CSSStyleSheet;
    sheet.replaceSync(cssText);
    shadowRoot.adoptedStyleSheets.push(sheet);
}

const ET = new EventTarget();

const I18N_DELAY_BEFORE_REFRESH = 100;
var I18nEvents;
(function (I18nEvents) {
    I18nEvents["LangChanged"] = "langchanged";
    I18nEvents["TranslationsUpdated"] = "translationsupdated";
    I18nEvents["Any"] = "*";
})(I18nEvents || (I18nEvents = {}));
const targets = ['innerHTML', 'innerText', 'placeholder', 'title', 'label'];
const I18nElements = new Map();
function AddI18nElement(element, descriptor) {
    if (typeof descriptor == 'string') {
        descriptor = { innerText: descriptor };
    }
    const existing = I18nElements.get(element);
    if (existing) {
        if (descriptor === null) {
            I18nElements.delete(element);
            return;
        }
        for (const target of targets) {
            const desc = descriptor[target];
            if (desc === null) {
                delete existing[target];
            }
            else if (desc !== undefined) {
                existing[target] = desc;
            }
        }
        if (descriptor.values) {
            if (!existing.values) {
                existing.values = {};
            }
            for (const name in descriptor.values) {
                existing.values[name] = descriptor.values[name];
            }
        }
    }
    else {
        if (descriptor) {
            I18nElements.set(element, descriptor);
        }
    }
}
class I18n {
    static #started = false;
    static #lang = 'english';
    static #defaultLang = 'english';
    static #translations = new Map();
    static #executing = false;
    static #refreshTimeout;
    static #observerConfig = { childList: true, subtree: true, attributeFilter: ['i18n', 'data-i18n-json', 'data-i18n-values'] };
    static #observer;
    static #observed = new Set();
    static #eventTarget = new EventTarget();
    static start() {
        if (this.#started) {
            return;
        }
        this.#started = true;
        this.observeElement(document.body);
        ET.addEventListener('created', (event) => this.#processElement2(event.detail));
        ET.addEventListener('updated', (event) => this.#processElement2(event.detail));
    }
    static setOptions(options) {
        if (options.translations) {
            for (const translation of options.translations) {
                this.#addTranslation(translation);
            }
            this.#eventTarget.dispatchEvent(new CustomEvent(I18nEvents.TranslationsUpdated));
            this.#eventTarget.dispatchEvent(new CustomEvent(I18nEvents.Any));
        }
        this.i18n();
    }
    static addTranslation(translation) {
        this.#addTranslation(translation);
        if (translation.lang == this.#lang) {
            this.i18n();
        }
    }
    static #addTranslation(translation) {
        this.#translations.set(translation.lang, translation);
    }
    static #initObserver() {
        if (this.#observer) {
            return;
        }
        const callback = async (mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        if (node instanceof HTMLElement) {
                            this.updateElement(node);
                        }
                    }
                }
                else if (mutation.type === 'attributes') {
                    this.updateElement(mutation.target);
                }
            }
        };
        this.#observer = new MutationObserver(callback);
    }
    static observeElement(element) {
        this.#observed.add(element);
        this.#initObserver();
        this.#observer?.observe(element, this.#observerConfig);
        this.updateElement(element);
    }
    static #processList(parentNode, className, attribute, subElement) {
        const elements = parentNode.querySelectorAll('.' + className);
        if (parentNode.classList?.contains(className)) {
            this.#processElement(parentNode, attribute, subElement);
        }
        for (const element of elements) {
            this.#processElement(element, attribute, subElement);
        }
    }
    static #processJSON(parentNode) {
        const className = 'i18n';
        const elements = parentNode.querySelectorAll('.' + className);
        if (parentNode.classList?.contains(className)) {
            this.#processElementJSON(parentNode);
        }
        for (const element of elements) {
            this.#processElementJSON(element);
        }
    }
    static #processElement(htmlElement, attribute, subElement) {
        const dataLabel = htmlElement.getAttribute(attribute);
        if (dataLabel) {
            htmlElement[subElement] = this.getString(dataLabel);
        }
    }
    // TODO: merge with function above
    static #processElement2(htmlElement) {
        const descriptor = I18nElements.get(htmlElement);
        if (descriptor) {
            const values = descriptor.values ?? {};
            for (const target of targets) {
                const desc = descriptor[target];
                if (desc && (htmlElement[target] !== undefined)) {
                    htmlElement[target] = this.formatString(desc, values);
                }
            }
        }
    }
    static #processElementJSON(htmlElement) {
        const str = htmlElement.getAttribute('data-i18n-json');
        if (!str) {
            return;
        }
        const dataJSON = JSON.parse(str);
        if (!dataJSON) {
            return;
        }
        let valuesJSON;
        const values = htmlElement.getAttribute('data-i18n-values');
        if (values) {
            valuesJSON = JSON.parse(values);
        }
        else {
            valuesJSON = dataJSON.values;
        }
        const innerHTML = dataJSON.innerHTML;
        if (innerHTML) {
            htmlElement.innerHTML = this.formatString(innerHTML, valuesJSON);
        }
        const innerText = dataJSON.innerText;
        if (innerText && (htmlElement.innerText !== undefined)) {
            htmlElement.innerText = this.formatString(innerText, valuesJSON);
        }
    }
    static i18n() {
        if (!this.#refreshTimeout) {
            this.#refreshTimeout = setTimeout(() => this.#i18n(), I18N_DELAY_BEFORE_REFRESH);
        }
    }
    static #i18n() {
        this.#refreshTimeout = null;
        if (this.#executing) {
            return;
        }
        this.#executing = true;
        for (const element of this.#observed) {
            this.#processList(element, 'i18n', 'data-i18n', 'innerHTML');
            this.#processJSON(element);
        }
        for (const [element] of I18nElements) {
            this.#processElement2(element);
        }
        this.#executing = false;
        return;
    }
    static updateElement(htmlElement) {
        this.#processList(htmlElement, 'i18n', 'data-i18n', 'innerHTML');
        this.#processJSON(htmlElement);
    }
    /**
     * @deprecated use setLang() instead
     */
    static set lang(lang) {
        throw 'Deprecated, use setLang() instead';
    }
    static setLang(lang) {
        if (this.#lang != lang) {
            const oldLang = this.#lang;
            this.#lang = lang;
            this.#eventTarget.dispatchEvent(new CustomEvent(I18nEvents.LangChanged, { detail: { oldLang: oldLang, newLang: lang } }));
            this.#eventTarget.dispatchEvent(new CustomEvent(I18nEvents.Any));
            this.i18n();
        }
    }
    static setDefaultLang(defaultLang) {
        this.#defaultLang = defaultLang;
    }
    static addEventListener(type, callback, options) {
        this.#eventTarget.addEventListener(type, callback, options);
    }
    static getString(s) {
        const s2 = this.#translations.get(this.#lang)?.strings?.[s] ?? this.#translations.get(this.#defaultLang)?.strings?.[s];
        if (typeof s2 == 'string') {
            return s2;
        }
        else {
            console.warn('Missing translation for key ' + s);
            return s;
        }
    }
    static formatString(s, values) {
        let str = this.getString(s);
        for (const key in values) {
            str = str.replace(new RegExp("\\${" + key + "\\}", "gi"), String(values[key]));
        }
        return str;
    }
    /**
     * @deprecated use getAuthors() instead
     */
    static get authors() {
        throw 'Deprecated, use getAuthors() instead';
    }
    static getAuthors() {
        return this.#translations.get(this.#lang)?.authors ?? [];
    }
    static setValue(element, name, value) {
        if (!element) {
            return;
        }
        const i18n = {};
        i18n[name] = value;
        AddI18nElement(element, { values: i18n });
        this.#processElement2(element);
    }
}

function createElement(tagName, options) {
    const element = document.createElement(tagName);
    createElementOptions(element, options);
    ET.dispatchEvent(new CustomEvent('created', { detail: element }));
    return element;
}
function createElementNS(namespaceURI, tagName, options) {
    const element = document.createElementNS(namespaceURI, tagName);
    createElementOptions(element, options);
    return element;
}
function createShadowRoot(tagName, options, mode = 'closed') {
    const element = document.createElement(tagName);
    const shadowRoot = element.attachShadow({ mode: mode });
    createElementOptions(element, options, shadowRoot);
    return shadowRoot;
}
function updateElement(element, options) {
    if (!element) {
        return;
    }
    createElementOptions(element, options);
    ET.dispatchEvent(new CustomEvent('updated', { detail: element }));
    return element;
}
function append$1(element, child) {
    if (child === null || child === undefined) {
        return;
    }
    if (child instanceof ShadowRoot) {
        element.append(child.host);
    }
    else {
        element.append(child);
    }
}
function createElementOptions(element, options, shadowRoot) {
    if (options) {
        for (const optionName in options) {
            const optionValue = options[optionName];
            if (optionName.startsWith('$')) {
                const eventType = optionName.substring(1);
                if (typeof optionValue === 'function') {
                    element.addEventListener(eventType, optionValue);
                }
                else {
                    element.addEventListener(eventType, optionValue.listener, optionValue.options);
                }
                continue;
            }
            switch (optionName) {
                case 'id':
                    element.id = optionValue;
                    break;
                case 'class':
                    element.classList.add(...optionValue.split(' ').filter((n) => n));
                    break;
                case 'i18n':
                    AddI18nElement(element, optionValue);
                    break;
                case 'parent':
                    optionValue.append(element);
                    break;
                case 'child':
                    append$1(shadowRoot ?? element, optionValue);
                    break;
                case 'childs':
                    optionValue.forEach((entry) => append$1(shadowRoot ?? element, entry));
                    break;
                case 'events':
                    for (const eventType in optionValue) {
                        const eventParams = optionValue[eventType];
                        if (typeof eventParams === 'function') {
                            element.addEventListener(eventType, eventParams);
                        }
                        else {
                            element.addEventListener(eventType, eventParams.listener, eventParams.options);
                        }
                    }
                    break;
                case 'properties':
                    for (const name in optionValue) {
                        element[name] = optionValue[name];
                    }
                    break;
                case 'hidden':
                    if (optionValue) {
                        hide(element);
                    }
                    break;
                case 'innerHTML':
                    element.innerHTML = optionValue;
                    break;
                case 'innerText':
                    element.innerText = optionValue;
                    break;
                case 'attributes':
                    for (const attributeName in optionValue) {
                        element.setAttribute(attributeName, optionValue[attributeName]);
                    }
                    break;
                case 'slot':
                    element.slot = optionValue;
                    break;
                case 'htmlFor':
                    element.htmlFor = optionValue;
                    break;
                case 'adoptStyle':
                    adoptStyleSheet(shadowRoot ?? element, optionValue);
                    break;
                case 'adoptStyles':
                    optionValue.forEach((entry) => {
                        adoptStyleSheet(shadowRoot ?? element, entry);
                    });
                    break;
                case 'style':
                    element.style.cssText = optionValue;
                    break;
                case 'checked':
                    element.checked = optionValue;
                    break;
                case 'elementCreated':
                    break;
                default:
                    element.setAttribute(optionName, optionValue);
                    break;
            }
        }
        options.elementCreated?.(element, shadowRoot);
    }
}
async function adoptStyleSheet(element, cssText) {
    const sheet = new CSSStyleSheet;
    await sheet.replace(cssText);
    if (element.adoptStyleSheet) {
        element.adoptStyleSheet(sheet);
    }
    else {
        if (element.adoptedStyleSheets) {
            element.adoptedStyleSheets.push(sheet);
        }
    }
}
function display(htmlElement, visible) {
    if (Array.isArray(htmlElement)) {
        for (const e of htmlElement) {
            disp(e, visible);
        }
    }
    else {
        disp(htmlElement, visible);
    }
}
function disp(htmlElement, visible) {
    if (!htmlElement) {
        return;
    }
    if (htmlElement instanceof ShadowRoot) {
        htmlElement = htmlElement.host;
    }
    if (visible) {
        htmlElement.style.display = '';
    }
    else {
        htmlElement.style.display = 'none';
    }
}
function show(htmlElement) {
    display(htmlElement, true);
}
function hide(htmlElement) {
    display(htmlElement, false);
}
function toggle(htmlElement) {
    if (!htmlElement) {
        return;
    }
    if (htmlElement instanceof ShadowRoot) {
        htmlElement = htmlElement.host;
    }
    if (htmlElement.style.display == 'none') {
        htmlElement.style.display = '';
    }
    else {
        htmlElement.style.display = 'none';
    }
}
function isVisible(htmlElement) {
    return htmlElement.style.display == '';
}
const visible$1 = isVisible;
function styleInject(css) {
    document.head.append(createElement('style', { textContent: css }));
}

var manipulator2dCSS = ":host {\n\t--handle-radius: var(--harmony-2d-manipulator-radius, 0.5rem);\n\t--harmony-2d-manipulator-shadow-bg-color: var(--harmony-2d-manipulator-bg-color, red);\n\t--harmony-2d-manipulator-shadow-border: var(--harmony-2d-manipulator-border, none);\n\t--handle-bg-color: var(--harmony-2d-manipulator-handle-bg-color, chartreuse);\n\t--corner-bg-color: var(--harmony-2d-manipulator-corner-bg-color, var(--handle-bg-color));\n\t--side-bg-color: var(--harmony-2d-manipulator-side-bg-color, var(--handle-bg-color));\n\t--rotate-bg-color: var(--harmony-2d-manipulator-rotate-bg-color, var(--handle-bg-color));\n\n\twidth: 1rem;\n\theight: 1rem;\n\tdisplay: block;\n\tuser-select: none;\n\tpointer-events: all;\n}\n\n:host-context(.grabbing) {\n\tcursor: grabbing;\n}\n\n.manipulator {\n\tposition: absolute;\n\tbackground-color: var(--harmony-2d-manipulator-shadow-bg-color);\n\tborder: var(--harmony-2d-manipulator-shadow-border);\n\tcursor: move;\n\tpointer-events: all;\n}\n\n.rotator {\n\tscale: var(--rotate);\n\tposition: absolute;\n\twidth: var(--handle-radius);\n\theight: var(--handle-radius);\n\tbackground-color: var(--rotate-bg-color);\n\tborder-radius: calc(var(--handle-radius) * 0.5);\n\ttransform: translate(-50%, -50%);\n\tcursor: grab;\n}\n\n.corner {\n\tscale: var(--scale);\n\tposition: absolute;\n\twidth: var(--handle-radius);\n\theight: var(--handle-radius);\n\tbackground-color: var(--corner-bg-color);\n\tborder-radius: calc(var(--handle-radius) * 0.5);\n\ttransform: translate(-50%, -50%);\n\tcursor: grab;\n}\n\n.side {\n\tposition: absolute;\n\twidth: var(--handle-radius);\n\theight: var(--handle-radius);\n\tbackground-color: var(--side-bg-color);\n\tborder-radius: calc(var(--handle-radius) * 0.5);\n\ttransform: translate(-50%, -50%);\n\tcursor: grab;\n}\n\n.side.x {\n\tscale: var(--resize-x);\n}\n\n.side.y {\n\tscale: var(--resize-y);\n}\n\n.corner.grabbing {\n\tcursor: grabbing;\n}\n";

function toBool(s) {
    return s === '1' || s === 'true';
}

var uiCSS = "@media (prefers-color-scheme: light) {\n\t:root:not(.light):not(.dark) {\n\t\t--harmony-ui-background-primary: #ccc;\n\t\t--harmony-ui-background-secondary: #f9f9fb;\n\t\t--harmony-ui-background-tertiary: #fff;\n\n\t\t--harmony-ui-input-background-primary: #aaa;\n\t\t--harmony-ui-input-background-secondary: #ccc;\n\t\t--harmony-ui-input-background-tertiary: #4e4e4e;\n\n\t\t--harmony-ui-border-primary: #222;\n\t\t--harmony-ui-border-secondary: #222;\n\n\t\t--harmony-ui-input-border-primary: #222;\n\t\t--harmony-ui-input-border-secondary: #222;\n\n\t\t--harmony-ui-text-primary: #222;\n\t\t--harmony-ui-text-secondary: #222;\n\t\t--harmony-ui-text-inactive: #9e9e9ea6;\n\t\t--harmony-ui-text-link: #0069c2;\n\t\t--harmony-ui-text-invert: #fff;\n\n\t\t--harmony-ui-accent-primary: #1072eb;\n\t\t--harmony-ui-accent-secondary: #1040c1;\n\n\t\t--harmony-ui-scrollbar-bg: transparent;\n\t\t--harmony-ui-scrollbar-color: rgba(0, 0, 0, 0.25);\n\t}\n}\n\n@media (prefers-color-scheme: dark) {\n\t:root:not(.light):not(.dark) {\n\t\t--harmony-ui-background-primary: #1b1b1b;\n\t\t--harmony-ui-background-secondary: #464747;\n\t\t--harmony-ui-background-tertiary: #4e4e4e;\n\n\t\t--harmony-ui-input-background-primary: #555;\n\t\t--harmony-ui-input-background-secondary: #333;\n\t\t--harmony-ui-input-background-tertiary: #fff;\n\n\t\t--harmony-ui-border-primary: #858585;\n\t\t--harmony-ui-border-secondary: #696969;\n\n\t\t--harmony-ui-input-border-primary: #aaa;\n\t\t--harmony-ui-input-border-secondary: #696969;\n\n\t\t--harmony-ui-text-primary: #fff;\n\t\t--harmony-ui-text-secondary: #cdcdcd;\n\t\t--harmony-ui-text-inactive: #cdcdcda6;\n\t\t--harmony-ui-text-link: #8cb4ff;\n\t\t--harmony-ui-text-invert: #1b1b1b;\n\n\t\t--harmony-ui-accent-primary: #1072eb;\n\t\t--harmony-ui-accent-secondary: #1040c1;\n\n\t\t--harmony-ui-scrollbar-bg: transparent;\n\t\t--harmony-ui-scrollbar-color: rgba(255, 255, 255, 0.25);\n\t}\n}\n\n:root.light {\n\t--harmony-ui-background-primary: #ccc;\n\t--harmony-ui-background-secondary: #f9f9fb;\n\t--harmony-ui-background-tertiary: #fff;\n\n\t--harmony-ui-input-background-primary: #aaa;\n\t--harmony-ui-input-background-secondary: #ccc;\n\t--harmony-ui-input-background-tertiary: #4e4e4e;\n\n\t--harmony-ui-border-primary: #222;\n\t--harmony-ui-border-secondary: #222;\n\n\t--harmony-ui-input-border-primary: #222;\n\t--harmony-ui-input-border-secondary: #222;\n\n\t--harmony-ui-text-primary: #222;\n\t--harmony-ui-text-secondary: #222;\n\t--harmony-ui-text-inactive: #9e9e9ea6;\n\t--harmony-ui-text-link: #0069c2;\n\t--harmony-ui-text-invert: #fff;\n\n\t--harmony-ui-accent-primary: #1072eb;\n\t--harmony-ui-accent-secondary: #1040c1;\n\n\t--harmony-ui-scrollbar-bg: transparent;\n\t--harmony-ui-scrollbar-color: rgba(0, 0, 0, 0.25);\n}\n\n:root.dark {\n\t--harmony-ui-background-primary: #1b1b1b;\n\t--harmony-ui-background-secondary: #464747;\n\t--harmony-ui-background-tertiary: #4e4e4e;\n\n\t--harmony-ui-input-background-primary: #555;\n\t--harmony-ui-input-background-secondary: #333;\n\t--harmony-ui-input-background-tertiary: #fff;\n\n\t--harmony-ui-border-primary: #858585;\n\t--harmony-ui-border-secondary: #696969;\n\n\t--harmony-ui-input-border-primary: #aaa;\n\t--harmony-ui-input-border-secondary: #696969;\n\n\t--harmony-ui-text-primary: #fff;\n\t--harmony-ui-text-secondary: #cdcdcd;\n\t--harmony-ui-text-inactive: #cdcdcda6;\n\t--harmony-ui-text-link: #8cb4ff;\n\t--harmony-ui-text-invert: #1b1b1b;\n\n\t--harmony-ui-accent-primary: #1072eb;\n\t--harmony-ui-accent-secondary: #1040c1;\n\n\t--harmony-ui-scrollbar-bg: transparent;\n\t--harmony-ui-scrollbar-color: rgba(255, 255, 255, 0.25);\n}\n";

let injected = false;
function injectGlobalCss() {
    if (injected) {
        return;
    }
    documentStyle(uiCSS);
    injected = true;
}

var ManipulatorDirection;
(function (ManipulatorDirection) {
    ManipulatorDirection["All"] = "all";
    ManipulatorDirection["X"] = "x";
    ManipulatorDirection["Y"] = "y";
    ManipulatorDirection["None"] = "none";
})(ManipulatorDirection || (ManipulatorDirection = {}));
function getDirection(s) {
    switch (s) {
        case 'x':
            return ManipulatorDirection.X;
        case 'y':
            return ManipulatorDirection.Y;
        case 'none':
            return ManipulatorDirection.None;
        case 'all':
        default:
            return ManipulatorDirection.All;
    }
}
function getResizeOrigin(s) {
    switch (s) {
        case 'center':
            return ManipulatorResizeOrigin.Center;
        default:
            return ManipulatorResizeOrigin.OppositeCorner;
    }
}
function hasX(d) {
    return d == ManipulatorDirection.All || d == ManipulatorDirection.X;
}
function hasY(d) {
    return d == ManipulatorDirection.All || d == ManipulatorDirection.Y;
}
var ManipulatorUpdatedEventType;
(function (ManipulatorUpdatedEventType) {
    ManipulatorUpdatedEventType["Position"] = "position";
    ManipulatorUpdatedEventType["Size"] = "size";
    ManipulatorUpdatedEventType["Rotation"] = "rotation";
})(ManipulatorUpdatedEventType || (ManipulatorUpdatedEventType = {}));
const CORNERS = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
const SIDES = [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];
const SCALE_SIDES = [[0, 1], [0, 1], [1, 0], [1, 0]];
const SNAP_POSITION = 20; // Pixels
const SNAP_ROTATION = 15; // Degrees
const DEG_TO_RAD$1 = Math.PI / 180;
const RAD_TO_DEG$1 = 180 / Math.PI;
var ManipulatorCorner;
(function (ManipulatorCorner) {
    ManipulatorCorner[ManipulatorCorner["None"] = -1] = "None";
    ManipulatorCorner[ManipulatorCorner["TopLeft"] = 0] = "TopLeft";
    ManipulatorCorner[ManipulatorCorner["TopRight"] = 1] = "TopRight";
    ManipulatorCorner[ManipulatorCorner["BottomLeft"] = 2] = "BottomLeft";
    ManipulatorCorner[ManipulatorCorner["BottomRight"] = 3] = "BottomRight";
})(ManipulatorCorner || (ManipulatorCorner = {}));
var ManipulatorSide;
(function (ManipulatorSide) {
    ManipulatorSide[ManipulatorSide["None"] = -1] = "None";
    ManipulatorSide[ManipulatorSide["Top"] = 0] = "Top";
    ManipulatorSide[ManipulatorSide["Bottom"] = 1] = "Bottom";
    ManipulatorSide[ManipulatorSide["Left"] = 2] = "Left";
    ManipulatorSide[ManipulatorSide["Right"] = 3] = "Right";
})(ManipulatorSide || (ManipulatorSide = {}));
var ManipulatorResizeOrigin;
(function (ManipulatorResizeOrigin) {
    ManipulatorResizeOrigin[ManipulatorResizeOrigin["OppositeCorner"] = 0] = "OppositeCorner";
    ManipulatorResizeOrigin[ManipulatorResizeOrigin["Center"] = 1] = "Center";
})(ManipulatorResizeOrigin || (ManipulatorResizeOrigin = {}));
class HTMLHarmony2dManipulatorElement extends HTMLElement {
    #shadowRoot;
    #htmlQuad;
    #translationMode = ManipulatorDirection.All;
    #canRotate = true;
    #resizeMode = ManipulatorDirection.All;
    #scale = ManipulatorDirection.All;
    #skew = ManipulatorDirection.All;
    #htmlScaleCorners = [];
    #htmlResizeSides = [];
    #htmlRotator;
    #center = { x: 25, y: 25 };
    #width = 50;
    #height = 50;
    #previousCenter = { x: -1, y: -1 };
    #previousWidth = -1;
    #previousHeight = -1;
    #rotation = 0;
    #previousRotation = 0;
    #dragCorner = ManipulatorCorner.None;
    #dragSide = ManipulatorSide.None;
    #dragThis = false;
    #dragRotator = false;
    #startPageX = 0;
    #startPageY = 0;
    #minWidth = 0;
    #minHeight = 0;
    #startWidth = 0;
    #startHeight = 0;
    #startTop = 0;
    #startLeft = 0;
    #startCenter = { x: 0, y: 0 };
    #startRotationCenter = { x: 0, y: 0 };
    #startCorners = [];
    #c0_x = 0;
    #c0_y = 0;
    #qp0_x = 0;
    #qp0_y = 0;
    #pp_x = 0;
    #pp_y = 0;
    #dragging = false;
    #transformScale = 1;
    #resizeOrigin = ManipulatorResizeOrigin.OppositeCorner;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, manipulator2dCSS);
        this.#htmlQuad = createElement('div', {
            parent: this.#shadowRoot,
            class: 'manipulator',
            child: this.#htmlRotator = createElement('div', {
                class: 'rotator',
                events: {
                    mousedown: (event) => {
                        switch (event.button) {
                            case 0:
                                event.stopPropagation();
                                this.#startDragRotator(event);
                                break;
                            case 2:
                                event.stopPropagation();
                                this.#rotateInput(event);
                                break;
                        }
                    },
                }
            }),
            events: {
                mousedown: (event) => {
                    switch (event.button) {
                        case 0:
                            this.#startTranslate(event);
                            break;
                        case 2:
                            this.#translateInput(event);
                            break;
                    }
                },
            }
        });
        for (let i = 0; i < 4; i++) {
            const htmlCorner = createElement('div', {
                class: 'corner',
                parent: this.#htmlQuad,
                events: {
                    mousedown: (event) => {
                        if (event.button == 0) {
                            this.#startDragCorner(event, i);
                        }
                    },
                }
            });
            this.#htmlScaleCorners.push(htmlCorner);
        }
        for (let i = 0; i < 4; i++) {
            const htmlCorner = createElement('div', {
                class: `side ${i < 2 ? 'y' : 'x'}`,
                parent: this.#htmlQuad,
                events: {
                    mousedown: (event) => {
                        if (event.button == 0) {
                            this.#startDragSide(event, i);
                        }
                    },
                }
            });
            this.#htmlResizeSides.push(htmlCorner);
        }
        document.addEventListener('mousemove', (event) => this.#onMouseMove(event));
        document.addEventListener('mouseup', (event) => this.#stopDrag(event));
    }
    setTopLeft(x, y) {
    }
    #onMouseMove(event) {
        this.#translate(event);
        this.#resize(event);
        this.#rotate(event);
    }
    #stopDrag(event) {
        if (this.#dragging) {
            let type = ManipulatorUpdatedEventType.Position;
            switch (true) {
                case this.#dragThis:
                    type = ManipulatorUpdatedEventType.Position;
                    break;
                case this.#dragRotator:
                    type = ManipulatorUpdatedEventType.Rotation;
                    break;
                case this.#dragCorner >= 0:
                case this.#dragSide >= 0:
                    type = ManipulatorUpdatedEventType.Size;
                    break;
            }
            this.#dragging = false;
            this.#dispatchEvent('updateend', type);
        }
        this.#stopTranslate(event);
        this.#stopDragRotator(event);
        this.#stopDragCorner(event);
        this.#stopDragSide(event);
    }
    #stopTranslate(event) {
        this.#dragThis = false;
    }
    #stopDragRotator(event) {
        this.#dragRotator = false;
    }
    #stopDragCorner(event) {
        if (this.#dragCorner < 0) {
            return;
        }
        this.#htmlScaleCorners[this.#dragCorner].classList.remove('grabbing');
        this.classList.remove('grabbing');
        this.#dragCorner = ManipulatorCorner.None;
    }
    #stopDragSide(event) {
        if (this.#dragSide < 0) {
            return;
        }
        this.#htmlResizeSides[this.#dragSide].classList.remove('grabbing');
        this.classList.remove('grabbing');
        this.#dragSide = ManipulatorSide.None;
    }
    #startTranslate(event) {
        if (this.#dragging) {
            return;
        }
        this.#dragging = true;
        this.#dragThis = true;
        this.#initStartPositions(event);
    }
    #startDragRotator(event) {
        if (this.#dragging) {
            return;
        }
        this.#dragging = true;
        this.#dragRotator = true;
        this.#htmlRotator?.classList.add('grabbing');
        this.classList.add('grabbing');
        this.#initStartPositions(event);
    }
    #startDragCorner(event, i) {
        if (this.#dragging) {
            return;
        }
        this.#htmlScaleCorners[i].classList.add('grabbing');
        this.classList.add('grabbing');
        this.#dragging = true;
        this.#dragCorner = i;
        this.#initStartPositions(event);
    }
    #startDragSide(event, i) {
        if (this.#dragging) {
            return;
        }
        this.#htmlResizeSides[i].classList.add('grabbing');
        this.classList.add('grabbing');
        this.#dragging = true;
        this.#dragSide = i;
        this.#initStartPositions(event);
    }
    #translate(event) {
        if (!this.#dragThis) {
            return;
        }
        this.#deltaMove(event);
        this.#refresh();
        /*
        if (this.drag === 'x-axis') {
            this.deltaMove($event, false, true);
          } else if (this.drag === 'y-axis') {
            this.deltaMove($event, true, false);
          } else {
            this.deltaMove($event, true, true);
          }
            */
    }
    #resize(event) {
        if (this.#dragCorner > ManipulatorCorner.None || this.#dragSide > ManipulatorSide.None) {
            this.#deltaResize(event);
            this.#refresh();
        }
    }
    #rotate(event) {
        if (this.#dragRotator && this.#canRotate) {
            const currentX = event.clientX;
            const currentY = event.clientY;
            this.#rotation = -Math.atan2(currentX - this.#startRotationCenter.x, currentY - this.#startRotationCenter.y) + Math.PI;
            if (event.ctrlKey) {
                this.#snapRotation();
            }
            this.#update(ManipulatorUpdatedEventType.Rotation);
            this.#refresh();
        }
    }
    #snapPosition(a) {
        return Math.round(a / SNAP_POSITION) * SNAP_POSITION;
    }
    #snapRotation() {
        this.#rotation = Math.round(this.#rotation * RAD_TO_DEG$1 / SNAP_ROTATION) * SNAP_ROTATION * DEG_TO_RAD$1;
    }
    #update(type) {
        if (this.#previousHeight == this.#height && this.#previousCenter.x == this.#center.x && this.#previousCenter.y == this.#center.y && this.#previousWidth == this.#width && this.#previousRotation == this.#rotation) {
            return;
        }
        this.#previousHeight = this.#height;
        this.#previousWidth = this.#width;
        this.#previousCenter.x = this.#center.x;
        this.#previousCenter.y = this.#center.y;
        this.#previousRotation = this.#rotation;
        this.#dispatchEvent('change', type);
    }
    #dispatchEvent(name, type) {
        this.dispatchEvent(new CustomEvent(name, {
            detail: {
                type: type,
                position: { x: this.#center.x, y: this.#center.y },
                width: this.#width,
                height: this.#height,
                rotation: this.#rotation,
                topLeft: this.getTopLeft(),
                topRight: this.getTopRight(),
                bottomLeft: this.getBottomLeft(),
                bottomRight: this.getBottomRight(),
            }
        }));
    }
    getTopLeft() {
        return this.getCorner(ManipulatorCorner.TopLeft);
    }
    getTopRight() {
        return this.getCorner(ManipulatorCorner.TopRight);
    }
    getBottomLeft() {
        return this.getCorner(ManipulatorCorner.BottomLeft);
    }
    getBottomRight() {
        return this.getCorner(ManipulatorCorner.BottomRight);
    }
    getCorner(i) {
        if (i < 0 || i >= 4) {
            return { x: 0, y: 0 };
        }
        const c = CORNERS[i];
        const x = c[0] * this.#width * 0.5;
        const y = c[1] * this.#height * 0.5;
        return {
            x: x * Math.cos(this.#rotation) - y * Math.sin(this.#rotation) + this.#center.x,
            y: x * Math.sin(this.#rotation) + y * Math.cos(this.#rotation) + this.#center.y,
        };
    }
    set(values) {
        if (values.rotation !== undefined) {
            this.#rotation = values.rotation;
        }
        if (values.left !== undefined) {
            this.#center.x = values.left;
        }
        if (values.top !== undefined) {
            this.#center.y = values.top;
        }
        if (values.width !== undefined) {
            this.#width = values.width;
        }
        if (values.height !== undefined) {
            this.#height = values.height;
        }
        this.#refresh();
    }
    setMode(values) {
        if (values.rotation !== undefined) {
            this.#canRotate = values.rotation;
        }
        if (values.translation !== undefined) {
            this.#translationMode = values.translation;
        }
        if (values.resize !== undefined) {
            this.#resizeMode = values.resize;
        }
        if (values.resizeOrigin !== undefined) {
            this.#resizeOrigin = values.resizeOrigin;
        }
        if (values.scale !== undefined) {
            this.#scale = values.scale;
        }
        this.#refresh();
    }
    setMinWidth(minWidth) {
        this.#minWidth = minWidth;
    }
    setMinHeight(minHeight) {
        this.#minHeight = minHeight;
    }
    connectedCallback() {
        this.#refresh();
    }
    #refresh() {
        this.style.setProperty('--translate', this.#translationMode);
        this.style.setProperty('--rotate', this.#canRotate ? '1' : '0');
        this.style.setProperty('--resize-x', hasX(this.#resizeMode) ? '1' : '0');
        this.style.setProperty('--resize-y', hasY(this.#resizeMode) ? '1' : '0');
        this.style.setProperty('--scale', this.#scale == ManipulatorDirection.All ? '1' : '0');
        this.style.setProperty('--skew', this.#skew);
        this.#htmlQuad.style.rotate = `${this.#rotation}rad`;
        const width = Math.abs(this.#width);
        const height = Math.abs(this.#height);
        this.#htmlQuad.style.left = `${this.#center.x - width * 0.5}px`;
        this.#htmlQuad.style.top = `${this.#center.y - height * 0.5}px`;
        this.#htmlQuad.style.width = `${width}px`;
        this.#htmlQuad.style.height = `${height}px`;
        for (let i = 0; i < 4; i++) {
            const c = CORNERS[i];
            const htmlCorner = this.#htmlScaleCorners[i];
            htmlCorner.style.left = `${(c[0] == -1 ? 0 : 1) * width}px`;
            htmlCorner.style.top = `${(c[1] == -1 ? 0 : 1) * height}px`;
        }
        for (let i = 0; i < 4; i++) {
            const s = SIDES[i];
            const htmlSide = this.#htmlResizeSides[i];
            htmlSide.style.left = `${s[0] * width}px`;
            htmlSide.style.top = `${s[1] * height}px`;
        }
        if (this.#htmlRotator) {
            this.#htmlRotator.style.left = `${0.5 * width}px`;
            this.#htmlRotator.style.top = `${-0.2 * height}px`;
        }
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'translate':
                this.#translationMode = getDirection(newValue);
                break;
            case 'rotate':
                this.#canRotate = toBool(newValue);
                break;
            case 'resize':
                this.#resizeMode = getDirection(newValue);
                break;
            case 'resize-origin':
                this.#resizeOrigin = getResizeOrigin(newValue);
                break;
            case 'scale':
                this.#scale = getDirection(newValue);
                break;
            case 'skew':
                this.#skew = getDirection(newValue);
                break;
            case 'width':
                this.#width = Number(newValue);
                break;
            case 'height':
                this.#height = Number(newValue);
                break;
            case 'min-width':
                this.#minWidth = Number(newValue);
                break;
            case 'min-height':
                this.#minHeight = Number(newValue);
                break;
        }
        this.#refresh();
    }
    static get observedAttributes() {
        return ['translate', 'rotate', 'resize', 'scale', 'resize-origin', 'skew', 'width', 'height', 'min-width', 'min-height'];
    }
    #deltaMove(event) {
        const left = this.#translationMode == ManipulatorDirection.All || this.#translationMode == ManipulatorDirection.X;
        const top = this.#translationMode == ManipulatorDirection.All || this.#translationMode == ManipulatorDirection.Y;
        const delta = this.#getDelta(event);
        const deltaX = this.convertToUnit(delta.x, 'width') * this.#transformScale;
        const deltaY = this.convertToUnit(delta.y, 'height') * this.#transformScale;
        if (top) {
            this.#center.y = this.#startTop + deltaY;
        }
        if (left) {
            this.#center.x = this.#startLeft + deltaX;
        }
        this.#update(ManipulatorUpdatedEventType.Position);
    }
    #deltaResize(event) {
        function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        if (!((this.#dragCorner > ManipulatorCorner.None && this.#scale == ManipulatorDirection.All) ||
            (this.#dragSide > ManipulatorSide.None && this.#resizeMode == ManipulatorDirection.All) ||
            ((this.#dragSide == ManipulatorSide.Left || this.#dragSide == ManipulatorSide.Right) && this.#resizeMode == ManipulatorDirection.X) ||
            ((this.#dragSide == ManipulatorSide.Top || this.#dragSide == ManipulatorSide.Bottom) && this.#resizeMode == ManipulatorDirection.Y))) {
            return;
        }
        const delta = this.#getDelta(event);
        if (!event.shiftKey && this.#dragCorner > ManipulatorCorner.None) {
            const tl = this.#startCorners[ManipulatorCorner.TopLeft];
            const br = this.#startCorners[ManipulatorCorner.BottomRight];
            const startCenter = { x: (tl.x + br.x) * 0.5, y: (tl.y + br.y) * 0.5 };
            const v = { x: this.#startCorners[this.#dragCorner].x - startCenter.x, y: this.#startCorners[this.#dragCorner].y - startCenter.y };
            const norm = Math.sqrt(v.x * v.x + v.y * v.y);
            v.x = v.x / norm * (this.#startWidth < 0 ? -1 : 1);
            v.y = v.y / norm * (this.#startHeight < 0 ? -1 : 1);
            const d = dot(delta, v);
            delta.x = v.x * d;
            delta.y = v.y * d;
        }
        if (this.#dragSide > ManipulatorSide.None) {
            const c = SCALE_SIDES[this.#dragSide];
            const v = { x: c[0] * Math.cos(this.#rotation) - c[1] * Math.sin(this.#rotation), y: c[0] * Math.sin(this.#rotation) + c[1] * Math.cos(this.#rotation) };
            const d = dot(delta, v);
            delta.x = v.x * d;
            delta.y = v.y * d;
        }
        delta.x *= this.#transformScale;
        delta.y *= this.#transformScale;
        const qp_x = this.#qp0_x + delta.x;
        const qp_y = this.#qp0_y + delta.y;
        let resizeOrigin = this.#resizeOrigin;
        if (event.altKey) {
            if (resizeOrigin == ManipulatorResizeOrigin.Center) {
                resizeOrigin = ManipulatorResizeOrigin.OppositeCorner;
            }
            else {
                resizeOrigin = ManipulatorResizeOrigin.Center;
            }
        }
        const cp_x = resizeOrigin == ManipulatorResizeOrigin.Center ? this.#c0_x : (qp_x + this.#pp_x) * 0.5;
        const cp_y = resizeOrigin == ManipulatorResizeOrigin.Center ? this.#c0_y : (qp_y + this.#pp_y) * 0.5;
        const mtheta = -this.#rotation;
        const cos_mt = Math.cos(mtheta);
        const sin_mt = Math.sin(mtheta);
        let q_x = qp_x * cos_mt - qp_y * sin_mt - cos_mt * cp_x + sin_mt * cp_y + cp_x;
        let q_y = qp_x * sin_mt + qp_y * cos_mt - sin_mt * cp_x - cos_mt * cp_y + cp_y;
        let p_x = this.#pp_x * cos_mt - this.#pp_y * sin_mt - cos_mt * cp_x + sin_mt * cp_y + cp_x;
        let p_y = this.#pp_x * sin_mt + this.#pp_y * cos_mt - sin_mt * cp_x - cos_mt * cp_y + cp_y;
        const matrix = this.#resizeMatrix();
        const wtmp = matrix.a * (q_x - p_x) + matrix.c * (p_x - q_x);
        const htmp = matrix.b * (q_y - p_y) + matrix.d * (p_y - q_y);
        let w;
        let h;
        if (wtmp < this.#minWidth || htmp < this.#minHeight) {
            w = Math.max(this.#minWidth, wtmp);
            h = Math.max(this.#minHeight, htmp);
            const theta = -mtheta;
            const cos_t = Math.cos(theta);
            const sin_t = Math.sin(theta);
            const dh_x = -sin_t * h;
            const dh_y = cos_t * h;
            const dw_x = cos_t * w;
            const dw_y = sin_t * w;
            const qp_x_min = this.#pp_x + (matrix.a - matrix.c) * dw_x + (matrix.b - matrix.d) * dh_x;
            const qp_y_min = this.#pp_y + (matrix.a - matrix.c) * dw_y + (matrix.b - matrix.d) * dh_y;
            const cp_x_min = (qp_x_min + this.#pp_x) * 0.5;
            const cp_y_min = (qp_y_min + this.#pp_y) * 0.5;
            q_x = qp_x_min * cos_mt - qp_y_min * sin_mt - cos_mt * cp_x_min + sin_mt * cp_y_min + cp_x_min;
            q_y = qp_x_min * sin_mt + qp_y_min * cos_mt - sin_mt * cp_x_min - cos_mt * cp_y_min + cp_y_min;
            p_x = this.#pp_x * cos_mt - this.#pp_y * sin_mt - cos_mt * cp_x_min + sin_mt * cp_y_min + cp_x_min;
            p_y = this.#pp_x * sin_mt + this.#pp_y * cos_mt - sin_mt * cp_x_min - cos_mt * cp_y_min + cp_y_min;
        }
        else {
            w = wtmp;
            h = htmp;
        }
        let deltaCenterX = 0;
        let deltaCenterY = 0;
        let deltaWidth = (w - this.#startWidth);
        let deltaHeight = h - this.#startHeight;
        const dx = (deltaWidth * Math.cos(this.#rotation) + deltaHeight * Math.sin(this.#rotation)) * 0.5;
        const dy = (deltaHeight * Math.cos(this.#rotation) + deltaWidth * Math.sin(this.#rotation)) * 0.5;
        if (resizeOrigin != ManipulatorResizeOrigin.Center) {
            switch (this.#dragSide) {
                case ManipulatorSide.Left:
                    deltaCenterX = -dx;
                    deltaCenterY = -dy;
                    break;
                case ManipulatorSide.Right:
                    deltaCenterX = dx;
                    deltaCenterY = dy;
                    break;
                case ManipulatorSide.Top:
                    deltaCenterX = dx;
                    deltaCenterY = -dy;
                    break;
                case ManipulatorSide.Bottom:
                    deltaCenterX = -dx;
                    deltaCenterY = dy;
                    break;
            }
            this.#center.x = this.#startCenter.x + deltaCenterX;
            this.#center.y = this.#startCenter.y + deltaCenterY;
            let oppositeCorner = ManipulatorCorner.None;
            switch (this.#dragCorner) {
                case ManipulatorCorner.TopLeft:
                    oppositeCorner = ManipulatorCorner.BottomRight;
                    break;
                case ManipulatorCorner.TopRight:
                    oppositeCorner = ManipulatorCorner.BottomLeft;
                    break;
                case ManipulatorCorner.BottomLeft:
                    oppositeCorner = ManipulatorCorner.TopRight;
                    break;
                case ManipulatorCorner.BottomRight:
                    oppositeCorner = ManipulatorCorner.TopLeft;
                    break;
            }
            if (oppositeCorner != ManipulatorCorner.None) {
                const startCorner = this.#startCorners[oppositeCorner];
                const c = CORNERS[this.#dragCorner];
                const x = c[0] * (this.#startWidth + deltaWidth) * 0.5;
                const y = c[1] * (this.#startHeight + deltaHeight) * 0.5;
                this.#center.x = startCorner.x + x * Math.cos(this.#rotation) - y * Math.sin(this.#rotation);
                this.#center.y = startCorner.y + x * Math.sin(this.#rotation) + y * Math.cos(this.#rotation);
            }
        }
        else {
            deltaWidth = 2 * deltaWidth;
            deltaHeight = 2 * deltaHeight;
        }
        //console.info("deltaWidth", deltaWidth);
        this.#width = this.#startWidth + deltaWidth * (this.#startWidth < 0 ? -1 : 1);
        this.#height = this.#startHeight + deltaHeight * (this.#startHeight < 0 ? -1 : 1);
        this.#update(ManipulatorUpdatedEventType.Size);
    }
    #getDelta(event) {
        let currentX = event.pageX;
        let currentY = event.pageY;
        if (event.ctrlKey) {
            currentX = this.#snapPosition(currentX);
            currentY = this.#snapPosition(currentY);
        }
        return {
            x: currentX - this.#startPageX,
            y: currentY - this.#startPageY,
        };
    }
    #resizeMatrix() {
        const a = (this.#dragCorner == ManipulatorCorner.BottomRight) || (this.#dragCorner == ManipulatorCorner.TopRight) || this.#dragSide == ManipulatorSide.Right ? 1 : 0;
        const b = (this.#dragCorner == ManipulatorCorner.BottomRight) || (this.#dragCorner == ManipulatorCorner.BottomLeft) || this.#dragSide == ManipulatorSide.Left || this.#dragSide == ManipulatorSide.Bottom ? 1 : 0;
        const c = a === 1 ? 0 : 1;
        const d = b === 1 ? 0 : 1;
        return {
            a,
            b,
            c,
            d
        };
    }
    convertToUnit(value, ratio) {
        return value;
        /*
        if (this.unit === 'px') {
        }

        if (this.unit === 'viewport') {
            const windowSize: number = ratio === 'width' ? window.innerWidth || screen.width : window.innerHeight || screen.height;
            return (value * 100) / windowSize;
        }

        const parentSize: number = ratio === 'width' ? this.parentWidth : this.parentHeight;
        return (value * 100) / parentSize;
        */
    }
    #initStartPositions(event) {
        this.#startPageX = event.pageX;
        this.#startPageY = event.pageY;
        const rect = this.#htmlQuad.getBoundingClientRect();
        const width = Math.abs(this.#htmlQuad.offsetWidth * Math.cos(this.#rotation)) + Math.abs(this.#htmlQuad.offsetHeight * Math.sin(this.#rotation));
        if (rect.width != 0) {
            this.#transformScale = width / rect.width;
        }
        else {
            this.#transformScale = 1;
        }
        this.#initStartPositionsMove();
        this.#initStartPositionsRotation();
        this.#initStartPositionsResize();
        this.#initStartCorners();
    }
    #initStartPositionsMove() {
        this.#startWidth = this.#width;
        this.#startHeight = this.#height;
        this.#startLeft = this.#center.x;
        this.#startTop = this.#center.y;
    }
    #initStartPositionsRotation() {
        const rect = this.#htmlQuad.getBoundingClientRect();
        this.#startRotationCenter.x = rect.left + rect.width * 0.5;
        this.#startRotationCenter.y = rect.top + rect.height * 0.5;
    }
    #initStartPositionsResize() {
        const theta = this.#rotation;
        const cos_t = Math.cos(theta);
        const sin_t = Math.sin(theta);
        const l = this.#center.x; // - this.#width * 0.5;
        const t = this.#center.y; //- this.#height * 0.5;
        const w = this.#width;
        const h = this.#height;
        const matrix = this.#resizeMatrix();
        this.#c0_x = this.#center.x;
        this.#c0_y = this.#center.y;
        const q0_x = l + matrix.a * w;
        const q0_y = t + matrix.b * h;
        const p0_x = l + matrix.c * w;
        const p0_y = t + matrix.d * h;
        this.#qp0_x = q0_x * cos_t - q0_y * sin_t - this.#c0_x * cos_t + this.#c0_y * sin_t + this.#c0_x;
        this.#qp0_y = q0_x * sin_t + q0_y * cos_t - this.#c0_x * sin_t - this.#c0_y * cos_t + this.#c0_y;
        this.#pp_x = p0_x * cos_t - p0_y * sin_t - this.#c0_x * cos_t + this.#c0_y * sin_t + this.#c0_x;
        this.#pp_y = p0_x * sin_t + p0_y * cos_t - this.#c0_x * sin_t - this.#c0_y * cos_t + this.#c0_y;
        this.#startCenter.x = this.#center.x;
        this.#startCenter.y = this.#center.y;
    }
    #initStartCorners() {
        for (let i = 0; i < 4; i++) {
            this.#startCorners[i] = this.getCorner(i);
        }
    }
    #rotateInput(event) {
        const result = prompt('rotation', String(this.#rotation * RAD_TO_DEG$1));
        if (result) {
            this.#rotation = Number(result) * DEG_TO_RAD$1;
            this.#update(ManipulatorUpdatedEventType.Rotation);
            this.#refresh();
            this.#dispatchEvent('updateend', ManipulatorUpdatedEventType.Rotation);
        }
    }
    #translateInput(event) {
        const result = prompt('center', `${this.#center.x} ${this.#center.y}`);
        if (result) {
            const a = result.split(' ');
            if (a.length >= 2) {
                this.#center.x = Number(a[0]);
                this.#center.y = Number(a[1]);
                this.#update(ManipulatorUpdatedEventType.Position);
                this.#refresh();
                this.#dispatchEvent('updateend', ManipulatorUpdatedEventType.Position);
            }
        }
    }
}
let defined2dManipulator = false;
function defineHarmony2dManipulator() {
    if (window.customElements && !defined2dManipulator) {
        customElements.define('harmony-2d-manipulator', HTMLHarmony2dManipulatorElement);
        defined2dManipulator = true;
        injectGlobalCss();
    }
}

var accordionCSS = ":host {\n\toverflow: hidden;\n\tdisplay: flex;\n\tjustify-content: center;\n\tflex-direction: column;\n\tposition: relative;\n\n\t/*--accordion-text-color: #000;*/\n}\n\n.item .header {\n\tcursor: pointer;\n\tdisplay: block;\n\tuser-select: none;\n\tpadding: 5px;\n\t/*color: var(--accordion-text-color)\n\tcolor: var(--accordion-text-color)*/\n}\n\n.item .content {\n\tdisplay: block;\n\toverflow: hidden;\n\theight: 0;\n\t/*transition: all 0.5s ease 0s;*/\n}\n\n.item .content.selected {\n\theight: unset;\n\tpadding: 10px;\n}\n\n\n@media (prefers-color-scheme: light) {\n\t:host {\n\t\t--accordion-text-color: #000;\n\t\t--accordion-background-color: #eee;\n\t\tcolor: #000;\n\t\tbackground: #eee;\n\t}\n}\n\n@media (prefers-color-scheme: dark) {\n\t:host {\n\t\t--accordion-text-color: #eee;\n\t\t--accordion-background-color: #000;\n\t\tcolor: #eee;\n\t\tbackground: #000;\n\t}\n}\n";

var itemCSS = "slot[name=\"header\"] {\n\tcursor: pointer;\n}\n";

class HTMLHarmonyItemElement extends HTMLElement {
    #shadowRoot;
    #htmlHeader;
    #htmlContent;
    #id = '';
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, itemCSS);
        this.#htmlHeader = createElement('slot', {
            name: 'header',
            parent: this.#shadowRoot,
        });
        this.#htmlContent = createElement('slot', {
            name: 'content',
            parent: this.#shadowRoot,
        });
    }
    getHeader() {
        return this.#htmlHeader;
    }
    getContent() {
        return this.#htmlContent;
    }
    getId() {
        return this.#id;
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'id':
            case 'item-id':
                this.#id = newValue;
                break;
        }
    }
    static get observedAttributes() {
        return ['id', 'item-id'];
    }
}
let definedHarmonyItem = false;
function defineHarmonyItem() {
    if (window.customElements && !definedHarmonyItem) {
        customElements.define('harmony-item', HTMLHarmonyItemElement);
        definedHarmonyItem = true;
    }
}

class HTMLHarmonyAccordionElement extends HTMLElement {
    #doOnce = true;
    #multiple = false;
    #disabled = false;
    #items = new Set();
    #selected = new Set();
    #shadowRoot;
    //#htmlSlots = new Set<HTMLSlotElement>();
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed', slotAssignment: "manual", });
        shadowRootStyle(this.#shadowRoot, accordionCSS);
        this.#initMutationObserver();
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.#processChilds();
            this.#doOnce = false;
        }
    }
    #processChilds() {
        for (const child of this.children) {
            this.#addItem(child);
        }
    }
    #addItem(item) {
        if (this.#items.has(item)) {
            return;
        }
        if (item.tagName == 'HARMONY-ITEM') {
            const htmlSlot = createElement('slot', {
                parent: this.#shadowRoot,
            });
            htmlSlot.assign(item);
            this.#items.add(item);
            item.getHeader().addEventListener('click', () => this.#toggle(item));
        }
        this.#refresh();
    }
    createItem(header, content) {
        const item = createElement('harmony-item', { childs: [header, content] });
        header.slot = 'header';
        content.slot = 'content';
        this.append(item);
        return item;
    }
    #refresh() {
        for (const htmlItem of this.#items) {
            hide(htmlItem.getContent());
        }
    }
    #toggle(htmlItem, collapse = true) {
        //let content = this.#items.get(header);
        /*
        if (collapse && !this.#multiple) {
            for (let selected of this.#selected) {
                if (htmlItem != selected) {
                    this.#toggle(selected, false);
                }
            }
        }*/
        if (this.#selected.has(htmlItem)) {
            this.#display(htmlItem, false);
        }
        else {
            this.#display(htmlItem, true);
        }
    }
    #display(htmlItem, display) {
        if (display) {
            this.#selected.add(htmlItem);
            //htmlHeader.classList.add('selected');
            //htmlContent.classList.add('selected');
            show(htmlItem);
            show(htmlItem.getContent());
            this.#dispatchSelect(true, htmlItem);
            if (!this.#multiple) {
                for (const selected of this.#selected) {
                    if (htmlItem != selected) {
                        this.#display(selected, false);
                    }
                }
            }
        }
        else {
            this.#selected.delete(htmlItem);
            //htmlHeader.classList.remove('selected');
            //htmlContent.classList.remove('selected');
            hide(htmlItem.getContent());
            this.#dispatchSelect(false, htmlItem);
        }
    }
    clear() {
        this.#items.clear();
        this.#selected.clear();
        this.#refresh();
    }
    expand(id) {
        for (const htmlItem of this.#items) {
            if (htmlItem.getId() == id) {
                this.#display(htmlItem, true);
            }
        }
    }
    expandAll() {
        for (const htmlItem of this.#items) {
            this.#display(htmlItem, true);
        }
    }
    collapse(id) {
        for (const htmlItem of this.#items) {
            if (htmlItem.getId() == id) {
                this.#display(htmlItem, false);
            }
        }
    }
    collapseAll() {
        for (const htmlItem of this.#items) {
            this.#display(htmlItem, false);
        }
    }
    #dispatchSelect(selected, htmlItem) {
        const htmlHeader = htmlItem.getHeader();
        const htmlContent = htmlItem.getContent();
        this.dispatchEvent(new CustomEvent(selected ? 'select' : 'unselect', {
            detail: {
                id: htmlItem.getId(),
                header: htmlHeader.assignedElements()[0],
                content: htmlContent.assignedElements()[0]
            }
        }));
    }
    #initMutationObserver() {
        const config = { childList: true, subtree: true };
        const mutationCallback = (mutationsList, observer) => {
            for (const mutation of mutationsList) {
                const addedNodes = mutation.addedNodes;
                for (const addedNode of addedNodes) {
                    if (addedNode.parentNode == this) {
                        this.#addItem(addedNode);
                    }
                }
            }
        };
        const observer = new MutationObserver(mutationCallback);
        observer.observe(this, config);
    }
    set disabled(disabled) {
        this.#disabled = disabled ? true : false;
        this.classList[this.#disabled ? 'add' : 'remove']('disabled');
    }
    get disabled() {
        return this.#disabled;
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'multiple':
                this.#multiple = toBool(newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['multiple'];
    }
}
let definedAccordion = false;
function defineHarmonyAccordion() {
    if (window.customElements && !definedAccordion) {
        defineHarmonyItem();
        customElements.define('harmony-accordion', HTMLHarmonyAccordionElement);
        definedAccordion = true;
        injectGlobalCss();
    }
}

var colorPickerCSS = ":host {\n\t--harmony-color-picker-shadow-width: var(--harmony-color-picker-width, 15rem);\n\t--harmony-color-picker-shadow-height: var(--harmony-color-picker-height, 15rem);\n\t--harmony-color-picker-shadow-gap: var(--harmony-color-picker-gap, 0.5rem);\n\n\t--foreground-layer: none;\n\n\tbackground-color: var(--main-bg-color-bright);\n\tpadding: var(--harmony-color-picker-shadow-gap);\n\tbox-sizing: border-box;\n\tdisplay: inline-grid;\n\t/*grid-template-rows: 1rem 5fr;\n\tgrid-template-columns: 2fr 2fr 1rem;*/\n\tcolumn-gap: var(--harmony-color-picker-shadow-gap);\n\trow-gap: var(--harmony-color-picker-shadow-gap);\n\n\t/*width: var(--harmony-color-picker-width, 10rem);\n\theight: var(--harmony-color-picker-height, 10rem);*/\n\t/*display: flex;\n\tflex-wrap: wrap;*/\n\tgrid-template-areas: \"h h h h\" \"m m m a\" \"i i s s\" \"b b b b\";\n}\n\n#hue-picker {\n\tposition: relative;\n\t/*flex-basis: var(--harmony-color-picker-shadow-width);*/\n\tpadding: 1rem;\n\tbackground-image: linear-gradient(90deg, red, yellow, lime, cyan, blue, magenta, red);\n\tgrid-area: h;\n\theight: 0;\n}\n\n#main-picker {\n\tposition: relative;\n\tgrid-area: m;\n\twidth: var(--harmony-color-picker-shadow-width);\n\theight: var(--harmony-color-picker-shadow-height);\n\tbackground-image: linear-gradient(180deg, white, rgba(255, 255, 255, 0) 50%), linear-gradient(0deg, black, rgba(0, 0, 0, 0) 50%), linear-gradient(90deg, #808080, rgba(128, 128, 128, 0));\n\tbackground-color: currentColor;\n}\n\n#alpha-picker {\n\tposition: relative;\n\tpadding: 1rem;\n\tgrid-area: a;\n\twidth: 0;\n}\n\n#hue-selector {\n\tpadding: 1rem 0.2rem;\n}\n\n#alpha-selector {\n\tpadding: 0.2rem 1rem;\n}\n\n#main-selector {\n\tpadding: 0.5rem;\n\tborder-radius: 50%;\n}\n\n#input {\n\twidth: calc(var(--harmony-color-picker-shadow-width) * 0.6);\n\tgrid-area: i;\n\tfont-family: monospace;\n\tfont-size: 1.5rem;\n\tbox-sizing: border-box;\n}\n\n#sample {\n\tgrid-area: s;\n\t/*width: calc(var(--harmony-color-picker-shadow-width) * 0.25);*/\n}\n\n#buttons {\n\tgrid-area: b;\n\tdisplay: flex;\n\tgap: 2rem;\n}\n\n#buttons>button {\n\tflex: 1;\n\tfont-size: 1.5rem;\n\tcursor: pointer;\n}\n\n.alpha-background {\n\tbackground: var(--foreground-layer),\n\t\tlinear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0 / 1rem 1rem,\n\t\tlinear-gradient(45deg, lightgrey 25%, white 25%, white 75%, lightgrey 75%) 0.5em 0.5em / 1em 1em;\n}\n\n.selector {\n\tposition: absolute;\n\tborder: 2px solid #fff;\n\tborder-radius: 100%;\n\tbox-shadow: 0 0 3px 1px #67b9ff;\n\ttransform: translate(-50%, -50%);\n\tcursor: pointer;\n\tdisplay: block;\n\tbackground: none;\n\tborder-radius: 2px;\n}\n";

class HTMLHarmonyColorPickerElement extends HTMLElement {
    #doOnce = true;
    #shadowRoot;
    #color = new Color$1({ hex: '#00ffffff' });
    #htmlHuePicker;
    #htmlHueSelector;
    #htmlMainPicker;
    #htmlMainSelector;
    #htmlAlphaPicker;
    #htmlAlphaSelector;
    #htmlInput;
    #htmlSample;
    #htmlOk;
    #htmlCancel;
    #dragElement = null;
    #shiftX = 0;
    #shiftY = 0;
    #pageX = 0;
    #pageY = 0;
    constructor() {
        super();
        document.addEventListener('mouseup', () => this.#dragElement = null);
        document.addEventListener('mousemove', event => this.#handleMouseMove(event));
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, colorPickerCSS);
        this.#htmlHuePicker = createElement('div', {
            parent: this.#shadowRoot,
            id: 'hue-picker',
            child: this.#htmlHueSelector = createElement('div', {
                id: 'hue-selector',
                class: 'selector',
                events: {
                    mousedown: (event) => this.#handleMouseDown(event),
                },
            }),
            events: {
                mousedown: (event) => {
                    this.#updateHue(event.offsetX / this.#htmlHuePicker.offsetWidth);
                    this.#handleMouseDown(event, this.#htmlHueSelector);
                },
            },
        });
        this.#htmlMainPicker = createElement('div', {
            parent: this.#shadowRoot,
            id: 'main-picker',
            child: this.#htmlMainSelector = createElement('div', {
                id: 'main-selector',
                class: 'selector',
                events: {
                    mousedown: (event) => this.#handleMouseDown(event),
                },
            }),
            events: {
                mousedown: (event) => {
                    this.#updateSatLum(event.offsetX / this.#htmlMainPicker.offsetWidth, 1 - (event.offsetY / this.#htmlMainPicker.offsetHeight));
                    this.#handleMouseDown(event, this.#htmlMainSelector);
                },
            },
        });
        this.#htmlAlphaPicker = createElement('div', {
            parent: this.#shadowRoot,
            id: 'alpha-picker',
            class: 'alpha-background',
            child: this.#htmlAlphaSelector = createElement('div', {
                id: 'alpha-selector',
                class: 'selector',
                events: {
                    mousedown: (event) => this.#handleMouseDown(event),
                },
            }),
            events: {
                mousedown: (event) => {
                    this.#updateAlpha(1 - (event.offsetY / this.#htmlAlphaPicker.offsetHeight));
                    this.#handleMouseDown(event, this.#htmlAlphaSelector);
                },
            },
        });
        this.#htmlInput = createElement('input', {
            parent: this.#shadowRoot,
            id: 'input',
            events: {
                change: () => this.#updateHex(this.#htmlInput.value),
            }
        });
        this.#htmlSample = createElement('div', {
            parent: this.#shadowRoot,
            id: 'sample',
            class: 'alpha-background',
        });
        createElement('div', {
            parent: this.#shadowRoot,
            id: 'buttons',
            childs: [
                this.#htmlOk = createElement('button', {
                    parent: this.#shadowRoot,
                    i18n: '#ok',
                    events: {
                        click: () => {
                            this.#updateHex(this.#htmlInput.value);
                            this.dispatchEvent(new CustomEvent('ok', { detail: { hex: this.#color.getHex(), rgba: this.#color.getRgba() } }));
                        },
                    },
                }),
                this.#htmlCancel = createElement('button', {
                    parent: this.#shadowRoot,
                    i18n: '#cancel',
                    events: {
                        click: () => this.dispatchEvent(new CustomEvent('cancel')),
                    }
                }),
            ],
        });
    }
    #updateAlpha(alpha) {
        this.#color.alpha = alpha;
        this.#update();
        this.#colorChanged();
    }
    #updateHue(hue) {
        this.#color.setHue(hue);
        this.#update();
        this.#colorChanged();
    }
    #updateHex(hex) {
        this.#color.setHex(hex);
        this.#update();
        this.#colorChanged();
    }
    #updateSatLum(sat, lum) {
        /*const sat = event.offsetX / event.target.offsetWidth;
        const lum = 1 - event.offsetY / event.target.offsetHeight;*/
        this.#color.setSatLum(sat, lum);
        this.#update();
        this.#colorChanged();
    }
    #colorChanged() {
        this.dispatchEvent(new CustomEvent('change', { detail: { hex: this.#color.getHex(), rgba: this.#color.getRgba() } }));
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.#update();
            this.#doOnce = false;
        }
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    #update() {
        const red = this.#color.red * 255;
        const green = this.#color.green * 255;
        const blue = this.#color.blue * 255;
        const hsl = this.#color.getHsl();
        const hue = hsl[0];
        const sat = hsl[1];
        const lum = hsl[2];
        this.#htmlAlphaPicker.style.cssText = `--foreground-layer: linear-gradient(rgb(${red} ${green} ${blue} / 1), rgb(${red} ${green} ${blue} / 0));`;
        // Note: As of today (feb 2024) the css image() function is not yet supported by any browser. We resort to use a constant linear gradient
        this.#htmlSample.style.cssText = `--foreground-layer: linear-gradient(rgb(${red} ${green} ${blue} / ${this.#color.alpha}), rgb(${red} ${green} ${blue} / ${this.#color.alpha}));`;
        this.#htmlMainPicker.style.cssText = `color: hsl(${hue}turn 100% 50%)`;
        this.#htmlInput.value = this.#color.getHex();
        this.#htmlHueSelector.style.left = `${hue * 100}%`;
        this.#htmlAlphaSelector.style.top = `${100 - this.#color.alpha * 100}%`;
        this.#htmlMainSelector.style.left = `${sat * 100}%`;
        this.#htmlMainSelector.style.top = `${100 - lum * 100}%`;
    }
    getColor() {
        return this.#color;
    }
    setHex(hex) {
        this.#color.setHex(hex);
        this.#update();
    }
    #handleMouseDown(event, selector) {
        this.#dragElement = selector ?? event.currentTarget;
        this.#shiftX = (selector ?? event.currentTarget).offsetLeft;
        this.#shiftY = (selector ?? event.currentTarget).offsetTop;
        this.#pageX = event.pageX;
        this.#pageY = event.pageY;
        event.stopPropagation();
    }
    #handleMouseMove(event) {
        const pageX = event.pageX - this.#pageX;
        const pageY = event.pageY - this.#pageY;
        switch (this.#dragElement) {
            case this.#htmlHueSelector:
                const hue = Math.max(Math.min((pageX + this.#shiftX) / this.#htmlHuePicker.offsetWidth, 1), 0);
                this.#updateHue(hue);
                break;
            case this.#htmlMainSelector:
                const sat = Math.max(Math.min((pageX + this.#shiftX) / this.#htmlMainPicker.offsetWidth, 1), 0);
                const lum = Math.max(Math.min((pageY + this.#shiftY) / this.#htmlMainPicker.offsetHeight, 1), 0);
                this.#updateSatLum(sat, 1 - lum);
                break;
            case this.#htmlAlphaSelector:
                const alpha = Math.max(Math.min((pageY + this.#shiftY) / this.#htmlAlphaPicker.offsetHeight, 1), 0);
                this.#updateAlpha(1 - alpha);
                break;
        }
    }
}
let definedColorPicker = false;
function defineHarmonyColorPicker() {
    if (window.customElements && !definedColorPicker) {
        customElements.define('harmony-color-picker', HTMLHarmonyColorPickerElement);
        definedColorPicker = true;
        injectGlobalCss();
    }
}

var menuCSS = ":host {\n\tfont-size: 1.5em;\n\tcursor: not-allowed;\n\tbackground-color: green;\n\tbackground-color: var(--theme-menu-bg-color);\n\toverflow: auto;\n\tz-index: 100000;\n}\n\n:host-context(.contextual) {\n\tposition: absolute;\n}\n\n.harmony-menu-item {\n\tbackground-color: green;\n\tcursor: pointer;\n\tbackground-color: var(--theme-menu-item-bg-color);\n}\n\n.harmony-menu-item.disabled {\n\tpointer-events: none;\n}\n\n.harmony-menu-item.selected {\n\tbackground-color: blue;\n\tbackground-color: var(--theme-menu-item-selected-bg-color);\n}\n\n\n.harmony-menu-item.separator {\n\theight: 5px;\n\tbackground-color: black;\n}\n\n.harmony-menu-item>.harmony-menu-item-title:hover {\n\tbackground-color: var(--theme-menu-item-hover-bg-color);\n}\n\n.harmony-menu-item.selected>.harmony-menu-item-title::after {\n\tcontent: \"✔\";\n\tright: 0px;\n\tposition: absolute;\n}\n\n.harmony-menu-item>.harmony-menu-item-title::after {\n\ttransition: all 0.2s ease 0s;\n\twidth: 32px;\n\theight: 32px;\n}\n\n.harmony-menu-item.closed>.harmony-menu-item-title,\n.harmony-menu-item.opened>.harmony-menu-item-title {\n\tpadding-right: 32px;\n}\n\n.harmony-menu-item.closed>.harmony-menu-item-title::after {\n\tcontent: \"➤\";\n\tright: 0px;\n\tposition: absolute;\n}\n\n.harmony-menu-item.opened>.harmony-menu-item-title::after {\n\tcontent: \"➤\";\n\tright: 0px;\n\tposition: absolute;\n\t/*writing-mode: vertical-rl; */\n\ttransform: rotate(90deg);\n}\n\n.harmony-menu-item .submenu {\n\tbackground-color: var(--theme-menu-submenu-bg-color);\n\tpadding-left: 10px;\n\tmargin-left: 2px;\n\tdisplay: none;\n\toverflow: hidden;\n\tposition: relative;\n\tbackground-color: var(--theme-menu-submenu-fg-color);\n}\n\n.harmony-menu-item.opened>.submenu {\n\tdisplay: block;\n}\n";

class HTMLHarmonyMenuElement extends HTMLElement {
    #doOnce = true;
    #subMenus = new Map();
    #shadowRoot;
    #contextual = false;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        document.addEventListener('click', (event) => {
            if (this.#contextual && !this.contains(event.target)) {
                this.close();
            }
        });
    }
    show(items, userData) {
        this.#setItems(items, userData);
        this.#checkSize();
    }
    showContextual(items, clientX, clientY, userData) {
        document.body.append(this);
        this.style.left = clientX + 'px';
        this.style.top = clientY + 'px';
        this.classList.add('contextual');
        this.#contextual = true;
        this.show(items, userData);
    }
    #checkSize() {
        const bodyRect = document.body.getBoundingClientRect();
        const elemRect = this.getBoundingClientRect();
        this.style.maxWidth = bodyRect.width + 'px';
        this.style.maxHeight = bodyRect.height + 'px';
        if (elemRect.right > bodyRect.right) {
            this.style.left = Math.max((bodyRect.width - elemRect.width), 0) + 'px';
            /*if (elemRect.width > bodyRect.width) {
                this.style.maxWidth = bodyRect.width + 'px';
            } else {
                this.style.maxWidth = '';
            }*/
        }
        if (elemRect.bottom > bodyRect.bottom) {
            this.style.top = Math.max((bodyRect.height - elemRect.height), 0) + 'px';
            /*if (elemRect.height > bodyRect.height) {
                this.style.maxHeight = bodyRect.height + 'px';
            } else {
                this.style.maxHeight = '';
            }*/
        }
        if (elemRect.left < 0) {
            this.style.left = '0px';
        }
        if (elemRect.top < 0) {
            this.style.top = '0px';
        }
    }
    close() {
        if (this.#contextual) {
            this.remove();
        }
    }
    connectedCallback() {
        if (this.#doOnce) {
            I18n.observeElement(this.#shadowRoot);
            shadowRootStyle(this.#shadowRoot, menuCSS);
            const callback = (entries, observer) => {
                entries.forEach(() => {
                    this.#checkSize();
                });
            };
            const resizeObserver = new ResizeObserver(callback);
            resizeObserver.observe(this);
            resizeObserver.observe(document.body);
            this.#doOnce = false;
        }
    }
    #setItems(items, userData) {
        this.#shadowRoot.innerHTML = '';
        if (items instanceof Array) {
            for (const item of items) {
                this.#shadowRoot.append(this.addItem(item, userData));
            }
        }
        else {
            for (const itemId in items) {
                const item = items[itemId];
                this.#shadowRoot.append(this.addItem(item, userData));
            }
        }
    }
    #openSubMenu(htmlSubMenu) {
        for (const [htmlItem, sub] of this.#subMenus) {
            if (sub == htmlSubMenu || sub.contains(htmlSubMenu)) {
                htmlItem.classList.add('opened');
                htmlItem.classList.remove('closed');
            }
            else {
                htmlItem.classList.remove('opened');
                htmlItem.classList.add('closed');
            }
        }
        this.#checkSize();
    }
    addItem(item, userData) {
        const htmlItem = createElement('div', {
            class: 'harmony-menu-item',
        });
        if (!item) {
            htmlItem.classList.add('separator');
        }
        else {
            const htmlItemTitle = createElement('div', {
                class: 'harmony-menu-item-title',
            });
            if (item.i18n) {
                htmlItemTitle.classList.add('i18n');
                htmlItemTitle.setAttribute('data-i18n', item.i18n);
                htmlItemTitle.innerHTML = item.i18n;
            }
            else {
                htmlItemTitle.innerText = item.name ?? '';
            }
            htmlItem.append(htmlItemTitle);
            if (item.selected) {
                htmlItem.classList.add('selected');
            }
            if (item.disabled) {
                htmlItem.classList.add('disabled');
            }
            if (item.submenu) {
                const htmlSubMenu = createElement('div', {
                    class: 'submenu',
                });
                this.#subMenus.set(htmlItem, htmlSubMenu);
                let subItems = 0;
                if (item.submenu instanceof Array) {
                    for (const subItem of item.submenu) {
                        htmlSubMenu.append(this.addItem(subItem, userData));
                        ++subItems;
                    }
                }
                else {
                    for (const subItemName in item.submenu) {
                        const subItem = item.submenu[subItemName];
                        htmlSubMenu.append(this.addItem(subItem, userData));
                        ++subItems;
                    }
                }
                htmlItem.append(htmlSubMenu);
                //htmlSubMenu.style.display = 'none';
                htmlItem.classList.add('closed');
                if (item.opened) {
                    this.#openSubMenu(htmlSubMenu);
                }
                htmlItem.addEventListener('click', event => {
                    this.#openSubMenu(htmlSubMenu);
                    if (item.cmd) {
                        this.dispatchEvent(new CustomEvent(item.cmd));
                    }
                    if (item.f) {
                        item.f(userData);
                    }
                    event.stopPropagation();
                });
                if (subItems == 0) {
                    hide(htmlItem);
                }
            }
            else {
                htmlItem.addEventListener('click', (event) => {
                    if (item.cmd) {
                        this.dispatchEvent(new CustomEvent(item.cmd));
                    }
                    if (item.f) {
                        item.f(userData);
                    }
                    event.stopPropagation();
                });
                htmlItem.addEventListener('click', () => this.close());
            }
        }
        return htmlItem;
    }
}
let definedMenu = false;
function defineHarmonyMenu() {
    if (window.customElements && !definedMenu) {
        customElements.define('harmony-menu', HTMLHarmonyMenuElement);
        definedMenu = true;
        injectGlobalCss();
    }
}

var copyCSS = "harmony-copy {\n\tcursor: pointer;\n\tposition: relative;\n}\n\n.harmony-copy-copied {\n\ttransition: top 1s;\n\tposition: absolute;\n\ttop: 0%;\n}\n\n.harmony-copy-copied-end {\n\ttop: -100%;\n}\n";

class HTMLHarmonyCopyElement extends HTMLElement {
    #doOnce = true;
    #htmlCopied;
    constructor() {
        super();
        this.#htmlCopied = createElement('div', { class: 'harmony-copy-copied' });
        this.addEventListener('click', () => this.#copy());
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.#doOnce = false;
            this.append(this.#htmlCopied);
            hide(this.#htmlCopied);
        }
    }
    async #copy() {
        try {
            const text = this.innerText;
            this.#htmlCopied.innerText = text;
            show(this.#htmlCopied);
            await navigator.clipboard.writeText(text);
            this.#htmlCopied.classList.add('harmony-copy-copied-end');
            setTimeout(() => { this.#htmlCopied.classList.remove('harmony-copy-copied-end'); hide(this.#htmlCopied); }, 1000);
        }
        catch (e) {
            console.log(e);
        }
    }
}
let definedCopy = false;
function defineHarmonyCopy() {
    if (window.customElements && !definedCopy) {
        customElements.define('harmony-copy', HTMLHarmonyCopyElement);
        documentStyle(copyCSS);
        definedCopy = true;
        injectGlobalCss();
    }
}

var fileInputCSS = "label {\n\tcursor: pointer;\n\theight: 100%;\n\tdisplay: flex;\n\tuser-select: none;\n}\n\nlabel>span {\n\tmargin: auto;\n}\n\n.tooltip {\n\tposition: relative;\n}\n\n.text {\n\tflex: 1;\n\tfont-size: 2rem;\n}\n\n.icon,\n.info {\n\tzoom: 2;\n}\n";

var tooltipCSS = ":host {\n\tdisplay: grid;\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\ttop: 0;\n\tanchor-name: --anchor-el;\n}\n\n:host(:hover) {\n\t--harmony-tooltip-hover: 1;\n}\n\n.tooltip {\n\t--bottom-tip: conic-gradient(from -30deg at bottom, rgba(0, 0, 0, 0), #000 1deg 60deg, rgba(0, 0, 0, 0) 61deg) bottom / 100% 50% no-repeat;\n\t--top-tip: conic-gradient(from 150deg at top, rgba(0, 0, 0, 0), #000 1deg 60deg, rgba(0, 0, 0, 0) 61deg) top / 100% 50% no-repeat;\n\t--right-tip: conic-gradient(from -120deg at right, rgba(0, 0, 0, 0), #000 1deg 60deg, rgba(0, 0, 0, 0) 61deg) right / 50% 100% no-repeat;\n\t--left-tip: conic-gradient(from 60deg at left, rgba(0, 0, 0, 0), #000 1deg 60deg, rgba(0, 0, 0, 0) 61deg) left / 50% 100% no-repeat;\n\n\t--p-inline: 1.5ch;\n\t--p-block: .75ch;\n\t--triangle-size: 0.5rem;\n\t--bg: hsl(0 0% 20%);\n\n\n\n\tpointer-events: none;\n\tuser-select: none;\n\topacity: var(--harmony-tooltip-hover, 0);\n\tposition: fixed;\n\tposition-anchor: --anchor-el;\n\t/*top: anchor(bottom);*/\n\t/*justify-self: anchor-center;*/\n\tjustify-self: var(--justify);\n\tbottom: var(--bottom);\n\tleft: var(--left);\n\tright: var(--right);\n\ttop: var(--top);\n\n\tmax-width: 10rem;\n\tbackground-color: var(--bg);\n\tcolor: #fff;\n\ttext-align: center;\n\tborder-radius: 6px;\n\tpadding: 0.3rem 0.3rem;\n\tz-index: 1;\n\ttransition: opacity 0.3s;\n}\n\n.tooltip::after {\n\tcontent: \"\";\n\tbackground: var(--bg);\n\tposition: absolute;\n\tz-index: -1;\n\tinset: 0;\n\tmask: var(--tip);\n\tinset-block-start: var(--inset-block-start-tip, 0);\n\tinset-block-end: var(--inset-block-end-tip, 0);\n\tborder-block-start: var(--border-block-start-tip, 0);\n\tborder-block-end: var(--border-block-end-tip, 0);\n\tinset-inline-start: var(--inset-inline-start-tip, 0);\n\tinset-inline-end: var(--inset-inline-end-tip, 0);\n\tborder-inline-start: var(--border-inline-start-tip, 0);\n\tborder-inline-end: var(--border-inline-end-tip, 0);\n}\n\n.tooltip:is([data-position=\"top\"], :not([data-position])) {\n\t--bottom: anchor(top);\n\t--justify: anchor-center;\n\t--tip: var(--bottom-tip);\n\t--inset-block-end-tip: calc(var(--triangle-size) * -1);\n\t--border-block-end-tip: var(--triangle-size) solid transparent;\n}\n\n.tooltip[data-position=\"left\"] {\n\t--right: anchor(left);\n\t--tip: var(--right-tip);\n\t--inset-inline-end-tip: calc(var(--triangle-size) * -1);\n\t--border-inline-end-tip: var(--triangle-size) solid transparent;\n}\n\n.tooltip[data-position=\"right\"] {\n\t--left: anchor(right);\n\t--tip: var(--left-tip);\n\t--inset-inline-start-tip: calc(var(--triangle-size) * -1);\n\t--border-inline-start-tip: var(--triangle-size) solid transparent;\n}\n\n.tooltip[data-position=\"bottom\"] {\n\t--top: anchor(bottom);\n\t--justify: anchor-center;\n\t--tip: var(--top-tip);\n\t--inset-block-start-tip: calc(var(--triangle-size) * -1);\n\t--border-block-start-tip: var(--triangle-size) solid transparent;\n}\n";

class HTMLHarmonyTooltipElement extends HTMLElement {
    #shadowRoot;
    #htmlText;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, tooltipCSS);
        I18n.observeElement(this.#shadowRoot);
        this.#htmlText = createElement('div', {
            class: 'tooltip',
            parent: this.#shadowRoot,
        });
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'data-label':
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.remove('i18n');
                break;
            case 'data-i18n':
                this.#htmlText.setAttribute('data-i18n', newValue);
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.add('i18n');
                break;
            case 'data-position':
                this.#htmlText.setAttribute('data-position', newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['data-label', 'data-i18n', 'data-position'];
    }
}
let definedTooltip = false;
function defineHarmonyTooltip() {
    if (window.customElements && !definedTooltip) {
        customElements.define('harmony-tooltip', HTMLHarmonyTooltipElement);
        definedTooltip = true;
        injectGlobalCss();
    }
}

class HTMLHarmonyFileInputElement extends HTMLElement {
    #shadowRoot;
    #htmlText;
    #htmlInput;
    #htmlHelp;
    #htmlTooltip;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, fileInputCSS);
        I18n.observeElement(this.#shadowRoot);
        defineHarmonyTooltip();
        createElement('label', {
            parent: this.#shadowRoot,
            childs: [
                createElement('span', {
                    class: 'icon',
                    innerHTML: folderOpenSVG,
                }),
                this.#htmlText = createElement('span', {
                    class: 'text',
                }),
                this.#htmlHelp = createElement('span', {
                    class: 'tooltip',
                    hidden: true,
                    childs: [
                        createElement('span', {
                            class: 'info',
                            innerHTML: infoSVG,
                        }),
                        this.#htmlTooltip = createElement('harmony-tooltip', {
                            i18n: '',
                            'data-position': 'bottom',
                        }),
                    ]
                }),
                this.#htmlInput = createElement('input', {
                    type: 'file',
                    hidden: true,
                    events: {
                        change: (event) => this.dispatchEvent(cloneEvent(event)),
                    }
                }),
            ],
        });
    }
    get files() {
        return this.#htmlInput.files;
    }
    set accept(accept) {
        this.#htmlInput.accept = accept;
    }
    get accept() {
        return this.#htmlInput.accept;
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'data-label':
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.remove('i18n');
                break;
            case 'data-i18n':
                this.#htmlText.setAttribute('data-i18n', newValue);
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.add('i18n');
                break;
            case 'data-tooltip-i18n':
                if (newValue == '') {
                    hide(this.#htmlHelp);
                }
                else {
                    show(this.#htmlHelp);
                    this.#htmlTooltip.setAttribute('data-i18n', newValue);
                }
                break;
            case 'data-accept':
                this.accept = newValue;
                break;
        }
    }
    static get observedAttributes() {
        return ['data-label', 'data-i18n', 'data-accept', 'data-tooltip-i18n'];
    }
}
let definedFileInput = false;
function defineHarmonyFileInput() {
    if (window.customElements && !definedFileInput) {
        customElements.define('harmony-file-input', HTMLHarmonyFileInputElement);
        definedFileInput = true;
        injectGlobalCss();
    }
}

var labelPropertyCSS = ":host {\n\tdisplay: flex;\n\tgap: var(--harmony-label-property-gap, 0.5);\n}\n";

class HTMLHarmonyLabelPropertyElement extends HTMLElement {
    #doOnce = false;
    #htmlLabel;
    #htmlProperty;
    #shadowRoot;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, labelPropertyCSS);
        this.#htmlLabel = createElement('label', { i18n: '', parent: this.#shadowRoot });
        this.#htmlProperty = createElement('span', { parent: this.#shadowRoot });
    }
    set label(label) {
        this.#htmlLabel.setAttribute('data-i18n', label);
    }
    set property(property) {
        this.#htmlProperty.innerHTML = property;
    }
    connectedCallback() {
        if (!this.#doOnce) {
            this.#doOnce = true;
            this.append(this.#htmlLabel, this.#htmlProperty);
        }
    }
}
let definedLabelProperty = false;
function defineHarmonyLabelProperty() {
    if (window.customElements && !definedLabelProperty) {
        customElements.define('harmony-label-property', HTMLHarmonyLabelPropertyElement);
        definedLabelProperty = true;
        injectGlobalCss();
    }
}

var paletteCSS = ":host {\r\n\t--harmony-palette-shadow-color-size: var(--harmony-palette-color-size, 2rem);\r\n\t--harmony-palette-shadow-gap: var(--harmony-palette-gap, 0.5rem);\r\n\t--harmony-palette-shadow-border-color: var(--harmony-palette-border-color, grey);\r\n\t--harmony-palette-shadow-selected-border-color: var(--harmony-palette-selected-border-color, orange);\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tflex-wrap: wrap;\r\n\tgap: var(--harmony-palette-shadow-gap);\r\n}\r\n\r\n.color {\r\n\theight: var(--harmony-palette-shadow-color-size);\r\n\twidth: var(--harmony-palette-shadow-color-size);\r\n\tborder-radius: calc(var(--harmony-palette-shadow-color-size) * .1);\r\n\tborder: calc(var(--harmony-palette-shadow-color-size) * .1) solid var(--harmony-palette-shadow-border-color);\r\n\tpadding: calc(var(--harmony-palette-shadow-color-size) * .1);\r\n\tcursor: pointer;\r\n}\r\n\r\n.color.selected {\r\n\tborder-color: var(--harmony-palette-shadow-selected-border-color);\r\n\tborder-width: calc(var(--harmony-palette-shadow-color-size) * .2);\r\n\tpadding: 0;\r\n\tcolor: black;\r\n}\r\n\r\n.color>svg {\r\n\theight: 100%;\r\n\twidth: 100%;\r\n}\r\n";

function clampColor(val) {
    return Math.min(Math.max(0, val), 1);
}
class HTMLHarmonyPaletteElement extends HTMLElement {
    #initialized = false;
    #multiple = false;
    #colors = new Map();
    #selected = new Map();
    #colorElements = new Map();
    #preSelected = new Set();
    #shadowRoot;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
    }
    connectedCallback() {
        if (!this.#initialized) {
            I18n.observeElement(this.#shadowRoot);
            shadowRootStyle(this.#shadowRoot, paletteCSS);
            this.#initialized = true;
            this.#processChilds();
        }
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    #processChilds() {
        //This is a 2 steps process cause we may change DOM
        const children = this.children;
        const list = [];
        for (const child of children) {
            list.push(child);
        }
        list.forEach(element => {
            const c = this.#addColor(element.innerText);
            element.remove();
            if (c && element.hasAttribute('selected')) {
                this.#preSelected.add(c.h);
            }
        });
        this.#refreshHTML();
    }
    #refreshHTML() {
        if (!this.#initialized) {
            return;
        }
        this.innerText = '';
        this.#colorElements.clear();
        for (const [colorHex, color] of this.#colors) {
            const element = createElement('div', {
                parent: this.#shadowRoot,
                class: 'color',
                'data-color': colorHex,
                style: `background-color: ${colorHex}`,
                events: {
                    click: (event) => this.#selectColor(colorHex, event.target),
                }
            });
            this.#colorElements.set(colorHex, element);
            if (this.#preSelected.has(colorHex)) {
                this.#selectColor(colorHex, element);
            }
        }
        this.#preSelected.clear();
    }
    #selectColor(hex, element, selected = false) {
        if (this.#selected.has(hex) && selected !== true) {
            this.#setSelected(this.#selected.get(hex), false);
            this.#dispatchSelect(hex, false);
            this.#selected.delete(hex);
        }
        else {
            if (!this.#multiple) {
                for (const [h, e] of this.#selected) {
                    this.#setSelected(e, false);
                    this.#dispatchSelect(h, false);
                    this.#selected.delete(h);
                }
            }
            this.#dispatchSelect(hex, true);
            this.#selected.set(hex, element);
            this.#setSelected(element, true);
        }
    }
    #setSelected(element, selected) {
        if (!element) {
            return;
        }
        if (selected) {
            element.classList.add('selected');
            element.innerHTML = checkOutlineSVG;
        }
        else {
            element.classList.remove('selected');
            element.innerText = '';
        }
    }
    #dispatchSelect(hex, selected) {
        this.dispatchEvent(new CustomEvent(selected ? 'select' : 'unselect', { detail: { hex: hex } }));
    }
    clearColors() {
        this.#colors.clear();
        this.#refreshHTML();
    }
    addColor(color, tooltip) {
        const c = this.#addColor(color, tooltip);
        this.#refreshHTML();
        return c;
    }
    selectColor(color, selected = true) {
        const c = this.#getColorAsRGB(color);
        this.#selectColor(c.h, this.#colorElements.get(c.h), selected);
    }
    toggleColor(color) {
        const c = this.#getColorAsRGB(color);
        this.#selectColor(c.h, this.#colorElements.get(c.h));
    }
    #addColor(color, tooltip) {
        const c = this.#getColorAsRGB(color);
        if (!c) {
            return;
        }
        c.selected = false;
        c.tooltip = tooltip;
        this.#colors.set(c.h, c);
        return c;
    }
    #getColorAsRGB(color) {
        let r = 0, g = 0, b = 0;
        switch (true) {
            case typeof color == 'string':
                const c = parseInt('0x' + color.replace('#', ''), 16);
                r = ((c >> 16) & 0xFF) / 255;
                g = ((c >> 8) & 0xFF) / 255;
                b = (c & 0xFF) / 255;
                break;
            case Array.isArray(color):
                r = clampColor(color[0]);
                g = clampColor(color[1]);
                b = clampColor(color[2]);
                break;
        }
        return { r: r, g: g, b: b, h: '#' + Number((r * 255 << 16) + (g * 255 << 8) + (b * 255)).toString(16).padStart(6, '0') };
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'multiple':
                this.#multiple = toBool(newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['multiple'];
    }
}
let definedPalette = false;
function defineHarmonyPalette() {
    if (window.customElements && !definedPalette) {
        customElements.define('harmony-palette', HTMLHarmonyPaletteElement);
        definedPalette = true;
        injectGlobalCss();
    }
}

var panelCSS = ":host {\n\tdisplay: flex;\n\tflex: 1;\n\tflex-direction: column;\n\n\tflex: 0 0 auto;\n\t/*flex-grow: 0;\n\tflex-shrink: 0;\n\tflex-basis: auto;*/\n\t/*flex-basis: 0;*/\n\t/*flex: 1;*/\n\t/*height:100%;\n\twidth:100%;*/\n\n\t/*padding: 5px !important;*/\n\tbox-sizing: border-box;\n\tpointer-events: all;\n\toverflow: hidden;\n\tposition: relative;\n\tflex-direction: column;\n\tbox-sizing: border-box;\n}\n\n.harmony-panel-row {\n\tflex-direction: row;\n}\n\n.harmony-panel-row>harmony-panel {\n\theight: 100%;\n}\n\n.harmony-panel-column {\n\tflex-direction: column;\n}\n\n.harmony-panel-column>harmony-panel {\n\twidth: 100%;\n}\n\n.harmony-panel-splitter {\n\tdisplay: none;\n\tflex: 0 0 10px;\n\tbackground-color: red;\n}\n\n.title {\n\tcursor: pointer;\n\ttext-align: center;\n\tfont-size: 1.5em;\n\tpadding: 4px;\n\toverflow: hidden;\n}\n\n.content {\n\twidth: 100%;\n\tbox-sizing: border-box;\n}\n\n[collapsible='1']>.title::after {\n\tcontent: \"-\";\n\tright: 5px;\n\tposition: absolute;\n}\n\n[collapsed='1']>.title::after {\n\tcontent: \"+\";\n}\n";

let nextId = 0;
//let spliter: HTMLElement = createElement('div', { class: 'harmony-panel-splitter' }) as HTMLElement;
let highlitPanel;
class HTMLHarmonyPanelElement extends HTMLElement {
    #doOnce = true;
    #parent = null;
    #panels = new Set();
    #size = 1;
    #direction = 'undefined';
    #isContainer = false;
    #isMovable = false;
    #isCollapsible = false;
    #isCollapsed = false;
    customPanelId = nextId++;
    htmlTitle;
    htmlContent;
    #isDummy = false;
    #shadowRoot;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, panelCSS);
        //this.addEventListener('dragstart', event => this._handleDragStart(event));
        //this.addEventListener('dragover', event => this._handleDragOver(event));
        //this.addEventListener('drop', event => this._handleDrop(event));
        //this.addEventListener('mouseenter', event => this._handleMouseEnter(event));
        //this.addEventListener('mousemove', event => this._handleMouseMove(event));
        //this.addEventListener('mouseleave', event => this._handleMouseLeave(event));
        this.htmlTitle = createElement('div', {
            class: 'title',
            parent: this.#shadowRoot,
            events: {
                click: () => this.#toggleCollapse(),
            }
        });
        this.htmlContent = createElement('div', {
            class: 'content',
            parent: this.#shadowRoot,
        });
    }
    connectedCallback() {
        if (this.#doOnce) {
            //this.append(...this.childNodes);
            this.#doOnce = false;
        }
        super.append(this.htmlTitle);
        super.append(this.htmlContent);
        //let parentElement = this.parentElement;
        /*if (this._parent && (this._parent != parentElement)) {
            this._parent._removePanel(this);
        }

        if (parentElement && parentElement.tagName == 'HARMONY-PANEL') {
            parentElement._addPanel(this);
            this._parent = parentElement;
        }*/
        /*if (!this._firstTime) {
            this._firstTime = true;
            //this.style.backgroundColor = `rgb(${255*Math.random()},${255*Math.random()},${255*Math.random()})`;
            //this.append(this.CustomPanelId);
            this.title = this.CustomPanelId;
            this.direction = this._direction;
            //this.size = this._size;
            //this.draggable = true;
        }*/
    }
    append() {
        this.htmlContent.append(...arguments);
    }
    prepend() {
        this.htmlContent.prepend(...arguments);
    }
    /*
        appendChild(child: HTMLElement) {
            this.htmlContent.appendChild(child);
        }
    */
    get innerHTML() {
        return this.htmlContent.innerHTML;
    }
    set innerHTML(innerHTML) {
        this.htmlContent.innerHTML = innerHTML;
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue == newValue) {
            return;
        }
        if (name == 'panel-direction') {
            this.#direction = newValue;
        }
        else if (name == 'panel-size') {
            this.size = Number(newValue);
        }
        else if (name == 'is-container') {
            this.isContainer = toBool(newValue);
        }
        else if (name == 'is-movable') {
            this.isMovable = toBool(newValue);
        }
        else if (name == 'collapsible') {
            this.collapsible = toBool(newValue);
        }
        else if (name == 'collapsed') {
            this.collapsed = toBool(newValue);
        }
        else if (name == 'title') {
            this.title = newValue;
        }
        else if (name == 'title-i18n') {
            this.titleI18n = newValue;
        }
    }
    static get observedAttributes() {
        return ['panel-direction', 'panel-size', 'is-container', 'is-movable', 'title', 'title-i18n', 'collapsible', 'collapsed'];
    }
    /*
        _handleDragStart(event) {
            if (this._isMovable == false) {
                event.preventDefault();
                return;
            }
            event.stopPropagation();
            event.dataTransfer.setData('text/plain', null);
            dragged = event.target;
        }

        _handleDragOver(event) {
            if (this._isContainer != false) {
                event.preventDefault();
            }
            event.stopPropagation();
        }

        _handleDrop(event) {
            if (this._isContainer != false) {
                event.stopPropagation();
                event.preventDefault();
                if (dragged) {
                    if (this != dragged) {
                        this._addChild(dragged, event.offsetX, event.offsetY);
                        //OptionsManager.setItem('app.layout.disposition', HTMLHarmonyPanelElement.saveDisposition());
                    }
                }
            }
            dragged = null;
        }

        _handleMouseEnter(event) {
            //console.error(this, event);
            //clearInterval(HTMLHarmonyPanelElement._interval);
            //HTMLHarmonyPanelElement._interval = setInterval(event => this.style.opacity = (Math.floor(new Date().getTime() / 500) % 2) / 2 + 0.5, 100);
            //event.stopPropagation();
        }

        _handleMouseMove(event) {
            const delta = 5;
            //console.error(event.offsetX, event.offsetY);
            //this.style.opacity = (Math.floor(new Date().getTime() / 1000) % 2);
            //HTMLHarmonyPanelElement.highlitPanel = this;
            event.stopPropagation();
            if (event.offsetX < delta || event.offsetY < delta) {
                HTMLHarmonyPanelElement.highlitPanel = this;
                this.parentNode.insertBefore(HTMLHarmonyPanelElement._spliter, this);
            } else if ((this.offsetWidth - event.offsetX) < delta || (this.offsetHeight - event.offsetY) < delta) {
                HTMLHarmonyPanelElement.highlitPanel = this;
                this.parentNode.insertBefore(HTMLHarmonyPanelElement._spliter, this.nextSibling);
            } else {
                HTMLHarmonyPanelElement.highlitPanel = null;
            }

        }

        _handleMouseLeave(event) {
            //console.error(this, event);
            //clearInterval(HTMLHarmonyPanelElement._interval);
        }
            */
    static set highlitPanel(panel) {
        if (highlitPanel) {
            highlitPanel.style.filter = '';
        }
        highlitPanel = panel;
        if (highlitPanel) {
            highlitPanel.style.filter = 'grayscale(80%)'; ///'contrast(200%)';
        }
    }
    /*
        _addChild(child, x, y) {
            let percent = 0.2;
            let percent2 = 0.8;
            let height = this.clientHeight;
            let width = this.clientWidth;

            if (this._direction == undefined) {
                if (x <= width * percent) {
                    this.prepend(dragged);
                    this.direction = 'row';
                }
                if (x >= width * percent2) {
                    this.append(dragged);
                    this.direction = 'row';
                }
                if (y <= height * percent) {
                    this.prepend(dragged);
                    this.direction = 'column';
                }
                if (y >= height * percent2) {
                    this.append(dragged);
                    this.direction = 'column';
                }
            } else if (this._direction == 'row') {
                if (x <= width * percent) {
                    this.prepend(dragged);
                }
                if (x >= width * percent2) {
                    this.append(dragged);
                }
                if (y <= height * percent) {
                    this._split(dragged, true, 'column');
                }
                if (y >= height * percent2) {
                    this._split(dragged, false, 'column');
                }
            } else if (this._direction == 'column') {
                if (x <= width * percent) {
                    this._split(dragged, true, 'row');
                }
                if (x >= width * percent2) {
                    this._split(dragged, false, 'row');
                }
                if (y <= height * percent) {
                    this.prepend(dragged);
                }
                if (y >= height * percent2) {
                    this.append(dragged);
                }
            }
        }*/
    /*
        _split(newNode, before, direction) {
            let panel = HTMLHarmonyPanelElement._createDummy();//document.createElement('harmony-panel');
            /*panel.id = HTMLHarmonyPanelElement.nextId;
            panel._isDummy = true;
            panel.classList.add('dummy');* /
            panel.size = this.size;
            this.style.flex = this.style.flex;
            this.after(panel);
            if (before) {
                panel.append(newNode);
                panel.append(this);
            } else {
                panel.append(this);
                panel.append(newNode);
            }
            panel.direction = direction;
        }
    */
    /*
        static _createDummy() {
            let dummy = document.createElement('harmony-panel');
            dummy.id = HTMLHarmonyPanelElement.#nextId;
            dummy._isDummy = true;
            dummy.classList.add('dummy');
            return dummy;
        }
    */
    /*
        _addPanel(panel) {
            this._panels.add(panel);
        }

        _removePanel(panel) {
            this._panels.delete(panel);
            if (this._isDummy) {
                if (this._panels.size == 0) {
                    this.remove();
                } else if (this._panels.size == 1) {
                    this.after(this._panels.values().next().value);
                    this.remove();
                }
            }
        }
    */
    /*
        set active(active) {
            if (this._active != active) {
                this.dispatchEvent(new CustomEvent('activated'));
            }
            this._active = active;
            this.style.display = active ? '' : 'none';
            if (active) {
                this._header.classList.add('activated');
            } else {
                this._header.classList.remove('activated');
            }
        }
        */
    /*
        _click() {
            this.active = true;
            if (this._group) {
                this._group.active = this;
            }
        }
    */
    set direction(direction) {
        this.#direction = direction;
        this.classList.remove('harmony-panel-row');
        this.classList.remove('harmony-panel-column');
        if (direction == 'row') {
            this.classList.add('harmony-panel-row');
        }
        else if (direction == 'column') {
            this.classList.add('harmony-panel-column');
        }
    }
    get direction() {
        return this.#direction;
    }
    set size(size) {
        /*if (size === undefined) {
            return;
        }*/
        this.#size = size;
        //this.style.flexBasis = size;
        this.style.flex = String(size);
    }
    get size() {
        return this.#size;
    }
    set isContainer(isContainer) {
        this.#isContainer = isContainer;
    }
    set isMovable(isMovable) {
        this.#isMovable = isMovable;
    }
    set collapsible(collapsible) {
        this.#isCollapsible = collapsible;
        this.setAttribute('collapsible', String(this.#isCollapsible ? 1 : 0));
    }
    set collapsed(collapsed) {
        this.#isCollapsed = (collapsed == true) ? this.#isCollapsible : false;
        this.setAttribute('collapsed', String(this.#isCollapsed ? 1 : 0));
        if (this.#isCollapsed) {
            this.htmlContent.style.display = 'none';
        }
        else {
            this.htmlContent.style.display = '';
        }
    }
    set title(title) {
        if (title) {
            this.htmlTitle = this.htmlTitle ?? document.createElement('div');
            this.htmlTitle.innerHTML = title;
            super.prepend(this.htmlTitle);
        }
        else {
            this.htmlTitle.remove();
        }
    }
    set titleI18n(titleI18n) {
        this.htmlTitle.classList.add('i18n');
        this.htmlTitle.setAttribute('data-i18n', titleI18n);
        this.htmlTitle.remove();
        this.title = titleI18n;
    }
    #toggleCollapse() {
        this.collapsed = !this.#isCollapsed;
    }
    static get nextId() {
        return `harmony-panel-dummy-${++nextId}`;
    }
    static saveDisposition() {
        const list = document.getElementsByTagName('harmony-panel');
        const json = { panels: {}, dummies: [] };
        for (const panel of list) {
            if (panel.id && panel.parentElement && panel.parentElement.id && panel.parentElement.tagName == 'HARMONY-PANEL') {
                json.panels[panel.id] = { parent: panel.parentElement.id, size: panel.size, direction: panel.direction };
                if (panel.#isDummy) {
                    json.dummies.push(panel.id);
                }
            }
        }
        return json;
    }
    static restoreDisposition(json) {
        return;
        /*
        if (!json || !json.dummies || !json.panels) { return; }

        let dummiesList = new Map();
        for (let oldDummy of json.dummies) {
            let newDummy = HTMLHarmonyPanelElement._createDummy();
            document.body.append(newDummy);
            dummiesList.set(oldDummy, newDummy.id);
        }

        let list = document.getElementsByTagName('harmony-panel');
        for (let panel of list) {
            if (panel.id) {
                let p = json.panels[panel.id];
                if (p) {
                    if (p.size != 1 || panel._isDummy) {
                        panel.size = p.size;
                    }
                    panel.direction = p.direction;
                    let newParentId = dummiesList.get(p.parent) || p.parent;
                    if (p && newParentId) {
                        let parent = document.getElementById(newParentId);
                        /*if (!parent && p.dummy) {
                            parent = document.createElement('harmony-panel');
                        }* /
                        if (parent) {
                            parent.append(panel);
                        } else {
                            console.error('no parent', panel, newParentId);
                        }
                    }
                }
            }
        }*/
    }
}
let definedPanel = false;
function defineHarmonyPanel() {
    if (window.customElements && !definedPanel) {
        customElements.define('harmony-panel', HTMLHarmonyPanelElement);
        definedPanel = true;
        injectGlobalCss();
    }
}

var radioCSS = ":host {\n\t--harmony-radio-shadow-button-border-radius: var(--harmony-radio-button-border-radius, 0.5rem);\n\tdisplay: inline-flex;\n\toverflow: hidden;\n\tuser-select: none;\n}\n\n.label {\n\tmargin: auto 0;\n\tfont-weight: bold;\n\tmargin-right: 0.25rem;\n}\n\n::slotted(button) {\n\tpadding: 0.5rem;\n\tcolor: var(--harmony-ui-text-primary);\n\tflex: auto;\n\tcursor: pointer;\n\tappearance: none;\n\tborder-style: solid;\n\tborder-width: 0.0625rem;\n\tborder-color: var(--harmony-ui-border-primary);\n\tborder-right-style: none;\n\tbackground-color: var(--harmony-ui-input-background-primary);\n\ttransition: background-color 0.2s linear;\n\tfont-size: 1rem;\n\toverflow: hidden;\n}\n\n::slotted(button:hover) {\n\tbackground-color: var(--harmony-ui-input-background-secondary);\n}\n\n::slotted(button[selected]) {\n\tbackground-color: var(--harmony-ui-accent-primary);\n}\n\n::slotted(button[selected]:hover) {\n\tbackground-color: var(--harmony-ui-accent-secondary);\n}\n\n::slotted(button:first-of-type) {\n\tborder-radius: var(--harmony-radio-shadow-button-border-radius) 0 0 var(--harmony-radio-shadow-button-border-radius);\n}\n\n::slotted(button:last-child) {\n\tborder-right-style: solid;\n\tborder-radius: 0 var(--harmony-radio-shadow-button-border-radius) var(--harmony-radio-shadow-button-border-radius) 0;\n}\n";

class HTMLHarmonyRadioElement extends HTMLElement {
    #doOnce = true;
    #disabled = false;
    #multiple = false;
    #htmlLabel;
    #buttons = new Map();
    #buttons2 = new Set();
    #slots = new Set();
    #selected = new Set();
    #shadowRoot;
    #lastSelected;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed', slotAssignment: "manual" });
        this.#htmlLabel = createElement('div', { class: 'label' });
        this.#initMutationObserver();
    }
    connectedCallback() {
        if (this.#doOnce) {
            I18n.observeElement(this.#shadowRoot);
            shadowRootStyle(this.#shadowRoot, radioCSS);
            this.#shadowRoot.prepend(this.#htmlLabel);
            hide(this.#htmlLabel);
            this.#processChilds();
            this.#doOnce = false;
        }
    }
    #processChilds() {
        for (const child of this.children) {
            this.#initButton(child);
        }
    }
    #initButton(htmlButton) {
        this.#buttons.set(htmlButton.value, htmlButton);
        if (!this.#buttons2.has(htmlButton)) {
            htmlButton.addEventListener('click', () => this.select(htmlButton.value, !this.#multiple || !htmlButton.hasAttribute('selected')));
            this.#buttons2.add(htmlButton);
            const htmlSlot = createElement('slot', {
                parent: this.#shadowRoot,
            });
            this.#slots.add(htmlSlot);
            htmlSlot.assign(htmlButton);
            I18n.updateElement(htmlButton);
        }
        if (this.#selected.has(htmlButton.value) || htmlButton.hasAttribute('selected')) {
            this.select(htmlButton.value, true);
        }
    }
    select(value, select = true) {
        this.#selected[select ? 'add' : 'delete'](value);
        const htmlButton = this.#buttons.get(value);
        if (htmlButton) {
            if (select) {
                if (!this.#multiple) {
                    for (const child of this.children) {
                        if (child.hasAttribute('selected')) {
                            child.removeAttribute('selected');
                            this.dispatchEvent(new CustomEvent('change', { detail: { value: child.value, state: false } }));
                            child.dispatchEvent(new CustomEvent('change', { detail: { value: child.value, state: false } }));
                        }
                    }
                }
                htmlButton.setAttribute('selected', '');
                if (this.#lastSelected) {
                    this.#lastSelected.classList.remove('last-selected');
                }
                this.#lastSelected = htmlButton;
                this.#lastSelected.classList.add('last-selected');
            }
            else {
                htmlButton.removeAttribute('selected');
            }
            this.dispatchEvent(new CustomEvent('change', { detail: { value: htmlButton.value, state: select } }));
            htmlButton.dispatchEvent(new CustomEvent('change', { detail: { value: htmlButton.value, state: select } }));
        }
    }
    isSelected(value) {
        const htmlButton = this.#buttons.get(value);
        return htmlButton?.value ?? false;
    }
    set disabled(disabled) {
        this.#disabled = disabled ? true : false;
        this.classList[this.#disabled ? 'add' : 'remove']('disabled');
    }
    get disabled() {
        return this.#disabled;
    }
    clear() {
        for (const button of this.#buttons2) {
            button.remove();
        }
        for (const slot of this.#slots) {
            slot.remove();
        }
        this.#buttons.clear();
        this.#buttons2.clear();
        this.#selected.clear();
        this.#slots.clear();
    }
    #initMutationObserver() {
        const config = { childList: true, subtree: true };
        const mutationCallback = (mutationsList, observer) => {
            for (const mutation of mutationsList) {
                const addedNodes = mutation.addedNodes;
                for (const addedNode of addedNodes) {
                    if (addedNode.parentNode == this) {
                        this.#initButton(addedNode);
                    }
                }
            }
        };
        const observer = new MutationObserver(mutationCallback);
        observer.observe(this, config);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'data-label':
                this.#htmlLabel.innerHTML = newValue;
                this.#htmlLabel.classList.remove('i18n');
                show(this.#htmlLabel);
                break;
            case 'data-i18n':
                this.#htmlLabel.setAttribute('data-i18n', newValue);
                this.#htmlLabel.innerHTML = newValue;
                this.#htmlLabel.classList.add('i18n');
                show(this.#htmlLabel);
                break;
            case 'disabled':
                this.disabled = toBool(newValue);
                break;
            case 'multiple':
                this.#multiple = true;
            case 'value':
                this.select(newValue, true);
                break;
        }
    }
    static get observedAttributes() {
        return ['data-label', 'data-i18n', 'disabled', 'multiple', 'value'];
    }
}
let definedRadio = false;
function defineHarmonyRadio() {
    if (window.customElements && !definedRadio) {
        customElements.define('harmony-radio', HTMLHarmonyRadioElement);
        definedRadio = true;
        injectGlobalCss();
    }
}

var slideshowCSS = ":host {\n\toverflow: hidden;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tflex-direction: column;\n\tposition: relative;\n}\n\n.image {\n\tposition: relative;\n\tflex-shrink: 0;\n}\n\n.images {\n\toverflow: hidden;\n\tflex: 1;\n\twidth: 100%;\n}\n\n.images-outer {\n\toverflow: hidden;\n\tmargin: auto;\n}\n\n.images-inner {\n\tdisplay: flex;\n\tposition: relative;\n\twidth: 100%;\n\theight: 100%;\n}\n\n:host(.dynamic) .images-inner {\n\ttransition: all 0.5s ease 0s;\n}\n\n/* Controls */\n.controls {\n\tposition: absolute;\n\tz-index: 1000;\n\topacity: 0;\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: none;\n}\n\n:host(.dynamic) .controls {\n\tdisplay: unset;\n}\n\n.controls>div {\n\tposition: absolute;\n\n\tbackground-size: 100%;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n\tpointer-events: all;\n\tcursor: pointer;\n}\n\n.previous-image,\n.next-image {\n\ttop: calc(50% - 24px);\n\twidth: 48px;\n\theight: 48px;\n\tbackground-image: url(\"data:image/svg+xml,%3C%3Fxml version='1.0'%3F%3E%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath style='fill:%23ffffff;stroke:%23000000;stroke-width:10;' d='M 360,100 300,30 30,256 300,482 360,412 175,256 Z'/%3E%3C/svg%3E%0A\");\n\n}\n\n.previous-image {\n\tleft: 10px;\n}\n\n.next-image {\n\tright: 10px;\n\ttransform: scaleX(-1);\n}\n\n.play,\n.pause {\n\tbottom: 10px;\n\tleft: 10px;\n\twidth: 25px;\n\theight: 25px;\n}\n\n.play {\n\tbackground-image: url(\"data:image/svg+xml,%3C%3Fxml version='1.0'%3F%3E%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath style='fill:%23ffffff;stroke:%23000000;stroke-width:40;' d='M20 20 L470 256 L20 492 Z'/%3E%3C/svg%3E%0A\");\n}\n\n.pause {\n\tright: 0px;\n\tbackground-image: url(\"data:image/svg+xml,%3C%3Fxml version='1.0'%3F%3E%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cg style='fill:%23ffffff;stroke:%23000000;stroke-width:30;'%3E%3Crect width='140' height='452' x='30' y='30' /%3E%3Crect width='140' height='452' x='342' y='30' /%3E%3C/g%3E%3C/svg%3E%0A\");\n}\n\n/* thumbnails */\n.thumbnails {\n\twidth: 100%;\n\t/*background-color: red;*/\n\tflex: 0;\n\tdisplay: flex;\n\tjustify-content: center;\n}\n\n:host(.dynamic) .thumbnails {\n\tdisplay: none;\n}\n\n.thumbnails>img {\n\tobject-fit: contain;\n\theight: 80px;\n\tcursor: pointer;\n\tmargin: 3px;\n}\n\n.zoom {\n\tposition: fixed;\n\tpointer-events: none;\n\t/*transform: scale(3);*/\n\twidth: 100%;\n\theight: 100%;\n}\n\n.zoom>img {\n\t/*transform: scale(3);*/\n\twidth: 100%;\n\tposition: relative;\n\twidth: 1500px;\n}\n";

var slideshowZoomCSS = ":host {\n\tposition: fixed;\n\tpointer-events: none;\n\twidth: 100%;\n\theight: 100%;\n\tz-index: var(--harmony-slideshow-zoom-z-index, 1000000);\n\ttop: 0;\n\tleft: 0;\n\n}\n\nimg {\n\twidth: 100%;\n\tposition: relative;\n\twidth: 1500px;\n}\n";

const resizeCallback = (entries, observer) => {
    entries.forEach(entry => {
        entry.target.onResized();
    });
};
const DEFAULT_AUTO_PLAY_DELAY = 3000;
const DEFAULT_SCROLL_TRANSITION_TIME = 0.5;
class HTMLHarmonySlideshowElement extends HTMLElement {
    #shadowRoot;
    #zoomShadowRoot;
    #activeImage;
    #currentImage = 0;
    #doOnce = true;
    #doOnceOptions;
    #dynamic = true;
    #htmlImages;
    #htmlImagesOuter;
    #htmlImagesInner;
    #htmlPauseButton;
    #htmlPlayButton;
    #htmlThumbnails;
    #images = [];
    #imgSet = new Set();
    #htmlZoomImage;
    #resizeObserver = new ResizeObserver(resizeCallback);
    #autoPlay = false;
    #autoPlayDelay = 0;
    #smoothScroll = false;
    #smoothScrollTransitionTime = 0;
    #autoplayTimeout = 0;
    constructor(options) {
        super();
        this.#doOnceOptions = options;
        this.#initObserver();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        I18n.observeElement(this.#shadowRoot);
        shadowRootStyleSync(this.#shadowRoot, slideshowCSS); // sync version is used to ensure style is loaded before computation occurs
        this.#htmlImages = createElement('div', {
            class: 'images',
            parent: this.#shadowRoot,
            child: this.#htmlImagesOuter = createElement('div', {
                class: 'images-outer',
                child: this.#htmlImagesInner = createElement('div', {
                    class: 'images-inner',
                }),
                events: {
                    mouseover: (event) => this.#zoomImage(event),
                    mousemove: (event) => this.#zoomImage(event),
                    mouseout: (event) => this.#zoomImage(event),
                },
            }),
        });
        createElement('div', {
            class: 'controls',
            parent: this.#shadowRoot,
            childs: [
                createElement('div', {
                    class: 'previous-image',
                    events: {
                        click: (event) => { this.previousImage(); this.setAutoPlay(false); },
                    },
                }),
                createElement('div', {
                    class: 'next-image',
                    events: {
                        click: (event) => { this.nextImage(); this.setAutoPlay(false); },
                    },
                }),
                this.#htmlPlayButton = createElement('div', {
                    class: 'play',
                    events: {
                        click: () => this.play(true),
                    },
                }),
                this.#htmlPauseButton = createElement('div', {
                    class: 'pause',
                    events: {
                        click: () => this.play(false),
                    },
                }),
            ],
            events: {
                mouseenter: (event) => event.target.style.opacity = 'unset',
                mouseleave: (event) => event.target.style.opacity = '0',
            },
        });
        this.#htmlZoomImage = createElement('img');
        this.#zoomShadowRoot = createShadowRoot('div', {
            adoptStyle: slideshowZoomCSS,
            parent: document.body,
            childs: [
                this.#htmlZoomImage,
            ]
        });
        this.#htmlThumbnails = createElement('div', {
            class: 'thumbnails',
            parent: this.#shadowRoot,
        });
    }
    previousImage() {
        if (this.#currentImage == 0) {
            this.setImage(this.#images.length - 1);
        }
        else {
            this.setImage(this.#currentImage - 1);
        }
    }
    nextImage() {
        if (this.#currentImage >= this.#images.length - 1) {
            this.setImage(0);
        }
        else {
            this.setImage(this.#currentImage + 1);
        }
    }
    setImage(imageId) {
        this.#currentImage = imageId;
        this.active = this.#images[imageId];
    }
    connectedCallback() {
        if (this.#doOnce) {
            //this.#initHtml();
            this.#processOptions(this.#doOnceOptions);
            this.#processChilds();
            this.#doOnce = false;
        }
        this.#resizeObserver.observe(this);
        this.checkImagesSize();
        if (this.#dynamic) {
            this.classList.add('dynamic');
        }
    }
    disconnectedCallback() {
        if (this.#zoomShadowRoot) {
            this.#zoomShadowRoot.host.remove();
            hide(this.#zoomShadowRoot);
        }
    }
    addImage(htmlImage) {
        if (htmlImage.constructor.name == 'HTMLImageElement') {
            if (!this.#imgSet.has(htmlImage)) {
                this.#images.push(htmlImage);
                this.#imgSet.add(htmlImage);
                this.#htmlImagesInner.append(htmlImage);
                if (!this.#activeImage) {
                    this.active = htmlImage;
                }
                htmlImage.classList.add('image');
                htmlImage.decode().then(() => {
                    this.refresh();
                });
                htmlImage.onload = () => this.checkImageSize(htmlImage);
                const htmlThumbnailImage = htmlImage.cloneNode();
                this.#htmlThumbnails.append(htmlThumbnailImage);
                htmlThumbnailImage.addEventListener('click', () => this.active = htmlImage);
            }
        }
    }
    removeAllImages() {
        this.#images = [];
        this.#imgSet = new Set();
        this.#htmlImagesInner.innerText = '';
        this.#htmlThumbnails.innerText = '';
        this.#activeImage = undefined;
        // Remove pending images
        const list = [];
        for (const child of this.children) {
            if (child.constructor.name == 'HTMLImageElement') {
                list.push(child);
            }
        }
        list.forEach(element => element.remove());
    }
    refresh() {
        for (const image of this.#images) {
            //image.style.display = (image ==  this.#activeImage) ? '' : 'none';
            image.style.display = '';
        }
    }
    #processOptions(options = {}) {
        this.setAutoPlay(options.autoPlay ?? true);
        this.#autoPlayDelay = options.autoPlayDelay ?? DEFAULT_AUTO_PLAY_DELAY;
        this.#smoothScroll = options.smoothScroll ?? true;
        this.#smoothScrollTransitionTime = options.smoothScrollTransitionTime ?? DEFAULT_SCROLL_TRANSITION_TIME;
        if (options.images) {
            for (const image of options.images) {
                const htmlImage = createElement('img');
                htmlImage.src = image;
                this.addImage(htmlImage);
            }
        }
        if (options.class) {
            this.className = options.class;
        }
        if (options.id) {
            this.id = options.id;
        }
    }
    #processChilds() {
        //This is a 2 steps process cause we may change DOM
        const list = [];
        for (const child of this.children) {
            list.push(child);
        }
        list.forEach(element => this.addImage(element));
    }
    set active(htmlImage) {
        if (htmlImage) {
            this.#activeImage = htmlImage;
            this.refresh();
            this.checkImageSize(htmlImage);
            this.#htmlImagesInner.style.left = `-${htmlImage.offsetLeft}px`;
            this.play();
        }
    }
    set dynamic(dynamic) {
        this.#dynamic = dynamic;
        if (!dynamic) {
            this.setAutoPlay(false);
            this.setImage(0);
        }
        if (dynamic) {
            this.classList.add('dynamic');
        }
        else {
            this.classList.remove('dynamic');
        }
    }
    setAutoPlay(autoPlay) {
        this.#autoPlay = autoPlay && this.#dynamic;
        if (autoPlay) {
            hide(this.#htmlPlayButton);
            show(this.#htmlPauseButton);
        }
        else {
            show(this.#htmlPlayButton);
            hide(this.#htmlPauseButton);
        }
    }
    play(autoPlay) {
        if (autoPlay !== undefined) {
            this.setAutoPlay(autoPlay);
        }
        clearTimeout(this.#autoplayTimeout);
        if (this.#autoPlay) {
            this.#autoplayTimeout = setTimeout(() => this.nextImage(), this.#autoPlayDelay);
        }
    }
    onResized() {
        this.checkImagesSize();
    }
    checkImagesSize() {
        const rect = this.#htmlImages.getBoundingClientRect();
        for (const image of this.#images) {
            this.checkImageSize(image, rect);
        }
    }
    checkImageSize(htmlImage, rect = this.#htmlImages.getBoundingClientRect()) {
        if (this.#activeImage != htmlImage) {
            return;
        }
        let widthRatio = 1.0;
        let heightRatio = 1.0;
        const naturalWidth = htmlImage.naturalWidth;
        const naturalHeight = htmlImage.naturalHeight;
        if (naturalWidth > rect.width) {
            widthRatio = rect.width / naturalWidth;
        }
        if (naturalHeight > rect.height) {
            heightRatio = rect.height / naturalHeight;
        }
        const ratio = Math.min(widthRatio, heightRatio);
        const imageWidth = naturalWidth * ratio + 'px';
        const imageHeight = naturalHeight * ratio + 'px';
        this.#htmlImagesOuter.style.width = imageWidth;
        this.#htmlImagesOuter.style.height = imageHeight;
    }
    #zoomImage(event) {
        const activeImage = this.#activeImage;
        switch (event.type) {
            case 'mouseover':
                if (activeImage) {
                    this.#htmlZoomImage.src = activeImage.src;
                    show(this.#zoomShadowRoot);
                }
                break;
            case 'mousemove':
                if (activeImage) {
                    const deltaWidth = this.#zoomShadowRoot.host.clientWidth - this.#htmlZoomImage.clientWidth;
                    const deltaHeight = this.#zoomShadowRoot.host.clientHeight - this.#htmlZoomImage.clientHeight;
                    const mouseX = event.offsetX / activeImage.offsetWidth - 0.5;
                    const mouseY = event.offsetY / activeImage.offsetHeight - 0.5;
                    /*if (deltaWidth >= 0) {
                        this.#htmlZoomImage.style.left = `${-mouseX * deltaWidth}px`;
                    } else {

                    }
                    if (deltaHeight >= 0) {
                        this.#htmlZoomImage.style.top = `${-mouseY * deltaHeight}px`;
                    }*/
                    //console.log(deltaWidth, deltaHeight);
                    //console.log(mouseX, mouseY);
                    this.#htmlZoomImage.style.left = `${deltaWidth * 0.5 - Math.sign(deltaWidth) * mouseX * deltaWidth}px`;
                    this.#htmlZoomImage.style.top = `${deltaHeight * 0.5 - Math.sign(deltaHeight) * mouseY * deltaHeight}px`;
                }
                break;
            case 'mouseout':
                hide(this.#zoomShadowRoot);
                break;
        }
    }
    #initObserver() {
        const config = { childList: true, subtree: true };
        const mutationCallback = (mutationsList, observer) => {
            for (const mutation of mutationsList) {
                for (const addedNode of mutation.addedNodes) {
                    if (addedNode.parentNode == this) {
                        this.addImage(addedNode);
                    }
                }
            }
        };
        const observer = new MutationObserver(mutationCallback);
        observer.observe(this, config);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'dynamic':
                this.dynamic = toBool(newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['dynamic'];
    }
}
let definedSlideshow = false;
function defineHarmonySlideshow() {
    if (window.customElements && !definedSlideshow) {
        customElements.define('harmony-slideshow', HTMLHarmonySlideshowElement);
        definedSlideshow = true;
        injectGlobalCss();
    }
}

var selectCSS = "";

class HTMLHarmonySelectElement extends HTMLElement {
    #htmlSelect;
    #shadowRoot;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        this.#htmlSelect = createElement('select', { parent: this.#shadowRoot });
    }
    connectedCallback() {
        shadowRootStyle(this.#shadowRoot, selectCSS);
        this.#shadowRoot.append(this.#htmlSelect);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (name == 'multiple') {
            this.#htmlSelect.setAttribute('multiple', newValue);
        }
    }
    addEventListener(type, listener) {
        this.#htmlSelect.addEventListener(type, listener);
    }
    /*
        onChange(event: Event) {
            let newEvent = new event.constructor(event.type, event);
            this.dispatchEvent(newEvent);
        }
    */
    addOption(value, text) {
        text = text ?? value;
        const option = document.createElement('option');
        option.value = value;
        option.innerHTML = text;
        this.#htmlSelect.append(option);
    }
    addOptions(values) {
        if (values && values.entries) {
            for (const [value, text] of values.entries()) {
                this.addOption(value, text);
            }
        }
    }
    setOptions(values) {
        this.removeAllOptions();
        this.addOptions(values);
    }
    removeOption(value) {
        const list = this.#htmlSelect.children;
        for (let i = 0; i < list.length; i++) {
            if (list[i].value === value) {
                list[i].remove();
            }
        }
    }
    removeAllOptions() {
        const list = this.#htmlSelect.children;
        while (list[0]) {
            list[0].remove();
        }
    }
    select(value) {
        const list = this.#htmlSelect.children;
        for (let i = 0; i < list.length; i++) {
            if (list[i].value === value) {
                list[i].selected = true;
            }
        }
    }
    selectFirst() {
        if (this.#htmlSelect.children[0]) {
            this.#htmlSelect.children[0].selected = true;
            this.#htmlSelect.dispatchEvent(new Event('input'));
        }
    }
    unselect(value) {
        const list = this.#htmlSelect.children;
        for (let i = 0; i < list.length; i++) {
            if (list[i].value === value) {
                list[i].selected = false;
            }
        }
    }
    unselectAll() {
        const list = this.#htmlSelect.children;
        for (let i = 0; i < list.length; i++) {
            list[i].selected = false;
        }
    }
    static get observedAttributes() {
        return ['multiple'];
    }
}
let definedSelect = false;
function defineHarmonySelect() {
    if (window.customElements && !definedSelect) {
        customElements.define('harmony-select', HTMLHarmonySelectElement);
        definedSelect = true;
        injectGlobalCss();
    }
}

var sliderCSS = ":host {\n\tdisplay: flex;\n}\n\nlabel {\n\twidth: var(--h-slider-label-width, auto);\n}\n\ninput[type=range] {\n\tflex: auto;\n}\n\ninput[type=number] {\n\tflex: 0 0 var(--h-slider-input-width, 4rem);\n\tfont-size: var(--h-slider-input-font-size, 1.2rem);\n\tmin-width: 0;\n\ttext-align: center;\n}\n";

class HTMLHarmonyElement extends HTMLElement {
    initialized = false;
    initElement() {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.createElement();
    }
    createElement() {
    }
    connectedCallback() {
        this.initElement();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        this.initElement();
        this.onAttributeChanged(name, oldValue, newValue);
    }
    onAttributeChanged(name, oldValue, newValue) {
    }
    static get observedAttributes() {
        return ['label'];
    }
}

class HTMLHarmonySliderElement extends HTMLHarmonyElement {
    #shadowRoot;
    #htmlLabel;
    #htmlSlider;
    #htmlInput;
    #htmlPrependSlot;
    #htmlAppendSlot;
    #htmlPrependIcon;
    #htmlAppendIcon;
    #min = 0;
    #max = 100;
    #value = [50, 50];
    #isRange = false;
    createElement() {
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, sliderCSS);
        I18n.observeElement(this.#shadowRoot);
        this.#htmlLabel = createElement('label', {
            parent: this.#shadowRoot,
            hidden: true,
        });
        this.#htmlPrependSlot = createElement('slot', {
            parent: this.#shadowRoot,
            name: 'prepend',
        });
        this.#htmlPrependIcon = createElement('img', {
            parent: this.#shadowRoot,
        });
        this.#htmlSlider = createElement('input', {
            type: 'range',
            parent: this.#shadowRoot,
            step: 'any',
            $change: (event) => this.#setValue(Number(event.target.value), undefined, event.target),
            $input: (event) => this.#setValue(Number(event.target.value), undefined, event.target),
        });
        this.#htmlAppendIcon = createElement('img', {
            parent: this.#shadowRoot,
        });
        this.#htmlAppendSlot = createElement('slot', {
            parent: this.#shadowRoot,
            name: 'append',
        });
        this.#htmlInput = createElement('input', {
            type: 'number',
            hidden: true,
            parent: this.#shadowRoot,
            value: 50,
            step: 'any',
            min: 0,
            max: 1000,
            $change: (event) => this.#setValue(Number(event.target.value), undefined, event.target),
            $input: (event) => this.#setValue(Number(event.target.value), undefined, event.target),
        });
    }
    #checkMin(value) {
        if (value < this.#min) {
            return this.#min;
        }
        return value;
    }
    #checkMax(max) {
        if (max > this.#max) {
            return this.#max;
        }
        return max;
    }
    #setValue(min, max, initiator) {
        //	 TODO: swap min/max
        if (min !== undefined) {
            this.#value[0] = this.#checkMin(min);
        }
        if (max !== undefined) {
            this.#value[1] = this.#checkMax(max);
        }
        if (initiator != this.#htmlSlider) {
            this.#htmlSlider.value = String(min ?? this.#value[0]);
        }
        if (initiator != this.#htmlInput) {
            this.#htmlInput.value = String((min ?? this.#value[0]).toFixed(2));
        }
        this.dispatchEvent(new CustomEvent('input', {
            detail: {
                value: this.#isRange ? this.#value : this.#value[0],
            }
        }));
    }
    get value() {
        return this.#isRange ? this.#value : this.#value[0];
    }
    isRange() {
        return this.#isRange;
    }
    setValue(value) {
        if (Array.isArray(value)) {
            this.#setValue(value[0], value[1]);
        }
        else {
            if (this.#isRange) {
                console.error('value must be an array');
            }
            else {
                this.#setValue(value);
            }
        }
    }
    onAttributeChanged(name, oldValue, newValue) {
        let step;
        switch (name) {
            case 'label':
                this.#htmlLabel.innerHTML = newValue;
                updateElement(this.#htmlLabel, { i18n: newValue, });
                show(this.#htmlLabel);
                break;
            case 'min':
                this.#min = Number(newValue);
                this.#htmlSlider.setAttribute('min', String(this.#min));
                this.#htmlInput.setAttribute('min', String(this.#min));
                break;
            case 'max':
                this.#max = Number(newValue);
                this.#htmlSlider.setAttribute('max', String(this.#max));
                this.#htmlInput.setAttribute('max', String(this.#max));
                break;
            case 'value':
                if (newValue === null) {
                    break;
                }
                const value = JSON.parse(newValue);
                if (Array.isArray(value)) {
                    this.setValue(value);
                }
                else {
                    const n = Number(value);
                    if (!Number.isNaN(n)) {
                        this.setValue(n);
                    }
                }
                break;
            case 'step':
                step = Number(newValue);
                if (Number.isNaN(step)) {
                    step = undefined;
                }
                else {
                    step = step;
                }
                this.#htmlSlider.setAttribute('step', step ? String(step) : 'any');
                break;
            case 'input-step':
                step = Number(newValue);
                if (Number.isNaN(step)) {
                    step = undefined;
                }
                else {
                    step = step;
                }
                this.#htmlInput.setAttribute('step', step ? String(step) : 'any');
                break;
            case 'has-input':
                if (newValue === null) {
                    hide(this.#htmlInput);
                }
                else {
                    show(this.#htmlInput);
                }
                break;
            /*
            case 'data-label':
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.remove('i18n');
                break;
            case 'data-i18n':
                this.#htmlText.setAttribute('data-i18n', newValue);
                this.#htmlText.innerHTML = newValue;
                this.#htmlText.classList.add('i18n');
                break;
            case 'data-position':
                this.#htmlText.setAttribute('data-position', newValue);
                break;
                */
        }
    }
    static get observedAttributes() {
        return super.observedAttributes.concat(['label', 'min', 'max', 'input-step', 'has-input', 'append-icon', 'prepend-icon', 'value']);
    }
}
let definedSlider = false;
function defineHarmonySlider() {
    if (window.customElements && !definedSlider) {
        customElements.define('harmony-slider', HTMLHarmonySliderElement);
        definedSlider = true;
        injectGlobalCss();
    }
}

var splitterCSS = ":host {\n\tdisplay: flex;\n\tpointer-events: none;\n\t/*--harmony-color-picker-shadow-gap: var(--harmony-color-picker-gap, 0.5rem);*/\n\t--harmony-splitter-shadow-gutter-thickness: var(--harmony-splitter-gutter-thickness, 0.3rem);\n\t--harmony-splitter-shadow-gutter-bg-color: var(--harmony-splitter-gutter-bg-color, black);\n}\n\n:host(.vertical) {\n\tflex-direction: row;\n}\n\n:host(.horizontal) {\n\tflex-direction: column;\n}\n\n:host .gutter {\n\tflex: 0 0 var(--harmony-splitter-shadow-gutter-thickness);\n\tpointer-events: all;\n\tbackground-color: var(--harmony-splitter-shadow-gutter-bg-color);\n}\n\n:host(.vertical) .gutter {\n\tcursor: ew-resize;\n}\n\n:host(.horizontal) .gutter {\n\tcursor: ns-resize;\n}\n\n:host .panel {\n\tflex: 0 0 50%;\n\tdisplay: flex;\n\tpointer-events: none;\n}\n";

class HTMLHarmonySplitterElement extends HTMLElement {
    #shadowRoot;
    #htmlPanel1;
    #htmlPanel2;
    #htmlGutter;
    #doOnce = true;
    #orientation = 'v';
    #split = 0.5;
    #startOffsetLeft = 0;
    #startOffsetTop = 0;
    #startPageX = 0;
    #startPageY = 0;
    #startOffsetX = 0;
    #startOffsetY = 0;
    #dragging = false;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyleSync(this.#shadowRoot, splitterCSS); // sync version is used to ensure style is loaded before computation occurs
        this.#htmlPanel1 = createElement('slot', {
            class: 'panel',
            name: '1',
            parent: this.#shadowRoot,
        });
        this.#htmlGutter = createElement('div', {
            class: 'gutter',
            parent: this.#shadowRoot,
            /*events: {
                mousedown: event => this.#handleMouseDown(event),
            },*/
        });
        this.#htmlPanel2 = createElement('slot', {
            class: 'panel',
            name: '2',
            parent: this.#shadowRoot,
        });
        this.#htmlGutter.addEventListener('mousedown', event => this.#handleMouseDown(event));
        document.body.addEventListener('mousemove', event => this.#handleMouseMove(event), { capture: true });
        document.body.addEventListener('mouseup', () => this.#dragging = false);
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.setOrientation(this.getAttribute('orientation') ?? 'v');
            this.#update();
            this.#doOnce = false;
        }
    }
    #update() {
        this.#htmlPanel1.style.flexBasis = this.#split * 100 + '%';
        this.#htmlPanel2.style.flexBasis = (1 - this.#split) * 100 + '%';
    }
    setOrientation(orientation) {
        this.classList.remove('vertical', 'horizontal');
        switch (orientation) {
            case 'v':
            case 'vertical':
                this.#orientation = 'v';
                this.classList.add('vertical');
                break;
            case 'h':
            case 'horizontal':
                this.#orientation = 'h';
                this.classList.add('horizontal');
                break;
        }
    }
    #handleMouseDown(event) {
        this.#startOffsetLeft = this.#htmlGutter.offsetLeft;
        this.#startOffsetTop = this.#htmlGutter.offsetTop;
        this.#startOffsetX = event.offsetX;
        this.#startOffsetY = event.offsetY;
        this.#startPageX = event.pageX;
        this.#startPageY = event.pageY;
        this.#dragging = true;
        event.stopPropagation();
    }
    #handleMouseMove(event) {
        if (!this.#dragging) {
            return;
        }
        const elemRect = this.getBoundingClientRect();
        const clientX = event.clientX;
        const clientY = event.clientY;
        if (this.#orientation == 'v') {
            this.#split = (clientX - elemRect.x) / elemRect.width;
        }
        else {
            this.#split = (clientY - elemRect.y) / elemRect.height;
        }
        this.#split = Math.max(Math.min(this.#split, 0.99), 0.01);
        this.dispatchEvent(new CustomEvent('change', { detail: { value: this.#split } }));
        this.#update();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'orientation':
                this.setOrientation(newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['orientation'];
    }
}
let definedSplitter = false;
function defineHarmonySplitter() {
    if (window.customElements && !definedSplitter) {
        customElements.define('harmony-splitter', HTMLHarmonySplitterElement);
        definedSplitter = true;
        injectGlobalCss();
    }
}

var switchCSS = ":host {\n\t--harmony-switch-shadow-width: var(--harmony-switch-width, 4rem);\n\t--harmony-switch-shadow-height: var(--harmony-switch-height, 2rem);\n\t--harmony-switch-shadow-on-background-color: var(--harmony-switch-on-background-color, #1072eb);\n\t--harmony-switch-shadow-on-background-color-hover: var(--harmony-switch-on-background-color-hover, #1040c1);\n\t--harmony-switch-shadow-slider-width: var(--harmony-switch-slider-width, 1.4rem);\n\t--harmony-switch-shadow-slider-height: var(--harmony-switch-slider-height, 1.4rem);\n\t--harmony-switch-shadow-slider-margin: var(--harmony-switch-slider-margin, 0.3rem);\n\t--harmony-switch-shadow-slider-border-width: var(--harmony-switch-slider-border-width, 0rem);\n\t--slot-width: var(--harmony-switch-slot-width, auto);\n\t--prepend-width: var(--harmony-switch-prepend-width, var(--slot-width));\n\t--append-width: var(--harmony-switch-append-width, var(--slot-width));\n\n\tdisplay: inline-flex;\n\tuser-select: none;\n\tcursor: pointer;\n\tjustify-content: space-between;\n}\n\n:host>* {\n\tflex-grow: 0;\n}\n\n.label {\n\tmargin: auto 0;\n\tfont-weight: bold;\n\tflex: 1;\n}\n\nslot{\n\tdisplay: inline-block;\n}\n\nslot[name=\"prepend\"] {\n\twidth: var(--prepend-width);\n}\n\nslot[name=\"append\"] {\n\twidth: var(--append-width);\n}\n\n.harmony-switch-outer {\n\tdisplay: flex;\n\theight: var(--harmony-switch-shadow-height);\n\tborder-radius: calc(var(--harmony-switch-shadow-height) * 0.5);\n\talign-items: center;\n\tmargin-left: 0.25rem;\n\ttransition: background-color 0.25s linear;\n\twidth: var(--harmony-switch-shadow-width);\n}\n\n.harmony-switch-outer {\n\tbackground-color: var(--harmony-ui-input-background-primary);\n}\n\n.harmony-switch-outer:hover {\n\tbackground-color: var(--harmony-ui-input-background-secondary);\n}\n\n.harmony-switch-outer.on {\n\tbackground-color: var(--harmony-ui-accent-primary);\n}\n\n.harmony-switch-outer.on:hover {\n\tbackground-color: var(--harmony-ui-accent-secondary);\n}\n\n.harmony-switch-inner {\n\tdisplay: inline-block;\n\theight: var(--harmony-switch-shadow-slider-height);\n\twidth: var(--harmony-switch-shadow-slider-width);\n\tborder-radius: calc(var(--harmony-switch-shadow-slider-height) * 0.5);\n\ttransition: all 0.25s;\n\tposition: relative;\n\tleft: var(--harmony-switch-shadow-slider-margin);\n\tborder: var(--harmony-switch-shadow-slider-border-width) solid;\n\tbox-sizing: border-box;\n\tborder-color: var(--harmony-ui-input-border-primary);\n\tbackground-color: var(--harmony-ui-input-background-tertiary);\n}\n\n.harmony-switch-outer.ternary .harmony-switch-inner {\n\tleft: calc(50% - var(--harmony-switch-shadow-slider-width) * 0.5);\n}\n\n.harmony-switch-outer.off .harmony-switch-inner {\n\tleft: var(--harmony-switch-shadow-slider-margin);\n}\n\n.harmony-switch-outer.on .harmony-switch-inner {\n\tleft: calc(100% - var(--harmony-switch-shadow-slider-width) - var(--harmony-switch-shadow-slider-margin));\n}\n\n.harmony-switch-outer.ternary.off {\n\tbackground-color: red;\n}\n\n.harmony-switch-outer.ternary.off:hover {\n\tbackground-color: red;\n}\n\n.harmony-switch-outer.ternary.on {\n\tbackground-color: green;\n}\n\n.harmony-switch-outer.ternary.on:hover {\n\tbackground-color: green;\n}\n";

class HTMLHarmonySwitchElement extends HTMLHarmonyElement {
    #shadowRoot;
    #disabled = false;
    #htmlLabel;
    #htmlSwitchOuter;
    #state = false;
    #ternary = false;
    createElement() {
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, switchCSS);
        I18n.observeElement(this.#shadowRoot);
        this.#htmlLabel = createElement('div', {
            parent: this.#shadowRoot,
            class: 'label',
        });
        createElement('slot', {
            parent: this.#shadowRoot,
            name: 'prepend',
            $click: () => this.state = false,
        });
        this.#htmlSwitchOuter = createElement('span', {
            parent: this.#shadowRoot,
            class: 'harmony-switch-outer',
            child: createElement('span', { class: 'harmony-switch-inner' }),
            $click: () => this.toggle(),
        });
        createElement('slot', {
            parent: this.#shadowRoot,
            name: 'append',
            $click: () => this.state = true,
        });
        this.#refresh();
    }
    set disabled(disabled) {
        this.#disabled = disabled ? true : false;
        this.classList[this.#disabled ? 'add' : 'remove']('disabled');
    }
    get disabled() {
        return this.#disabled;
    }
    set state(state) {
        if (this.#state != state) {
            this.#state = state;
            this.dispatchEvent(new CustomEvent('change', { detail: { state: state, value: state } }));
        }
        else {
            this.#state = state;
        }
        this.#refresh();
    }
    get state() {
        return this.#state;
    }
    set checked(checked) {
        this.state = checked;
    }
    get checked() {
        return this.#state;
    }
    set ternary(ternary) {
        this.#ternary = ternary;
        this.#refresh();
    }
    get ternary() {
        return this.#ternary;
    }
    toggle() {
        if (this.#ternary) {
            if (this.#state === false) {
                this.state = undefined;
            }
            else if (this.#state === undefined) {
                this.state = true;
            }
            else {
                this.state = false;
            }
        }
        else {
            this.state = !this.#state;
        }
        this.#refresh();
    }
    #refresh() {
        this.#htmlSwitchOuter?.classList.remove('on', 'off', 'ternary');
        if (this.#ternary) {
            this.#htmlSwitchOuter?.classList.add('ternary');
        }
        if (this.#state === undefined) {
            return;
        }
        this.#htmlSwitchOuter?.classList.add(this.#state ? 'on' : 'off');
    }
    onAttributeChanged(name, oldValue, newValue) {
        switch (name) {
            case 'data-label':
                if (this.#htmlLabel) {
                    this.#htmlLabel.innerHTML = newValue;
                }
                this.#htmlLabel?.classList.remove('i18n');
                break;
            case 'data-i18n':
                this.#htmlLabel?.setAttribute('data-i18n', newValue);
                if (this.#htmlLabel) {
                    this.#htmlLabel.innerHTML = newValue;
                }
                this.#htmlLabel?.classList.add('i18n');
                break;
            case 'disabled':
                this.disabled = toBool(newValue);
                break;
            case 'ternary':
                this.ternary = true;
            case 'state':
                if (newValue == '' || newValue == 'undefined') {
                    this.state = undefined;
                }
                else {
                    if (newValue == 'true' || newValue == '1') {
                        this.state = true;
                    }
                    else {
                        this.state = false;
                    }
                }
                break;
        }
    }
    static get observedAttributes() {
        return ['data-label', 'data-i18n', 'disabled', 'ternary', 'state'];
    }
}
let definedSwitch = false;
function defineHarmonySwitch() {
    if (window.customElements && !definedSwitch) {
        customElements.define('harmony-switch', HTMLHarmonySwitchElement);
        definedSwitch = true;
        injectGlobalCss();
    }
}

class HTMLHarmonyTabElement extends HTMLElement {
    #disabled = false;
    #active = false;
    #header;
    #group;
    constructor() {
        super();
        this.#header = createElement('div', {
            class: 'harmony-tab-label',
            ...(this.getAttribute('data-i18n')) && { i18n: this.getAttribute('data-i18n') },
            ...(this.getAttribute('data-text')) && { innerText: this.getAttribute('data-text') },
            events: {
                click: (event) => this.#click(),
            },
        });
    }
    get htmlHeader() {
        return this.#header;
    }
    connectedCallback() {
        const parentElement = this.parentElement;
        if (parentElement && parentElement.tagName == 'HARMONY-TAB-GROUP') {
            parentElement.addTab(this);
            this.#group = parentElement;
        }
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'data-i18n':
                this.#header.setAttribute('data-i18n', newValue);
                this.#header.innerText = newValue;
                this.#header.classList.add('i18n');
                break;
            case 'data-text':
                this.#header.innerText = newValue;
                break;
            case 'disabled':
                this.disabled = toBool(newValue);
                break;
        }
    }
    set disabled(disabled) {
        this.#disabled = disabled ? true : false;
        this.#header.classList[this.#disabled ? 'add' : 'remove']('disabled');
    }
    get disabled() {
        return this.#disabled;
    }
    activate() {
        this.setActive(true);
    }
    /**
     * @deprecated use setActive() instead
     */
    set active(active) {
        console.warn('deprecated, use setActive instead');
        this.setActive(active);
    }
    setActive(active) {
        if (this.#active != active) {
            this.#active = active;
            if (active) {
                this.dispatchEvent(new CustomEvent('activated'));
            }
            else {
                this.dispatchEvent(new CustomEvent('deactivated'));
            }
        }
        display(this, active);
        if (active) {
            this.#header.classList.add('activated');
        }
        else {
            this.#header.classList.remove('activated');
        }
        if (active && this.#group) {
            this.#group.activateTab(this);
        }
    }
    /**
     * @deprecated use isActive() instead
     */
    get active() {
        console.warn('deprecated, use getActive instead');
        return this.isActive();
    }
    isActive() {
        return this.#active;
    }
    #click() {
        if (!this.dispatchEvent(new CustomEvent('click', { cancelable: true }))) {
            return;
        }
        if (!this.#disabled) {
            this.activate();
        }
    }
    static get observedAttributes() {
        return ['data-i18n', 'data-text', 'disabled'];
    }
}
let definedTab = false;
function defineHarmonyTab() {
    if (window.customElements && !definedTab) {
        customElements.define('harmony-tab', HTMLHarmonyTabElement);
        definedTab = true;
        injectGlobalCss();
    }
}

var tabGroupCSS = ":host,\nharmony-tab-group {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: relative;\n\toverflow: hidden;\n}\n\n.harmony-tab-group-header {\n\tbackground-color: var(--main-bg-color-bright);\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\toverflow: hidden;\n\twidth: 100%;\n}\n\n.harmony-tab-group-content {\n\tflex: 1;\n\tbackground-color: var(--main-bg-color-dark);\n\toverflow: auto;\n\twidth: 100%;\n}\n";

var tabCSS = "harmony-tab {\n\tdisplay: block;\n\theight: 100%;\n\toverflow: auto;\n}\n\nharmony-tab::first-letter {\n\ttext-transform: uppercase;\n}\n\n.harmony-tab-label {\n\tdisplay: inline-block;\n\tbackground-color: var(--main-bg-color-bright);\n\tpadding: 10px;\n\tborder: 1px solid black;\n\tborder-top: 0px;\n\t/*border-right:0px;*/\n\t/*margin-left: -1px;*/\n\tposition: relative;\n\t/*left: 1px;*/\n\tcolor: var(--main-text-color-dark2);\n\tcursor: pointer;\n\tuser-select: none;\n\tpointer-events: all;\n\tflex: 0 0;\n\ttext-align: center;\n\twhite-space: nowrap;\n}\n\n.harmony-tab-label.activated {\n\tbackground-color: var(--main-bg-color-dark);\n\tborder-bottom: 1px solid var(--main-bg-color-dark);\n\tborder-left: 1px solid white;\n\tz-index: 2;\n}\n";

class HTMLHarmonyTabGroupElement extends HTMLElement {
    #doOnce = true;
    #tabs = new Set();
    #header;
    #content;
    #activeTab;
    #shadowRoot;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        this.#header = createElement('div', {
            class: 'harmony-tab-group-header',
        });
        this.#content = createElement('div', {
            class: 'harmony-tab-group-content',
        });
    }
    connectedCallback() {
        if (this.#doOnce) {
            I18n.observeElement(this.#shadowRoot);
            shadowRootStyle(this.#shadowRoot, tabGroupCSS);
            shadowRootStyle(this.#shadowRoot, tabCSS);
            this.#shadowRoot.append(this.#header, this.#content);
            this.#doOnce = false;
        }
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    addTab(tab) {
        this.#tabs.add(tab);
        if (!this.#activeTab) {
            this.#activeTab = tab;
        }
        this.#refresh();
    }
    #refresh() {
        for (const tab of this.#tabs) {
            this.#header.append(tab.htmlHeader);
            this.#content.append(tab);
            if (tab != this.#activeTab) {
                tab.setActive(false);
            }
        }
        this.#activeTab?.setActive(true);
    }
    /**
     * @deprecated use activateTab() instead
     */
    set active(tab) {
        console.warn('deprecated, use activateTab instead');
        this.activateTab(tab);
    }
    activateTab(tab) {
        if (this.#activeTab != tab) {
            this.#activeTab = tab;
            this.#refresh();
        }
    }
    clear() {
        this.#tabs.clear();
        this.#activeTab = undefined;
        this.#header.innerText = '';
        this.#content.innerText = '';
    }
}
let definedTabGroup = false;
function defineHarmonyTabGroup() {
    if (window.customElements && !definedTabGroup) {
        customElements.define('harmony-tab-group', HTMLHarmonyTabGroupElement);
        definedTabGroup = true;
        injectGlobalCss();
    }
}

var toggleButtonCSS = ":host {\n\tcursor: pointer;\n\tdisplay: inline-block;\n\tposition: relative;\n}\n\non,\noff {\n\theight: 100%;\n\twidth: 100%;\n\tbackground-size: 100% auto;\n\tbox-sizing: border-box;\n}\n";

class HTMLHarmonyToggleButtonElement extends HTMLElement {
    #state = false;
    #shadowRoot;
    #htmlSlotOn;
    #htmlSlotOff;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        this.#htmlSlotOn = createElement('slot', {
            parent: this.#shadowRoot,
            name: 'on',
        });
        this.#htmlSlotOff = createElement('slot', {
            parent: this.#shadowRoot,
            name: 'off',
        });
        I18n.observeElement(this.#shadowRoot);
        shadowRootStyle(this.#shadowRoot, toggleButtonCSS);
        this.addEventListener('click', (event) => {
            this.#click();
            event.stopPropagation();
        });
        this.#initObserver();
    }
    connectedCallback() {
        this.#refresh();
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (name == 'state') {
            this.state = toBool(newValue);
        }
    }
    get state() {
        return this.#state;
    }
    set state(state) {
        state = state ? true : false;
        if (this.#state != state) {
            this.#state = state;
            this.dispatchEvent(new CustomEvent('change', { detail: { oldState: this.#state, newState: state } }));
            this.#refresh();
        }
    }
    #refresh() {
        this.classList.remove('on', 'off');
        if (this.#state) {
            this.classList.add('on');
            if (this.#htmlSlotOn.assignedElements().length) {
                show(this.#htmlSlotOn);
                hide(this.#htmlSlotOff);
            }
        }
        else {
            this.classList.add('off');
            if (this.#htmlSlotOff.assignedElements().length) {
                hide(this.#htmlSlotOn);
                show(this.#htmlSlotOff);
            }
        }
    }
    #click() {
        this.state = !this.#state;
    }
    #initObserver() {
        const config = { childList: true, subtree: true };
        const mutationCallback = (mutationsList, observer) => {
            for (const mutation of mutationsList) {
                for (const addedNode of mutation.addedNodes) {
                    if (addedNode.parentNode == this) {
                        this.#refresh();
                    }
                }
            }
        };
        const observer = new MutationObserver(mutationCallback);
        observer.observe(this, config);
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    static get observedAttributes() {
        return ['state'];
    }
}
let definedToggleButton = false;
function defineHarmonyToggleButton() {
    if (window.customElements && !definedToggleButton) {
        customElements.define('harmony-toggle-button', HTMLHarmonyToggleButtonElement);
        definedToggleButton = true;
        injectGlobalCss();
    }
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AddI18nElement: AddI18nElement,
  HTMLHarmony2dManipulatorElement: HTMLHarmony2dManipulatorElement,
  HTMLHarmonyAccordionElement: HTMLHarmonyAccordionElement,
  HTMLHarmonyColorPickerElement: HTMLHarmonyColorPickerElement,
  HTMLHarmonyCopyElement: HTMLHarmonyCopyElement,
  HTMLHarmonyFileInputElement: HTMLHarmonyFileInputElement,
  HTMLHarmonyItemElement: HTMLHarmonyItemElement,
  HTMLHarmonyLabelPropertyElement: HTMLHarmonyLabelPropertyElement,
  HTMLHarmonyMenuElement: HTMLHarmonyMenuElement,
  HTMLHarmonyPaletteElement: HTMLHarmonyPaletteElement,
  HTMLHarmonyPanelElement: HTMLHarmonyPanelElement,
  HTMLHarmonyRadioElement: HTMLHarmonyRadioElement,
  HTMLHarmonySelectElement: HTMLHarmonySelectElement,
  HTMLHarmonySliderElement: HTMLHarmonySliderElement,
  HTMLHarmonySlideshowElement: HTMLHarmonySlideshowElement,
  HTMLHarmonySplitterElement: HTMLHarmonySplitterElement,
  HTMLHarmonySwitchElement: HTMLHarmonySwitchElement,
  HTMLHarmonyTabElement: HTMLHarmonyTabElement,
  HTMLHarmonyTabGroupElement: HTMLHarmonyTabGroupElement,
  HTMLHarmonyToggleButtonElement: HTMLHarmonyToggleButtonElement,
  HTMLHarmonyTooltipElement: HTMLHarmonyTooltipElement,
  I18n: I18n,
  I18nElements: I18nElements,
  get I18nEvents () { return I18nEvents; },
  get ManipulatorCorner () { return ManipulatorCorner; },
  get ManipulatorDirection () { return ManipulatorDirection; },
  get ManipulatorResizeOrigin () { return ManipulatorResizeOrigin; },
  get ManipulatorSide () { return ManipulatorSide; },
  get ManipulatorUpdatedEventType () { return ManipulatorUpdatedEventType; },
  cloneEvent: cloneEvent,
  createElement: createElement,
  createElementNS: createElementNS,
  createShadowRoot: createShadowRoot,
  defineHarmony2dManipulator: defineHarmony2dManipulator,
  defineHarmonyAccordion: defineHarmonyAccordion,
  defineHarmonyColorPicker: defineHarmonyColorPicker,
  defineHarmonyCopy: defineHarmonyCopy,
  defineHarmonyFileInput: defineHarmonyFileInput,
  defineHarmonyItem: defineHarmonyItem,
  defineHarmonyLabelProperty: defineHarmonyLabelProperty,
  defineHarmonyMenu: defineHarmonyMenu,
  defineHarmonyPalette: defineHarmonyPalette,
  defineHarmonyPanel: defineHarmonyPanel,
  defineHarmonyRadio: defineHarmonyRadio,
  defineHarmonySelect: defineHarmonySelect,
  defineHarmonySlider: defineHarmonySlider,
  defineHarmonySlideshow: defineHarmonySlideshow,
  defineHarmonySplitter: defineHarmonySplitter,
  defineHarmonySwitch: defineHarmonySwitch,
  defineHarmonyTab: defineHarmonyTab,
  defineHarmonyTabGroup: defineHarmonyTabGroup,
  defineHarmonyToggleButton: defineHarmonyToggleButton,
  defineHarmonyTooltip: defineHarmonyTooltip,
  display: display,
  documentStyle: documentStyle,
  documentStyleSync: documentStyleSync,
  hide: hide,
  isVisible: isVisible,
  shadowRootStyle: shadowRootStyle,
  shadowRootStyleSync: shadowRootStyleSync,
  show: show,
  styleInject: styleInject,
  toggle: toggle,
  updateElement: updateElement,
  visible: visible$1
});

function SaveFile(file) {
    const link = document.createElement('a');
    link.setAttribute('href', URL.createObjectURL(file));
    link.setAttribute('download', file.name);
    link.click();
}

var notificationManagerCSS = ":host, .notification-manager{\r\n\tposition: absolute;\r\n\tz-index: 100;\r\n\tbottom: 0px;\r\n\twidth: 100%;\r\n\tdisplay: flex;\r\n\tflex-direction: column-reverse;\r\n\tmax-height: 50%;\r\n\toverflow-y: auto;\r\n}\r\n.notification-manager-notification{\r\n\tbackground-color: var(--theme-popup-bg-color);\r\n\tcolor: var(--theme-text-color);\r\n\tfont-size: 1.5em;\r\n\tpadding: 4px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n}\r\n.notification-manager-notification-content{\r\n\toverflow: auto;\r\n\tflex: 1;\r\n\tmax-width: calc(100% - 20px);\r\n}\r\n.notification-manager-notification-close{\r\n\tfill: currentColor;\r\n\tcursor: pointer;\r\n}\r\n.notification-manager-notification-copy{\r\n\tfill: currentColor;\r\n\tcursor: pointer;\r\n\ttransition: all 0.3s ease-in 0s;\r\n}\r\n.notification-manager-notification-copy-success{\r\n\ttransform: rotate(1turn);\r\n}\r\n.notification-manager-notification-close > svg{\r\n\twidth: 20px;\r\n\tmargin: 5px;\r\n}\r\n.notification-manager-notification-success{\r\n\tbackground-color: #5aa822ff;\r\n}\r\n.notification-manager-notification-warning{\r\n\tbackground-color: #c78a17ff;\r\n}\r\n.notification-manager-notification-error{\r\n\tbackground-color: #c71717ff;\r\n}\r\n.notification-manager-notification-info{\r\n\tbackground-color: #2e88e8ff;\r\n}\r\n";

const NOTIFICATION_CLASSNAME = 'notification-manager-notification';
class Notification {
    #htmlElement;
    timeout = 0;
    content;
    type;
    constructor(content, type, ttl) {
        this.content = content;
        this.type = type;
        this.setTtl(ttl);
    }
    setTtl(ttl) {
        if (ttl) {
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => closeNofication(this), ttl * 1000);
        }
    }
    get view() {
        if (!this.#htmlElement) {
            let htmlElementContent;
            this.#htmlElement = createElement('div', {
                class: NOTIFICATION_CLASSNAME,
                childs: [
                    htmlElementContent = createElement('div', {
                        class: NOTIFICATION_CLASSNAME + '-content',
                    }),
                    createElement('div', {
                        class: NOTIFICATION_CLASSNAME + '-copy',
                        innerHTML: contentCopySVG,
                        events: {
                            click: async (event) => {
                                try {
                                    if (this.#htmlElement) {
                                        await navigator.clipboard.writeText(this.#htmlElement.innerText);
                                        event.target.parentElement?.classList.toggle(NOTIFICATION_CLASSNAME + '-copy-success');
                                    }
                                }
                                catch (e) {
                                    console.error(e);
                                }
                            },
                        }
                    }),
                    createElement('div', {
                        class: NOTIFICATION_CLASSNAME + '-close',
                        innerHTML: closeSVG,
                        events: {
                            click: () => closeNofication(this),
                        }
                    }),
                ]
            });
            if (this.type) {
                this.#htmlElement.classList.add(NOTIFICATION_CLASSNAME + '-' + this.type);
            }
            if (this.content instanceof HTMLElement) {
                htmlElementContent.append(this.content);
            }
            else {
                htmlElementContent.innerHTML = this.content;
            }
        }
        return this.#htmlElement;
    }
}
let htmlParent = document.body;
const shadowRoot = createShadowRoot('div', {
    class: 'notification-manager',
    parent: htmlParent,
    adoptStyle: notificationManagerCSS,
});
I18n.observeElement(shadowRoot);
const nofifications = new Set();
function closeNofication(notification) {
    nofifications.delete(notification);
    notification.view.remove();
}

var optionsManagerCSS = ":host{\r\n\tposition: absolute;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\toverflow: auto;\r\n\tz-index: 10000;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\r\n\ttop:0px;\r\n\tleft: 0px;\r\n}\r\n\r\n#options-manager-inner{\r\n\tposition: relative;\r\n\t/*background-color: rgba(255, 255, 255, 1.0);*/\r\n\tbackground-color: var(--theme-popup-bg-color);\r\n\tcolor: var(--main-text-color-dark2);\r\n\tpadding:10px;\r\n\toverflow: hidden;\r\n\tmax-height: 70%;\r\n\tmax-width: 75%;\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\topacity: 0.9;\r\n}\r\n\r\n#options-manager-inner h1{\r\n\ttext-transform: capitalize;\r\n\ttext-align: center;\r\n}\r\n\r\n#options-manager-inner-filter{\r\n\twidth:100%;\r\n}\r\n\r\n.options-manager-button{\r\n\tcursor:pointer;\r\n\twhite-space: nowrap;\r\n\ttext-transform: capitalize;\r\n}\r\n\r\n#options-manager-inner table{\r\n\ttext-align: left;\r\n\toverflow: hidden auto;\r\n\tdisplay: block;\r\n\theight: 100%;\r\n}\r\n\r\n#options-manager-inner thead{\r\n\tposition: sticky;\r\n\t/*display: block;*/\r\n\ttop: 0px;\r\n\tbackground-color: var(--theme-popup-bg-color);\r\n}\r\n\r\n#options-manager-inner thead th{\r\n\tposition: sticky;\r\n\ttop: 0px;\r\n\tbackground-color: var(--theme-popup-bg-color);\r\n}\r\n\r\n#options-manager-inner th{\r\n\ttext-transform: capitalize;\r\n}\r\n\r\n#options-manager-inner th button, #options-manager-inner td button{\r\n\twidth: 100%;\r\n}\r\n\r\n#options-manager-title{\r\n\tcursor:move;\r\n}\r\n\r\n[draggable=true] {\r\n\tcursor: move;\r\n}\r\n\r\n[draggable=true] *{\r\n\tcursor: initial;\r\n}\r\n\r\n#options-manager-outer kbd{\r\n\tbackground-color: #eee;\r\n\tborder-radius: 0.25rem;\r\n\tborder: 0.1rem solid #b4b4b4;\r\n\tbox-shadow: 0 0.06rem 0.06rem rgba(0, 0, 0, .2), 0 0.1rem 0 0 rgba(255, 255, 255, .7) inset;\r\n\tcolor: #333;\r\n\tdisplay: inline-block;\r\n\tline-height: 1;\r\n\tpadding: 0.15rem;\r\n\twhite-space: nowrap;\r\n\tfont-weight: 1000;\r\n\tfont-size: 1.3rem;\r\n}\r\n";

class OptionsManager extends EventTarget {
    static #instance;
    #defaultValues = new Map();
    #currentValues = new Map();
    #categories = new Map();
    #dirtyCategories = true;
    #initPromiseResolve;
    #initPromise = new Promise((resolve) => this.#initPromiseResolve = resolve);
    #currentFilter = '';
    #optionsManagerRows = new Set();
    #htmlOptionsTable;
    #htmlOptionsManagerContentThead;
    #uniqueId = 0;
    #shadowRoot;
    logException = false;
    constructor() {
        if (OptionsManager.#instance) {
            return OptionsManager.#instance;
        }
        super();
        OptionsManager.#instance = this;
        this.#defaultValues[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => { return a[0] < b[0] ? -1 : 1; });
        };
    }
    async init(parameters) {
        if (parameters.url) {
            await this.#initFromURL(parameters.url);
        }
        else if (parameters.json) {
            this.#initFromJSON(parameters.json);
        }
    }
    async #initFromURL(url) {
        const response = await fetch(url);
        this.#initFromJSON(await response.json());
    }
    #initFromJSON(json) {
        if (json) {
            if (json.categories) {
                json.categories.forEach((category) => this.#addCategory(category));
            }
            this.#addCategory('');
            if (json.options) {
                json.options.forEach((option /*TODO:better type*/) => this.addOption(option));
            }
            if (this.#initPromiseResolve) {
                this.#initPromiseResolve();
            }
        }
    }
    #addCategory(name) {
        this.#categories.set(name.toLowerCase(), []);
        this.#dirtyCategories = true;
    }
    #refreshCategories() {
        if (this.#dirtyCategories) {
            for (const [categoryName, category] of this.#categories) {
                category.length = 0;
            }
            for (const [optionName, option] of this.#defaultValues) {
                let maxLength = -1;
                let cat = null;
                for (const [categoryName, category] of this.#categories) {
                    if (categoryName.length > maxLength) {
                        if (optionName.startsWith(categoryName) || categoryName === '') {
                            maxLength = categoryName.length;
                            cat = category;
                        }
                    }
                }
                if (cat !== null) {
                    cat.push(option);
                }
            }
        }
        this.#dirtyCategories = false;
    }
    addOption(option /*TODO:better type*/) {
        if (!option) {
            return;
        }
        const name = option.name.toLowerCase();
        const type = option.type;
        const defaultValue = option.default;
        const datalist = option.datalist;
        const editable = option.editable;
        const context = option.context;
        const protec = option.protected;
        const dv = this.#defaultValues.get(name) || { name: '', editable: true, type: '' };
        this.#defaultValues.set(name, dv);
        dv.name = name;
        if (type !== undefined) {
            dv.type = type;
        }
        if (defaultValue !== undefined) {
            dv.dv = defaultValue;
        }
        if (datalist !== undefined) {
            dv.datalist = datalist;
        }
        if (editable !== undefined) {
            dv.editable = editable;
        }
        if (context !== undefined) {
            dv.context = context;
        }
        if (protec !== undefined) {
            dv.protected = protec;
        }
        try {
            if (typeof localStorage != 'undefined') {
                const value = this.getItem(name);
                if (value === undefined) {
                    this.setItem(name, defaultValue);
                }
                else {
                    this.setItem(name, value);
                }
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    setItem(name, value) {
        try {
            if (typeof localStorage != 'undefined') {
                localStorage.setItem(name, JSON.stringify(value));
                if (this.#currentValues.has(name)) {
                    if (value == this.#currentValues.get(name)) {
                        return;
                    }
                }
                this.#currentValues.set(name, value);
                this.#valueChanged(name, value);
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    async getSubItem(name, subName) {
        try {
            const option = await this.getOption(name);
            if (option && option.type == 'map') {
                const map = this.#currentValues.get(name) ?? {};
                if (map && (typeof map == 'object')) {
                    return map[subName];
                }
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    async setSubItem(name, subName, value) {
        try {
            const option = await this.getOption(name);
            if (option && option.type == 'map') {
                const map = this.#currentValues.get(name) ?? {};
                if (map[subName] == value) {
                    return;
                }
                map[subName] = value;
                this.#valueChanged(name, map);
                localStorage.setItem(name, JSON.stringify(map));
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    removeSubItem(name, subName) {
        try {
            const map = this.#currentValues.get(name) ?? {};
            if (map && (typeof map == 'object')) {
                delete map[subName];
                this.#valueChanged(name, map);
                localStorage.setItem(name, JSON.stringify(map));
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    #valueChanged(name, value) {
        const option = this.#defaultValues.get(name);
        if (!option) {
            return;
        }
        const context = option.context;
        this.dispatchEvent(new CustomEvent(name, { detail: { name: name, value: value, context: context } }));
        let lastIndex = name.lastIndexOf('.');
        while (lastIndex != -1) {
            const wildCardName = name.slice(0, lastIndex);
            this.dispatchEvent(new CustomEvent(wildCardName + '.*', { detail: { name: name, value: value, context: context } }));
            lastIndex = name.lastIndexOf('.', lastIndex - 1);
        }
        this.dispatchEvent(new CustomEvent('*', { detail: { name: name, value: value, context: context } }));
    }
    getItem(name) {
        try {
            if (typeof localStorage != 'undefined') {
                const value = localStorage.getItem(name);
                if (value) {
                    const parsedValue = JSON.parse(value);
                    return parsedValue;
                }
            }
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
        if (this.#defaultValues.get(name)) {
            return this.#defaultValues.get(name)?.dv;
        }
    }
    removeItem(name) {
        this.#defaultValues.delete(name);
        try {
            if (typeof localStorage != 'undefined') {
                localStorage.removeItem(name);
            }
            this.#currentValues.delete(name);
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    resetItem(name) {
        const item = this.#defaultValues.get(name);
        if (item) {
            const defaultValue = item.dv;
            this.#currentValues.delete(name);
            this.setItem(name, defaultValue);
        }
    }
    resetItems(names) {
        for (const name of names) {
            this.resetItem(name);
        }
    }
    resetAllItems() {
        for (const [item, option] of this.#defaultValues) {
            if (option.protected) {
                continue;
            }
            this.resetItem(item);
        }
    }
    clear() {
        this.#defaultValues.clear();
        try {
            if (typeof localStorage != 'undefined') {
                localStorage.clear();
            }
            this.#currentValues.clear();
        }
        catch (exception) {
            if (this.logException) {
                console.error(exception);
            }
        }
    }
    #filter(filter) {
        this.#currentFilter = String(filter).toLowerCase();
        this.#applyFilter();
    }
    #applyFilter() {
        for (const row of this.#optionsManagerRows) {
            //let row = i[0];
            const optionName = row.getAttribute('user-data-option-name')?.toLowerCase();
            if (!optionName) {
                continue;
            }
            if (!this.#currentFilter || optionName.indexOf(this.#currentFilter) != -1) {
                row.style.display = '';
            }
            else {
                row.style.display = 'none';
            }
        }
    }
    #initPanel() {
        this.#shadowRoot = createShadowRoot('options-manager', {
            parent: document.body,
            adoptStyle: optionsManagerCSS,
            events: {
                click: () => hide(this.#shadowRoot?.host)
            }
        });
        I18n.observeElement(this.#shadowRoot);
        const optionsManagerInner = createElement('div', {
            id: 'options-manager-inner',
            draggable: true,
            'data-left': 0,
            'data-top': 0,
            parent: this.#shadowRoot,
            events: {
                click: (event) => event.stopPropagation(),
                dragstart: (event) => handleDragStart(event),
                dragend: (event) => handleDragEnd(event),
            }
        });
        const handleDragStart = function (event) {
            const target = event.target;
            target?.setAttribute('data-drag-start-layerx', String(event.layerX));
            target?.setAttribute('data-drag-start-layery', String(event.layerY));
        };
        const handleDragEnd = function (event) {
            const target = event.target;
            const startEventX = Number(target.getAttribute('data-drag-start-layerx'));
            const startEventY = Number(target.getAttribute('data-drag-start-layery'));
            target.style.left = (event.layerX - startEventX) + 'px';
            target.style.top = (event.layerY - startEventY) + 'px';
            const dataTop = Number(target.getAttribute('data-top')) + (event.layerY - startEventY);
            const dataLeft = Number(target.getAttribute('data-left')) + (event.layerX - startEventX);
            target.style.left = dataLeft + 'px';
            target.style.top = dataTop + 'px';
            optionsManagerInner.setAttribute('data-left', String(dataLeft));
            optionsManagerInner.setAttribute('data-top', String(dataTop));
        };
        createElement('h1', { id: 'options-manager-title', i18n: '#manage_options', parent: optionsManagerInner });
        createElement('input', {
            id: 'options-manager-inner-filter',
            i18n: { placeholder: '#filter', },
            parent: optionsManagerInner,
            events: {
                input: (event) => this.#filter(event.target.value)
            }
        });
        this.#htmlOptionsTable = createElement('table', { parent: optionsManagerInner });
        this.#htmlOptionsManagerContentThead = createElement('thead', { parent: this.#htmlOptionsTable });
    }
    #populateOptionRow(option) {
        const htmlRow = createElement('tr');
        const htmlResetButtonCell = createElement('td');
        const htmlOptionNameCell = createElement('td', { innerHTML: option.name });
        const htmlDefaultValueCell = createElement('td');
        const htmlUserValueCell = createElement('td');
        const myValue = this.getItem(option.name);
        this.#fillCell(htmlDefaultValueCell, option.type, option.dv);
        createElement('button', {
            class: 'options-manager-button',
            i18n: '#reset',
            parent: htmlResetButtonCell,
            events: {
                click: () => { this.resetItem(option.name); this.#refreshPanel(); }
            }
        });
        const valueEdit = this.#createInput(option.name, this.#defaultValues.get(option.name), myValue, htmlResetButtonCell);
        if (valueEdit) {
            htmlUserValueCell.appendChild(valueEdit);
            htmlRow.append(htmlResetButtonCell, htmlOptionNameCell, htmlDefaultValueCell, htmlUserValueCell);
        }
        return htmlRow;
    }
    #populateMapOptionRow(option) {
        const htmlRow = createElement('tbody', { innerHTML: `<td></td><td colspan="3">${option.name}</td>` });
        const userValue = this.getItem(option.name);
        if (userValue && typeof userValue === 'object') {
            for (const key in userValue) {
                const htmlSubRow = createElement('tr', { parent: htmlRow });
                const value = userValue[key];
                const htmlRemoveButtonCell = createElement('td');
                const htmlSubNameCell = createElement('td', { innerHTML: key });
                const htmlSubValueCell = createElement('td');
                htmlSubRow.append(htmlRemoveButtonCell, htmlSubNameCell, htmlSubValueCell);
                createElement('input', { value: value, parent: htmlSubValueCell });
            }
        }
        return htmlRow;
    }
    #addOptionRow(option) {
        if (option.editable === false) {
            return;
        }
        let htmlRow;
        if (option.type == 'map') {
            htmlRow = this.#populateMapOptionRow(option);
        }
        else {
            htmlRow = this.#populateOptionRow(option);
        }
        htmlRow.setAttribute('user-data-option-name', option.name);
        return htmlRow;
    }
    #refreshPanel() {
        this.#refreshCategories();
        if (this.#htmlOptionsManagerContentThead) {
            this.#htmlOptionsManagerContentThead.innerText = '';
            this.#htmlOptionsManagerContentThead.append(createElement('th', {
                child: createElement('button', {
                    class: 'options-manager-button',
                    i18n: '#reset_all',
                    events: {
                        click: () => { this.resetAllItems(); this.#refreshPanel(); }
                    }
                })
            }), createElement('th', { i18n: '#option_name' }), createElement('th', { i18n: '#option_default_value' }), createElement('th', { i18n: '#option_user_value' }));
        }
        for (const row of this.#optionsManagerRows) {
            row.remove();
        }
        this.#optionsManagerRows.clear();
        for (const [categoryName, category] of this.#categories) {
            for (const option of category) {
                const htmlRow = this.#addOptionRow(option);
                if (htmlRow) {
                    this.#optionsManagerRows.add(htmlRow);
                    this.#htmlOptionsTable?.append(htmlRow);
                }
            }
        }
        I18n.i18n();
        this.#applyFilter();
    }
    #fillCell(cell, type, value) {
        switch (type) {
            case 'string':
                if (value) {
                    cell.innerHTML = value;
                }
                break;
            case 'shortcut':
                if (value) {
                    const arr = value.split('+');
                    for (const key of arr) {
                        createElement('kbd', {
                            innerHTML: key,
                            parent: cell,
                        });
                    }
                    //cell.innerHTML = value;
                }
                break;
            default:
                if (value) {
                    cell.innerHTML = value;
                }
        }
    }
    #getUniqueId() {
        return 'options-manager-' + (this.#uniqueId++);
    }
    #createInput(optionName, option, value, resetButton) {
        if (!option) {
            return;
        }
        const showHideResetButton = () => {
            let defaultValue = this.#defaultValues.get(optionName)?.dv;
            defaultValue = defaultValue === undefined ? undefined : JSON.stringify(defaultValue);
            let optionValue = this.getItem(optionName);
            optionValue = optionValue === null ? null : JSON.stringify(optionValue);
            if ((optionValue) != defaultValue) {
                resetButton.style.opacity = '';
            }
            else {
                resetButton.style.opacity = '0';
            }
        };
        let htmlElement;
        switch (option.type) {
            case 'number':
            case 'integer':
                htmlElement = createElement('input', {
                    value: value,
                    events: {
                        change: (event) => {
                            const value = event.target.value.trim();
                            this.setItem(optionName, value === '' ? null : Number(value));
                            showHideResetButton();
                        }
                    }
                });
                break;
            case 'object':
                htmlElement = createElement('input', {
                    value: JSON.stringify(value),
                    events: {
                        change: (event) => { this.setItem(optionName, JSON.parse(event.target.value)); showHideResetButton(); }
                    }
                });
                break;
            case 'boolean':
                htmlElement = createElement('input', {
                    type: 'checkbox',
                    checked: value,
                    events: {
                        change: (event) => { this.setItem(optionName, event.target.checked); showHideResetButton(); }
                    }
                });
                break;
            case 'ternary':
                htmlElement = createElement('select', {
                    events: {
                        change: (event) => {
                            let value;
                            switch (event.target.value) {
                                case '0':
                                    value = false;
                                    break;
                                case '1':
                                    value = true;
                                    break;
                            }
                            this.setItem(optionName, value);
                            showHideResetButton();
                        }
                    }
                });
                for (const o of ['', 0, 1]) {
                    createElement('option', { innerHTML: o, parent: htmlElement });
                }
                let v = '';
                switch (value) {
                    case undefined:
                        v = '';
                        break;
                    case false:
                        v = '0';
                        break;
                    case true:
                        v = '1';
                        break;
                }
                htmlElement.value = v;
                break;
            case 'list':
                this.#getUniqueId();
                htmlElement = createElement('select', {
                    value: value,
                    events: {
                        change: (event) => { this.setItem(optionName, event.target.value); showHideResetButton(); }
                    }
                });
                if (option.datalist) {
                    for (const o of option.datalist) {
                        createElement('option', { innerHTML: o, parent: htmlElement });
                    }
                }
                htmlElement.value = value;
                break;
            case 'vec2':
                htmlElement = createElement('input', {
                    value: value,
                    events: {
                        change: (event) => { this.setItem(optionName, (readVec2Value(event.target.value))); showHideResetButton(); }
                    }
                });
                break;
            /*case 'editablelist':
                let dataListId = OptionsManager.#getUniqueId();
                htmlElement = createElement('input');
                let datalist = createElement('datalist');
                datalist.id = dataListId;
                htmlElement.setAttribute('list', dataListId);
                document.body.appendChild(datalist);
                if (option.datalist) {
                    for(let o of option.datalist) {
                        let htmlOption = createElement('option');
                        datalist.appendChild(htmlOption);
                        htmlOption.innerHTML = o;
                    }
                }
                htmlElement.addEventListener('change', event => {this.setItem(optionName, event.target.value);showHideResetButton();});
                break;*/
            /*			case 'vec4':
                            htmlElement = createElement('input');
                            htmlElement.value = value;//value.join(',');
                            function readValue(value) {
                                let v = value.split(',');
                                if (v.length == 4) {
                                    return quat.fromValues(v[0] * 1, v[1] * 1, v[2] * 1, v[3] * 1);
                                }
                                return null;
                            }
                            htmlElement.addEventListener('change', event => {this.setItem(optionName, (readValue(event.target.value)));showHideResetButton();});
                            break;*/
            case 'string':
            case 'color':
            default:
                htmlElement = createElement('input', {
                    value: value,
                    events: {
                        change: (event) => { this.setItem(optionName, (event.target.value)); showHideResetButton(); }
                    }
                });
                break;
        }
        showHideResetButton();
        return htmlElement;
    }
    showOptionsManager() {
        if (!this.#shadowRoot) {
            this.#initPanel();
        }
        this.#refreshPanel();
        show(this.#shadowRoot?.host);
    }
    async getOptionsPerType(type) {
        await this.#initPromise;
        const ret = new Map();
        for (const option of this.#defaultValues.values()) {
            if (option.type == type) {
                const optionName = option.name;
                ret.set(optionName, this.#currentValues.get(optionName));
            }
        }
        return ret;
    }
    async getOption(name) {
        await this.#initPromise;
        return this.#defaultValues.get(name);
    }
    async getOptionType(name) {
        await this.#initPromise;
        return this.#defaultValues.get(name)?.type;
    }
    async getList(name) {
        await this.#initPromise;
        const option = this.#defaultValues.get(name);
        if (option && option.type == 'list') {
            return option.datalist;
        }
    }
}
function readVec2Value(value) {
    const v = value.split(',');
    if (v.length == 2) {
        return fromValues(Number(v[0]), Number(v[1]));
    }
    return null;
}

class Shortcut {
    #contexts;
    #key;
    #alt = false;
    #ctrl = false;
    #meta = false;
    #shift = false;
    constructor(context, shortcut) {
        this.#contexts = context.split(',');
        const keys = shortcut.toUpperCase().split('+');
        for (const key of keys) {
            switch (key) {
                case 'ALT':
                    this.#alt = true;
                    break;
                case 'CTRL':
                    this.#ctrl = true;
                    break;
                case 'META':
                    this.#meta = true;
                    break;
                case 'SHIFT':
                    this.#shift = true;
                    break;
                case 'PLUS':
                    this.#key = '+';
                    break;
                default:
                    this.#key = key;
            }
        }
    }
    match(context, keyBoardEvent) {
        return (this.#contexts.indexOf(context) > -1) &&
            (keyBoardEvent.altKey == this.#alt) &&
            (keyBoardEvent.ctrlKey == this.#ctrl) &&
            (keyBoardEvent.metaKey == this.#meta) &&
            (keyBoardEvent.shiftKey == this.#shift) &&
            (keyBoardEvent.key.toUpperCase() == this.#key);
    }
}
class ShortcutHandler {
    static #shortcuts = new Map();
    static #eventTarget = new EventTarget();
    static {
        this.addContext('window', document);
    }
    static #handleKeyDown(contextName, event) {
        const contexts = contextName.split(',');
        for (const [name, shortcuts] of this.#shortcuts) {
            for (const shortcut of shortcuts) {
                for (const context of contexts) {
                    if (shortcut.match(context, event)) {
                        this.#eventTarget.dispatchEvent(new CustomEvent(name, { detail: event }));
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
    }
    static addContext(name, element) {
        element.addEventListener('keydown', (event) => this.#handleKeyDown(name, event));
    }
    static setShortcuts(contextName, shortcutMap) {
        if (!shortcutMap) {
            return;
        }
        this.#shortcuts.clear();
        for (const [name, shortcut] of shortcutMap) {
            this.addShortcut(contextName, name, shortcut);
        }
    }
    static setShortcut(contextName, name, shortcut) {
        this.#shortcuts.delete(name);
        this.addShortcut(contextName, name, shortcut);
    }
    static addShortcut(contextName, name, shortcut) {
        if (!shortcut) {
            return;
        }
        const shortcuts = shortcut.split(';');
        let shortcutSet = this.#shortcuts.get(name);
        if (!shortcutSet) {
            shortcutSet = new Set();
            this.#shortcuts.set(name, shortcutSet);
        }
        for (const shortcut of shortcuts) {
            shortcutSet.add(new Shortcut(contextName, shortcut));
        }
    }
    static addEventListener(type, callback, options) {
        this.#eventTarget.addEventListener(type, callback, options);
    }
}

var _a$4;
const TWO_POW_10 = 1024;
const TWO_POW_MINUS_14 = Math.pow(2, -14);
function getCharCodes(str) {
    let codes = new Uint8Array(str.length);
    for (var i = 0, length = str.length; i < length; i++) {
        codes[i] = str.charCodeAt(i) & 0xff;
    }
    return codes;
}
class BinaryReader {
    #dataView = new DataView(new ArrayBuffer(0));
    #byteOffset = 0;
    #littleEndian;
    constructor(buffer, byteOffset, byteLength, littleEndian = true) {
        this.#littleEndian = littleEndian;
        this.#initDataview(buffer, byteOffset, byteLength);
    }
    #initDataview(buffer, byteOffset, byteLength) {
        switch (true) {
            case buffer instanceof _a$4:
                this.#dataView = new DataView(buffer.buffer, byteOffset ? byteOffset + buffer.#dataView.byteOffset : buffer.#dataView.byteOffset, byteLength);
                break;
            case buffer instanceof Uint8Array || buffer?.constructor?.name === 'Uint8Array':
                this.#dataView = new DataView(buffer.buffer, byteOffset ? byteOffset + buffer.byteOffset : buffer.byteOffset, byteLength);
                break;
            case buffer instanceof ArrayBuffer || buffer?.constructor?.name === 'ArrayBuffer':
                this.#dataView = new DataView(buffer, byteOffset, byteLength);
                break;
            case typeof buffer === 'string':
                this.#dataView = new DataView(getCharCodes(buffer).buffer, byteOffset, byteLength);
                break;
            case typeof buffer === 'number':
                this.#dataView = new DataView(new Uint8Array(buffer).buffer, byteOffset, byteLength);
                break;
            case Array.isArray(buffer):
                this.#dataView = new DataView(Uint8Array.from(buffer).buffer, byteOffset, byteLength);
                break;
            default:
                console.error(`Unknow buffer type : ${buffer}`);
                break;
        }
    }
    get buffer() {
        return this.#dataView.buffer;
    }
    get byteLength() {
        return this.#dataView.byteLength;
    }
    getDataView() {
        return this.#dataView;
    }
    tell() {
        return this.#byteOffset;
    }
    seek(byteOffset = this.#byteOffset) {
        // /_checkBounds
        this.#byteOffset = byteOffset;
    }
    skip(byteLength = 0) {
        // /_checkBounds
        this.#byteOffset += byteLength;
    }
    getString(byteLength, byteOffset = this.#byteOffset) {
        let string = '';
        let readBuffer = new Uint8Array(this.buffer, byteOffset + this.#dataView.byteOffset, byteLength);
        // /_checkBounds
        this.#byteOffset = byteOffset + byteLength;
        for (var i = 0; i < byteLength; i++) {
            string += String.fromCharCode(readBuffer[i]);
        }
        return string;
    }
    getNullString(byteOffset = this.#byteOffset) {
        let string = '';
        let readBuffer = new Uint8Array(this.buffer, this.#dataView.byteOffset);
        this.#byteOffset = byteOffset;
        let c;
        do {
            c = String.fromCharCode(readBuffer[this.#byteOffset++]);
            if (c == '\0') ;
            else {
                string += c;
            }
        } while (c != '\0');
        return string;
    }
    setString(str, byteOffset = this.#byteOffset) {
        let length = str.length;
        this.#byteOffset = byteOffset + length;
        let writeBuffer = new Uint8Array(this.buffer, byteOffset + this.#dataView.byteOffset, length);
        //TODO: check len
        for (var i = 0, l = length; i < l; i++) {
            writeBuffer[i] = str.charCodeAt(i) & 0xff;
        }
    }
    getBytes(byteLength, byteOffset = this.#byteOffset) {
        let readBuffer = new Uint8Array(this.buffer, byteOffset + this.#dataView.byteOffset, byteLength);
        this.#byteOffset = byteOffset + byteLength;
        return readBuffer;
    }
    getInt8(byteOffset = this.#byteOffset) {
        this.#byteOffset = byteOffset + 1;
        return this.#dataView.getInt8(byteOffset);
    }
    getUint8(byteOffset = this.#byteOffset) {
        this.#byteOffset = byteOffset + 1;
        return this.#dataView.getUint8(byteOffset);
    }
    getInt16(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 2;
        return this.#dataView.getInt16(byteOffset, littleEndian);
    }
    getUint16(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 2;
        return this.#dataView.getUint16(byteOffset, littleEndian);
    }
    getFloat16(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        //TODO: fix endianness
        this.#byteOffset = byteOffset + 2;
        let readBuffer = new Uint8Array(this.buffer, byteOffset + this.#dataView.byteOffset, 2); //TODOv3: optimize
        let b = readBuffer; //this._getBytes(2, byteOffset, littleEndian);
        let sign = b[1] >> 7;
        let exponent = ((b[1] & 0x7C) >> 2);
        let mantissa = ((b[1] & 0x03) << 8) | b[0];
        if (exponent == 0) {
            return (sign ? -1 : 1) * TWO_POW_MINUS_14 * (mantissa / TWO_POW_10);
        }
        else if (exponent == 0x1F) {
            return mantissa ? NaN : ((sign ? -1 : 1) * Infinity);
        }
        return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + (mantissa / TWO_POW_10));
    }
    getInt32(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.getInt32(byteOffset, littleEndian);
    }
    getUint32(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.getUint32(byteOffset, littleEndian);
    }
    getFloat32(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.getFloat32(byteOffset, littleEndian);
    }
    getBigInt64(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.getBigInt64(byteOffset, littleEndian);
    }
    getBigUint64(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.getBigUint64(byteOffset, littleEndian);
    }
    getFloat64(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.getFloat64(byteOffset, littleEndian);
    }
    getVector2(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian, vec = new Float32Array(2)) {
        vec[0] = this.getFloat32(byteOffset, littleEndian);
        vec[1] = this.getFloat32(undefined, littleEndian);
        return vec;
    }
    getVector3(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian, vec = new Float32Array(3)) {
        vec[0] = this.getFloat32(byteOffset, littleEndian);
        vec[1] = this.getFloat32(undefined, littleEndian);
        vec[2] = this.getFloat32(undefined, littleEndian);
        return vec;
    }
    getVector4(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian, vec = new Float32Array(4)) {
        vec[0] = this.getFloat32(byteOffset, littleEndian);
        vec[1] = this.getFloat32(undefined, littleEndian);
        vec[2] = this.getFloat32(undefined, littleEndian);
        vec[3] = this.getFloat32(undefined, littleEndian);
        return vec;
    }
    getVector48(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian, vec = new Float32Array(3)) {
        vec[0] = this.getFloat16(byteOffset, littleEndian);
        vec[1] = this.getFloat16(undefined, littleEndian);
        vec[2] = this.getFloat16(undefined, littleEndian);
        return vec;
    }
    getQuaternion(byteOffset = this.#byteOffset, littleEndian = this.#littleEndian, vec = new Float32Array(4)) {
        vec[0] = this.getFloat32(byteOffset, littleEndian);
        vec[1] = this.getFloat32(undefined, littleEndian);
        vec[2] = this.getFloat32(undefined, littleEndian);
        vec[3] = this.getFloat32(undefined, littleEndian);
        return vec;
    }
    setBigInt64(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.setBigInt64(byteOffset, value, littleEndian);
    }
    setBigUint64(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.setBigUint64(byteOffset, value, littleEndian);
    }
    setFloat32(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.setFloat32(byteOffset, value, littleEndian);
    }
    setFloat64(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 8;
        return this.#dataView.setFloat64(byteOffset, value, littleEndian);
    }
    setInt8(value, byteOffset = this.#byteOffset) {
        this.#byteOffset = byteOffset + 1;
        return this.#dataView.setInt8(byteOffset, value);
    }
    setInt16(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 2;
        return this.#dataView.setInt16(byteOffset, value, littleEndian);
    }
    setInt32(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.setInt32(byteOffset, value, littleEndian);
    }
    setUint8(value, byteOffset = this.#byteOffset) {
        this.#byteOffset = byteOffset + 1;
        return this.#dataView.setUint8(byteOffset, value);
    }
    setUint16(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 2;
        return this.#dataView.setUint16(byteOffset, value, littleEndian);
    }
    setUint32(value, byteOffset = this.#byteOffset, littleEndian = this.#littleEndian) {
        this.#byteOffset = byteOffset + 4;
        return this.#dataView.setUint32(byteOffset, value, littleEndian);
    }
    setBytes(bytes, byteOffset = this.#byteOffset) {
        let length = bytes.length;
        this.#byteOffset = byteOffset + length;
        new Uint8Array(this.#dataView.buffer, byteOffset + this.#dataView.byteOffset, length).set(bytes);
    }
}
_a$4 = BinaryReader;

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK$1 = 0;
const STATIC_TREES$1 = 1;
const DYN_TREES$1    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size$1      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS$1 = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK$1   = 256;
/* end of block literal code */

const REP_3_6$1     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10$1   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138$1 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code$1    = new Array(DIST_CODE_LEN);
zero$1(_dist_code$1);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code$1[dist] : _dist_code$1[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size$1 - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size$1 - s.bi_valid);
    s.bi_valid += length - Buf_size$1;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1$1; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code$1[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code$1[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS$1);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK$1 * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller$1 = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller$1(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller$1(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK$1, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6$1 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$1 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138$1 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6$1, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10$1, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138$1, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK$1 << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES$1 << 1, 3);
  send_code(s, END_BLOCK$1, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES$1 << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES$1 << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32$1 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32$1;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH$1, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED: Z_FILTERED$1, Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY$1, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL$1 = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL$1 = 8;


const LENGTH_CODES$2  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS$2      = 256;
/* number of literal bytes 0..255 */
const L_CODES$2       = LITERALS$2 + 1 + LENGTH_CODES$2;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES$2       = 30;
/* number of distance codes */
const BL_CODES$2      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE$2     = 2 * L_CODES$2 + 1;
/* maximum heap size */
const MAX_BITS$2  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH$2 = 3;
const MAX_MATCH$2 = 258;
const MIN_LOOKAHEAD$1 = (MAX_MATCH$2 + MIN_MATCH$2 + 1);

const PRESET_DICT$2 = 0x20;

const INIT_STATE$1    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE$1    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE$1  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD$1)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD$1) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH$2;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH$2 - (strend - scan);
    scan = strend - MAX_MATCH$2;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$1)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH$2) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$2) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD$1 && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                        flush === Z_NO_FLUSH$2 ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$2) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD$1))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH$2) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$2);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$2) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH$2 - 1)) ? s.strstart : MIN_MATCH$2 - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$2) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$2 - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD$1)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED$1 || (s.match_length === MIN_MATCH$2 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH$2 - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH$2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$2;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$2);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$2 - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH$2) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$2 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$2 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$2;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH$2 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH$2) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH$2);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config$1(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config$1(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config$1(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config$1(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config$1(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config$1(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config$1(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config$1(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config$1(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config$1(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config$1(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE$2 * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES$2 + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES$2 + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS$2 + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES$2 + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES$2 + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE$1 &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE$1 &&
                                s.status !== FINISH_STATE$1)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE$1 : BUSY_STATE$1;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$1 || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE$1;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$2 - 1) / MIN_MATCH$2);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL$1, Z_DEFAULT_STRATEGY$1);
};


/* ========================================================================= */
const deflate$2 = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE$1 && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1$1 : Z_STREAM_ERROR$2);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE$1 && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE$1 && s.wrap === 0) {
    s.status = BUSY_STATE$1;
  }
  if (s.status === INIT_STATE$1) {
    /* zlib header */
    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT$2; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE$1;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE$1;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE$1;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE$1)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY$1 ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE$1;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH$1) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE$1 ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE$1) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$2) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$2 - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$2 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream$2() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream$2;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1$1, Z_SYNC_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$2, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$2,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$2,
  Z_DEFLATED: Z_DEFLATED$1$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$2,
    method: Z_DEFLATED$1$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$2
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$2) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES$2 = 0;
const LENS$2 = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1$1, Z_STREAM_END: Z_STREAM_END$1$1, Z_NEED_DICT: Z_NEED_DICT$1$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1$1, Z_DATA_ERROR: Z_DATA_ERROR$1$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR: Z_BUF_ERROR$2,
  Z_DEFLATED: Z_DEFLATED$3
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE$2 = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED$2 = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY$1 = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE$1 = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN$1 = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT$1 = 16201;    /* i: waiting for length extra bits */
const            DIST$1 = 16202;      /* i: waiting for distance code */
const            DISTEXT$1 = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT$1 = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE$1 = 16208;      /* finished check, done -- remain here until reset */
const    BAD$2 = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS$2,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1$1;
  }

  state = strm.state;
  if (state.mode === TYPE$2) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD$2;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$3) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$2;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD$2;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE$2;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED$3) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$2;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD$2;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD$2;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE$2;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE$2;
        /* falls through */
      case TYPE$2:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED$2;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE$1;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD$2;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED$2:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD$2;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY$1;
        /* falls through */
      case COPY$1:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE$2;
        break;
      case TABLE$1:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD$2;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES$2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD$2;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD$2;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD$2;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD$2) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD$2;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS$2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD$2;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD$2;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN$1;
        /* falls through */
      case LEN$1:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE$2) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT$1;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE$2;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$2;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT$1;
        /* falls through */
      case LENEXT$1:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST$1;
        /* falls through */
      case DIST$1:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD$2;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT$1;
        /* falls through */
      case DISTEXT$1:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD$2;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$2;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN$1; }
        break;
      case LIT$1:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN$1;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD$2;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD$2;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE$1;
        /* falls through */
      case DONE$1:
        ret = Z_STREAM_END$1$1;
        break inf_leave;
      case BAD$2:
        ret = Z_DATA_ERROR$1$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$2 &&
                      (state.mode < CHECK || flush !== Z_FINISH$1$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE$2 ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1$1) && ret === Z_OK$1$1) {
    ret = Z_BUF_ERROR$2;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$3, Z_FINISH: Z_FINISH$4,
  Z_OK: Z_OK$4, Z_STREAM_END: Z_STREAM_END$4, Z_NEED_DICT: Z_NEED_DICT$2, Z_STREAM_ERROR: Z_STREAM_ERROR$3, Z_DATA_ERROR: Z_DATA_ERROR$3, Z_MEM_ERROR: Z_MEM_ERROR$2
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK$4) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$4) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$4 : Z_NO_FLUSH$3;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT$2 && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK$4) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$3) {
        // Replace code with more verbose
        status = Z_NEED_DICT$2;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END$4 &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR$3:
      case Z_DATA_ERROR$3:
      case Z_NEED_DICT$2:
      case Z_MEM_ERROR$2:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$4) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK$4 && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END$4) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$4) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

// I'm not sure there is reserved ids, let's start big
let uniqueId = 1000000n;
function getUniqueId() {
    return ++uniqueId;
}

var FbxPropertyType;
(function (FbxPropertyType) {
    FbxPropertyType[FbxPropertyType["Double"] = 50] = "Double";
    FbxPropertyType[FbxPropertyType["Double3"] = 100] = "Double3";
    FbxPropertyType[FbxPropertyType["String"] = 200] = "String";
    FbxPropertyType[FbxPropertyType["Time"] = 300] = "Time";
    FbxPropertyType[FbxPropertyType["Enum"] = 1000] = "Enum";
    FbxPropertyType[FbxPropertyType["Compound"] = 2000] = "Compound";
    FbxPropertyType[FbxPropertyType["Color3"] = 3000] = "Color3";
    FbxPropertyType[FbxPropertyType["Bool"] = 5000] = "Bool";
})(FbxPropertyType || (FbxPropertyType = {}));
const FBX_PROPERTY_TYPE_DOUBLE = 50;
const FBX_PROPERTY_TYPE_DOUBLE_3 = 100;
const FBX_PROPERTY_TYPE_STRING = 200;
const FBX_PROPERTY_TYPE_TIME = 300;
const FBX_PROPERTY_TYPE_ENUM = 1000;
const FBX_PROPERTY_TYPE_COLOR_3 = 3000;
const FBX_PROPERTY_TYPE_BOOL = 5000;

if (!BigInt.prototype.toJSON) {
    BigInt.prototype.toJSON = function () { return this.toString(); };
}
const FBX_PROPERTY_HIERARCHICAL_SEPARATOR = '|';
class FBXProperty {
    #type;
    #name;
    #value;
    #srcObjects = new Set();
    #flags = 0;
    #parent = null;
    isFBXProperty = true;
    constructor(parent, type = FbxPropertyType.Compound, name = '', value = undefined, flags = 0) {
        if (type != FbxPropertyType.Compound && value === undefined) {
            throw 'name is null';
        }
        if (parent) {
            if (parent.isFBXProperty) {
                if (parent.#type === FbxPropertyType.Compound) {
                    this.#parent = parent;
                    parent.#value.set(name, this);
                }
                else {
                    throw 'Parent must be of type compound';
                }
            }
            else if (parent.isFBXObject) {
                this.#parent = parent;
            }
            else {
                throw 'Parent must be FBXProperty or FBXObject';
            }
        }
        this.#type = type;
        this.#name = name;
        if (type === FbxPropertyType.Compound) {
            this.#value = new Map();
        }
        else {
            this.#value = value;
        }
        this.#flags = flags;
        //TODO: check the value type
    }
    get type() {
        return this.#type;
    }
    set value(value) {
        this.#value = value;
    }
    get value() {
        return this.#value;
    }
    set(value) {
        this.#value = value;
    }
    get() {
        return this.#value;
    }
    set flags(flags) {
        this.#flags = flags;
    }
    get flags() {
        return this.#flags;
    }
    set name(name) {
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
    get hierarchicalName() {
        //TODO: remove recursion
        if (this.#parent?.isFBXProperty) {
            const parentHierarchicalName = this.#parent.hierarchicalName;
            if (parentHierarchicalName) {
                return parentHierarchicalName + FBX_PROPERTY_HIERARCHICAL_SEPARATOR + this.#name;
            }
            else {
                return this.#name;
            }
        }
        else {
            return this.#name;
        }
    }
    get parent() {
        return this.#parent;
    }
    isCompound() {
        return this.#type === FbxPropertyType.Compound;
    }
    isRootProperty() {
        return this.#parent?.isFBXObject;
    }
    connectSrcObject(object) {
        //TODO: add connection type ?
        this.#srcObjects.add(object);
    }
    get srcObjects() {
        return this.#srcObjects;
    }
    createProperty(type, name, value, flags) {
        if (this.#type === FbxPropertyType.Compound) {
            if (this.#value.has(name)) {
                return false;
            }
            const newProperty = new FBXProperty(this, type, name, value, flags);
            this.#value.set(name, newProperty);
            return newProperty;
        }
        else {
            throw 'Trying to create a child property on a non coumpound property';
        }
    }
    getAllProperties(includeSelf = true) {
        return this.#getAllProperties(new Set(), includeSelf);
    }
    #getAllProperties(childs = new Set(), includeSelf = true) {
        if (includeSelf) {
            childs.add(this);
        }
        if (this.#type === FbxPropertyType.Compound) {
            for (let [childName, child] of this.#value) {
                child.#getAllProperties(childs);
            }
        }
        return childs;
    }
    getParentObject() {
        const parent = this.#parent;
        if (parent.isFBXObject) {
            return parent;
        }
        if (parent.isFBXProperty) {
            // TODO: remove recursion
            return parent.getParentObject();
        }
        return null;
    }
    findProperty(propertyName) {
        if (this.#name === propertyName) {
            return this;
        }
        if (this.isCompound()) {
            for (const [key, subProperty] of this.#value) {
                const found = subProperty.findProperty(propertyName);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }
    toJSON() {
        return {
            type: this.#type,
            value: this.#value,
        };
    }
}

class FBXObject {
    #id = getUniqueId();
    #name = '';
    #srcObjects = new Set();
    #rootProperty;
    #manager;
    isFBXObject = true;
    constructor(manager, name = '', ...args) {
        if (!manager.isFBXManager) {
            console.trace('Missing manager in FBXObject');
            throw 'Missing manager in FBXObject';
        }
        this.#manager = manager;
        this.name = name;
        this.#rootProperty = new FBXProperty(this);
    }
    set id(id) {
        this.#id = id;
    }
    get id() {
        return this.#id;
    }
    set name(name) {
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
    get rootProperty() {
        return this.#rootProperty;
    }
    get manager() {
        return this.#manager;
    }
    connectSrcObject(object) {
        //TODO: add connection type ?
        this.#srcObjects.add(object);
    }
    get srcObjects() {
        return this.#srcObjects;
    }
    createProperty(type, name, value, flags) {
        return new FBXProperty(this.#rootProperty, type, name, value, flags);
    }
    getAllProperties() {
        return this.#rootProperty.getAllProperties(false);
    }
    findProperty(propertyName) {
        return this.#rootProperty.findProperty(propertyName);
    }
}

class FBXCollection extends FBXObject {
    #members = new Set();
    isFBXCollection = true;
    add(member) {
        this.#members.add(member);
    }
    remove(member) {
        this.#members.delete(member);
    }
    get count() {
        return this.#members.size;
    }
    get members() {
        return this.#members;
    }
}

class FBXManager {
    #objects = new Set();
    #documents = new Set();
    isFBXManager = true;
    static #registry = new Map();
    destroy() {
        this.#objects.clear();
        this.#documents.clear();
    }
    static registerClass(className, classConstructor) {
        FBXManager.#registry.set(className, classConstructor);
    }
    createObject(className, objectName, ...args) {
        const classConstructor = FBXManager.#registry.get(className);
        if (!classConstructor) {
            throw 'Unknown constructor in FBXManager.createObject(): ' + className;
        }
        const createdObject = new classConstructor(this, objectName, args);
        if (createdObject) {
            if (createdObject.isFBXDocument) {
                this.#documents.add(createdObject);
            }
            else {
                this.#objects.add(createdObject);
            }
        }
        return createdObject;
    }
}

class FBXAnimLayer extends FBXCollection {
    //TODO: add Properties
    /*P: "Weight", "Number", "", "A",100
    P: "Mute", "bool", "", "",0
    P: "Solo", "bool", "", "",0
    P: "Lock", "bool", "", "",0
    P: "Color", "ColorRGB", "Color", "",0.8,0.8,0.8
    P: "BlendMode", "enum", "", "",0
    P: "RotationAccumulationMode", "enum", "", "",0
    P: "ScaleAccumulationMode", "enum", "", "",0
    P: "BlendModeBypass", "ULongLong", "", "",0*/
    isFBXAnimLayer = true;
}
FBXManager.registerClass('FBXAnimLayer', FBXAnimLayer);
const FBX_PROPERTY_FLAG_STATIC = 1 << 0;

class FBXAnimStack extends FBXCollection {
    #description;
    #localStart;
    #localStop;
    #referenceStart;
    #referenceStop;
    isFBXAnimStack = true;
    constructor(manager, name) {
        super(manager, name);
        this.#description = this.createProperty(FBX_PROPERTY_TYPE_STRING, 'Description', '', FBX_PROPERTY_FLAG_STATIC);
        this.#localStart = this.createProperty(FBX_PROPERTY_TYPE_TIME, 'LocalStart', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#localStop = this.createProperty(FBX_PROPERTY_TYPE_TIME, 'LocalStop', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#referenceStart = this.createProperty(FBX_PROPERTY_TYPE_TIME, 'ReferenceStart', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#referenceStop = this.createProperty(FBX_PROPERTY_TYPE_TIME, 'ReferenceStop', 0, FBX_PROPERTY_FLAG_STATIC);
    }
}
FBXManager.registerClass('FBXAnimStack', FBXAnimStack);

const FBX_NODE_ATTRIBUTE_TYPE_UNKNOWN = 0;
const FBX_NODE_ATTRIBUTE_TYPE_SKELETON = 3;
const FBX_NODE_ATTRIBUTE_TYPE_CAMERA = 7;

class FBXNodeAttribute extends FBXObject {
    isFBXNodeAttribute = true;
    getAttributeType() {
        return FBX_NODE_ATTRIBUTE_TYPE_UNKNOWN;
    }
}

class FBXCamera extends FBXNodeAttribute {
    #position;
    #upVector;
    #interestPosition;
    #roll;
    //#opticalCenterX;
    //#opticalCenterY;
    #nearPlane;
    #farPlane;
    #projectionType;
    #orthoZoom;
    isFBXCamera = true;
    constructor(manager, name) {
        super(manager, name);
        this.#position = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'Position', [0, 0, 0], FBX_PROPERTY_FLAG_STATIC);
        this.#upVector = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'UpVector', [0, 0, 0], FBX_PROPERTY_FLAG_STATIC);
        this.#interestPosition = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'InterestPosition', [0, 0, 0], FBX_PROPERTY_FLAG_STATIC);
        this.#roll = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'Roll', 0, FBX_PROPERTY_FLAG_STATIC);
        //this.#opticalCenterX = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'OpticalCenterX', 0, FBX_PROPERTY_FLAG_STATIC);
        //this.#opticalCenterY = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'OpticalCenterY', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#nearPlane = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'NearPlane', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#farPlane = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'FarPlane', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#projectionType = this.createProperty(FBX_PROPERTY_TYPE_ENUM, 'CameraProjectionType', 0, FBX_PROPERTY_FLAG_STATIC);
        this.#orthoZoom = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'OrthoZoom', 1, FBX_PROPERTY_FLAG_STATIC);
    }
    set position(position) {
        this.#position = position;
    }
    get position() {
        return this.#position;
    }
    set upVector(upVector) {
        this.#upVector = upVector;
    }
    get upVector() {
        return this.#upVector;
    }
    set interestPosition(interestPosition) {
        this.#interestPosition = interestPosition;
    }
    get interestPosition() {
        return this.#interestPosition;
    }
    set roll(roll) {
        this.#roll = roll;
    }
    get roll() {
        return this.#roll;
    }
    set nearPlane(nearPlane) {
        this.#nearPlane = nearPlane;
    }
    get nearPlane() {
        return this.#nearPlane;
    }
    set farPlane(farPlane) {
        this.#farPlane = farPlane;
    }
    get farPlane() {
        return this.#farPlane;
    }
    set projectionType(projectionType) {
        this.#projectionType = projectionType;
    }
    get projectionType() {
        return this.#projectionType;
    }
    set orthoZoom(orthoZoom) {
        this.#orthoZoom = orthoZoom;
    }
    get orthoZoom() {
        return this.#orthoZoom;
    }
    getAttributeType() {
        return FBX_NODE_ATTRIBUTE_TYPE_CAMERA;
    }
}
FBXManager.registerClass('FBXCamera', FBXCamera);

const FBX_SUB_DEFORMER_TYPE_UNKNOWN = 0;
const FBX_SUB_DEFORMER_TYPE_CLUSTER = 1;

class FBXSubDeformer extends FBXObject {
    isFBXSubDeformer = true;
    get subDeformerType() {
        return FBX_SUB_DEFORMER_TYPE_UNKNOWN;
    }
}

const FBX_LINK_MODE_NORMALIZE = 0;

class FBXCluster extends FBXSubDeformer {
    #linkMode = FBX_LINK_MODE_NORMALIZE;
    #link;
    #indexes = [];
    #weights = [];
    #transformMatrix = create$5();
    #transformLinkMatrix = create$5();
    //#transformParentMatrix;
    isFBXCluster = true;
    set linkMode(linkMode) {
        this.#linkMode = linkMode;
    }
    get linkMode() {
        return this.#linkMode;
    }
    set link(link) {
        this.#link = link;
    }
    get link() {
        return this.#link;
    }
    addVertexIndex(index, weight) {
        this.#indexes.push(index);
        this.#weights.push(weight);
    }
    get indexes() {
        return this.#indexes;
    }
    get weights() {
        return this.#weights;
    }
    get subDeformerType() {
        return FBX_SUB_DEFORMER_TYPE_CLUSTER;
    }
    set transformMatrix(transformMatrix) {
        copy$5(this.#transformMatrix, transformMatrix);
    }
    get transformMatrix() {
        return clone$5(this.#transformMatrix);
    }
    set transformLinkMatrix(transformLinkMatrix) {
        copy$5(this.#transformLinkMatrix, transformLinkMatrix);
    }
    get transformLinkMatrix() {
        return clone$5(this.#transformLinkMatrix);
    }
}
FBXManager.registerClass('FBXCluster', FBXCluster);

class FBXColor {
    #red;
    #green;
    #blue;
    #alpha;
    isFBXColor = true;
    constructor(red = 0.0, green = 0.0, blue = 0.0, alpha = 1.0) {
        this.#red = red;
        this.#green = green;
        this.#blue = blue;
        this.#alpha = alpha;
    }
    set red(red) {
        this.#red = red;
    }
    get red() {
        return this.#red;
    }
    set green(green) {
        this.#green = green;
    }
    get green() {
        return this.#green;
    }
    set blue(blue) {
        this.#blue = blue;
    }
    get blue() {
        return this.#blue;
    }
    set alpha(alpha) {
        this.#alpha = alpha;
    }
    get alpha() {
        return this.#alpha;
    }
}

class FBXAxisSystem {
    isFBXAxisSystem = true;
    #upAxis;
    #frontAxis;
    constructor(upAxis, frontAxis) {
        this.#upAxis = upAxis;
        this.#frontAxis = frontAxis;
    }
    set upAxis(upAxis) {
        this.#upAxis = upAxis;
    }
    get upAxis() {
        return this.#upAxis;
    }
    set frontAxis(frontAxis) {
        this.#frontAxis = frontAxis;
    }
    get frontAxis() {
        return this.#frontAxis;
    }
    get coordAxis() {
        return this.#frontAxis;
    }
}

class FBXGlobalSettings extends FBXObject {
    #ambientColor = new FBXColor();
    #defaultCamera = '';
    #axisSystem = new FBXAxisSystem(2, 1);
    isFBXGlobalSettings = true;
    set ambientColor(ambientColor) {
        this.#ambientColor = ambientColor;
    }
    get ambientColor() {
        return this.#ambientColor;
    }
    set defaultCamera(defaultCamera) {
        this.#defaultCamera = defaultCamera;
    }
    get defaultCamera() {
        return this.#defaultCamera;
    }
}
FBXManager.registerClass('FBXGlobalSettings', FBXGlobalSettings);

class FBXLayerContainer extends FBXNodeAttribute {
    isFBXLayerContainer = true;
}

class FBXGeometryBase extends FBXLayerContainer {
    isFBXGeometryBase = true;
}

class FBXGeometry extends FBXGeometryBase {
    #deformers = new Set();
    isFBXGeometry = true;
    addDeformer(deformer) {
        this.#deformers.add(deformer);
    }
    removeDeformer(deformer) {
        this.#deformers.delete(deformer);
    }
    get deformers() {
        return this.#deformers;
    }
}

class FBXMesh extends FBXGeometry {
    #vertices = [];
    #normals = [];
    #polygons = [];
    #edges = [];
    #uv = [];
    #uvIndex = [];
    isFBXMesh = true;
    set vertices(vertices) {
        this.#vertices = vertices;
    }
    get vertices() {
        return this.#vertices;
    }
    set normals(normals) {
        this.#normals = normals;
    }
    get normals() {
        return this.#normals;
    }
    set polygons(polygons) {
        this.#polygons = polygons;
    }
    get polygons() {
        return this.#polygons;
    }
    set edges(edges) {
        this.#edges = edges;
    }
    get edges() {
        return this.#edges;
    }
    set uv(uv) {
        this.#uv = uv;
    }
    get uv() {
        return this.#uv;
    }
    set uvIndex(uvIndex) {
        this.#uvIndex = uvIndex;
    }
    get uvIndex() {
        return this.#uvIndex;
    }
}
FBXManager.registerClass('FBXMesh', FBXMesh);
//Scaling of parent is applied before rotation of child
const FBX_INHERIT_TYPE_PARENT_SCALING_FIRST = 1;

class FBXNode extends FBXObject {
    #parent = null;
    #childs = new Set();
    #materials = [];
    #nodeAttribute;
    #inheritType = FBX_INHERIT_TYPE_PARENT_SCALING_FIRST;
    #show;
    #localTranslation;
    #localRotation;
    #localScaling;
    isFBXNode = true;
    constructor(manager, name) {
        super(manager, name);
        this.#show = this.createProperty(FBX_PROPERTY_TYPE_BOOL, 'Show', 1.0, FBX_PROPERTY_FLAG_STATIC);
        this.#localTranslation = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'Lcl Translation', [0, 0, 0], FBX_PROPERTY_FLAG_STATIC);
        this.#localRotation = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'Lcl Rotation', [0, 0, 0], FBX_PROPERTY_FLAG_STATIC);
        this.#localScaling = this.createProperty(FBX_PROPERTY_TYPE_DOUBLE_3, 'Lcl Scaling', [1, 1, 1], FBX_PROPERTY_FLAG_STATIC);
    }
    set parent(parent) {
        if (this.#checkParent(parent)) {
            if (this.#parent) {
                this.#parent.#childs.delete(this);
            }
            this.#parent = parent;
            if (parent) {
                parent.#childs.add(this);
            }
        }
        else {
            console.log(this, parent);
            throw 'Invalid parent';
        }
    }
    addChild(child) {
        child.parent = this;
    }
    removeChild(child) {
        child.parent = null;
    }
    get childs() {
        return this.#childs;
    }
    get parent() {
        return this.#parent;
    }
    #checkParent(parent) {
        if (parent === null) {
            return true;
        }
        if (!parent.isFBXNode) {
            console.log('Parent is not FBXNode');
            return false;
        }
        let current = parent;
        for (;;) {
            if (current == this) {
                console.log('Parent hierarchy contains self');
                return false;
            }
            if (!(current = current.parent)) {
                break;
            }
        }
        return true;
    }
    set nodeAttribute(nodeAttribute) {
        this.#nodeAttribute = nodeAttribute;
    }
    get nodeAttribute() {
        return this.#nodeAttribute;
    }
    set inheritType(inheritType) {
        this.#inheritType = inheritType;
    }
    get inheritType() {
        return this.#inheritType;
    }
    set show(show) {
        this.#show.value = show;
    }
    get show() {
        return this.#show.value;
    }
    set localTranslation(localTranslation) {
        this.#localTranslation = localTranslation;
    }
    get localTranslation() {
        return this.#localTranslation;
    }
    set localRotation(localRotation) {
        this.#localRotation = localRotation;
    }
    get localRotation() {
        return this.#localRotation;
    }
    set localScaling(localScaling) {
        this.#localScaling = localScaling;
    }
    get localScaling() {
        return this.#localScaling;
    }
    addMaterial(surfaceMaterial) {
        this.#materials.push(surfaceMaterial);
    }
    get materials() {
        return this.#materials;
    }
    toJSON() {
        return {};
    }
}
FBXManager.registerClass('FBXNode', FBXNode);

class FBXPoseInfo {
    #matrix = create$5();
    #matrixIsLocal = false;
    #node;
    constructor(node, matrix, matrixIsLocal) {
        this.#node = node;
        copy$5(this.#matrix, matrix);
        this.#matrixIsLocal = matrixIsLocal;
    }
    set matrix(matrix) {
        this.#matrix = matrix;
    }
    get matrix() {
        return this.#matrix;
    }
    set matrixIsLocal(matrixIsLocal) {
        this.#matrixIsLocal = matrixIsLocal;
    }
    get matrixIsLocal() {
        return this.#matrixIsLocal;
    }
    set node(node) {
        this.#node = node;
    }
    get node() {
        return this.#node;
    }
}

class FBXPose extends FBXObject {
    #isBindPose = true;
    #poseInfos = [];
    isFBXPose = true;
    set isBindPose(isBindPose) {
        this.#isBindPose = isBindPose;
    }
    get isBindPose() {
        return this.#isBindPose;
    }
    get isRestPose() {
        return !this.#isBindPose;
    }
    add(node, matrix, matrixIsLocal) {
        this.#poseInfos.push(new FBXPoseInfo(node, matrix, matrixIsLocal));
    }
    get poseInfos() {
        return this.#poseInfos;
    }
}
FBXManager.registerClass('FBXPose', FBXPose);

class FBXDocument extends FBXCollection {
    #documentInfo;
    isFBXDocument = true;
    constructor(manager, name) {
        super(manager, name);
    }
    set documentInfo(documentInfo) {
        this.#documentInfo = documentInfo;
    }
    get documentInfo() {
        return this.#documentInfo;
    }
}

class FBXScene extends FBXDocument {
    #rootNode;
    #globalSettings;
    #sceneInfo;
    #objects = new Set();
    isFBXScene = true;
    constructor(manager, name) {
        super(manager, name);
        this.#rootNode = manager.createObject('FBXNode', 'Root node. This node is not saved');
        this.#globalSettings = manager.createObject('FBXGlobalSettings', 'TODO: name me FBXScene / #globalSettings');
        this.#rootNode.id = 0n;
    }
    set sceneInfo(sceneInfo) {
        this.#sceneInfo = sceneInfo;
    }
    get sceneInfo() {
        return this.#sceneInfo;
    }
    get rootNode() {
        return this.#rootNode;
    }
    get globalSettings() {
        return this.#globalSettings;
    }
    addObject(object) {
        this.#objects.add(object);
    }
    get objects() {
        return this.#objects;
    }
}
FBXManager.registerClass('FBXScene', FBXScene);

class FBXSkeleton extends FBXNodeAttribute {
    skeletonType;
    isFBXSkeleton = true;
    constructor(manager, name, skeletonType) {
        super(manager, name);
        this.skeletonType = skeletonType;
    }
    getAttributeType() {
        return FBX_NODE_ATTRIBUTE_TYPE_SKELETON;
    }
}
FBXManager.registerClass('FBXSkeleton', FBXSkeleton);

const FBX_DEFORMER_TYPE_UNKNOWN = 0;
const FBX_DEFORMER_TYPE_SKIN = 1;

class FBXDeformer extends FBXObject {
    isFBXDeformer = true;
    get deformerType() {
        return FBX_DEFORMER_TYPE_UNKNOWN;
    }
}
const FBX_SKINNING_TYPE_LINEAR = 1;

class FBXSkin extends FBXDeformer {
    #geometry;
    #skinningType = FBX_SKINNING_TYPE_LINEAR;
    #clusters = new Set();
    isFBXSkin = true;
    set geometry(geometry) {
        if (geometry && !geometry.isFBXGeometry) {
            throw 'geometry must be of type FBXGeometry';
        }
        if (this.#geometry) {
            this.#geometry.removeDeformer(this);
        }
        if (geometry) {
            geometry.addDeformer(this);
        }
        this.#geometry = geometry;
    }
    get geometry() {
        return this.#geometry;
    }
    set skinningType(skinningType) {
        this.#skinningType = skinningType;
    }
    get skinningType() {
        return this.#skinningType;
    }
    addCluster(fbxCluster) {
        this.#clusters.add(fbxCluster);
    }
    removeCluster(fbxCluster) {
        this.#clusters.delete(fbxCluster);
    }
    get clusters() {
        return this.#clusters;
    }
    get deformerType() {
        return FBX_DEFORMER_TYPE_SKIN;
    }
}
FBXManager.registerClass('FBXSkin', FBXSkin);

class FBXSurfaceMaterial extends FBXObject {
    #shadingModel;
    #multiLayer;
    isFBXSurfaceMaterial = true;
    constructor(manager, name) {
        super(manager, name);
        this.#shadingModel = this.createProperty(FBX_PROPERTY_TYPE_STRING, 'ShadingModel', 'Unknown', FBX_PROPERTY_FLAG_STATIC);
        this.#multiLayer = this.createProperty(FBX_PROPERTY_TYPE_BOOL, 'MultiLayer', false, FBX_PROPERTY_FLAG_STATIC);
    }
    set shadingModel(shadingModel) {
        this.#shadingModel.value = shadingModel;
    }
    get shadingModel() {
        return this.#shadingModel.value;
    }
    set multiLayer(multiLayer) {
        this.#multiLayer.value = multiLayer;
    }
    get multiLayer() {
        return this.#multiLayer.value;
    }
}
FBXManager.registerClass('FBXSurfaceMaterial', FBXSurfaceMaterial);

class FBXSurfaceLambert extends FBXSurfaceMaterial {
    #diffuse;
    isFBXSurfaceLambert = true;
    constructor(manager, name) {
        super(manager, name);
        this.shadingModel = 'Lambert';
        this.#diffuse = this.createProperty(FBX_PROPERTY_TYPE_COLOR_3, 'DiffuseColor', [0.2, 0.2, 0.2], FBX_PROPERTY_FLAG_STATIC);
    }
    set diffuse(diffuse) {
        console.assert(diffuse.isFBXProperty && diffuse.type == FBX_PROPERTY_TYPE_COLOR_3, "diffuse is not an FBXProperty");
        this.#diffuse = diffuse;
    }
    get diffuse() {
        return this.#diffuse;
    }
}
FBXManager.registerClass('FBXSurfaceLambert', FBXSurfaceLambert);

class FBXSurfacePhong extends FBXSurfaceLambert {
    isFBXSurfacePhong = true;
    constructor(manager, name) {
        super(manager, name);
        this.shadingModel = 'Phong';
    }
}
FBXManager.registerClass('FBXSurfacePhong', FBXSurfacePhong);

class FBXTexture extends FBXObject {
    #media;
    #type = 'TextureVideoClip';
    isFBXTexture = true;
    set type(type) {
        throw 'We might want to check the exporter if we change the type';
    }
    get type() {
        return this.#type;
    }
    set media(media) {
        this.#media = media;
    }
    get media() {
        return this.#media;
    }
}
FBXManager.registerClass('FBXTexture', FBXTexture);

class FBXVideo extends FBXObject {
    #content;
    #type = 'Clip';
    isFBXVideo = true;
    set content(content) {
        this.#content = content;
    }
    get content() {
        return this.#content;
    }
    set type(type) {
        throw 'We might want to check the exporter if we change the type';
    }
    get type() {
        return this.#type;
    }
}
FBXManager.registerClass('FBXVideo', FBXVideo);

var FbxType;
(function (FbxType) {
    FbxType[FbxType["Int8"] = 67] = "Int8";
    FbxType[FbxType["Double"] = 68] = "Double";
    FbxType[FbxType["Float"] = 70] = "Float";
    FbxType[FbxType["Int32"] = 73] = "Int32";
    FbxType[FbxType["Int64"] = 76] = "Int64";
    FbxType[FbxType["Raw"] = 82] = "Raw";
    FbxType[FbxType["String"] = 83] = "String";
    FbxType[FbxType["Int16"] = 89] = "Int16";
    FbxType[FbxType["Int8Array"] = 98] = "Int8Array";
    FbxType[FbxType["DoubleArray"] = 100] = "DoubleArray";
    FbxType[FbxType["FloatArray"] = 102] = "FloatArray";
    FbxType[FbxType["Int32Array"] = 105] = "Int32Array";
    FbxType[FbxType["Int64Array"] = 108] = "Int64Array";
})(FbxType || (FbxType = {}));
const FBX_DATA_TYPE_INT_8 = 67;
const FBX_DATA_TYPE_DOUBLE = 68;
const FBX_DATA_TYPE_FLOAT = 70;
const FBX_DATA_TYPE_INT_32 = 73;
const FBX_DATA_TYPE_INT_64 = 76;
const FBX_DATA_TYPE_RAW = 82;
const FBX_DATA_TYPE_STRING = 83;
const FBX_DATA_TYPE_INT_16 = 89;
const FBX_DATA_TYPE_ARRAY_INT_8 = 98;
const FBX_DATA_TYPE_ARRAY_DOUBLE = 100;
const FBX_DATA_TYPE_ARRAY_FLOAT = 102;
const FBX_DATA_TYPE_ARRAY_INT_32 = 105;
const FBX_DATA_TYPE_ARRAY_INT_64 = 108;
const FBX_DATA_LEN = new Map([
    [FBX_DATA_TYPE_INT_8, 1],
    [FBX_DATA_TYPE_DOUBLE, 8],
    [FBX_DATA_TYPE_FLOAT, 4],
    [FBX_DATA_TYPE_INT_32, 4],
    [FBX_DATA_TYPE_INT_64, 8],
    [FBX_DATA_TYPE_INT_16, 2],
    [FBX_DATA_TYPE_ARRAY_INT_8, 1],
    [FBX_DATA_TYPE_ARRAY_DOUBLE, 8],
    [FBX_DATA_TYPE_ARRAY_FLOAT, 4],
    [FBX_DATA_TYPE_ARRAY_INT_32, 4],
    [FBX_DATA_TYPE_ARRAY_INT_64, 8],
]);
const FBX_BINARY_MAGIC = 'Kaydara FBX Binary  \0';
const FBX_HEADER_VERSION = 1003;
const FBX_SCENEINFO_VERSION = 100;
const FBX_TEMPLATES_VERSION = 100;
const FBX_KTIME = 46186158000n;
const FBX_GEOMETRY_VERSION = 124;
const FBX_GEOMETRY_UV_VERSION = 101;
const FBX_GEOMETRY_MATERIAL_VERSION = 101;
const FBX_GEOMETRY_LAYER_VERSION = 100;
const FBX_MATERIAL_VERSION = 102;
const FBX_TEXTURE_VERSION = 202;
const FBX_DEFORMER_SKIN_VERSION = 101;
const FBX_DEFORMER_CLUSTER_VERSION = 100;
const FBX_POSE_BIND_VERSION = 100;
const FBX_MODELS_VERSION = 232;

if (!BigInt.prototype.toJSON) {
    BigInt.prototype.toJSON = function () { return this.toString(); };
}
class FBXRecordProperty {
    #type;
    #value;
    #srcObjects = new Set();
    #flags = 0;
    #parent = null;
    isFBXProperty = true;
    constructor(parent, type, value) {
        if (parent) {
            if (parent.isFBXProperty) {
                this.#parent = parent;
            }
            else if (parent.isFBXObject) {
                this.#parent = parent.rootProperty;
            }
            else {
                throw 'Parent must be FBXRecordProperty or FBXObject';
            }
        }
        this.#type = type;
        this.#value = value;
        //TODO: check the value type
    }
    get type() {
        return this.#type;
    }
    set value(value) {
        this.#value = value;
    }
    get value() {
        return this.#value;
    }
    set(value) {
        this.#value = value;
    }
    get() {
        return this.#value;
    }
    set flags(flags) {
        this.#flags = flags;
    }
    get flags() {
        return this.#flags;
    }
    get parent() {
        return this.#parent;
    }
    connectSrcObject(fbxObject) {
        //TODO: add connection type ?
        this.#srcObjects.add(fbxObject);
    }
    get srcObjects() {
        return this.#srcObjects;
    }
    createProperty(type, value) {
        return new FBXRecordProperty(this, type, value);
    }
    toJSON() {
        return {
            type: this.#type,
            value: this.#value,
        };
    }
}

function createInt16Property(value) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_INT_16, value);
}
function createInt32Property(value) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_INT_32, value);
}
function createInt64Property(value) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_INT_64, value);
}
function createDoubleProperty(value) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_DOUBLE, value);
}
function createRawProperty(value /*TODO: better type*/) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_RAW, value);
}
function createStringProperty(value) {
    return new FBXRecordProperty(null, FBX_DATA_TYPE_STRING, value);
}

class FBXRecord {
    #name = '';
    #childs = new Set();
    #properties = new Set();
    isFBXRecord = true;
    constructor(name) {
        this.name = name;
    }
    addChild(child) {
        if (!child.isFBXRecord) {
            throw 'FBXFile: trying to insert a non FBXRecord child';
        }
        this.#childs.add(child);
        return child;
    }
    addChilds(childs) {
        for (let child of childs) {
            this.addChild(child);
        }
    }
    addProperty(property) {
        this.#properties.add(property);
    }
    addProperties(properties) {
        for (let property of properties) {
            this.addProperty(property);
        }
    }
    set name(name) {
        if (name.length > 255) {
            throw `Record name above 255 characters ${name}`;
        }
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
    get childs() {
        return this.#childs;
    }
    get properties() {
        return this.#properties;
    }
    getRecordsByName(recordName) {
        let output = [];
        for (let child of this.#childs) {
            if (child.name == recordName) {
                output.push(child);
            }
        }
        return output;
    }
    getRecordByName(recordName) {
        for (let child of this.#childs) {
            if (child.name == recordName) {
                return child;
            }
        }
    }
    getProperty(type) {
        for (let property of this.#properties) {
            if (property.type == type) {
                return property.value;
            }
        }
    }
    getPropertyInt32() {
        return this.getProperty(FBX_DATA_TYPE_INT_32);
    }
    getPropertyString() {
        return this.getProperty(FBX_DATA_TYPE_STRING);
    }
    toJSON() {
        return {
            name: this.#name,
            childs: this.#childs.size ? [...this.#childs] : undefined,
            properties: this.#properties.size ? [...this.#properties] : undefined,
        };
    }
}

const _TIME_ID = '1970-01-01 10:00:00:000';
const _FILE_ID = new Uint8Array([0x28, 0xb3, 0x2a, 0xeb, 0xb6, 0x24, 0xcc, 0xc2, 0xbf, 0xc8, 0xb0, 0x2a, 0xa9, 0x2b, 0xfc, 0xf1]);
const _FOOT_ID = new Uint8Array([0xfa, 0xbc, 0xab, 0x09, 0xd0, 0xc8, 0xd4, 0x66, 0xb1, 0x76, 0xfb, 0x83, 0x1c, 0xf7, 0x26, 0x7e]);
const FBX_FOOTER2 = '\xf8\x5a\x8c\x6a\xde\xf5\xd9\x7e\xec\xe9\x0c\xe3\x75\x8f\x29\x0b';
class FBXExporter {
    exportBinary(fbxFile) {
        checkFile(fbxFile);
        let version = fbxFile.version;
        let size = getFileSize(fbxFile, version);
        //console.log('File Size: ', size);
        let writer = new BinaryReader(new Uint8Array(size));
        return exportBinaryFile(writer, fbxFile);
    }
}
function checkFile(fbxFile) {
    for (let child of fbxFile.childs) {
        if (child.name == 'CreationTime' || child.name == 'FileId') {
            fbxFile.childs.delete(child);
        }
    }
    formatCreationTimeRecord(fbxFile);
    formatFileIdRecord(fbxFile);
}
function exportBinaryFile(writer, fbxFile) {
    let version = fbxFile.version;
    writer.seek(0);
    writer.setString(FBX_BINARY_MAGIC);
    writer.setUint8(0x1A);
    writer.setUint8(0x00);
    writer.setUint32(version);
    for (let child of fbxFile.childs) {
        exportBinaryRecord(writer, child, version);
    }
    writer.skip((version >= 7500) ? 25 : 13); //Null record
    writer.setBytes(generateFooterCode(fbxFile.dateCreated));
    writer.skip(align16(writer.tell()));
    if (version != 7400) {
        writer.skip(4);
    }
    writer.setUint32(version);
    writer.skip(120);
    writer.setString(FBX_FOOTER2);
    return writer.buffer;
}
function formatFileIdRecord(fbxFile) {
    let fbxRecord = fbxFile.addChild(new FBXRecord('FileId'));
    fbxRecord.properties.clear();
    let fbxProperty = createRawProperty(_FILE_ID);
    fbxRecord.addProperty(fbxProperty);
}
function formatCreationTimeRecord(fbxFile) {
    let fbxRecord = fbxFile.addChild(new FBXRecord('CreationTime'));
    fbxRecord.properties.clear();
    let dateCreated = fbxFile.dateCreated;
    `${dateCreated.getFullYear()}-${padNumber(dateCreated.getMonth() + 1, 2)}-${padNumber(dateCreated.getDate(), 2)} ${padNumber(dateCreated.getHours(), 2)}:${padNumber(dateCreated.getMinutes(), 2)}:${padNumber(dateCreated.getSeconds(), 2)}:${padNumber(dateCreated.getMilliseconds(), 3)}`;
    //console.log(creationTime);
    //let fbxProperty = createStringProperty(creationTime);
    let fbxProperty = createStringProperty(_TIME_ID);
    fbxRecord.addProperty(fbxProperty);
}
function align16(offset) {
    let pad = ((offset + 15) & ~15) - offset;
    if (pad == 0) {
        pad = 16;
    }
    return pad;
}
function exportBinaryRecord(writer, fbxRecord, version) {
    let startOffset = writer.tell();
    let recordLen = getRecordSize(fbxRecord, version);
    //console.log(startOffset);
    if (version >= 7500) {
        writer.setBigUint64(BigInt(startOffset + recordLen));
        writer.setBigUint64(BigInt(fbxRecord.properties.size));
        writer.setBigUint64(BigInt(getRecordPropertiesSize(fbxRecord)));
    }
    else {
        writer.setUint32(startOffset + recordLen);
        writer.setUint32(fbxRecord.properties.size);
        writer.setUint32(getRecordPropertiesSize(fbxRecord));
    }
    writer.setUint8(fbxRecord.name.length);
    writer.setString(fbxRecord.name);
    exportProperties(writer, fbxRecord);
    for (let child of fbxRecord.childs) {
        exportBinaryRecord(writer, child, version);
    }
    writer.skip((version >= 7500) ? 25 : 13); //Null record
}
function exportProperties(writer, fbxRecord) {
    for (let property of fbxRecord.properties) {
        exportRecordProperty(writer, property);
    }
}
function exportRecordProperty(writer, fbxProperty) {
    //console.log(fbxProperty);
    writer.setUint8(fbxProperty.type);
    switch (fbxProperty.type) {
        case FBX_DATA_TYPE_INT_16:
            writer.setInt16(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_INT_8:
            writer.setInt8(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_INT_32:
            writer.setInt32(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_FLOAT:
            writer.setFloat32(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_DOUBLE:
            writer.setFloat64(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_INT_64:
            writer.setBigInt64(BigInt(fbxProperty.value));
            break;
        case FBX_DATA_TYPE_RAW:
            writer.setUint32(fbxProperty.value.length);
            writer.setBytes(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_STRING:
            writer.setUint32(fbxProperty.value.length);
            writer.setString(fbxProperty.value);
            break;
        case FBX_DATA_TYPE_ARRAY_INT_8:
        case FBX_DATA_TYPE_ARRAY_DOUBLE:
        case FBX_DATA_TYPE_ARRAY_FLOAT:
        case FBX_DATA_TYPE_ARRAY_INT_32:
        case FBX_DATA_TYPE_ARRAY_INT_64:
            exportRecordPropertyArray(writer, fbxProperty);
            break;
        default:
            throw 'Unknown property type ' + fbxProperty.type;
    }
}
function exportRecordPropertyArray(writer, fbxProperty) {
    writer.setUint32(fbxProperty.value.length);
    writer.setUint32(0); //Encoding
    writer.setUint32(FBX_DATA_LEN.get(fbxProperty.type) * fbxProperty.value.length);
    let functionName;
    switch (fbxProperty.type) {
        case FBX_DATA_TYPE_ARRAY_INT_8:
            functionName = 'setInt8';
            break;
        case FBX_DATA_TYPE_ARRAY_DOUBLE:
            functionName = 'setFloat64';
            break;
        case FBX_DATA_TYPE_ARRAY_FLOAT:
            functionName = 'setFloat32';
            break;
        case FBX_DATA_TYPE_ARRAY_INT_32:
            functionName = 'setInt32';
            break;
        case FBX_DATA_TYPE_ARRAY_INT_64:
            functionName = 'setBigInt64';
            for (let value of fbxProperty.value) {
                writer.setBigInt64(value);
            }
            return;
        default:
            throw 'Unknown array property type ' + fbxProperty.type;
    }
    for (let value of fbxProperty.value) {
        writer[functionName](value);
    }
}
function getFileSize(fbxFile, version) {
    let size = 27; //header
    for (let child of fbxFile.childs) {
        size += getRecordSize(child, version);
    }
    size += (version >= 7500) ? 25 : 13; //Null record
    size += 16; // footer1
    //size += 4 // padding
    size += align16(size); //alignment
    if (version != 7400) {
        size += 4; // padding
    }
    size += 140; //version + padding + footer2
    return size;
}
function getRecordSize(fbxRecord, version) {
    let size;
    if (version >= 7500) {
        size = 8 + 8 + 8 + 1;
    }
    else {
        size = 4 + 4 + 4 + 1;
    }
    size += fbxRecord.name.length;
    size += getRecordPropertiesSize(fbxRecord);
    for (let child of fbxRecord.childs) {
        size += getRecordSize(child, version);
    }
    size += (version >= 7500) ? 25 : 13; //Null record
    return size;
}
function getRecordPropertiesSize(fbxRecord) {
    let size = 0;
    for (let property of fbxRecord.properties) {
        switch (property.type) {
            case FBX_DATA_TYPE_INT_8:
            case FBX_DATA_TYPE_DOUBLE:
            case FBX_DATA_TYPE_FLOAT:
            case FBX_DATA_TYPE_INT_32:
            case FBX_DATA_TYPE_INT_64:
            case FBX_DATA_TYPE_INT_16:
                ++size; //Typecode
                size += FBX_DATA_LEN.get(property.type);
                break;
            case FBX_DATA_TYPE_RAW:
            case FBX_DATA_TYPE_STRING:
                ++size; //Typecode
                size += 4; //string len
                size += property.value.length;
                break;
            case FBX_DATA_TYPE_ARRAY_INT_8:
            case FBX_DATA_TYPE_ARRAY_DOUBLE:
            case FBX_DATA_TYPE_ARRAY_FLOAT:
            case FBX_DATA_TYPE_ARRAY_INT_32:
            case FBX_DATA_TYPE_ARRAY_INT_64:
                size += 13; //Typecode + array header
                size += FBX_DATA_LEN.get(property.type) * property.value.length;
                break;
            default:
                throw 'Unknown property type ' + property.type;
        }
    }
    return size;
}
//const extension = new Uint8Array([0xF8, 0x5A, 0x8C, 0x6A, 0xDE, 0xF5, 0xD9, 0x7E, 0xEC, 0xE9, 0x0C, 0xE3, 0x75, 0x8F, 0x29, 0x0B]);
function padNumber(number, targetLength) {
    return number.toString().padStart(targetLength, '0');
}
function generateFooterCode(date) {
    return _FOOT_ID;
}

class FBXFile {
    #version = 7500;
    #childs = new Set();
    #dateCreated = new Date();
    set version(version) {
        this.#version = version;
    }
    get version() {
        return this.#version;
    }
    addChild(child) {
        this.#childs.add(child);
        return child;
    }
    get childs() {
        return this.#childs;
    }
    getRecordsByName(recordName) {
        let output = [];
        for (let child of this.#childs) {
            if (child.name == recordName) {
                output.push(child);
            }
        }
        return output;
    }
    getRecordByName(recordName) {
        for (let child of this.#childs) {
            if (child.name == recordName) {
                return child;
            }
        }
    }
    set dateCreated(dateCreated) {
        this.#dateCreated = dateCreated;
    }
    get dateCreated() {
        return this.#dateCreated;
    }
    toJSON() {
        return {
            version: this.#version,
            childs: this.#childs.size ? [...this.#childs] : undefined,
        };
    }
}

function createFBXRecord(name, options /*TODO: improve type*/) {
    let fbxRecord = new FBXRecord(name);
    if (options) {
        for (let optionName in options) {
            let optionValue = options[optionName];
            switch (optionName) {
                case 'parent':
                    optionValue.addChild(fbxRecord);
                    break;
                case 'child':
                    fbxRecord.addChild(optionValue);
                    break;
                case 'childs':
                    fbxRecord.addChilds(optionValue);
                    break;
                case 'property':
                    fbxRecord.addProperty(optionValue);
                    break;
                case 'properties':
                    fbxRecord.addProperties(optionValue);
                    break;
                default:
                    console.log(`Unknown property: ${optionName}`);
            }
        }
    }
    return fbxRecord;
}
function fbxNameClass(name, className) {
    return name + '\x00\x01' + className;
}
function createFBXRecordSingle(name, type, value) {
    let fbxRecord = new FBXRecord(name);
    fbxRecord.addProperty(new FBXRecordProperty(null, type, value));
    return fbxRecord;
}
function createFBXRecordMultiple(name, type, values) {
    let fbxRecord = new FBXRecord(name);
    for (let value of values) {
        fbxRecord.addProperty(new FBXRecordProperty(null, type, value));
    }
    return fbxRecord;
}
function createFBXRecordSingleInt8(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_INT_8, value);
}
function createFBXRecordSingleInt32(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_INT_32, value);
}
function createFBXRecordSingleInt64(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_INT_64, value);
}
function createFBXRecordSingleDouble(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_DOUBLE, value);
}
function createFBXRecordSingleString(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_STRING, value);
}
function createFBXRecordMultipleStrings(name, values) {
    return createFBXRecordMultiple(name, FBX_DATA_TYPE_STRING, values);
}
function createFBXRecordSingleBytes(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_RAW, value);
}
function createFBXRecordFloatArray(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_ARRAY_FLOAT, value);
}
function createFBXRecordDoubleArray(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_ARRAY_DOUBLE, value);
}
function createFBXRecordInt32Array(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_ARRAY_INT_32, value);
}
function createFBXRecordInt64Array(name, value) {
    return createFBXRecordSingle(name, FBX_DATA_TYPE_ARRAY_INT_64, value);
}

function createPString(name, value) {
    return createFBXRecordMultipleStrings('P', [name, 'KString', '', '', value]);
}
function createPInteger(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('int'),
            createStringProperty('Integer'),
            createStringProperty(''),
            createInt32Property(value),
        ],
    });
}
function createPDouble(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('double'),
            createStringProperty('Number'),
            createStringProperty(''),
            createDoubleProperty(value),
        ],
    });
}
function createPColorRGB(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('ColorRGB'),
            createStringProperty('Color'),
            createStringProperty(''),
            createDoubleProperty(value[0]),
            createDoubleProperty(value[1]),
            createDoubleProperty(value[2]),
        ],
    });
}
function createPEnum(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('enum'),
            createStringProperty(''),
            createStringProperty(''),
            createInt32Property(value),
        ],
    });
}
function createPTime(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('KTime'),
            createStringProperty('Time'),
            createStringProperty(''),
            createInt64Property(value),
        ],
    });
}
function createPObject(name) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('object'),
            createStringProperty(''),
            createStringProperty(''),
        ],
    });
}
function createPBool(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('bool'),
            createStringProperty(''),
            createStringProperty(''),
            createInt32Property(value ? 1 : 0),
        ],
    });
}
function createPVector3D(name, value) {
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('Vector3D'),
            createStringProperty('Vector'),
            createStringProperty(''),
            createDoubleProperty(value[0]),
            createDoubleProperty(value[1]),
            createDoubleProperty(value[2]),
        ],
    });
}

function exportFBXGlobalSettings(fbxGlobalSettings) {
    let globalSettings = createFBXRecord('GlobalSettings', {
        childs: [
            createFBXRecordSingleInt32('Version', 1000),
            createFBXRecord('Properties70', {
                childs: [
                    createPInteger('UpAxis', 1), //TODO
                    createPInteger('UpAxisSign', 1), //TODO
                    createPInteger('FrontAxis', 2), //TODO
                    createPInteger('FrontAxisSign', 1), //TODO
                    createPInteger('CoordAxis', 0), //TODO
                    createPInteger('CoordAxisSign', 1), //TODO
                    createPInteger('OriginalUpAxis', 1), //TODO
                    createPInteger('OriginalUpAxisSign', 1), //TODO
                    createPDouble('UnitScaleFactor', 1), //TODO
                    createPDouble('OriginalUnitScaleFactor', 1), //TODO
                    createPColorRGB('AmbientColor', [0, 0, 0]), //TODO
                    createPString('DefaultCamera', 'Producer Perspective'), //TODO
                    createPEnum('TimeMode', 17), //TODO
                    createPTime('TimeSpanStart', 0n), //TODO
                    createPTime('TimeSpanStop', FBX_KTIME), //TODO
                    createPDouble('CustomFrameRate', -1), //TODO
                    createPEnum('TimeProtocol', 2), //TODO
                    createPEnum('SnapOnFrameMode', 0), //TODO
                    createFBXRecordMultipleStrings('P', ['TimeMarker', 'Compound', '', '']),
                    createPInteger('CurrentTimeMarker', -1), //TODO
                ]
            }),
        ]
    });
    return globalSettings;
}
/*
export function exportFBXGlobalSettings(fbxGlobalSettings) {
    let upVector = fbxGlobalSettings.axisSystem.upVector;
    let frontVector = fbxGlobalSettings.axisSystem.frontVector;
    let coordVector = fbxGlobalSettings.axisSystem.coordVector;

    let globalSettings = createFBXRecord('GlobalSettings', {
        childs: [
            createFBXRecordSingleInt32('Version', 1000),
            createFBXRecord('Properties70', {
                childs: [
                    createPInteger('UpAxis', upVector),//TODO
                    createPInteger('UpAxisSign', Math.sign(upVector)),//TODO
                    createPInteger('FrontAxis', frontVector),//TODO
                    createPInteger('FrontAxisSign', Math.sign(frontVector)),//TODO
                    createPInteger('CoordAxis', coordVector),//TODO
                    createPInteger('CoordAxisSign', Math.sign(coordVector)),//TODO
                    createPInteger('OriginalUpAxis', 1),//TODO
                    createPInteger('OriginalUpAxisSign', 1),//TODO
                    createPDouble('UnitScaleFactor', 1),//TODO
                    createPDouble('OriginalUnitScaleFactor', 1),//TODO
                    createPColorRGB('AmbientColor', [0, 0, 0]),//TODO
                    createPString('DefaultCamera', 'Producer Perspective'),//TODO
                    createPEnum('TimeMode', 17),//TODO
                    createPTime('TimeSpanStart', 0n),//TODO
                    createPTime('TimeSpanStop', FBX_KTIME),//TODO
                    createPDouble('CustomFrameRate', -1),//TODO
                    createPEnum('TimeProtocol', 2),//TODO
                    createPEnum('SnapOnFrameMode', 0),//TODO
                    createFBXRecordMultipleStrings('P', ['TimeMarker', 'Compound', '', '']),
                    createPInteger('CurrentTimeMarker', -1),//TODO
                ]
            }),
        ]
    });
    return globalSettings;
}

*/

function exportFBXScene(fbxScene) {
    let documents = createFBXRecord('Documents', {
        childs: [
            createFBXRecordSingleInt32('Count', 1),
            createFBXRecord('Document', {
                childs: [
                    createFBXRecord('Properties70', {
                        childs: [
                            createPObject('SourceObject'),
                            createPString('ActiveAnimStackName', ''), //TODO
                        ]
                    }),
                    createFBXRecordSingleInt64('RootNode', 0n),
                ],
                properties: [
                    createInt64Property(fbxScene.id),
                    createStringProperty(''),
                    createStringProperty('Scene'),
                ]
            }),
        ],
    });
    return documents;
}

function createPropertiesRecord(fbxObject) {
    const fbxRecord = new FBXRecord('Properties70');
    const objectProperties = fbxObject.getAllProperties();
    for (let property of objectProperties) {
        if (!property.isCompound()) {
            const propertyRecord = createPropertyRecord(property);
            if (propertyRecord) {
                fbxRecord.addChild(propertyRecord);
            }
        }
    }
    return fbxRecord;
}
function createPropertyRecord(fbxProperty) {
    let fn = TYPE_PROPERTY.get(fbxProperty.type);
    if (!fn) {
        throw 'Unsupported property type';
    }
    return fn(fbxProperty.hierarchicalName, fbxProperty.value);
}
const TYPE_PROPERTY = new Map();
TYPE_PROPERTY.set(FBX_PROPERTY_TYPE_DOUBLE, createPDouble);

function fbxAnimCurveNodeToRecord(fbxAnimCurveNode) {
    return createFBXRecord('AnimationCurveNode', {
        childs: [
            createPropertiesRecord(fbxAnimCurveNode),
        ],
        properties: [
            createInt64Property(fbxAnimCurveNode.id),
            createStringProperty(fbxAnimCurveNode.name + '\x00\x01AnimCurveNode'),
            createStringProperty(''),
        ],
    });
}

function fbxAnimCurveToRecord(fbxAnimCurve) {
    return createFBXRecord('AnimationCurve', {
        childs: [
            createFBXRecordSingleDouble('Default', 0.0), //TODO: const
            createFBXRecordSingleInt32('KeyVer', 4008), //TODO: const
            createFBXRecordInt64Array('KeyTime', [100000n, 200000n, 300000n, 400000n]),
            createFBXRecordFloatArray('KeyValueFloat', [1, 2, 3, 4]),
            createFBXRecordInt32Array('KeyAttrFlags', [8456]),
            createFBXRecordFloatArray('KeyAttrDataFloat', [0, 0, 218434821, 0]),
            createFBXRecordInt32Array('KeyAttrRefCount', [4]),
        ],
        properties: [
            createInt64Property(fbxAnimCurve.id),
            createStringProperty(fbxAnimCurve.name + '\x00\x01AnimCurve'),
            createStringProperty(''),
        ],
    });
}

function fbxAnimLayerToRecord(fbxAnimLayer) {
    return createFBXRecord('AnimationLayer', {
        properties: [
            createInt64Property(fbxAnimLayer.id),
            createStringProperty(fbxAnimLayer.name + '\x00\x01AnimLayer'),
            createStringProperty(''),
        ],
    });
}

function fbxAnimStackToRecord(fbxAnimStack) {
    return createFBXRecord('AnimationStack', {
        childs: [
            createFBXRecord('Properties70', {
                childs: [
                    createPTime('LocalStart', 0n),
                    createPTime('LocalStop', 12345678900n),
                    createPTime('ReferenceStart', 0n),
                    createPTime('ReferenceStop', 12345678900n),
                ]
            }),
        ],
        properties: [
            createInt64Property(fbxAnimStack.id),
            createStringProperty(fbxAnimStack.name + '\x00\x01AnimStack'),
            createStringProperty('AnimationStack'),
        ],
    });
}

function fbxPropertyToRecord(fbxProperty, name = '') {
    switch (fbxProperty.type) {
        case FBX_PROPERTY_TYPE_DOUBLE_3:
            return fbxPropertyDouble3ToRecord(fbxProperty, name);
        default:
            throw 'unknown property type';
    }
}
function fbxPropertyDouble3ToRecord(fbxProperty, name) {
    let value = fbxProperty.value;
    return createFBXRecord('P', {
        properties: [
            createStringProperty(name),
            createStringProperty('Vector'),
            createStringProperty(''),
            createStringProperty('A'), //TODO: property flag
            createDoubleProperty(value[0]),
            createDoubleProperty(value[1]),
            createDoubleProperty(value[2]),
        ],
    });
}

function fbxCameraToRecord(fbxCamera) {
    return createFBXRecord('NodeAttribute', {
        childs: [
            createFBXRecordSingleString('TypeFlags', 'Camera'),
            createFBXRecordSingleInt32('GeometryVersion', FBX_GEOMETRY_VERSION),
            createFBXRecord('Properties70', {
                childs: [
                    fbxPropertyToRecord(fbxCamera.position, 'Position'),
                    fbxPropertyToRecord(fbxCamera.upVector, 'UpVector'),
                ],
            }),
        ],
        properties: [
            createInt64Property(fbxCamera.id),
            createStringProperty(fbxCamera.name + '\x00\x01NodeAttribute'),
            createStringProperty('Camera'),
        ],
    });
}

function fbxClusterToRecord(fbxCluster) {
    return createFBXRecord('Deformer', {
        childs: [
            createFBXRecordSingleInt32('Version', FBX_DEFORMER_CLUSTER_VERSION),
            createFBXRecordMultipleStrings('UserData', ['', '']),
            createFBXRecordInt32Array('Indexes', fbxCluster.indexes),
            createFBXRecordDoubleArray('Weights', fbxCluster.weights),
            createFBXRecordDoubleArray('Transform', fbxCluster.transformMatrix),
            createFBXRecordDoubleArray('TransformLink', fbxCluster.transformLinkMatrix),
        ],
        properties: [
            createInt64Property(fbxCluster.id),
            createStringProperty(fbxCluster.name + '\x00\x01SubDeformer'),
            createStringProperty('Cluster'),
        ],
    });
}

function fbxMeshToRecord(fbxMesh) {
    return createFBXRecord('Geometry', {
        childs: [
            createFBXRecord('Properties70'),
            createFBXRecordSingleInt32('GeometryVersion', FBX_GEOMETRY_VERSION),
            createFBXRecordDoubleArray('Vertices', fbxMesh.vertices),
            createFBXRecordInt32Array('PolygonVertexIndex', fbxMesh.polygons),
            createFBXRecordInt32Array('Edges', fbxMesh.edges),
            /*createFBXRecord('LayerElementNormal', {
                childs: [
                    createFBXRecordSingleInt32('Version', FBX_GEOMETRY_NORMAL_VERSION),
                    createFBXRecordSingleString('Name', ''),
                    createFBXRecordSingleString('MappingInformationType', 'ByPolygonVertex'),
                    createFBXRecordSingleString('ReferenceInformationType', 'Direct'),
                    createFBXRecordDoubleArray('Normals', fbxMesh.normals),//[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0, -1, 0,  0, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]),//TODO
                ],
                properties: [
                    createInt32Property(0),//What is this ?
                ],
            }),*/
            createFBXRecord('LayerElementUV', {
                childs: [
                    createFBXRecordSingleInt32('Version', FBX_GEOMETRY_UV_VERSION),
                    createFBXRecordSingleString('Name', 'UVMap'), //TODO: change name
                    createFBXRecordSingleString('MappingInformationType', 'ByPolygonVertex'),
                    createFBXRecordSingleString('ReferenceInformationType', 'IndexToDirect'),
                    createFBXRecordDoubleArray('UV', fbxMesh.uv), //[0.625, 1, 0.625, 0.25, 0.375, 0.5, 0.875, 0.5, 0.625, 0.75, 0.375, 1, 0.375, 0.75, 0.625, 0, 0.375, 0, 0.375, 0.25, 0.125, 0.5, 0.875, 0.75, 0.125, 0.75, 0.625, 0.5]),//TODO
                    createFBXRecordInt32Array('UVIndex', fbxMesh.uvIndex), //[13, 3, 11, 4, 6, 4, 0, 5, 8, 7, 1, 9, 10, 2, 6, 12, 2, 13, 4, 6, 9, 1, 13, 2]),//TODO
                ],
                properties: [
                    createInt32Property(0), //What is this ?
                ],
            }),
            createFBXRecord('LayerElementMaterial', {
                childs: [
                    createFBXRecordSingleInt32('Version', FBX_GEOMETRY_MATERIAL_VERSION),
                    createFBXRecordSingleString('Name', ''),
                    createFBXRecordSingleString('MappingInformationType', 'AllSame'),
                    createFBXRecordSingleString('ReferenceInformationType', 'IndexToDirect'),
                    createFBXRecordInt32Array('Materials', [0]), //TODO
                ],
                properties: [
                    createInt32Property(0), //What is this ?
                ],
            }),
            createFBXRecord('Layer', {
                childs: [
                    createFBXRecordSingleInt32('Version', FBX_GEOMETRY_LAYER_VERSION),
                    createFBXRecord('LayerElement', {
                        childs: [
                            createFBXRecordSingleString('Type', 'LayerElementNormal'),
                            createFBXRecordSingleInt32('TypedIndex', 0),
                        ],
                    }),
                    createFBXRecord('LayerElement', {
                        childs: [
                            createFBXRecordSingleString('Type', 'LayerElementUV'),
                            createFBXRecordSingleInt32('TypedIndex', 0),
                        ],
                    }),
                    createFBXRecord('LayerElement', {
                        childs: [
                            createFBXRecordSingleString('Type', 'LayerElementMaterial'),
                            createFBXRecordSingleInt32('TypedIndex', 0),
                        ],
                    }),
                ],
                properties: [
                    createInt32Property(0), //What is this ?
                ],
            }),
        ],
        properties: [
            createInt64Property(fbxMesh.id),
            createStringProperty(fbxMesh.name + '\x00\x01Geometry'),
            createStringProperty('Mesh'),
        ],
    });
}

function fbxNodeToRecord(fbxNode, type = '') {
    return createFBXRecord('Model', {
        childs: [
            createFBXRecordSingleInt32('Version', FBX_MODELS_VERSION),
            createFBXRecord('Properties70', {
                childs: [
                    fbxPropertyToRecord(fbxNode.localTranslation, 'Lcl Translation'),
                    /*createFBXRecord('P', {
                        properties: [
                            createStringProperty('Lcl Translation'),
                            createStringProperty('Lcl Translation'),
                            createStringProperty(''),
                            createStringProperty('A+'),
                            createDoubleProperty(0),
                            createDoubleProperty(0),
                            createDoubleProperty(0),
                        ],
                    }),*/
                    fbxPropertyToRecord(fbxNode.localRotation, 'Lcl Rotation'),
                    /*createFBXRecord('P', {
                        properties: [
                            createStringProperty('Lcl Rotation'),
                            createStringProperty('Lcl Rotation'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0),
                            createDoubleProperty(0),
                            createDoubleProperty(0),
                        ],
                    }),*/
                    fbxPropertyToRecord(fbxNode.localScaling, 'Lcl Scaling'),
                    /*createFBXRecord('P', {
                        properties: [
                            createStringProperty('Lcl Scaling'),
                            createStringProperty('Lcl Scaling'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(1),
                            createDoubleProperty(1),
                            createDoubleProperty(1),
                        ],
                    }),*/
                    createPInteger('DefaultAttributeIndex', 0),
                    createPEnum('InheritType', fbxNode.inheritType),
                    createPBool('RotationActive', true),
                    createPVector3D('ScalingMax', [0, 0, 0]),
                    createPDouble('PreferedAngleX', 0),
                    createPDouble('PreferedAngleY', 0),
                    createPDouble('PreferedAngleZ', 0),
                    createPBool('lockInfluenceWeights', false),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('filmboxTypeID'),
                            createStringProperty('Short'),
                            createStringProperty(''),
                            createStringProperty('A+UH'),
                            createInt16Property(5),
                            createInt16Property(5),
                            createInt16Property(5),
                        ],
                    }),
                ],
            }),
            createFBXRecordSingleInt32('MultiLayer', 0), //What is this ?
            createFBXRecordSingleInt32('MultiTake', 0), //What is this ?
            createFBXRecordSingleInt8('Shading', 89), //89 = Y
            createFBXRecordSingleString('Culling', 'CullingOff'),
        ],
        properties: [
            createInt64Property(fbxNode.id), //TODO
            createStringProperty(fbxNode.name + '\x00\x01Model'),
            createStringProperty(type),
        ],
    });
}

function fbxPoseToRecord(fbxPose) {
    let poseType = fbxPose.isBindPose ? 'BindPose' : 'RestPose'; //TODO: not sure about this
    let poseNodes = [];
    for (let poseInfo of fbxPose.poseInfos) {
        poseNodes.push(createFBXRecord('PoseNode', {
            childs: [
                createFBXRecordSingleInt64('Node', poseInfo.node.id),
                createFBXRecordDoubleArray('Matrix', poseInfo.matrix),
            ],
        }));
    }
    return createFBXRecord('Pose', {
        childs: [
            createFBXRecordSingleString('Type', poseType),
            createFBXRecordSingleInt32('Version', FBX_POSE_BIND_VERSION),
            createFBXRecordSingleInt32('NbPoseNodes', poseNodes.length),
            ...poseNodes,
        ],
        properties: [
            createInt64Property(fbxPose.id),
            createStringProperty(fbxPose.name + '\x00\x01Pose'),
            createStringProperty(poseType),
        ],
    });
}

function fbxSkeletonToRecord(fbxSkeleton) {
    return createFBXRecord('NodeAttribute', {
        childs: [
            createFBXRecordSingleString('TypeFlags', 'Skeleton'),
        ],
        properties: [
            createInt64Property(fbxSkeleton.id),
            createStringProperty(fbxSkeleton.name + '\x00\x01NodeAttribute'),
            createStringProperty('LimbNode'),
        ],
    });
}

function fbxSkinToRecord(fbxSkin) {
    return createFBXRecord('Deformer', {
        childs: [
            createFBXRecordSingleInt32('Version', FBX_DEFORMER_SKIN_VERSION),
            createFBXRecordSingleDouble('Link_DeformAcuracy', 50.), //TODO
        ],
        properties: [
            createInt64Property(fbxSkin.id),
            createStringProperty(fbxSkin.name + '\x00\x01Deformer'),
            createStringProperty('Skin'),
        ],
    });
}

function fbxSurfaceMaterialToRecord(fbxSurfaceMaterial) {
    return createFBXRecord('Material', {
        childs: [
            createFBXRecordSingleInt32('Version', FBX_MATERIAL_VERSION),
            createFBXRecordSingleString('ShadingModel', 'Phong'),
            createFBXRecordSingleInt32('MultiLayer', 0), //What is this ?
            createFBXRecord('Properties70', {
                childs: [
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('DiffuseColor'),
                            createStringProperty('Color'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('AmbientColor'),
                            createStringProperty('Color'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0.05),
                            createDoubleProperty(0.05),
                            createDoubleProperty(0.05),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('AmbientFactor'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('BumpFactor'),
                            createStringProperty('double'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createDoubleProperty(0),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('SpecularColor'),
                            createStringProperty('Color'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('SpecularFactor'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0.25),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('Shininess'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(25),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('ShininessExponent'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(25),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('ReflectionColor'),
                            createStringProperty('Color'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                            createDoubleProperty(0.8),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('ReflectionFactor'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createStringProperty('A'),
                            createDoubleProperty(0),
                        ],
                    }),
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('TransparencyFactor'),
                            createStringProperty('double'),
                            createStringProperty('Number'),
                            createStringProperty(''),
                            createDoubleProperty(0.0),
                        ],
                    }),
                ],
            }),
        ],
        properties: [
            createInt64Property(fbxSurfaceMaterial.id),
            createStringProperty(fbxSurfaceMaterial.name + '\x00\x01Material'),
            createStringProperty(''),
        ],
    });
}

function fbxTextureToRecord(fbxTexture) {
    let mediaRecord;
    let filenameRecord;
    let relativeFilenameRecord;
    let textureMedia = fbxTexture.media;
    if (textureMedia) {
        mediaRecord = createFBXRecordSingleString('Media', textureMedia.name + '\x00\x01' + 'Video');
        filenameRecord = createFBXRecordSingleString('FileName', textureMedia.name);
        relativeFilenameRecord = createFBXRecordSingleString('RelativeFilename', textureMedia.name);
    }
    return createFBXRecord('Texture', {
        childs: [
            createFBXRecordSingleString('Type', fbxTexture.type),
            createFBXRecordSingleInt32('Version', FBX_TEXTURE_VERSION),
            createFBXRecordSingleString('TextureName', fbxTexture.name + '\x00\x01' + 'Texture'),
            mediaRecord,
            filenameRecord,
            relativeFilenameRecord,
            createFBXRecord('Properties70', {
                childs: [
                    createFBXRecord('P', {
                        properties: [
                            createStringProperty('UseMaterial'),
                            createStringProperty('bool'),
                            createStringProperty(''),
                            createStringProperty(''),
                            createInt32Property(1),
                        ],
                    }),
                    /*createFBXRecord('P', {
                        properties: [
                            createStringProperty('AlphaSource'),
                            createStringProperty('enum'),
                            createStringProperty(''),
                            createStringProperty(''),
                            createDoubleProperty(2),
                        ],
                    }),*/
                ],
            }),
        ],
        properties: [
            createInt64Property(fbxTexture.id),
            createStringProperty(fbxTexture.name + '\x00\x01' + 'Texture'),
            createStringProperty(''),
        ],
    });
}

const FBX_RECORD_NAME_CONNECTIONS = 'Connections';
const FBX_RECORD_NAME_CREATOR = 'Creator';
const FBX_RECORD_NAME_OBJECTS = 'Objects';
const FBX_RECORD_NAME_REFERENCES = 'References';
const FBX_RECORD_NAME_TAKES = 'Takes';

function createConnectionRecord(id, parentId, target) {
    let fbxRecord = new FBXRecord('C');
    fbxRecord.addProperty(createStringProperty(target ? 'OP' : 'OO'));
    fbxRecord.addProperty(createInt64Property(id));
    fbxRecord.addProperty(createInt64Property(parentId));
    if (target != undefined) {
        fbxRecord.addProperty(createStringProperty(target));
    }
    return fbxRecord;
}
function createHeaderExtensionRecord(fbxFile, creator, appVendor, appName, appVersion) {
    let date = new Date();
    let fbxHeaderExtension = createFBXRecord('FBXHeaderExtension', {
        childs: [
            createFBXRecordSingleInt32('FBXHeaderVersion', FBX_HEADER_VERSION),
            createFBXRecordSingleInt32('FBXVersion', fbxFile.version),
            createFBXRecordSingleInt32('EncryptionType', 0),
            createFBXRecord('CreationTimeStamp', {
                childs: [
                    createFBXRecordSingleInt32('Version', 1000),
                    createFBXRecordSingleInt32('Year', date.getFullYear()),
                    createFBXRecordSingleInt32('Month', date.getMonth() + 1),
                    createFBXRecordSingleInt32('Day', date.getDate()),
                    createFBXRecordSingleInt32('Hour', date.getHours()),
                    createFBXRecordSingleInt32('Minute', date.getMinutes()),
                    createFBXRecordSingleInt32('Second', date.getSeconds()),
                    createFBXRecordSingleInt32('Millisecond', date.getMilliseconds()),
                ]
            }),
            createFBXRecordSingleString('Creator', creator),
            createFBXRecord('SceneInfo', {
                properties: [
                    createStringProperty(fbxNameClass('GlobalInfo', 'SceneInfo')),
                    createStringProperty('UserData'),
                ],
                childs: [
                    createFBXRecordSingleString('Type', 'UserData'),
                    createFBXRecordSingleInt32('Version', FBX_SCENEINFO_VERSION),
                    createFBXRecord('MetaData', {
                        childs: [
                            createFBXRecordSingleInt32('Version', FBX_SCENEINFO_VERSION),
                            createFBXRecordSingleString('Title', ''), //TODO
                            createFBXRecordSingleString('Subject', ''), //TODO
                            createFBXRecordSingleString('Author', ''), //TODO
                            createFBXRecordSingleString('Keywords', ''), //TODO
                            createFBXRecordSingleString('Revision', ''), //TODO
                            createFBXRecordSingleString('Comment', ''), //TODO
                        ]
                    }),
                    createFBXRecord('Properties70', {
                        childs: [
                            createFBXRecordMultipleStrings('P', ['DocumentUrl', 'KString', 'Url', '', './test.fbx']), //TODO
                            createFBXRecordMultipleStrings('P', ['SrcDocumentUrl', 'KString', 'Url', '', './test.fbx']), //TODO
                            createFBXRecordMultipleStrings('P', ['Original', 'Compound', '', '']),
                            createFBXRecordMultipleStrings('P', ['Original|ApplicationVendor', 'KString', '', '', appVendor]),
                            createFBXRecordMultipleStrings('P', ['Original|ApplicationName', 'KString', '', '', appName]),
                            createFBXRecordMultipleStrings('P', ['Original|ApplicationVersion', 'KString', '', '', appVersion]),
                            createFBXRecordMultipleStrings('P', ['Original|DateTime_GMT', 'DateTime', '', '', '01/01/1970 00:00:00.000']),
                            createFBXRecordMultipleStrings('P', ['Original|FileName', 'KString', '', '', './test.fbx']), //TODO
                            createFBXRecordMultipleStrings('P', ['LastSaved', 'Compound', '', '']),
                            createFBXRecordMultipleStrings('P', ['LastSaved|ApplicationVendor', 'KString', '', '', appVersion]),
                            createFBXRecordMultipleStrings('P', ['LastSaved|ApplicationName', 'KString', '', '', appName]),
                            createFBXRecordMultipleStrings('P', ['LastSaved|ApplicationVersion', 'KString', '', '', appVersion]),
                            createFBXRecordMultipleStrings('P', ['LastSaved|DateTime_GMT', 'DateTime', '', '', '01/01/1970 00:00:00.000']),
                            createFBXRecordMultipleStrings('P', ['LastSaved|ApplicationActiveProject', 'KString', '', '', './test.fbx']), //TODO
                        ]
                    }),
                ]
            }),
        ]
    });
    return fbxHeaderExtension;
}
function createDefinitionsRecord() {
    let definitions = createFBXRecord('Definitions', {
        childs: [
            createFBXRecordSingleInt32('Version', FBX_TEMPLATES_VERSION),
            createFBXRecordSingleInt32('Count', 4), //TODO: Sum of every template below
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('GlobalSettings'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        properties: [
                            createStringProperty('FbxMesh'),
                        ],
                    }),
                ],
                properties: [
                    createStringProperty('Geometry'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        childs: [],
                        properties: [
                            createStringProperty('FbxNode'),
                        ],
                    }),
                ],
                properties: [
                    createStringProperty('Model'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        childs: [],
                        properties: [
                            createStringProperty('FbxSurfacePhong'),
                        ],
                    }),
                ],
                properties: [
                    createStringProperty('Material'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        childs: [],
                        properties: [
                            createStringProperty('FbxFileTexture'),
                        ],
                    }),
                ],
                properties: [
                    createStringProperty('Texture'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        childs: [],
                        properties: [
                            createStringProperty('FbxVideo'),
                        ],
                    }),
                ],
                properties: [
                    createStringProperty('Video'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('Deformer'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                    createFBXRecord('PropertyTemplate', {
                        childs: [
                            createFBXRecord('Properties70', {
                                childs: [
                                    createPColorRGB('Color', [0.8, 0.8, 0.8]),
                                    createPDouble('Size', 100),
                                    createPDouble('LimbLength', 1), //TODO: P: "LimbLength", "double", "Number", "H",1
                                ]
                            }),
                        ],
                        properties: [
                            createStringProperty('FbxSkeleton'),
                        ]
                    }),
                ],
                properties: [
                    createStringProperty('NodeAttribute'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('Pose'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('AnimationStack'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('AnimationLayer'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('AnimationCurveNode'),
                ],
            }),
            createFBXRecord('ObjectType', {
                childs: [
                    createFBXRecordSingleInt32('Count', 1),
                ],
                properties: [
                    createStringProperty('AnimationCurve'),
                ],
            }),
        ],
    });
    return definitions;
}
function createTakesRecord() {
    let takes = createFBXRecord(FBX_RECORD_NAME_TAKES, {
        childs: [
            createFBXRecordSingleString('Current', ''),
        ],
    });
    return takes;
}

function createVideoRecord(fbxVideo) {
    return createFBXRecord('Video', {
        childs: [
            createFBXRecordSingleString('Type', fbxVideo.type),
            createFBXRecordSingleString('RelativeFilename', `mat_${fbxVideo.id}.png`),
            /*createFBXRecordSingleString('Filename', `C:\\Users\\Guillaume\\Desktop\\fbx\\untitled.fbm\\mat_${fbxVideo.id}.png`),*/
            createFBXRecordSingleBytes('Content', fbxVideo.content),
            createFBXRecord('Properties70', {
                childs: [
                    createFBXRecordMultipleStrings('P', ['Path', 'KString', 'XRefUrl', '', `C:\\fbx\\untitled.fbm\\mat_${fbxVideo.id}.png`]),
                ],
            }),
        ],
        properties: [
            createInt64Property(fbxVideo.id),
            createStringProperty(fbxVideo.name + '\x00\x01' + 'Video'),
            createStringProperty('Clip'),
        ],
    });
}

const FBX_RECORD_TYPE_MESH = 'Mesh';
const FBX_RECORD_TYPE_LIMB_NODE = 'LimbNode';
const FBX_RECORD_TYPE_CAMERA = 'Camera';
function fbxSceneToFBXFile(scene, creator = 'harmony-fbx', appVendor = 'harmony-fbx', appName = 'harmony-fbx', appVersion = '1') {
    let fbxFile = new FBXFile();
    fbxFile.version = 7400;
    fbxFile.addChild(createHeaderExtensionRecord(fbxFile, creator, appVendor, appName, appVersion));
    fbxFile.addChild(createFBXRecordSingleString(FBX_RECORD_NAME_CREATOR, creator));
    fbxFile.addChild(exportFBXGlobalSettings(scene.globalSettings));
    fbxFile.addChild(exportFBXScene(scene));
    fbxFile.addChild(createFBXRecord(FBX_RECORD_NAME_REFERENCES)); //TODO ?
    fbxFile.addChild(createDefinitionsRecord());
    fbxFile.addChild(createFBXRecord(FBX_RECORD_NAME_OBJECTS));
    fbxFile.addChild(createFBXRecord(FBX_RECORD_NAME_CONNECTIONS));
    fbxFile.addChild(createTakesRecord());
    exportObjects(fbxFile, scene);
    exportTakes(fbxFile, scene);
    return fbxFile;
}
function exportObjects(fbxFile, scene) {
    /*
    let nodesReferences = new Set();
    let nodesConnections = new Set();
    let alreadyExported = new Set<FBXObject>();
    */
    const context = {
        nodesReferences: new Set(),
        nodesConnections: new Set(),
        alreadyExported: new Set(),
    };
    for (let child of scene.rootNode.childs) {
        exportObject(fbxFile, child, context /*nodesReferences, nodesConnections, alreadyExported*/);
    }
    for (let object of scene.objects) {
        exportObject(fbxFile, object, context /*nodesReferences, nodesConnections, alreadyExported*/);
    }
    for (;;) {
        //let nodesReferences2 = new Set();
        const context2 = {
            nodesReferences: new Set(),
            nodesConnections: context.nodesConnections,
            alreadyExported: context.alreadyExported,
        };
        for (let child of context.nodesReferences) {
            exportObject(fbxFile, child, context2 /*nodesReferences2, nodesConnections, alreadyExported*/);
        }
        if (context2.nodesReferences.size == 0) {
            break;
        }
        context.nodesReferences = context2.nodesReferences;
    }
    createConnections(fbxFile, context.nodesConnections);
}
function exportObject(fbxFile, object, context /*nodesReferences, nodesConnections, alreadyExported*/) {
    if (context.alreadyExported.has(object)) {
        return;
    }
    switch (true) {
        case object.isFBXNode:
            exportNode(fbxFile, object, context /*nodesReferences, nodesConnections, alreadyExported*/);
            break;
        case object.isFBXObject:
            exportObject2(fbxFile, object, context /*nodesReferences, nodesConnections*/);
            break;
        default:
            console.log(object);
            throw 'Trying to export an unknown object';
    }
    context.alreadyExported.add(object);
}
function exportObject2(fbxFile, object, context) {
    exportObjectPropertiesConnections(fbxFile, object, context);
    switch (true) {
        case object.isFBXSurfacePhong:
            exportSurfacePhongObject(fbxFile, object, context);
            break;
        case object.isFBXTexture:
            exportFBXTexture(fbxFile, object, context);
            break;
        case object.isFBXVideo:
            exportFBXVideo(fbxFile, object);
            break;
        case object.isFBXSkin:
            exportFBXSkin(fbxFile, object, context);
            break;
        case object.isFBXCluster:
            exportFBXCluster(fbxFile, object, context);
            break;
        case object.isFBXPose:
            exportFBXPose(fbxFile, object);
            break;
        case object.isFBXAnimStack:
            exportFBXAnimStack(fbxFile, object, context);
            break;
        case object.isFBXAnimLayer:
            exportFBXAnimLayer(fbxFile, object, context);
            break;
        case object.isFBXAnimCurveNode:
            exportFBXAnimCurveNode(fbxFile, object);
            break;
        case object.isFBXAnimCurve:
            exportFBXAnimCurve(fbxFile, object);
            break;
        default:
            console.log(object);
            throw 'Export of this object is missing';
    }
}
function exportObjectPropertiesConnections(fbxFile, fbxObject, context) {
    exportPropertiesConnections(fbxFile, fbxObject.rootProperty, context);
}
function exportPropertiesConnections(fbxFile, fbxProperty, context /*nodesReferences, nodesConnections*/) {
    fbxProperty.srcObjects.forEach(object => {
        const parentObject = fbxProperty.getParentObject();
        if (!parentObject) {
            return;
        }
        // Ensure the parent object is exported
        context.nodesReferences.add(parentObject);
        context.nodesReferences.add(object);
        context.nodesConnections.add(createConnection(object, parentObject, fbxProperty.hierarchicalName));
        console.log(fbxProperty);
    });
    if (fbxProperty.isCompound()) {
        for (const [key, value] of fbxProperty.value) {
            //console.log(key, value);
            exportPropertiesConnections(fbxFile, value, context /*nodesReferences, nodesConnections*/);
        }
    }
}
function exportNode(fbxFile, node, context /*nodesReferences, nodesConnections, alreadyExported*/) {
    if (context.alreadyExported.has(node)) {
        return;
    }
    exportObjectPropertiesConnections(fbxFile, node, context /*nodesReferences, nodesConnections*/);
    if (node.nodeAttribute) {
        let nodeAttribute = node.nodeAttribute;
        switch (true) {
            case nodeAttribute.isFBXMesh:
                exportMeshNode(fbxFile, node, context);
                break;
            case nodeAttribute.isFBXSkeleton:
                exportSkeletonNode(fbxFile, node, context);
                break;
            case nodeAttribute.isFBXCamera:
                exportCameraNode(fbxFile, node, context);
                break;
            default:
                console.log(nodeAttribute);
                throw 'Error in exportNode: export of this nodeAttribute is missing';
        }
    }
    else {
        throw 'nodeAttribute is null ' + node.id;
    }
    for (let child of node.childs) {
        exportNode(fbxFile, child, context /*nodesReferences, nodesConnections, alreadyExported*/);
    }
}
function exportMeshNode(fbxFile, node, context) {
    // Add the materials for writing
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    node.materials.forEach(material => {
        context.nodesReferences.add(material);
        context.nodesConnections.add(createConnection(material, node));
    });
    node.nodeAttribute.deformers.forEach(deformer => {
        context.nodesReferences.add(deformer);
        context.nodesConnections.add(createConnection(deformer, node.nodeAttribute));
    });
    objectsRecord.addChild(fbxNodeToRecord(node, FBX_RECORD_TYPE_MESH));
    objectsRecord.addChild(fbxMeshToRecord(node.nodeAttribute));
    context.nodesConnections.add(createConnection(node, node.parent));
    context.nodesConnections.add(createConnection(node.nodeAttribute, node));
}
function exportSkeletonNode(fbxFile, node, context) {
    const objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(fbxNodeToRecord(node, FBX_RECORD_TYPE_LIMB_NODE));
    objectsRecord.addChild(fbxSkeletonToRecord(node.nodeAttribute));
    context.nodesConnections.add(createConnection(node, node.parent));
    context.nodesConnections.add(createConnection(node.nodeAttribute, node));
}
function exportCameraNode(fbxFile, node, context) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(fbxNodeToRecord(node, FBX_RECORD_TYPE_CAMERA));
    objectsRecord.addChild(fbxCameraToRecord(node.nodeAttribute));
    context.nodesConnections.add(createConnection(node, node.parent));
    context.nodesConnections.add(createConnection(node.nodeAttribute, node));
}
function createConnection(src, dst, target) {
    return { source: src.id, destination: dst.id, target: target };
}
function exportSurfacePhongObject(fbxFile, fbxSurfacePhong, context /*, nodesReferences, nodesConnections*/) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    let propertyNames = ['diffuse'];
    for (let propertyName of propertyNames) {
        const fbxProperty = fbxSurfacePhong.findProperty(propertyName);
        if (!fbxProperty) {
            continue;
        }
        fbxProperty.srcObjects.forEach(object => {
            context.nodesReferences.add(object);
            context.nodesConnections.add(createConnection(object, fbxSurfacePhong, 'DiffuseColor'));
        });
    }
    objectsRecord.addChild(fbxSurfaceMaterialToRecord(fbxSurfacePhong));
}
function exportFBXTexture(fbxFile, fbxTexture, context /*, nodesReferences, nodesConnections*/) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    let textureMedia = fbxTexture.media;
    if (textureMedia) {
        context.nodesReferences.add(textureMedia);
        context.nodesConnections.add(createConnection(textureMedia, fbxTexture));
    }
    objectsRecord.addChild(fbxTextureToRecord(fbxTexture));
}
function exportFBXVideo(fbxFile, fbxVideo) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(createVideoRecord(fbxVideo));
}
function exportFBXSkin(fbxFile, fbxSkin, context /*, nodesReferences, nodesConnections*/) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    fbxSkin.clusters.forEach(cluster => {
        context.nodesReferences.add(cluster);
        context.nodesConnections.add(createConnection(cluster, fbxSkin));
    });
    objectsRecord.addChild(fbxSkinToRecord(fbxSkin));
}
function exportFBXCluster(fbxFile, fbxCluster, context /*, nodesReferences, nodesConnections*/) {
    if (fbxCluster.indexes.length == 0) {
        return;
    }
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    if (fbxCluster.link) {
        context.nodesReferences.add(fbxCluster.link);
        context.nodesConnections.add(createConnection(fbxCluster.link, fbxCluster));
    }
    objectsRecord.addChild(fbxClusterToRecord(fbxCluster));
}
function exportFBXAnimStack(fbxFile, fbxAnimStack, context) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    /*if (fbxAnimStack.link) {
        nodesReferences.add(fbxAnimStack.link);
        nodesConnections.add(createConnection(fbxAnimStack.link, fbxAnimStack));
    }*/
    fbxAnimStack.members.forEach(member => {
        context.nodesReferences.add(member);
        context.nodesConnections.add(createConnection(member, fbxAnimStack));
    });
    objectsRecord.addChild(fbxAnimStackToRecord(fbxAnimStack));
}
function exportFBXAnimLayer(fbxFile, fbxAnimLayer, context) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    fbxAnimLayer.members.forEach(member => {
        context.nodesReferences.add(member);
        context.nodesConnections.add(createConnection(member, fbxAnimLayer));
    });
    objectsRecord.addChild(fbxAnimLayerToRecord(fbxAnimLayer));
}
function exportFBXAnimCurveNode(fbxFile, fbxAnimCurveNode) {
    const objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(fbxAnimCurveNodeToRecord(fbxAnimCurveNode));
}
function exportFBXAnimCurve(fbxFile, fbxAnimCurve) {
    const objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(fbxAnimCurveToRecord(fbxAnimCurve));
}
function createConnections(fbxFile, connections) {
    let connectionsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_CONNECTIONS);
    for (let connection of connections) {
        connectionsRecord.addChild(createConnectionRecord(connection.source, connection.destination, connection.target));
    }
}
function exportTakes(fbxFile, fbxScene) {
    fbxFile.getRecordByName(FBX_RECORD_NAME_TAKES);
    let srcObjects = fbxScene.srcObjects;
    for (let srcObject of srcObjects) {
        if (srcObject.isFBXAnimStack) ;
    }
}
function exportFBXPose(fbxFile, fbxPose) {
    let objectsRecord = fbxFile.getRecordByName(FBX_RECORD_NAME_OBJECTS);
    objectsRecord.addChild(fbxPoseToRecord(fbxPose));
}
const FBX_TC_MILLISECOND = 141120n;
const FBX_TC_SECOND = FBX_TC_MILLISECOND * 1000n;
const FBX_TC_MINUTE = FBX_TC_SECOND * 60n;
const FBX_TC_HOUR = FBX_TC_MINUTE * 60n;

var MappingMode;
(function (MappingMode) {
    MappingMode[MappingMode["None"] = 0] = "None";
    MappingMode[MappingMode["ControlPoint"] = 1] = "ControlPoint";
    MappingMode[MappingMode["PolygonVertex"] = 2] = "PolygonVertex";
    MappingMode[MappingMode["Polygon"] = 3] = "Polygon";
    MappingMode[MappingMode["Edge"] = 4] = "Edge";
    MappingMode[MappingMode["AllSame"] = 5] = "AllSame";
})(MappingMode || (MappingMode = {}));

var ReferenceMode;
(function (ReferenceMode) {
    ReferenceMode[ReferenceMode["Direct"] = 0] = "Direct";
    ReferenceMode[ReferenceMode["Index"] = 1] = "Index";
    ReferenceMode[ReferenceMode["IndexToDirect"] = 2] = "IndexToDirect";
})(ReferenceMode || (ReferenceMode = {}));

var SkeletonType;
(function (SkeletonType) {
    SkeletonType[SkeletonType["Root"] = 0] = "Root";
    SkeletonType[SkeletonType["Limb"] = 1] = "Limb";
    SkeletonType[SkeletonType["LimbNode"] = 2] = "LimbNode";
    SkeletonType[SkeletonType["Effector"] = 3] = "Effector";
})(SkeletonType || (SkeletonType = {}));
const FBX_SKELETON_TYPE_LIMB = 1;

var TimeMode;
(function (TimeMode) {
    TimeMode[TimeMode["Default"] = 0] = "Default";
    TimeMode[TimeMode["Frames120"] = 1] = "Frames120";
    TimeMode[TimeMode["Frames100"] = 2] = "Frames100";
    TimeMode[TimeMode["Frames60"] = 3] = "Frames60";
    TimeMode[TimeMode["Frames50"] = 4] = "Frames50";
    TimeMode[TimeMode["Frames48"] = 5] = "Frames48";
    TimeMode[TimeMode["Frames30"] = 6] = "Frames30";
    TimeMode[TimeMode["Frames30Drop"] = 7] = "Frames30Drop";
    TimeMode[TimeMode["NtscDropFrame"] = 8] = "NtscDropFrame";
    TimeMode[TimeMode["NtscFullFrame"] = 9] = "NtscFullFrame";
    TimeMode[TimeMode["Pal"] = 10] = "Pal";
    TimeMode[TimeMode["Frames24"] = 11] = "Frames24";
    TimeMode[TimeMode["Frames1000"] = 12] = "Frames1000";
    TimeMode[TimeMode["FilmFullFrame"] = 13] = "FilmFullFrame";
    TimeMode[TimeMode["Custom"] = 14] = "Custom";
    TimeMode[TimeMode["Frames96"] = 15] = "Frames96";
    TimeMode[TimeMode["Frames72"] = 16] = "Frames72";
    TimeMode[TimeMode["Frames59_94"] = 17] = "Frames59_94";
    TimeMode[TimeMode["Frames119_88"] = 18] = "Frames119_88";
})(TimeMode || (TimeMode = {}));
// TODO: remove those
const FBX_TIME_MODE_DEFAULT = 0;
const FBX_TIME_MODE_FRAMES = [
    30,
    120,
    100,
    60,
    50,
    48,
    30,
    30,
    29.97,
    29.97,
    25,
    24,
    1000,
    23.976,
    -1,
    96,
    72,
    59.94,
    119.88,
];

var TimeProtocol;
(function (TimeProtocol) {
    TimeProtocol[TimeProtocol["Smpte"] = 0] = "Smpte";
    TimeProtocol[TimeProtocol["FrameCount"] = 1] = "FrameCount";
    TimeProtocol[TimeProtocol["Default"] = 2] = "Default";
})(TimeProtocol || (TimeProtocol = {}));

class FBXTime {
    static #globalTimeMode = TimeMode.Frames30;
    static #globalTimeProtocol = TimeProtocol.FrameCount;
    #time = 0n;
    constructor(time = 0n) {
        this.time = time;
    }
    set time(time) {
        this.#time = time;
    }
    get time() {
        return this.#time;
    }
    copy(other) {
        this.#time = other.#time;
    }
    static setGlobalTimeMode(timeMode, frameRate = 0) {
        FBXTime.#globalTimeMode = timeMode;
    }
    static getGlobalTimeMode() {
        return FBXTime.#globalTimeMode;
    }
    static setGlobalTimeProtocol(timeProtocol) {
        FBXTime.#globalTimeProtocol = timeProtocol;
    }
    static getGlobalTimeProtocol() {
        return FBXTime.#globalTimeProtocol;
    }
    static getFrameRate(timeMode) {
        const frameRate = FBX_TIME_MODE_FRAMES[timeMode];
        if (frameRate === -1) {
            throw 'return global frame rate';
        }
        else {
            return frameRate;
        }
    }
    static convertFrameRateToTimeMode(frameRate, precision = 1e-8) {
        const lowRate = frameRate - precision;
        const highRate = frameRate + precision;
        for (let i = 1, l = FBX_TIME_MODE_FRAMES.length; i < l; ++i) {
            const targetFrameRate = FBX_TIME_MODE_FRAMES[i];
            if ((targetFrameRate >= lowRate) && (targetFrameRate <= highRate)) {
                return i;
            }
        }
        return FBX_TIME_MODE_DEFAULT;
    }
    static getOneFrameValue(timeMode) {
        const frameRate = FBXTime.getFrameRate(timeMode);
        return BigInt(Math.round(Number(FBX_TC_SECOND) / frameRate));
    }
    setMilliSeconds(milliSeconds) {
        this.#time = BigInt(milliSeconds) * FBX_TC_MILLISECOND;
    }
    getMilliSeconds() {
        return this.#time / FBX_TC_MILLISECOND;
    }
    setSecondDouble(seconds) {
        this.#time = BigInt(Math.round(Number(FBX_TC_SECOND) * seconds));
    }
    getSecondDouble() {
        return Number(this.#time) / Number(FBX_TC_SECOND);
    }
    setTime(hour, minute, second, frame = 0, field = 0, timeMode = FBX_TIME_MODE_DEFAULT) {
        this.#time = BigInt(hour) * FBX_TC_HOUR +
            BigInt(minute) * FBX_TC_MINUTE +
            BigInt(second) * FBX_TC_SECOND +
            BigInt(frame) * FBXTime.getOneFrameValue(timeMode);
    }
}

class FBXAnimCurveKey {
    #time = new FBXTime();
    #value = 0;
    isFBXAnimCurveKey = true;
    constructor(time, value) {
        this.#set(time, value);
    }
    set(time, value) {
        this.#set(time, value);
    }
    #set(time, value) {
        if (time) {
            this.#time.copy(time);
        }
        if (value !== undefined) {
            this.#value = value;
        }
    }
    get time() {
        return this.#time;
    }
}

class FBXLayer {
    isFBXLayer = true;
}

class FBXLayerElement {
    #mappingMode = MappingMode.AllSame;
    #referenceMode = ReferenceMode.Direct;
    #name = '';
    isFBXLayerElement = true;
    constructor(name = '') {
        this.name = name;
    }
    set mappingMode(mappingMode) {
        this.#mappingMode = mappingMode;
    }
    get mappingMode() {
        return this.#mappingMode;
    }
    set referenceMode(referenceMode) {
        this.#referenceMode = referenceMode;
    }
    get referenceMode() {
        return this.#referenceMode;
    }
    set name(name) {
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
}

class FBXLayerElementTemplate extends FBXLayerElement {
    #directArray = [];
    #indexArray = [];
    isFBXLayerElementTemplate = true;
    get directArray() {
        return this.#directArray;
    }
    get indexArray() {
        return this.#indexArray;
    }
}

class FBXLayerElementMaterial extends FBXLayerElementTemplate {
    isFBXLayerElementMaterial = true;
}

/**
 * HDRImageData contains all decompressed image data.
 */

/**
 * Decodes RGBE-encoded data to a flat list of floating point pixel data (RGB).
 * @param data A DataView object containing the RGBE data.
 */
function decodeRGBE(data) {
    var stream = {
        data: data,
        offset: 0
    };
    var header = parseHeader(stream);
    return {
        width: header.width,
        height: header.height,
        exposure: header.exposure,
        gamma: header.gamma,
        data: parseData(stream, header)
    };
}
/**
 * @ignore
 */
function parseHeader(stream) {
    var line = readLine(stream);
    var header = {
        colorCorr: [1, 1, 1],
        exposure: 1,
        gamma: 1,
        width: 0,
        height: 0,
        flipX: false,
        flipY: false
    };
    if (line !== "#?RADIANCE" && line !== "#?RGBE")
        throw new Error("Incorrect file format!");
    while (line !== "") {
        // empty line means there's only 1 line left, containing size info:
        line = readLine(stream);
        var parts_1 = line.split("=");
        switch (parts_1[0]) {
            case "GAMMA":
                header.gamma = parseFloat(parts_1[1]);
                break;
            case "FORMAT":
                if (parts_1[1] !== "32-bit_rle_rgbe" && parts_1[1] !== "32-bit_rle_xyze")
                    throw new Error("Incorrect encoding format!");
                break;
            case "EXPOSURE":
                header.exposure = parseFloat(parts_1[1]);
                break;
            case "COLORCORR":
                header.colorCorr = parts_1[1].replace(/^\s+|\s+$/g, "").split(" ").map(function (m) { return parseFloat(m); });
                break;
        }
    }
    line = readLine(stream);
    var parts = line.split(" ");
    parseSize(parts[0], parseInt(parts[1]), header);
    parseSize(parts[2], parseInt(parts[3]), header);
    return header;
}
/**
 * @ignore
 */
function parseSize(label, value, header) {
    switch (label) {
        case "+X":
            header.width = value;
            break;
        case "-X":
            header.width = value;
            header.flipX = true;
            console.warn("Flipping horizontal orientation not currently supported");
            break;
        case "-Y":
            header.height = value;
            break;
        case "+Y":
            header.height = value;
            header.flipY = true;
            break;
    }
}
/**
 * @ignore
 */
function readLine(stream) {
    var ch, str = "";
    while ((ch = stream.data.getUint8(stream.offset++)) !== 0x0a)
        str += String.fromCharCode(ch);
    return str;
}
/**
 * @ignore
 */
function parseData(stream, header) {
    var hash = stream.data.getUint16(stream.offset);
    var data;
    if (hash === 0x0202) {
        data = parseNewRLE(stream, header);
        if (header.flipX)
            flipX(data, header);
        if (header.flipY)
            flipY$1(data, header);
    }
    else {
        throw new Error("Obsolete HDR file version!");
    }
    return data;
}
/**
 * @ignore
 */
function parseNewRLE(stream, header) {
    var width = header.width, height = header.height, colorCorr = header.colorCorr;
    var tgt = new Float32Array(width * height * 3);
    var i = 0;
    var offset = stream.offset, data = stream.data;
    for (var y = 0; y < height; ++y) {
        if (data.getUint16(offset) !== 0x0202)
            throw new Error("Incorrect scanline start hash");
        if (data.getUint16(offset + 2) !== width)
            throw new Error("Scanline doesn't match picture dimension!");
        offset += 4;
        var numComps = width * 4;
        // read individual RLE components
        var comps = [];
        var x = 0;
        while (x < numComps) {
            var value = data.getUint8(offset++);
            if (value > 128) {
                // RLE:
                var len = value - 128;
                value = data.getUint8(offset++);
                for (var rle = 0; rle < len; ++rle) {
                    comps[x++] = value;
                }
            }
            else {
                for (var n = 0; n < value; ++n) {
                    comps[x++] = data.getUint8(offset++);
                }
            }
        }
        for (x = 0; x < width; ++x) {
            var r = comps[x];
            var g = comps[x + width];
            var b = comps[x + width * 2];
            var e = comps[x + width * 3];
            // NOT -128 but -136!!! This allows encoding smaller values rather than higher ones (as you'd expect).
            e = e ? Math.pow(2.0, e - 136) : 0;
            tgt[i++] = r * e * colorCorr[0];
            tgt[i++] = g * e * colorCorr[1];
            tgt[i++] = b * e * colorCorr[2];
        }
    }
    return tgt;
}
/**
 * @ignore
 */
function swap(data, i1, i2) {
    i1 *= 3;
    i2 *= 3;
    for (var i = 0; i < 3; ++i) {
        var tmp = data[i1 + i];
        data[i1 + i] = data[i2 + i];
        data[i2 + i] = tmp;
    }
}
/**
 * @ignore
 */
function flipX(data, header) {
    var width = header.width, height = header.height;
    var hw = width >> 1;
    for (var y = 0; y < height; ++y) {
        // selects the current row
        var b = y * width;
        for (var x = 0; x < hw; ++x) {
            // add the mirrored columns
            var i1 = b + x;
            var i2 = b + width - 1 - x;
            swap(data, i1, i2);
        }
    }
}
/**
 * @ignore
 */
function flipY$1(data, header) {
    var width = header.width, height = header.height;
    var hh = height >> 1;
    for (var y = 0; y < hh; ++y) {
        // selects the mirrored rows
        var b1 = y * width;
        var b2 = (height - 1 - y) * width;
        for (var x = 0; x < width; ++x) {
            // adds the column
            swap(data, b1 + x, b2 + x);
        }
    }
}

//import { File } from 'node:buffer';
var VpkError;
(function (VpkError) {
    VpkError[VpkError["Ok"] = 0] = "Ok";
    VpkError[VpkError["NoFileProvided"] = 1] = "NoFileProvided";
    VpkError[VpkError["NoDirectory"] = 2] = "NoDirectory";
    VpkError[VpkError["DuplicateDirectory"] = 3] = "DuplicateDirectory";
    VpkError[VpkError["UnknownFilename"] = 4] = "UnknownFilename";
    VpkError[VpkError["Uninitialized"] = 5] = "Uninitialized";
    VpkError[VpkError["FormatError"] = 6] = "FormatError";
    VpkError[VpkError["FileNotFound"] = 7] = "FileNotFound";
    VpkError[VpkError["InvalidArchive"] = 8] = "InvalidArchive";
    VpkError[VpkError["InternalError"] = 9] = "InternalError";
})(VpkError || (VpkError = {}));
const ArchiveRegEx = /(.*)_(\d*).vpk/;
class Vpk {
    #files = new Map;
    #directory;
    #archives = [];
    #readers = new Map;
    #initialized = false;
    #directoryDataOffset = 0;
    async setFiles(files) {
        return await this.#init(files);
    }
    async #init(files) {
        this.#directory = undefined;
        this.#archives = [];
        this.#readers.clear();
        this.#files.clear();
        let error;
        switch (files.length) {
            case 0:
                return VpkError.NoFileProvided;
            case 1:
                this.#directory = files[0];
                error = await this.#initDirectory();
                if (error) {
                    return error;
                }
                break;
            default:
                error = await this.#initFiles(files);
                if (error) {
                    return error;
                }
                break;
        }
        this.#initialized = true;
        return null;
    }
    async #initFiles(files) {
        for (const file of files) {
            if (file.name.endsWith('_dir.vpk')) {
                if (this.#directory) {
                    return VpkError.DuplicateDirectory;
                }
                else {
                    this.#directory = file;
                }
            }
            else {
                const result = ArchiveRegEx.exec(file.name);
                if (result && result.length == 3) {
                    this.#archives[Number(result[2])] = file;
                }
                else {
                    return VpkError.UnknownFilename;
                }
            }
        }
        await this.#initDirectory();
        return null;
    }
    async getFile(filename) {
        if (!this.#initialized) {
            return { error: VpkError.Uninitialized };
        }
        filename = cleanupFilename$2(filename);
        const fileInfo = this.#files.get(filename);
        if (!fileInfo) {
            return { error: VpkError.FileNotFound };
        }
        // TODO: preload bytes
        let sourceFile;
        let dataOffset = 0;
        if (fileInfo.archiveIndex == 0x7FFF) { // File is in directory
            sourceFile = this.#directory;
            dataOffset = this.#directoryDataOffset;
        }
        else {
            sourceFile = this.#archives[fileInfo.archiveIndex];
        }
        if (!sourceFile) {
            return { error: VpkError.InvalidArchive };
        }
        const reader = await this.#getReader(sourceFile);
        if (!reader) {
            return { error: VpkError.InternalError };
        }
        const bytes = reader.getBytes(fileInfo.entryLength, fileInfo.entryOffset + dataOffset);
        const file = new File([bytes], filename);
        return { file: file };
    }
    async getFileList() {
        const list = new Set;
        for (const [filename, _] of this.#files) {
            list.add(filename);
        }
        return list;
    }
    async #initDirectory() {
        if (!this.#directory) {
            return VpkError.NoDirectory;
        }
        const reader = await this.#getReader(this.#directory);
        const magic = reader.getUint32();
        if (magic != 1437209140) {
            return VpkError.FormatError;
        }
        const version = reader.getUint32();
        reader.getUint32();
        if (version == 2) {
            reader.getUint32();
            reader.getUint32();
            reader.getUint32();
            reader.getUint32();
        }
        const error = this.#readTree(reader);
        if (error) {
            return error;
        }
        this.#directoryDataOffset = reader.tell();
        return null;
    }
    #readTree(reader) {
        while (true) {
            const extension = reader.getNullString();
            if (extension == '') {
                break;
            }
            while (true) {
                const path = reader.getNullString();
                if (path == '') {
                    break;
                }
                while (true) {
                    let filename = reader.getNullString();
                    if (filename == '') {
                        break;
                    }
                    const fileinfo = this.#readFile(reader);
                    filename = cleanupFilename$2(path + '/' + filename + '.' + extension);
                    this.#files.set(filename, fileinfo);
                }
            }
        }
        return null;
    }
    #readFile(reader) {
        const fileinfo = new VpkFileInfo();
        fileinfo.crc = reader.getUint32();
        fileinfo.preloadBytes = reader.getUint16();
        fileinfo.archiveIndex = reader.getUint16();
        fileinfo.entryOffset = reader.getUint32();
        fileinfo.entryLength = reader.getUint32();
        reader.skip(fileinfo.preloadBytes); //TODO: read preload bytes
        reader.skip(2); //TODO: check Terminator = 0xffff;
        return fileinfo;
    }
    async #getReader(file) {
        if (this.#readers.has(file)) {
            return this.#readers.get(file);
        }
        else {
            const ab = await file.arrayBuffer();
            const reader = new BinaryReader(ab);
            this.#readers.set(file, reader);
            return reader;
        }
    }
}
class VpkFileInfo {
    crc = 0;
    preloadBytes = 0;
    archiveIndex = 0;
    entryOffset = 0;
    entryLength = 0;
}
function cleanupFilename$2(filename) {
    filename = filename.toLowerCase().replaceAll('\\', '/');
    const arr = filename.split('/');
    return arr.filter((path) => path != '').join('/');
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS$1 = 15;
const D_CODES = 30;
const BL_CODES = 19;

const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = (LITERALS + 1 + LENGTH_CODES);
const HEAP_SIZE = (2 * L_CODES + 1);

const END_BLOCK = 256;

// Bit length codes must not exceed MAX_BL_BITS bits
const MAX_BL_BITS = 7;

// repeat previous bit length 3-6 times (2 bits of repeat count)
const REP_3_6 = 16;

// repeat a zero length 3-10 times (3 bits of repeat count)
const REPZ_3_10 = 17;

// repeat a zero length 11-138 times (7 bits of repeat count)
const REPZ_11_138 = 18;

// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit
// length codes.

const Buf_size = 8 * 2;

// JZlib version : "1.0.2"
const Z_DEFAULT_COMPRESSION = -1;

// compression strategy
const Z_FILTERED = 1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;

const Z_NO_FLUSH$1 = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH$1 = 4;

const Z_OK$1 = 0;
const Z_STREAM_END$1 = 1;
const Z_NEED_DICT$1 = 2;
const Z_STREAM_ERROR$1 = -2;
const Z_DATA_ERROR$1 = -3;
const Z_BUF_ERROR$1 = -5;

// Tree

function extractArray(array) {
	return flatArray(array.map(([length, value]) => (new Array(length)).fill(value, 0, length)));
}

function flatArray(array) {
	return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}

// see definition of array dist_code below
const _dist_code = [0, 1, 2, 3].concat(...extractArray([
	[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16],
	[1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]
]));

function Tree() {
	const that = this;

	// dyn_tree; // the dynamic tree
	// max_code; // largest code with non zero frequency
	// stat_desc; // the corresponding static tree

	// Compute the optimal bit lengths for a tree and update the total bit
	// length
	// for the current block.
	// IN assertion: the fields freq and dad are set, heap[heap_max] and
	// above are the tree nodes sorted by increasing frequency.
	// OUT assertions: the field len is set to the optimal bit length, the
	// array bl_count contains the frequencies for each bit length.
	// The length opt_len is updated; static_len is also updated if stree is
	// not null.
	function gen_bitlen(s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const extra = that.stat_desc.extra_bits;
		const base = that.stat_desc.extra_base;
		const max_length = that.stat_desc.max_length;
		let h; // heap index
		let n, m; // iterate over the tree elements
		let bits; // bit length
		let xbits; // extra bits
		let f; // frequency
		let overflow = 0; // number of elements with bit length too large

		for (bits = 0; bits <= MAX_BITS$1; bits++)
			s.bl_count[bits] = 0;

		// In a first pass, compute the optimal bit lengths (which may
		// overflow in the case of the bit length tree).
		tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap

		for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
			n = s.heap[h];
			bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n * 2 + 1] = bits;
			// We overwrite tree[n*2+1] which is no longer needed

			if (n > that.max_code)
				continue; // not a leaf node

			s.bl_count[bits]++;
			xbits = 0;
			if (n >= base)
				xbits = extra[n - base];
			f = tree[n * 2];
			s.opt_len += f * (bits + xbits);
			if (stree)
				s.static_len += f * (stree[n * 2 + 1] + xbits);
		}
		if (overflow === 0)
			return;

		// This happens for example on obj2 and pic of the Calgary corpus
		// Find the first bit length which could increase:
		do {
			bits = max_length - 1;
			while (s.bl_count[bits] === 0)
				bits--;
			s.bl_count[bits]--; // move one leaf down the tree
			s.bl_count[bits + 1] += 2; // move one overflow item as its brother
			s.bl_count[max_length]--;
			// The brother of the overflow item also moves one step up,
			// but this does not affect bl_count[max_length]
			overflow -= 2;
		} while (overflow > 0);

		for (bits = max_length; bits !== 0; bits--) {
			n = s.bl_count[bits];
			while (n !== 0) {
				m = s.heap[--h];
				if (m > that.max_code)
					continue;
				if (tree[m * 2 + 1] != bits) {
					s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
					tree[m * 2 + 1] = bits;
				}
				n--;
			}
		}
	}

	// Reverse the first len bits of a code, using straightforward code (a
	// faster
	// method would use a table)
	// IN assertion: 1 <= len <= 15
	function bi_reverse(code, // the value to invert
		len // its bit length
	) {
		let res = 0;
		do {
			res |= code & 1;
			code >>>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >>> 1;
	}

	// Generate the codes for a given tree and bit counts (which need not be
	// optimal).
	// IN assertion: the array bl_count contains the bit length statistics for
	// the given tree and the field len is set for all tree elements.
	// OUT assertion: the field code is set for all tree elements of non
	// zero code length.
	function gen_codes(tree, // the tree to decorate
		max_code, // largest code with non zero frequency
		bl_count // number of codes at each bit length
	) {
		const next_code = []; // next code value for each
		// bit length
		let code = 0; // running code value
		let bits; // bit index
		let n; // code index
		let len;

		// The distribution counts are first used to generate the code values
		// without bit reversal.
		for (bits = 1; bits <= MAX_BITS$1; bits++) {
			next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);
		}

		// Check that the bit counts in bl_count are consistent. The last code
		// must be all ones.
		// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
		// "inconsistent bit counts");
		// Tracev((stderr,"gen_codes: max_code %d ", max_code));

		for (n = 0; n <= max_code; n++) {
			len = tree[n * 2 + 1];
			if (len === 0)
				continue;
			// Now reverse the bits
			tree[n * 2] = bi_reverse(next_code[len]++, len);
		}
	}

	// Construct one Huffman tree and assigns the code bit strings and lengths.
	// Update the total bit length for the current block.
	// IN assertion: the field freq is set for all tree elements.
	// OUT assertions: the fields len and code are set to the optimal bit length
	// and corresponding code. The length opt_len is updated; static_len is
	// also updated if stree is not null. The field max_code is set.
	that.build_tree = function (s) {
		const tree = that.dyn_tree;
		const stree = that.stat_desc.static_tree;
		const elems = that.stat_desc.elems;
		let n, m; // iterate over heap elements
		let max_code = -1; // largest code with non zero frequency
		let node; // new node being created

		// Construct the initial heap, with least frequent element in
		// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		// heap[0] is not used.
		s.heap_len = 0;
		s.heap_max = HEAP_SIZE;

		for (n = 0; n < elems; n++) {
			if (tree[n * 2] !== 0) {
				s.heap[++s.heap_len] = max_code = n;
				s.depth[n] = 0;
			} else {
				tree[n * 2 + 1] = 0;
			}
		}

		// The pkzip format requires that at least one distance code exists,
		// and that at least one bit should be sent even if there is only one
		// possible code. So to avoid special checks later on we force at least
		// two codes of non zero frequency.
		while (s.heap_len < 2) {
			node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
			tree[node * 2] = 1;
			s.depth[node] = 0;
			s.opt_len--;
			if (stree)
				s.static_len -= stree[node * 2 + 1];
			// node is 0 or 1 so it does not have extra bits
		}
		that.max_code = max_code;

		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		// establish sub-heaps of increasing lengths:

		for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
			s.pqdownheap(tree, n);

		// Construct the Huffman tree by repeatedly combining the least two
		// frequent nodes.

		node = elems; // next internal node of the tree
		do {
			// n = node of least frequency
			n = s.heap[1];
			s.heap[1] = s.heap[s.heap_len--];
			s.pqdownheap(tree, 1);
			m = s.heap[1]; // m = node of next least frequency

			s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency
			s.heap[--s.heap_max] = m;

			// Create a new node father of n and m
			tree[node * 2] = (tree[n * 2] + tree[m * 2]);
			s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
			tree[n * 2 + 1] = tree[m * 2 + 1] = node;

			// and insert the new node in the heap
			s.heap[1] = node++;
			s.pqdownheap(tree, 1);
		} while (s.heap_len >= 2);

		s.heap[--s.heap_max] = s.heap[1];

		// At this point, the fields freq and dad are set. We can now
		// generate the bit lengths.

		gen_bitlen(s);

		// The field len is now set, we can generate the bit codes
		gen_codes(tree, that.max_code, s.bl_count);
	};

}

Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
	[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19],
	[16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]]));

Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];

Tree.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,
	24576];

// Mapping from a distance to a distance code. dist is the distance - 1 and
// must not have side effects. _dist_code[256] and _dist_code[257] are never
// used.
Tree.d_code = function (dist) {
	return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);
};

// extra bits for each length code
Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

// extra bits for each distance code
Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// extra bits for each bit length code
Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

// StaticTree

function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
	const that = this;
	that.static_tree = static_tree;
	that.extra_bits = extra_bits;
	that.extra_base = extra_base;
	that.elems = elems;
	that.max_length = max_length;
}

const static_ltree2_first_part = [12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82,
	210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86,
	214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81,
	209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85,
	213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307,
	179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475,
	59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215,
	471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95,
	351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52,
	116, 3, 131, 67, 195, 35, 163, 99, 227];
const static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));

const static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
const static_dtree_second_part = extractArray([[30, 5]]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));

StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS$1);

StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS$1);

StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);

// Deflate

const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;

function Config(good_length, max_lazy, nice_length, max_chain, func) {
	const that = this;
	that.good_length = good_length;
	that.max_lazy = max_lazy;
	that.nice_length = nice_length;
	that.max_chain = max_chain;
	that.func = func;
}

const STORED$1 = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
	new Config(0, 0, 0, 0, STORED$1),
	new Config(4, 4, 8, 4, FAST),
	new Config(4, 5, 16, 8, FAST),
	new Config(4, 6, 32, 32, FAST),
	new Config(4, 4, 16, 16, SLOW),
	new Config(8, 16, 32, 32, SLOW),
	new Config(8, 16, 128, 128, SLOW),
	new Config(8, 32, 128, 256, SLOW),
	new Config(32, 128, 258, 1024, SLOW),
	new Config(32, 258, 258, 4096, SLOW)
];

const z_errmsg = ["need dictionary", // Z_NEED_DICT
	// 2
	"stream end", // Z_STREAM_END 1
	"", // Z_OK 0
	"", // Z_ERRNO (-1)
	"stream error", // Z_STREAM_ERROR (-2)
	"data error", // Z_DATA_ERROR (-3)
	"", // Z_MEM_ERROR (-4)
	"buffer error", // Z_BUF_ERROR (-5)
	"",// Z_VERSION_ERROR (-6)
	""];

// block not completed, need more input or more output
const NeedMore = 0;

// block flush performed
const BlockDone = 1;

// finish started, need only more output at next deflate
const FinishStarted = 2;

// finish done, accept no more input or output
const FinishDone = 3;

// preset dictionary flag in zlib header
const PRESET_DICT$1 = 0x20;

const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

// The deflate compression method
const Z_DEFLATED$1 = 8;

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

function smaller(tree, n, m, depth) {
	const tn2 = tree[n * 2];
	const tm2 = tree[m * 2];
	return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));
}

function Deflate() {

	const that = this;
	let strm; // pointer back to this zlib stream
	let status; // as the name implies
	// pending_buf; // output still pending
	let pending_buf_size; // size of pending_buf
	// pending_out; // next pending byte to output to the stream
	// pending; // nb of bytes in the pending buffer

	// dist_buf; // buffer for distances
	// lc_buf; // buffer for literals or lengths
	// To simplify the code, dist_buf and lc_buf have the same number of elements.
	// To use different lengths, an extra flag array would be necessary.

	let last_flush; // value of flush param for previous deflate call

	let w_size; // LZ77 win size (32K by default)
	let w_bits; // log2(w_size) (8..16)
	let w_mask; // w_size - 1

	let win;
	// Sliding win. Input bytes are read into the second half of the win,
	// and move to the first half later to keep a dictionary of at least wSize
	// bytes. With this organization, matches are limited to a distance of
	// wSize-MAX_MATCH bytes, but this ensures that IO is always
	// performed with a length multiple of the block size. Also, it limits
	// the win size to 64K, which is quite useful on MSDOS.
	// To do: use the user input buffer as sliding win.

	let window_size;
	// Actual size of win: 2*wSize, except when the user input buffer
	// is directly used as sliding win.

	let prev;
	// Link to older string with same hash index. To limit the size of this
	// array to 64K, this link is maintained only for the last 32K strings.
	// An index in this array is thus a win index modulo 32K.

	let head; // Heads of the hash chains or NIL.

	let ins_h; // hash index of string to be inserted
	let hash_size; // number of elements in hash table
	let hash_bits; // log2(hash_size)
	let hash_mask; // hash_size-1

	// Number of bits by which ins_h must be shifted at each input
	// step. It must be such that after MIN_MATCH steps, the oldest
	// byte no longer takes part in the hash key, that is:
	// hash_shift * MIN_MATCH >= hash_bits
	let hash_shift;

	// Window position at the beginning of the current output block. Gets
	// negative when the win is moved backwards.

	let block_start;

	let match_length; // length of best match
	let prev_match; // previous match
	let match_available; // set if previous match exists
	let strstart; // start of string to insert
	let match_start; // start of matching string
	let lookahead; // number of valid bytes ahead in win

	// Length of the best match at previous step. Matches not greater than this
	// are discarded. This is used in the lazy match evaluation.
	let prev_length;

	// To speed up deflation, hash chains are never searched beyond this
	// length. A higher limit improves compression ratio but degrades the speed.
	let max_chain_length;

	// Attempt to find a better match only when the current match is strictly
	// smaller than this value. This mechanism is used only for compression
	// levels >= 4.
	let max_lazy_match;

	// Insert new strings in the hash table only if the match length is not
	// greater than this length. This saves time but degrades compression.
	// max_insert_length is used only for compression levels <= 3.

	let level; // compression level (1..9)
	let strategy; // favor or force Huffman coding

	// Use a faster search when the previous match is longer than this
	let good_match;

	// Stop searching when current match exceeds this
	let nice_match;

	let dyn_ltree; // literal and length tree
	let dyn_dtree; // distance tree
	let bl_tree; // Huffman tree for bit lengths

	const l_desc = new Tree(); // desc for literal tree
	const d_desc = new Tree(); // desc for distance tree
	const bl_desc = new Tree(); // desc for bit length tree

	// that.heap_len; // number of elements in the heap
	// that.heap_max; // element of largest frequency
	// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	// The same heap array is used to build all trees.

	// Depth of each subtree used as tie breaker for trees of equal frequency
	that.depth = [];

	// Size of match buffer for literals/lengths. There are 4 reasons for
	// limiting lit_bufsize to 64K:
	// - frequencies can be kept in 16 bit counters
	// - if compression is not successful for the first block, all input
	// data is still in the win so we can still emit a stored block even
	// when input comes from standard input. (This can also be done for
	// all blocks if lit_bufsize is not greater than 32K.)
	// - if compression is not successful for a file smaller than 64K, we can
	// even emit a stored file instead of a stored block (saving 5 bytes).
	// This is applicable only for zip (not gzip or zlib).
	// - creating new Huffman trees less frequently may not provide fast
	// adaptation to changes in the input data statistics. (Take for
	// example a binary file with poorly compressible code followed by
	// a highly compressible string table.) Smaller buffer sizes give
	// fast adaptation but have of course the overhead of transmitting
	// trees more frequently.
	// - I can't count above 4
	let lit_bufsize;

	let last_lit; // running index in dist_buf and lc_buf

	// that.opt_len; // bit length of current block with optimal trees
	// that.static_len; // bit length of current block with static trees
	let matches; // number of string matches in current block
	let last_eob_len; // bit length of EOB code for last block

	// Output buffer. bits are inserted starting at the bottom (least
	// significant bits).
	let bi_buf;

	// Number of valid bits in bi_buf. All bits above the last valid bit
	// are always zero.
	let bi_valid;

	// number of codes at each bit length for an optimal tree
	that.bl_count = [];

	// heap used to build the Huffman trees
	that.heap = [];

	dyn_ltree = [];
	dyn_dtree = [];
	bl_tree = [];

	function lm_init() {
		window_size = 2 * w_size;

		head[hash_size - 1] = 0;
		for (let i = 0; i < hash_size - 1; i++) {
			head[i] = 0;
		}

		// Set the default configuration parameters:
		max_lazy_match = config_table[level].max_lazy;
		good_match = config_table[level].good_length;
		nice_match = config_table[level].nice_length;
		max_chain_length = config_table[level].max_chain;

		strstart = 0;
		block_start = 0;
		lookahead = 0;
		match_length = prev_length = MIN_MATCH - 1;
		match_available = 0;
		ins_h = 0;
	}

	function init_block() {
		let i;
		// Initialize the trees.
		for (i = 0; i < L_CODES; i++)
			dyn_ltree[i * 2] = 0;
		for (i = 0; i < D_CODES; i++)
			dyn_dtree[i * 2] = 0;
		for (i = 0; i < BL_CODES; i++)
			bl_tree[i * 2] = 0;

		dyn_ltree[END_BLOCK * 2] = 1;
		that.opt_len = that.static_len = 0;
		last_lit = matches = 0;
	}

	// Initialize the tree data structures for a new zlib stream.
	function tr_init() {

		l_desc.dyn_tree = dyn_ltree;
		l_desc.stat_desc = StaticTree.static_l_desc;

		d_desc.dyn_tree = dyn_dtree;
		d_desc.stat_desc = StaticTree.static_d_desc;

		bl_desc.dyn_tree = bl_tree;
		bl_desc.stat_desc = StaticTree.static_bl_desc;

		bi_buf = 0;
		bi_valid = 0;
		last_eob_len = 8; // enough lookahead for inflate

		// Initialize the first block of the first file:
		init_block();
	}

	// Restore the heap property by moving down the tree starting at node k,
	// exchanging a node with the smallest of its two sons if necessary,
	// stopping
	// when the heap property is re-established (each father smaller than its
	// two sons).
	that.pqdownheap = function (tree, // the tree to restore
		k // node to move down
	) {
		const heap = that.heap;
		const v = heap[k];
		let j = k << 1; // left son of k
		while (j <= that.heap_len) {
			// Set j to the smallest of the two sons:
			if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
				j++;
			}
			// Exit if v is smaller than both sons
			if (smaller(tree, v, heap[j], that.depth))
				break;

			// Exchange v with the smallest son
			heap[k] = heap[j];
			k = j;
			// And continue down the tree, setting j to the left son of k
			j <<= 1;
		}
		heap[k] = v;
	};

	// Scan a literal or distance tree to determine the frequencies of the codes
	// in the bit length tree.
	function scan_tree(tree,// the tree to be scanned
		max_code // and its largest code of non zero frequency
	) {
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[(max_code + 1) * 2 + 1] = 0xffff; // guard

		for (let n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				bl_tree[curlen * 2] += count;
			} else if (curlen !== 0) {
				if (curlen != prevlen)
					bl_tree[curlen * 2]++;
				bl_tree[REP_3_6 * 2]++;
			} else if (count <= 10) {
				bl_tree[REPZ_3_10 * 2]++;
			} else {
				bl_tree[REPZ_11_138 * 2]++;
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Construct the Huffman tree for the bit lengths and return the index in
	// bl_order of the last bit length code to send.
	function build_bl_tree() {
		let max_blindex; // index of last bit length code of non zero freq

		// Determine the bit length frequencies for literal and distance trees
		scan_tree(dyn_ltree, l_desc.max_code);
		scan_tree(dyn_dtree, d_desc.max_code);

		// Build the bit length tree:
		bl_desc.build_tree(that);
		// opt_len now includes the length of the tree representations, except
		// the lengths of the bit lengths codes and the 5+5+4 bits for the
		// counts.

		// Determine the number of bit length codes to send. The pkzip format
		// requires that at least 4 bit length codes be sent. (appnote.txt says
		// 3 but the actual value used is 4.)
		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
			if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
				break;
		}
		// Update opt_len to include the bit length tree and counts
		that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;

		return max_blindex;
	}

	// Output a byte on the stream.
	// IN assertion: there is enough room in pending_buf.
	function put_byte(p) {
		that.pending_buf[that.pending++] = p;
	}

	function put_short(w) {
		put_byte(w & 0xff);
		put_byte((w >>> 8) & 0xff);
	}

	function putShortMSB(b) {
		put_byte((b >> 8) & 0xff);
		put_byte((b & 0xff) & 0xff);
	}

	function send_bits(value, length) {
		let val;
		const len = length;
		if (bi_valid > Buf_size - len) {
			val = value;
			// bi_buf |= (val << bi_valid);
			bi_buf |= ((val << bi_valid) & 0xffff);
			put_short(bi_buf);
			bi_buf = val >>> (Buf_size - bi_valid);
			bi_valid += len - Buf_size;
		} else {
			// bi_buf |= (value) << bi_valid;
			bi_buf |= (((value) << bi_valid) & 0xffff);
			bi_valid += len;
		}
	}

	function send_code(c, tree) {
		const c2 = c * 2;
		send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
	}

	// Send a literal or distance tree in compressed form, using the codes in
	// bl_tree.
	function send_tree(tree,// the tree to be sent
		max_code // and its largest code of non zero frequency
	) {
		let n; // iterates over all tree elements
		let prevlen = -1; // last emitted length
		let curlen; // length of current code
		let nextlen = tree[0 * 2 + 1]; // length of next code
		let count = 0; // repeat count of the current code
		let max_count = 7; // max repeat count
		let min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[(n + 1) * 2 + 1];
			if (++count < max_count && curlen == nextlen) {
				continue;
			} else if (count < min_count) {
				do {
					send_code(curlen, bl_tree);
				} while (--count !== 0);
			} else if (curlen !== 0) {
				if (curlen != prevlen) {
					send_code(curlen, bl_tree);
					count--;
				}
				send_code(REP_3_6, bl_tree);
				send_bits(count - 3, 2);
			} else if (count <= 10) {
				send_code(REPZ_3_10, bl_tree);
				send_bits(count - 3, 3);
			} else {
				send_code(REPZ_11_138, bl_tree);
				send_bits(count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen == nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	// Send the header for a block using dynamic Huffman trees: the counts, the
	// lengths of the bit length codes, the literal tree and the distance tree.
	// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	function send_all_trees(lcodes, dcodes, blcodes) {
		let rank; // index in bl_order

		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
		send_bits(dcodes - 1, 5);
		send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt
		for (rank = 0; rank < blcodes; rank++) {
			send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
		}
		send_tree(dyn_ltree, lcodes - 1); // literal tree
		send_tree(dyn_dtree, dcodes - 1); // distance tree
	}

	// Flush the bit buffer, keeping at most 7 bits in it.
	function bi_flush() {
		if (bi_valid == 16) {
			put_short(bi_buf);
			bi_buf = 0;
			bi_valid = 0;
		} else if (bi_valid >= 8) {
			put_byte(bi_buf & 0xff);
			bi_buf >>>= 8;
			bi_valid -= 8;
		}
	}

	// Send one empty static block to give enough lookahead for inflate.
	// This takes 10 bits, of which 7 may remain in the bit buffer.
	// The current inflate code requires 9 bits of lookahead. If the
	// last two codes for the previous block (real code plus EOB) were coded
	// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
	// the last real code. In this case we send two empty static blocks instead
	// of one. (There are no problems if the previous block is stored or fixed.)
	// To simplify the code, we assume the worst case of last real code encoded
	// on one bit only.
	function _tr_align() {
		send_bits(STATIC_TREES << 1, 3);
		send_code(END_BLOCK, StaticTree.static_ltree);

		bi_flush();

		// Of the 10 bits for the empty block, we have already sent
		// (10 - bi_valid) bits. The lookahead for the last real code (before
		// the EOB of the previous block) was thus at least one plus the length
		// of the EOB plus what we have just sent of the empty static block.
		if (1 + last_eob_len + 10 - bi_valid < 9) {
			send_bits(STATIC_TREES << 1, 3);
			send_code(END_BLOCK, StaticTree.static_ltree);
			bi_flush();
		}
		last_eob_len = 7;
	}

	// Save the match info and tally the frequency counts. Return true if
	// the current block must be flushed.
	function _tr_tally(dist, // distance of matched string
		lc // match length-MIN_MATCH or unmatched char (if dist==0)
	) {
		let out_length, in_length, dcode;
		that.dist_buf[last_lit] = dist;
		that.lc_buf[last_lit] = lc & 0xff;
		last_lit++;

		if (dist === 0) {
			// lc is the unmatched char
			dyn_ltree[lc * 2]++;
		} else {
			matches++;
			// Here, lc is the match length - MIN_MATCH
			dist--; // dist = match distance - 1
			dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
			dyn_dtree[Tree.d_code(dist) * 2]++;
		}

		if ((last_lit & 0x1fff) === 0 && level > 2) {
			// Compute an upper bound for the compressed length
			out_length = last_lit * 8;
			in_length = strstart - block_start;
			for (dcode = 0; dcode < D_CODES; dcode++) {
				out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
			}
			out_length >>>= 3;
			if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))
				return true;
		}

		return (last_lit == lit_bufsize - 1);
		// We avoid equality with lit_bufsize because of wraparound at 64K
		// on 16 bit machines and because stored blocks are restricted to
		// 64K-1 bytes.
	}

	// Send the block data compressed using the given Huffman trees
	function compress_block(ltree, dtree) {
		let dist; // distance of matched string
		let lc; // match length or unmatched char (if dist === 0)
		let lx = 0; // running index in dist_buf and lc_buf
		let code; // the code to send
		let extra; // number of extra bits to send

		if (last_lit !== 0) {
			do {
				dist = that.dist_buf[lx];
				lc = that.lc_buf[lx];
				lx++;

				if (dist === 0) {
					send_code(lc, ltree); // send a literal byte
				} else {
					// Here, lc is the match length - MIN_MATCH
					code = Tree._length_code[lc];

					send_code(code + LITERALS + 1, ltree); // send the length
					// code
					extra = Tree.extra_lbits[code];
					if (extra !== 0) {
						lc -= Tree.base_length[code];
						send_bits(lc, extra); // send the extra length bits
					}
					dist--; // dist is now the match distance - 1
					code = Tree.d_code(dist);

					send_code(code, dtree); // send the distance code
					extra = Tree.extra_dbits[code];
					if (extra !== 0) {
						dist -= Tree.base_dist[code];
						send_bits(dist, extra); // send the extra distance bits
					}
				} // literal or match pair ?
			} while (lx < last_lit);
		}

		send_code(END_BLOCK, ltree);
		last_eob_len = ltree[END_BLOCK * 2 + 1];
	}

	// Flush the bit buffer and align the output on a byte boundary
	function bi_windup() {
		if (bi_valid > 8) {
			put_short(bi_buf);
		} else if (bi_valid > 0) {
			put_byte(bi_buf & 0xff);
		}
		bi_buf = 0;
		bi_valid = 0;
	}

	// Copy a stored block, storing first the length and its
	// one's complement if requested.
	function copy_block(buf, // the input data
		len, // its length
		header // true if block header must be written
	) {
		bi_windup(); // align on byte boundary
		last_eob_len = 8; // enough lookahead for inflate

		if (header) {
			put_short(len);
			put_short(~len);
		}

		that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
		that.pending += len;
	}

	// Send a stored block
	function _tr_stored_block(buf, // input block
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type
		copy_block(buf, stored_len, true); // with header
	}

	// Determine the best encoding for the current block: dynamic trees, static
	// trees or store, and output the encoded block to the zip file.
	function _tr_flush_block(buf, // input block, or NULL if too old
		stored_len, // length of input block
		eof // true if this is the last block for a file
	) {
		let opt_lenb, static_lenb;// opt_len and static_len in bytes
		let max_blindex = 0; // index of last bit length code of non zero freq

		// Build the Huffman trees unless a stored block is forced
		if (level > 0) {
			// Construct the literal and distance trees
			l_desc.build_tree(that);

			d_desc.build_tree(that);

			// At this point, opt_len and static_len are the total bit lengths
			// of
			// the compressed block data, excluding the tree representations.

			// Build the bit length tree for the above two trees, and get the
			// index
			// in bl_order of the last bit length code to send.
			max_blindex = build_bl_tree();

			// Determine the best encoding. Compute first the block length in
			// bytes
			opt_lenb = (that.opt_len + 3 + 7) >>> 3;
			static_lenb = (that.static_len + 3 + 7) >>> 3;

			if (static_lenb <= opt_lenb)
				opt_lenb = static_lenb;
		} else {
			opt_lenb = static_lenb = stored_len + 5; // force a stored block
		}

		if ((stored_len + 4 <= opt_lenb) && buf != -1) {
			// 4: two words for the lengths
			// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
			// Otherwise we can't have processed more than WSIZE input bytes
			// since
			// the last block flush, because compression would have been
			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
			// transform a block into a stored block.
			_tr_stored_block(buf, stored_len, eof);
		} else if (static_lenb == opt_lenb) {
			send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
			compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
		} else {
			send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
			compress_block(dyn_ltree, dyn_dtree);
		}

		// The above check is made mod 2^32, for files larger than 512 MB
		// and uLong implemented on 32 bits.

		init_block();

		if (eof) {
			bi_windup();
		}
	}

	function flush_block_only(eof) {
		_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
		block_start = strstart;
		strm.flush_pending();
	}

	// Fill the win when the lookahead becomes insufficient.
	// Updates strstart and lookahead.
	//
	// IN assertion: lookahead < MIN_LOOKAHEAD
	// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	// At least one byte has been read, or avail_in === 0; reads are
	// performed for at least two bytes (required for the zip translate_eol
	// option -- not supported here).
	function fill_window() {
		let n, m;
		let p;
		let more; // Amount of free space at the end of the win.

		do {
			more = (window_size - lookahead - strstart);

			// Deal with !@#$% 64K limit:
			if (more === 0 && strstart === 0 && lookahead === 0) {
				more = w_size;
			} else if (more == -1) {
				// Very unlikely, but possible on 16 bit machine if strstart ==
				// 0
				// and lookahead == 1 (input done one byte at time)
				more--;

				// If the win is almost full and there is insufficient
				// lookahead,
				// move the upper half to the lower one to make room in the
				// upper half.
			} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
				win.set(win.subarray(w_size, w_size + w_size), 0);

				match_start -= w_size;
				strstart -= w_size; // we now have strstart >= MAX_DIST
				block_start -= w_size;

				// Slide the hash table (could be avoided with 32 bit values
				// at the expense of memory usage). We slide even when level ==
				// 0
				// to keep the hash table consistent if we switch back to level
				// > 0
				// later. (Using level 0 permanently is not an optimal usage of
				// zlib, so we don't care about this pathological case.)

				n = hash_size;
				p = n;
				do {
					m = (head[--p] & 0xffff);
					head[p] = (m >= w_size ? m - w_size : 0);
				} while (--n !== 0);

				n = w_size;
				p = n;
				do {
					m = (prev[--p] & 0xffff);
					prev[p] = (m >= w_size ? m - w_size : 0);
					// If n is not on any hash chain, prev[n] is garbage but
					// its value will never be used.
				} while (--n !== 0);
				more += w_size;
			}

			if (strm.avail_in === 0)
				return;

			// If there was no sliding:
			// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
			// more == window_size - lookahead - strstart
			// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
			// => more >= window_size - 2*WSIZE + 2
			// In the BIG_MEM or MMAP case (not yet supported),
			// window_size == input_size + MIN_LOOKAHEAD &&
			// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
			// Otherwise, window_size == 2*WSIZE so more >= 2.
			// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

			n = strm.read_buf(win, strstart + lookahead, more);
			lookahead += n;

			// Initialize the hash value now that we have some input:
			if (lookahead >= MIN_MATCH) {
				ins_h = win[strstart] & 0xff;
				ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
			}
			// If the whole input has less than MIN_MATCH bytes, ins_h is
			// garbage,
			// but this is not important since only literal bytes will be
			// emitted.
		} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
	}

	// Copy without compression as much as possible from the input stream,
	// return
	// the current block state.
	// This function does not insert new strings in the dictionary since
	// uncompressible data is probably not useful. This function is used
	// only for the level=0 compression option.
	// NOTE: this function should be optimized to avoid extra copying from
	// win to pending_buf.
	function deflate_stored(flush) {
		// Stored blocks are limited to 0xffff bytes, pending_buf is limited
		// to pending_buf_size, and each stored block has a 5 byte header:

		let max_block_size = 0xffff;
		let max_start;

		if (max_block_size > pending_buf_size - 5) {
			max_block_size = pending_buf_size - 5;
		}

		// Copy as much as possible from input to output:
		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Fill the win as much as possible:
			if (lookahead <= 1) {
				fill_window();
				if (lookahead === 0 && flush == Z_NO_FLUSH$1)
					return NeedMore;
				if (lookahead === 0)
					break; // flush the current block
			}

			strstart += lookahead;
			lookahead = 0;

			// Emit a stored block if pending_buf will be full:
			max_start = block_start + max_block_size;
			if (strstart === 0 || strstart >= max_start) {
				// strstart === 0 is possible when wraparound on 16-bit machine
				lookahead = (strstart - max_start);
				strstart = max_start;

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;

			}

			// Flush if we may have to slide, otherwise block_start may become
			// negative and the data will be gone:
			if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$1);
		if (strm.avail_out === 0)
			return (flush == Z_FINISH$1) ? FinishStarted : NeedMore;

		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	function longest_match(cur_match) {
		let chain_length = max_chain_length; // max hash chain length
		let scan = strstart; // current string
		let match; // matched string
		let len; // length of current match
		let best_len = prev_length; // best match length so far
		const limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
		let _nice_match = nice_match;

		// Stop when cur_match becomes <= limit. To simplify the code,
		// we prevent matches with the string of win index 0.

		const wmask = w_mask;

		const strend = strstart + MAX_MATCH;
		let scan_end1 = win[scan + best_len - 1];
		let scan_end = win[scan + best_len];

		// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of
		// 16.
		// It is easy to get rid of this optimization if necessary.

		// Do not waste too much time if we already have a good match:
		if (prev_length >= good_match) {
			chain_length >>= 2;
		}

		// Do not look for matches beyond the end of the input. This is
		// necessary
		// to make deflate deterministic.
		if (_nice_match > lookahead)
			_nice_match = lookahead;

		do {
			match = cur_match;

			// Skip to next match if the match length cannot increase
			// or if the match length is less than 2:
			if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan]
				|| win[++match] != win[scan + 1])
				continue;

			// The check at best_len-1 can be removed because it will be made
			// again later. (This heuristic is not always a win.)
			// It is not necessary to compare scan[2] and match[2] since they
			// are always equal when the other bytes match, given that
			// the hash keys are equal and that HASH_BITS >= 8.
			scan += 2;
			match++;

			// We check for insufficient lookahead only every 8th comparison;
			// the 256th check will be made at strstart+258.
			// eslint-disable-next-line no-empty
			do {
				// empty block
			} while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match]
			&& win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);

			len = MAX_MATCH - (strend - scan);
			scan = strend - MAX_MATCH;

			if (len > best_len) {
				match_start = cur_match;
				best_len = len;
				if (len >= _nice_match)
					break;
				scan_end1 = win[scan + best_len - 1];
				scan_end = win[scan + best_len];
			}

		} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);

		if (best_len <= lookahead)
			return best_len;
		return lookahead;
	}

	// Compress as much as possible from the input stream, return the current
	// block state.
	// This function does not perform lazy evaluation of matches and inserts
	// new strings in the dictionary only for unmatched strings or for short
	// matches. It is used only for the fast compression options.
	function deflate_fast(flush) {
		// short hash_head = 0; // head of the hash chain
		let hash_head = 0; // head of the hash chain
		let bflush; // set if current block must be flushed

		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			if (lookahead < MIN_LOOKAHEAD) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			if (lookahead >= MIN_MATCH) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;

				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			// At this point we have always match_length < MIN_MATCH

			if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				if (strategy != Z_HUFFMAN_ONLY) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start
			}
			if (match_length >= MIN_MATCH) {
				// check_match(strstart, match_start, match_length);

				bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);

				lookahead -= match_length;

				// Insert new strings in the hash table only if the match length
				// is not too large. This saves time but degrades compression.
				if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
					match_length--; // string at strstart already in hash table
					do {
						strstart++;

						ins_h = ((ins_h << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;

						// strstart never exceeds WSIZE-MAX_MATCH, so there are
						// always MIN_MATCH bytes ahead.
					} while (--match_length !== 0);
					strstart++;
				} else {
					strstart += match_length;
					match_length = 0;
					ins_h = win[strstart] & 0xff;

					ins_h = (((ins_h) << hash_shift) ^ (win[strstart + 1] & 0xff)) & hash_mask;
					// If lookahead < MIN_MATCH, ins_h is garbage, but it does
					// not
					// matter since it will be recomputed at next deflate call.
				}
			} else {
				// No match, output a literal byte

				bflush = _tr_tally(0, win[strstart] & 0xff);
				lookahead--;
				strstart++;
			}
			if (bflush) {

				flush_block_only(false);
				if (strm.avail_out === 0)
					return NeedMore;
			}
		}

		flush_block_only(flush == Z_FINISH$1);
		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$1)
				return FinishStarted;
			else
				return NeedMore;
		}
		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	// Same as above, but achieves better compression. We use a lazy
	// evaluation for matches: a match is finally adopted only if there is
	// no better match at the next win position.
	function deflate_slow(flush) {
		// short hash_head = 0; // head of hash chain
		let hash_head = 0; // head of hash chain
		let bflush; // set if current block must be flushed
		let max_insert;

		// Process the input block.
		// eslint-disable-next-line no-constant-condition
		while (true) {
			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.

			if (lookahead < MIN_LOOKAHEAD) {
				fill_window();
				if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH$1) {
					return NeedMore;
				}
				if (lookahead === 0)
					break; // flush the current block
			}

			// Insert the string win[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:

			if (lookahead >= MIN_MATCH) {
				ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
				// prev[strstart&w_mask]=hash_head=head[ins_h];
				hash_head = (head[ins_h] & 0xffff);
				prev[strstart & w_mask] = head[ins_h];
				head[ins_h] = strstart;
			}

			// Find the longest match, discarding those <= prev_length.
			prev_length = match_length;
			prev_match = match_start;
			match_length = MIN_MATCH - 1;

			if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
				// To simplify the code, we prevent matches with the string
				// of win index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).

				if (strategy != Z_HUFFMAN_ONLY) {
					match_length = longest_match(hash_head);
				}
				// longest_match() sets match_start

				if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {

					// If prev_match is also MIN_MATCH, match_start is garbage
					// but we will ignore the current match anyway.
					match_length = MIN_MATCH - 1;
				}
			}

			// If there was a match at the previous step and the current
			// match is not better, output the previous match:
			if (prev_length >= MIN_MATCH && match_length <= prev_length) {
				max_insert = strstart + lookahead - MIN_MATCH;
				// Do not insert strings in hash table beyond this.

				// check_match(strstart-1, prev_match, prev_length);

				bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

				// Insert in hash table all strings up to the end of the match.
				// strstart-1 and strstart are already inserted. If there is not
				// enough lookahead, the last two strings are not inserted in
				// the hash table.
				lookahead -= prev_length - 1;
				prev_length -= 2;
				do {
					if (++strstart <= max_insert) {
						ins_h = (((ins_h) << hash_shift) ^ (win[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
						// prev[strstart&w_mask]=hash_head=head[ins_h];
						hash_head = (head[ins_h] & 0xffff);
						prev[strstart & w_mask] = head[ins_h];
						head[ins_h] = strstart;
					}
				} while (--prev_length !== 0);
				match_available = 0;
				match_length = MIN_MATCH - 1;
				strstart++;

				if (bflush) {
					flush_block_only(false);
					if (strm.avail_out === 0)
						return NeedMore;
				}
			} else if (match_available !== 0) {

				// If there was no match at the previous position, output a
				// single literal. If there was a match but the current match
				// is longer, truncate the previous match to a single literal.

				bflush = _tr_tally(0, win[strstart - 1] & 0xff);

				if (bflush) {
					flush_block_only(false);
				}
				strstart++;
				lookahead--;
				if (strm.avail_out === 0)
					return NeedMore;
			} else {
				// There is no previous match to compare with, wait for
				// the next step to decide.

				match_available = 1;
				strstart++;
				lookahead--;
			}
		}

		if (match_available !== 0) {
			bflush = _tr_tally(0, win[strstart - 1] & 0xff);
			match_available = 0;
		}
		flush_block_only(flush == Z_FINISH$1);

		if (strm.avail_out === 0) {
			if (flush == Z_FINISH$1)
				return FinishStarted;
			else
				return NeedMore;
		}

		return flush == Z_FINISH$1 ? FinishDone : BlockDone;
	}

	function deflateReset(strm) {
		strm.total_in = strm.total_out = 0;
		strm.msg = null; //

		that.pending = 0;
		that.pending_out = 0;

		status = BUSY_STATE;

		last_flush = Z_NO_FLUSH$1;

		tr_init();
		lm_init();
		return Z_OK$1;
	}

	that.deflateInit = function (strm, _level, bits, _method, memLevel, _strategy) {
		if (!_method)
			_method = Z_DEFLATED$1;
		if (!memLevel)
			memLevel = DEF_MEM_LEVEL;
		if (!_strategy)
			_strategy = Z_DEFAULT_STRATEGY;

		// byte[] my_version=ZLIB_VERSION;

		//
		// if (!version || version[0] != my_version[0]
		// || stream_size != sizeof(z_stream)) {
		// return Z_VERSION_ERROR;
		// }

		strm.msg = null;

		if (_level == Z_DEFAULT_COMPRESSION)
			_level = 6;

		if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED$1 || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0
			|| _strategy > Z_HUFFMAN_ONLY) {
			return Z_STREAM_ERROR$1;
		}

		strm.dstate = that;

		w_bits = bits;
		w_size = 1 << w_bits;
		w_mask = w_size - 1;

		hash_bits = memLevel + 7;
		hash_size = 1 << hash_bits;
		hash_mask = hash_size - 1;
		hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);

		win = new Uint8Array(w_size * 2);
		prev = [];
		head = [];

		lit_bufsize = 1 << (memLevel + 6); // 16K elements by default

		that.pending_buf = new Uint8Array(lit_bufsize * 4);
		pending_buf_size = lit_bufsize * 4;

		that.dist_buf = new Uint16Array(lit_bufsize);
		that.lc_buf = new Uint8Array(lit_bufsize);

		level = _level;

		strategy = _strategy;

		return deflateReset(strm);
	};

	that.deflateEnd = function () {
		if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
			return Z_STREAM_ERROR$1;
		}
		// Deallocate in reverse order of allocations:
		that.lc_buf = null;
		that.dist_buf = null;
		that.pending_buf = null;
		head = null;
		prev = null;
		win = null;
		// free
		that.dstate = null;
		return status == BUSY_STATE ? Z_DATA_ERROR$1 : Z_OK$1;
	};

	that.deflateParams = function (strm, _level, _strategy) {
		let err = Z_OK$1;

		if (_level == Z_DEFAULT_COMPRESSION) {
			_level = 6;
		}
		if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
			return Z_STREAM_ERROR$1;
		}

		if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
			// Flush the last buffer:
			err = strm.deflate(Z_PARTIAL_FLUSH);
		}

		if (level != _level) {
			level = _level;
			max_lazy_match = config_table[level].max_lazy;
			good_match = config_table[level].good_length;
			nice_match = config_table[level].nice_length;
			max_chain_length = config_table[level].max_chain;
		}
		strategy = _strategy;
		return err;
	};

	that.deflateSetDictionary = function (_strm, dictionary, dictLength) {
		let length = dictLength;
		let n, index = 0;

		if (!dictionary || status != INIT_STATE)
			return Z_STREAM_ERROR$1;

		if (length < MIN_MATCH)
			return Z_OK$1;
		if (length > w_size - MIN_LOOKAHEAD) {
			length = w_size - MIN_LOOKAHEAD;
			index = dictLength - length; // use the tail of the dictionary
		}
		win.set(dictionary.subarray(index, index + length), 0);

		strstart = length;
		block_start = length;

		// Insert all strings in the hash table (except for the last two bytes).
		// s->lookahead stays null, so s->ins_h will be recomputed at the next
		// call of fill_window.

		ins_h = win[0] & 0xff;
		ins_h = (((ins_h) << hash_shift) ^ (win[1] & 0xff)) & hash_mask;

		for (n = 0; n <= length - MIN_MATCH; n++) {
			ins_h = (((ins_h) << hash_shift) ^ (win[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
			prev[n & w_mask] = head[ins_h];
			head[ins_h] = n;
		}
		return Z_OK$1;
	};

	that.deflate = function (_strm, flush) {
		let i, header, level_flags, old_flush, bstate;

		if (flush > Z_FINISH$1 || flush < 0) {
			return Z_STREAM_ERROR$1;
		}

		if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH$1)) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_STREAM_ERROR$1)];
			return Z_STREAM_ERROR$1;
		}
		if (_strm.avail_out === 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		strm = _strm; // just in case
		old_flush = last_flush;
		last_flush = flush;

		// Write the zlib header
		if (status == INIT_STATE) {
			header = (Z_DEFLATED$1 + ((w_bits - 8) << 4)) << 8;
			level_flags = ((level - 1) & 0xff) >> 1;

			if (level_flags > 3)
				level_flags = 3;
			header |= (level_flags << 6);
			if (strstart !== 0)
				header |= PRESET_DICT$1;
			header += 31 - (header % 31);

			status = BUSY_STATE;
			putShortMSB(header);
		}

		// Flush as much pending output as possible
		if (that.pending !== 0) {
			strm.flush_pending();
			if (strm.avail_out === 0) {
				// console.log(" avail_out==0");
				// Since avail_out is 0, deflate will be called again with
				// more output space, but possibly with both pending and
				// avail_in equal to zero. There won't be anything to do,
				// but this is not an error situation so make sure we
				// return OK instead of BUF_ERROR at next call of deflate:
				last_flush = -1;
				return Z_OK$1;
			}

			// Make sure there is something to do and avoid duplicate
			// consecutive
			// flushes. For repeated and useless calls with Z_FINISH, we keep
			// returning Z_STREAM_END instead of Z_BUFF_ERROR.
		} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH$1) {
			strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		// User must not provide more input after the first FINISH:
		if (status == FINISH_STATE && strm.avail_in !== 0) {
			_strm.msg = z_errmsg[Z_NEED_DICT$1 - (Z_BUF_ERROR$1)];
			return Z_BUF_ERROR$1;
		}

		// Start a new block or continue the current one.
		if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH$1 && status != FINISH_STATE)) {
			bstate = -1;
			switch (config_table[level].func) {
				case STORED$1:
					bstate = deflate_stored(flush);
					break;
				case FAST:
					bstate = deflate_fast(flush);
					break;
				case SLOW:
					bstate = deflate_slow(flush);
					break;
			}

			if (bstate == FinishStarted || bstate == FinishDone) {
				status = FINISH_STATE;
			}
			if (bstate == NeedMore || bstate == FinishStarted) {
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR next call, see above
				}
				return Z_OK$1;
				// If flush != Z_NO_FLUSH && avail_out === 0, the next call
				// of deflate should use the same flush parameter to make sure
				// that the flush is complete. So we don't have to output an
				// empty block here, this will be done at next call. This also
				// ensures that for a very small output buffer, we emit at most
				// one empty block.
			}

			if (bstate == BlockDone) {
				if (flush == Z_PARTIAL_FLUSH) {
					_tr_align();
				} else { // FULL_FLUSH or SYNC_FLUSH
					_tr_stored_block(0, 0, false);
					// For a full flush, this empty block will be recognized
					// as a special marker by inflate_sync().
					if (flush == Z_FULL_FLUSH) {
						// state.head[s.hash_size-1]=0;
						for (i = 0; i < hash_size/*-1*/; i++)
							// forget history
							head[i] = 0;
					}
				}
				strm.flush_pending();
				if (strm.avail_out === 0) {
					last_flush = -1; // avoid BUF_ERROR at next call, see above
					return Z_OK$1;
				}
			}
		}

		if (flush != Z_FINISH$1)
			return Z_OK$1;
		return Z_STREAM_END$1;
	};
}

// ZStream

function ZStream$1() {
	const that = this;
	that.next_in_index = 0;
	that.next_out_index = 0;
	// that.next_in; // next input byte
	that.avail_in = 0; // number of bytes available at next_in
	that.total_in = 0; // total nb of input bytes read so far
	// that.next_out; // next output byte should be put there
	that.avail_out = 0; // remaining free space at next_out
	that.total_out = 0; // total nb of bytes output so far
	// that.msg;
	// that.dstate;
}

ZStream$1.prototype = {
	deflateInit(level, bits) {
		const that = this;
		that.dstate = new Deflate();
		if (!bits)
			bits = MAX_BITS$1;
		return that.dstate.deflateInit(that, level, bits);
	},

	deflate(flush) {
		const that = this;
		if (!that.dstate) {
			return Z_STREAM_ERROR$1;
		}
		return that.dstate.deflate(that, flush);
	},

	deflateEnd() {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		const ret = that.dstate.deflateEnd();
		that.dstate = null;
		return ret;
	},

	deflateParams(level, strategy) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		return that.dstate.deflateParams(that, level, strategy);
	},

	deflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.dstate)
			return Z_STREAM_ERROR$1;
		return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
	},

	// Read a new buffer from the current input stream, update the
	// total number of bytes read. All deflate() input goes through
	// this function so some applications may wish to modify it to avoid
	// allocating a large strm->next_in buffer and copying from it.
	// (See also flush_pending()).
	read_buf(buf, start, size) {
		const that = this;
		let len = that.avail_in;
		if (len > size)
			len = size;
		if (len === 0)
			return 0;
		that.avail_in -= len;
		buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
		that.next_in_index += len;
		that.total_in += len;
		return len;
	},

	// Flush as much pending output as possible. All deflate() output goes
	// through this function so some applications may wish to modify it
	// to avoid allocating a large strm->next_out buffer and copying into it.
	// (See also read_buf()).
	flush_pending() {
		const that = this;
		let len = that.dstate.pending;

		if (len > that.avail_out)
			len = that.avail_out;
		if (len === 0)
			return;

		// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index
		// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +
		// len)) {
		// console.log(that.dstate.pending_buf.length + ", " + that.dstate.pending_out + ", " + that.next_out.length + ", " +
		// that.next_out_index + ", " + len);
		// console.log("avail_out=" + that.avail_out);
		// }

		that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);

		that.next_out_index += len;
		that.dstate.pending_out += len;
		that.total_out += len;
		that.avail_out -= len;
		that.dstate.pending -= len;
		if (that.dstate.pending === 0) {
			that.dstate.pending_out = 0;
		}
	}
};

// Deflate

function ZipDeflate(options) {
	const that = this;
	const z = new ZStream$1();
	const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
	const flush = Z_NO_FLUSH$1;
	const buf = new Uint8Array(bufsize);
	let level = options ? options.level : Z_DEFAULT_COMPRESSION;
	if (typeof level == "undefined")
		level = Z_DEFAULT_COMPRESSION;
	z.deflateInit(level);
	z.next_out = buf;

	that.append = function (data, onprogress) {
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		if (!data.length)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(flush);
			if (err != Z_OK$1)
				throw new Error("deflating: " + z.msg);
			if (z.next_out_index)
				if (z.next_out_index == bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		let err, array, bufferIndex = 0, bufferSize = 0;
		const buffers = [];
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			err = z.deflate(Z_FINISH$1);
			if (err != Z_STREAM_END$1 && err != Z_OK$1)
				throw new Error("deflating: " + z.msg);
			if (bufsize - z.avail_out > 0)
				buffers.push(buf.slice(0, z.next_out_index));
			bufferSize += z.next_out_index;
		} while (z.avail_in > 0 || z.avail_out === 0);
		z.deflateEnd();
		array = new Uint8Array(bufferSize);
		buffers.forEach(function (chunk) {
			array.set(chunk, bufferIndex);
			bufferIndex += chunk.length;
		});
		return array;
	};
}

function getMaximumCompressedSize(uncompressedSize) {
	return uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

// deno-lint-ignore-file no-this-alias prefer-const

// Global

const MAX_BITS = 15;

const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR = -5;

const inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,
	0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

const MANY = 1440;

// JZlib version : "1.0.2"
const Z_NO_FLUSH = 0;
const Z_FINISH = 4;

// InfTree
const fixed_bl = 9;
const fixed_bd = 5;

const fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,
	0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,
	0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,
	0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,
	0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,
	35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,
	26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,
	7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,
	8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,
	8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,
	0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,
	81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,
	0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
	84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,
	0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,
	80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,
	0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,
	0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
	0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,
	193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,
	120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,
	227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,
	92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,
	249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,
	130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,
	181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,
	102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,
	221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
	8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,
	147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,
	85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,
	235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,
	141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,
	167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,
	107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,
	207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,
	127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];
const fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,
	8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,
	24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];

// Tables for deflate from PKZIP's appnote.txt.
const cplens = [ // Copy lengths for literal codes 257..285
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

// see note #13 above about 258
const cplext = [ // Extra bits for literal codes 257..285
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid
];

const cpdist = [ // Copy offsets for distance codes 0..29
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];

const cpdext = [ // Extra bits for distance codes
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

// If BMAX needs to be larger than 16, then h and x[] should be uLong.
const BMAX = 15; // maximum bit length of any code

function InfTree() {
	const that = this;

	let hn; // hufts used in space
	let v; // work area for huft_build
	let c; // bit length count table
	let r; // table entry for structure assignment
	let u; // table stack
	let x; // bit offsets, then code stack

	function huft_build(b, // code lengths in bits (all assumed <=
		// BMAX)
		bindex, n, // number of codes (assumed <= 288)
		s, // number of simple-valued codes (0..s-1)
		d, // list of base values for non-simple codes
		e, // list of extra bits for non-simple codes
		t, // result: starting table
		m, // maximum lookup bits, returns actual
		hp,// space for trees
		hn,// hufts used in space
		v // working area: values in order of bit length
	) {
		// Given a list of code lengths and a maximum table size, make a set of
		// tables to decode that set of codes. Return Z_OK on success,
		// Z_BUF_ERROR
		// if the given code set is incomplete (the tables are still built in
		// this
		// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set
		// of
		// lengths), or Z_MEM_ERROR if not enough memory.

		let a; // counter for codes of length k
		let f; // i repeats in table every f entries
		let g; // maximum code length
		let h; // table level
		let i; // counter, current code
		let j; // counter
		let k; // number of bits in current code
		let l; // bits per table (returned in m)
		let mask; // (1 << w) - 1, to avoid cc -O bug on HP
		let p; // pointer into c[], b[], or v[]
		let q; // points to current table
		let w; // bits before this table == (l * h)
		let xp; // pointer into x
		let y; // number of dummy codes added
		let z; // number of entries in current table

		// Generate counts for each bit length

		p = 0;
		i = n;
		do {
			c[b[bindex + p]]++;
			p++;
			i--; // assume all entries <= BMAX
		} while (i !== 0);

		if (c[0] == n) { // null input--all zero length codes
			t[0] = -1;
			m[0] = 0;
			return Z_OK;
		}

		// Find minimum and maximum length, bound *m by those
		l = m[0];
		for (j = 1; j <= BMAX; j++)
			if (c[j] !== 0)
				break;
		k = j; // minimum code length
		if (l < j) {
			l = j;
		}
		for (i = BMAX; i !== 0; i--) {
			if (c[i] !== 0)
				break;
		}
		g = i; // maximum code length
		if (l > i) {
			l = i;
		}
		m[0] = l;

		// Adjust last length count to fill out codes, if needed
		for (y = 1 << j; j < i; j++, y <<= 1) {
			if ((y -= c[j]) < 0) {
				return Z_DATA_ERROR;
			}
		}
		if ((y -= c[i]) < 0) {
			return Z_DATA_ERROR;
		}
		c[i] += y;

		// Generate starting offsets into the value table for each length
		x[1] = j = 0;
		p = 1;
		xp = 2;
		while (--i !== 0) { // note that i == g from above
			x[xp] = (j += c[p]);
			xp++;
			p++;
		}

		// Make a table of values in order of bit lengths
		i = 0;
		p = 0;
		do {
			if ((j = b[bindex + p]) !== 0) {
				v[x[j]++] = i;
			}
			p++;
		} while (++i < n);
		n = x[g]; // set n to length of v

		// Generate the Huffman codes and for each, make the table entries
		x[0] = i = 0; // first Huffman code is zero
		p = 0; // grab values in bit order
		h = -1; // no tables yet--level -1
		w = -l; // bits decoded == (l * h)
		u[0] = 0; // just to keep compilers happy
		q = 0; // ditto
		z = 0; // ditto

		// go through the bit lengths (k already is bits in shortest code)
		for (; k <= g; k++) {
			a = c[k];
			while (a-- !== 0) {
				// here i is the Huffman code of length k bits for value *p
				// make tables up to required level
				while (k > w + l) {
					h++;
					w += l; // previous table always l bits
					// compute minimum size table less than or equal to l bits
					z = g - w;
					z = (z > l) ? l : z; // table size upper limit
					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
						// too few codes for
						// k-w bit table
						f -= a + 1; // deduct codes from patterns left
						xp = k;
						if (j < z) {
							while (++j < z) { // try smaller tables up to z bits
								if ((f <<= 1) <= c[++xp])
									break; // enough codes to use up j bits
								f -= c[xp]; // else deduct codes from patterns
							}
						}
					}
					z = 1 << j; // table entries for j-bit table

					// allocate new table
					if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)
						return Z_DATA_ERROR; // overflow of MANY
					}
					u[h] = q = /* hp+ */hn[0]; // DEBUG
					hn[0] += z;

					// connect to last table, if there is one
					if (h !== 0) {
						x[h] = i; // save pattern for backing up
						r[0] = /* (byte) */j; // bits in this table
						r[1] = /* (byte) */l; // bits to dump before this table
						j = i >>> (w - l);
						r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table
						hp.set(r, (u[h - 1] + j) * 3);
						// to
						// last
						// table
					} else {
						t[0] = q; // first table is returned result
					}
				}

				// set up table entry in r
				r[1] = /* (byte) */(k - w);
				if (p >= n) {
					r[0] = 128 + 64; // out of values--invalid code
				} else if (v[p] < s) {
					r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is
					// end-of-block
					r[2] = v[p++]; // simple code is just the value
				} else {
					r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look
					// up in lists
					r[2] = d[v[p++] - s];
				}

				// fill code-like entries with r
				f = 1 << (k - w);
				for (j = i >>> w; j < z; j += f) {
					hp.set(r, (q + j) * 3);
				}

				// backwards increment the k-bit code i
				for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {
					i ^= j;
				}
				i ^= j;

				// backup over finished tables
				mask = (1 << w) - 1; // needed on HP, cc -O bug
				while ((i & mask) != x[h]) {
					h--; // don't need to update q
					w -= l;
					mask = (1 << w) - 1;
				}
			}
		}
		// Return Z_BUF_ERROR if we were given an incomplete table
		return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
	}

	function initWorkArea(vsize) {
		let i;
		if (!hn) {
			hn = []; // []; //new Array(1);
			v = []; // new Array(vsize);
			c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
			r = []; // new Array(3);
			u = new Int32Array(BMAX); // new Array(BMAX);
			x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
		}
		if (v.length < vsize) {
			v = []; // new Array(vsize);
		}
		for (i = 0; i < vsize; i++) {
			v[i] = 0;
		}
		for (i = 0; i < BMAX + 1; i++) {
			c[i] = 0;
		}
		for (i = 0; i < 3; i++) {
			r[i] = 0;
		}
		// for(int i=0; i<BMAX; i++){u[i]=0;}
		u.set(c.subarray(0, BMAX), 0);
		// for(int i=0; i<BMAX+1; i++){x[i]=0;}
		x.set(c.subarray(0, BMAX + 1), 0);
	}

	that.inflate_trees_bits = function (c, // 19 code lengths
		bb, // bits tree desired/actual depth
		tb, // bits tree result
		hp, // space for trees
		z // for messages
	) {
		let result;
		initWorkArea(19);
		hn[0] = 0;
		result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);

		if (result == Z_DATA_ERROR) {
			z.msg = "oversubscribed dynamic bit lengths tree";
		} else if (result == Z_BUF_ERROR || bb[0] === 0) {
			z.msg = "incomplete dynamic bit lengths tree";
			result = Z_DATA_ERROR;
		}
		return result;
	};

	that.inflate_trees_dynamic = function (nl, // number of literal/length codes
		nd, // number of distance codes
		c, // that many (total) code lengths
		bl, // literal desired/actual bit depth
		bd, // distance desired/actual bit depth
		tl, // literal/length tree result
		td, // distance tree result
		hp, // space for trees
		z // for messages
	) {
		let result;

		// build literal/length tree
		initWorkArea(288);
		hn[0] = 0;
		result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
		if (result != Z_OK || bl[0] === 0) {
			if (result == Z_DATA_ERROR) {
				z.msg = "oversubscribed literal/length tree";
			} else if (result != Z_MEM_ERROR) {
				z.msg = "incomplete literal/length tree";
				result = Z_DATA_ERROR;
			}
			return result;
		}

		// build distance tree
		initWorkArea(288);
		result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);

		if (result != Z_OK || (bd[0] === 0 && nl > 257)) {
			if (result == Z_DATA_ERROR) {
				z.msg = "oversubscribed distance tree";
			} else if (result == Z_BUF_ERROR) {
				z.msg = "incomplete distance tree";
				result = Z_DATA_ERROR;
			} else if (result != Z_MEM_ERROR) {
				z.msg = "empty distance tree with lengths";
				result = Z_DATA_ERROR;
			}
			return result;
		}

		return Z_OK;
	};

}

InfTree.inflate_trees_fixed = function (bl, // literal desired/actual bit depth
	bd, // distance desired/actual bit depth
	tl,// literal/length tree result
	td// distance tree result
) {
	bl[0] = fixed_bl;
	bd[0] = fixed_bd;
	tl[0] = fixed_tl;
	td[0] = fixed_td;
	return Z_OK;
};

// InfCodes

// waiting for "i:"=input,
// "o:"=output,
// "x:"=nothing
const START = 0; // x: set up for LEN
const LEN = 1; // i: get length/literal/eob next
const LENEXT = 2; // i: getting length extra (have base)
const DIST = 3; // i: get distance next
const DISTEXT = 4;// i: getting distance extra
const COPY = 5; // o: copying bytes in win, waiting
// for space
const LIT = 6; // o: got literal, waiting for output
// space
const WASH = 7; // o: got eob, possibly still output
// waiting
const END = 8; // x: got eob and all data flushed
const BADCODE = 9;// x: got error

function InfCodes() {
	const that = this;

	let mode; // current inflate_codes mode

	// mode dependent information
	let len = 0;

	let tree; // pointer into tree
	let tree_index = 0;
	let need = 0; // bits needed

	let lit = 0;

	// if EXT or COPY, where and how much
	let get = 0; // bits to get for extra
	let dist = 0; // distance back to copy from

	let lbits = 0; // ltree bits decoded per branch
	let dbits = 0; // dtree bits decoder per branch
	let ltree; // literal/length/eob tree
	let ltree_index = 0; // literal/length/eob tree
	let dtree; // distance tree
	let dtree_index = 0; // distance tree

	// Called with number of bytes left to write in win at least 258
	// (the maximum string length) and number of input bytes available
	// at least ten. The ten bytes are six bytes for the longest length/
	// distance pair plus four bytes for overloading the bit buffer.

	function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
		let t; // temporary pointer
		let tp; // temporary pointer
		let tp_index; // temporary pointer
		let e; // extra bits or operation
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let ml; // mask for literal/length tree
		let md; // mask for distance tree
		let c; // bytes to copy
		let d; // distance back to copy from
		let r; // copy source pointer

		let tp_index_t_3; // (tp_index+t)*3

		// load input, output, bit values
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// initialize masks
		ml = inflate_mask[bl];
		md = inflate_mask[bd];

		// do until not enough input or output space for fast loop
		do { // assume called with m >= 258 && n >= 10
			// get literal/length code
			while (k < (20)) { // max bits for literal/length code
				n--;
				b |= (z.read_byte(p++) & 0xff) << k;
				k += 8;
			}

			t = b & ml;
			tp = tl;
			tp_index = tl_index;
			tp_index_t_3 = (tp_index + t) * 3;
			if ((e = tp[tp_index_t_3]) === 0) {
				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
				m--;
				continue;
			}
			do {

				b >>= (tp[tp_index_t_3 + 1]);
				k -= (tp[tp_index_t_3 + 1]);

				if ((e & 16) !== 0) {
					e &= 15;
					c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);

					b >>= e;
					k -= e;

					// decode distance base of block to copy
					while (k < (15)) { // max bits for distance code
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					t = b & md;
					tp = td;
					tp_index = td_index;
					tp_index_t_3 = (tp_index + t) * 3;
					e = tp[tp_index_t_3];

					do {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						if ((e & 16) !== 0) {
							// get extra bits to add to distance base
							e &= 15;
							while (k < (e)) { // get extra bits (up to 13)
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);

							b >>= (e);
							k -= (e);

							// do the copy
							m -= c;
							if (q >= d) { // offset before dest
								// just copy
								r = q - d;
								if (q - r > 0 && 2 > (q - r)) {
									s.win[q++] = s.win[r++]; // minimum
									// count is
									// three,
									s.win[q++] = s.win[r++]; // so unroll
									// loop a
									// little
									c -= 2;
								} else {
									s.win.set(s.win.subarray(r, r + 2), q);
									q += 2;
									r += 2;
									c -= 2;
								}
							} else { // else offset after destination
								r = q - d;
								do {
									r += s.end; // force pointer in win
								} while (r < 0); // covers invalid distances
								e = s.end - r;
								if (c > e) { // if source crosses,
									c -= e; // wrapped copy
									if (q - r > 0 && e > (q - r)) {
										do {
											s.win[q++] = s.win[r++];
										} while (--e !== 0);
									} else {
										s.win.set(s.win.subarray(r, r + e), q);
										q += e;
										r += e;
										e = 0;
									}
									r = 0; // copy rest from start of win
								}

							}

							// copy all or what's left
							if (q - r > 0 && c > (q - r)) {
								do {
									s.win[q++] = s.win[r++];
								} while (--c !== 0);
							} else {
								s.win.set(s.win.subarray(r, r + c), q);
								q += c;
								r += c;
								c = 0;
							}
							break;
						} else if ((e & 64) === 0) {
							t += tp[tp_index_t_3 + 2];
							t += (b & inflate_mask[e]);
							tp_index_t_3 = (tp_index + t) * 3;
							e = tp[tp_index_t_3];
						} else {
							z.msg = "invalid distance code";

							c = z.avail_in - n;
							c = (k >> 3) < c ? k >> 3 : c;
							n += c;
							p -= c;
							k -= c << 3;

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;

							return Z_DATA_ERROR;
						}
						// eslint-disable-next-line no-constant-condition
					} while (true);
					break;
				}

				if ((e & 64) === 0) {
					t += tp[tp_index_t_3 + 2];
					t += (b & inflate_mask[e]);
					tp_index_t_3 = (tp_index + t) * 3;
					if ((e = tp[tp_index_t_3]) === 0) {

						b >>= (tp[tp_index_t_3 + 1]);
						k -= (tp[tp_index_t_3 + 1]);

						s.win[q++] = /* (byte) */tp[tp_index_t_3 + 2];
						m--;
						break;
					}
				} else if ((e & 32) !== 0) {

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_STREAM_END;
				} else {
					z.msg = "invalid literal/length code";

					c = z.avail_in - n;
					c = (k >> 3) < c ? k >> 3 : c;
					n += c;
					p -= c;
					k -= c << 3;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;

					return Z_DATA_ERROR;
				}
				// eslint-disable-next-line no-constant-condition
			} while (true);
		} while (m >= 258 && n >= 10);

		// not enough input or output--restore pointers and return
		c = z.avail_in - n;
		c = (k >> 3) < c ? k >> 3 : c;
		n += c;
		p -= c;
		k -= c << 3;

		s.bitb = b;
		s.bitk = k;
		z.avail_in = n;
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		s.write = q;

		return Z_OK;
	}

	that.init = function (bl, bd, tl, tl_index, td, td_index) {
		mode = START;
		lbits = /* (byte) */bl;
		dbits = /* (byte) */bd;
		ltree = tl;
		ltree_index = tl_index;
		dtree = td;
		dtree_index = td_index;
		tree = null;
	};

	that.proc = function (s, z, r) {
		let j; // temporary storage
		let tindex; // temporary pointer
		let e; // extra bits or operation
		let b = 0; // bit buffer
		let k = 0; // bits in bit buffer
		let p = 0; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer
		let f; // pointer to copy strings from

		// copy input/output information to locals (UPDATE macro restores)
		p = z.next_in_index;
		n = z.avail_in;
		b = s.bitb;
		k = s.bitk;
		q = s.write;
		m = q < s.read ? s.read - q - 1 : s.end - q;

		// process input and output based on current state
		// eslint-disable-next-line no-constant-condition
		while (true) {
			switch (mode) {
				// waiting for "i:"=input, "o:"=output, "x:"=nothing
				case START: // x: set up for LEN
					if (m >= 258 && n >= 10) {

						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);

						p = z.next_in_index;
						n = z.avail_in;
						b = s.bitb;
						k = s.bitk;
						q = s.write;
						m = q < s.read ? s.read - q - 1 : s.end - q;

						if (r != Z_OK) {
							mode = r == Z_STREAM_END ? WASH : BADCODE;
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;

					mode = LEN;
				/* falls through */
				case LEN: // i: get length/literal/eob next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>>= (tree[tindex + 1]);
					k -= (tree[tindex + 1]);

					e = tree[tindex];

					if (e === 0) { // literal
						lit = tree[tindex + 2];
						mode = LIT;
						break;
					}
					if ((e & 16) !== 0) { // length
						get = e & 15;
						len = tree[tindex + 2];
						mode = LENEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					if ((e & 32) !== 0) { // end of block
						mode = WASH;
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid literal/length code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case LENEXT: // i: getting length extra (have base)
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					len += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = DIST;
				/* falls through */
				case DIST: // i: get distance next
					j = need;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					tindex = (tree_index + (b & inflate_mask[j])) * 3;

					b >>= tree[tindex + 1];
					k -= tree[tindex + 1];

					e = (tree[tindex]);
					if ((e & 16) !== 0) { // distance
						get = e & 15;
						dist = tree[tindex + 2];
						mode = DISTEXT;
						break;
					}
					if ((e & 64) === 0) { // next table
						need = e;
						tree_index = tindex / 3 + tree[tindex + 2];
						break;
					}
					mode = BADCODE; // invalid code
					z.msg = "invalid distance code";
					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case DISTEXT: // i: getting distance extra
					j = get;

					while (k < (j)) {
						if (n !== 0)
							r = Z_OK;
						else {

							s.bitb = b;
							s.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							s.write = q;
							return s.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					dist += (b & inflate_mask[j]);

					b >>= j;
					k -= j;

					mode = COPY;
				/* falls through */
				case COPY: // o: copying bytes in win, waiting for space
					f = q - dist;
					while (f < 0) { // modulo win size-"while" instead
						f += s.end; // of "if" handles invalid distances
					}
					while (len !== 0) {

						if (m === 0) {
							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.write = q;
								r = s.inflate_flush(z, r);
								q = s.write;
								m = q < s.read ? s.read - q - 1 : s.end - q;

								if (q == s.end && s.read !== 0) {
									q = 0;
									m = q < s.read ? s.read - q - 1 : s.end - q;
								}

								if (m === 0) {
									s.bitb = b;
									s.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									s.write = q;
									return s.inflate_flush(z, r);
								}
							}
						}

						s.win[q++] = s.win[f++];
						m--;

						if (f == s.end)
							f = 0;
						len--;
					}
					mode = START;
					break;
				case LIT: // o: got literal, waiting for output space
					if (m === 0) {
						if (q == s.end && s.read !== 0) {
							q = 0;
							m = q < s.read ? s.read - q - 1 : s.end - q;
						}
						if (m === 0) {
							s.write = q;
							r = s.inflate_flush(z, r);
							q = s.write;
							m = q < s.read ? s.read - q - 1 : s.end - q;

							if (q == s.end && s.read !== 0) {
								q = 0;
								m = q < s.read ? s.read - q - 1 : s.end - q;
							}
							if (m === 0) {
								s.bitb = b;
								s.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								s.write = q;
								return s.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					s.win[q++] = /* (byte) */lit;
					m--;

					mode = START;
					break;
				case WASH: // o: got eob, possibly more output
					if (k > 7) { // return unused byte, if any
						k -= 8;
						n++;
						p--; // can always return one
					}

					s.write = q;
					r = s.inflate_flush(z, r);
					q = s.write;
					m = q < s.read ? s.read - q - 1 : s.end - q;

					if (s.read != s.write) {
						s.bitb = b;
						s.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						s.write = q;
						return s.inflate_flush(z, r);
					}
					mode = END;
				/* falls through */
				case END:
					r = Z_STREAM_END;
					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				case BADCODE: // x: got error

					r = Z_DATA_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					s.bitb = b;
					s.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					s.write = q;
					return s.inflate_flush(z, r);
			}
		}
	};

	that.free = function () {
		// ZFREE(z, c);
	};

}

// InfBlocks

// Table for deflate from PKZIP's appnote.txt.
const border = [ // Order of the bit length code lengths
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

const TYPE = 0; // get type bits (3, including end bit)
const LENS = 1; // get lengths for stored
const STORED = 2;// processing stored block
const TABLE = 3; // get table lengths
const BTREE = 4; // get bit lengths tree for a dynamic
// block
const DTREE = 5; // get length, distance trees for a
// dynamic block
const CODES = 6; // processing fixed or dynamic block
const DRY = 7; // output remaining win bytes
const DONELOCKS = 8; // finished last block, done
const BADBLOCKS = 9; // ot a data error--stuck here

function InfBlocks(z, w) {
	const that = this;

	let mode = TYPE; // current inflate_block mode

	let left = 0; // if STORED, bytes left to copy

	let table = 0; // table lengths (14 bits)
	let index = 0; // index into blens (or border)
	let blens; // bit lengths of codes
	const bb = [0]; // bit length tree depth
	const tb = [0]; // bit length decoding tree

	const codes = new InfCodes(); // if CODES, current state

	let last = 0; // true if this block is the last block

	let hufts = new Int32Array(MANY * 3); // single malloc for tree space
	const check = 0; // check on output
	const inftree = new InfTree();

	that.bitk = 0; // bits in bit buffer
	that.bitb = 0; // bit buffer
	that.win = new Uint8Array(w); // sliding win
	that.end = w; // one byte after sliding win
	that.read = 0; // win read pointer
	that.write = 0; // win write pointer

	that.reset = function (z, c) {
		if (c)
			c[0] = check;
		// if (mode == BTREE || mode == DTREE) {
		// }
		if (mode == CODES) {
			codes.free(z);
		}
		mode = TYPE;
		that.bitk = 0;
		that.bitb = 0;
		that.read = that.write = 0;
	};

	that.reset(z, null);

	// copy as much as possible from the sliding win to the output area
	that.inflate_flush = function (z, r) {
		let n;
		let p;
		let q;

		// local copies of source and destination pointers
		p = z.next_out_index;
		q = that.read;

		// compute number of bytes to copy as far as end of win
		n = /* (int) */((q <= that.write ? that.write : that.end) - q);
		if (n > z.avail_out)
			n = z.avail_out;
		if (n !== 0 && r == Z_BUF_ERROR)
			r = Z_OK;

		// update counters
		z.avail_out -= n;
		z.total_out += n;

		// copy as far as end of win
		z.next_out.set(that.win.subarray(q, q + n), p);
		p += n;
		q += n;

		// see if more to copy at beginning of win
		if (q == that.end) {
			// wrap pointers
			q = 0;
			if (that.write == that.end)
				that.write = 0;

			// compute bytes to copy
			n = that.write - q;
			if (n > z.avail_out)
				n = z.avail_out;
			if (n !== 0 && r == Z_BUF_ERROR)
				r = Z_OK;

			// update counters
			z.avail_out -= n;
			z.total_out += n;

			// copy
			z.next_out.set(that.win.subarray(q, q + n), p);
			p += n;
			q += n;
		}

		// update pointers
		z.next_out_index = p;
		that.read = q;

		// done
		return r;
	};

	that.proc = function (z, r) {
		let t; // temporary storage
		let b; // bit buffer
		let k; // bits in bit buffer
		let p; // input data pointer
		let n; // bytes available there
		let q; // output win write pointer
		let m; // bytes to end of win or read pointer

		let i;

		// copy input/output information to locals (UPDATE macro restores)
		// {
		p = z.next_in_index;
		n = z.avail_in;
		b = that.bitb;
		k = that.bitk;
		// }
		// {
		q = that.write;
		m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
		// }

		// process input based on current state
		// DEBUG dtree
		// eslint-disable-next-line no-constant-condition
		while (true) {
			let bl, bd, tl, td, bl_, bd_, tl_, td_;
			switch (mode) {
				case TYPE:

					while (k < (3)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}
					t = /* (int) */(b & 7);
					last = t & 1;

					switch (t >>> 1) {
						case 0: // stored
							// {
							b >>>= (3);
							k -= (3);
							// }
							t = k & 7; // go to byte boundary

							// {
							b >>>= (t);
							k -= (t);
							// }
							mode = LENS; // get length of stored block
							break;
						case 1: // fixed
							// {
							bl = []; // new Array(1);
							bd = []; // new Array(1);
							tl = [[]]; // new Array(1);
							td = [[]]; // new Array(1);

							InfTree.inflate_trees_fixed(bl, bd, tl, td);
							codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
							// }

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = CODES;
							break;
						case 2: // dynamic

							// {
							b >>>= (3);
							k -= (3);
							// }

							mode = TABLE;
							break;
						case 3: // illegal

							// {
							b >>>= (3);
							k -= (3);
							// }
							mode = BADBLOCKS;
							z.msg = "invalid block type";
							r = Z_DATA_ERROR;

							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
					}
					break;
				case LENS:

					while (k < (32)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}
						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {
						mode = BADBLOCKS;
						z.msg = "invalid stored block lengths";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					left = (b & 0xffff);
					b = k = 0; // dump bits
					mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);
					break;
				case STORED:
					if (n === 0) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					if (m === 0) {
						if (q == that.end && that.read !== 0) {
							q = 0;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
						}
						if (m === 0) {
							that.write = q;
							r = that.inflate_flush(z, r);
							q = that.write;
							m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							if (q == that.end && that.read !== 0) {
								q = 0;
								m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
							}
							if (m === 0) {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
						}
					}
					r = Z_OK;

					t = left;
					if (t > n)
						t = n;
					if (t > m)
						t = m;
					that.win.set(z.read_buf(p, t), q);
					p += t;
					n -= t;
					q += t;
					m -= t;
					if ((left -= t) !== 0)
						break;
					mode = last !== 0 ? DRY : TYPE;
					break;
				case TABLE:

					while (k < (14)) {
						if (n !== 0) {
							r = Z_OK;
						} else {
							that.bitb = b;
							that.bitk = k;
							z.avail_in = n;
							z.total_in += p - z.next_in_index;
							z.next_in_index = p;
							that.write = q;
							return that.inflate_flush(z, r);
						}

						n--;
						b |= (z.read_byte(p++) & 0xff) << k;
						k += 8;
					}

					table = t = (b & 0x3fff);
					if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
						mode = BADBLOCKS;
						z.msg = "too many length or distance symbols";
						r = Z_DATA_ERROR;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
					if (!blens || blens.length < t) {
						blens = []; // new Array(t);
					} else {
						for (i = 0; i < t; i++) {
							blens[i] = 0;
						}
					}

					// {
					b >>>= (14);
					k -= (14);
					// }

					index = 0;
					mode = BTREE;
				/* falls through */
				case BTREE:
					while (index < 4 + (table >>> 10)) {
						while (k < (3)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						blens[border[index++]] = b & 7;

						// {
						b >>>= (3);
						k -= (3);
						// }
					}

					while (index < 19) {
						blens[border[index++]] = 0;
					}

					bb[0] = 7;
					t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
					if (t != Z_OK) {
						r = t;
						if (r == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}

					index = 0;
					mode = DTREE;
				/* falls through */
				case DTREE:
					// eslint-disable-next-line no-constant-condition
					while (true) {
						t = table;
						if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {
							break;
						}

						let j, c;

						t = bb[0];

						while (k < (t)) {
							if (n !== 0) {
								r = Z_OK;
							} else {
								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}
							n--;
							b |= (z.read_byte(p++) & 0xff) << k;
							k += 8;
						}

						// if (tb[0] == -1) {
						// System.err.println("null...");
						// }

						t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
						c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];

						if (c < 16) {
							b >>>= (t);
							k -= (t);
							blens[index++] = c;
						} else { // c == 16..18
							i = c == 18 ? 7 : c - 14;
							j = c == 18 ? 11 : 3;

							while (k < (t + i)) {
								if (n !== 0) {
									r = Z_OK;
								} else {
									that.bitb = b;
									that.bitk = k;
									z.avail_in = n;
									z.total_in += p - z.next_in_index;
									z.next_in_index = p;
									that.write = q;
									return that.inflate_flush(z, r);
								}
								n--;
								b |= (z.read_byte(p++) & 0xff) << k;
								k += 8;
							}

							b >>>= (t);
							k -= (t);

							j += (b & inflate_mask[i]);

							b >>>= (i);
							k -= (i);

							i = index;
							t = table;
							if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {
								blens = null;
								mode = BADBLOCKS;
								z.msg = "invalid bit length repeat";
								r = Z_DATA_ERROR;

								that.bitb = b;
								that.bitk = k;
								z.avail_in = n;
								z.total_in += p - z.next_in_index;
								z.next_in_index = p;
								that.write = q;
								return that.inflate_flush(z, r);
							}

							c = c == 16 ? blens[i - 1] : 0;
							do {
								blens[i++] = c;
							} while (--j !== 0);
							index = i;
						}
					}

					tb[0] = -1;
					// {
					bl_ = []; // new Array(1);
					bd_ = []; // new Array(1);
					tl_ = []; // new Array(1);
					td_ = []; // new Array(1);
					bl_[0] = 9; // must be <= 9 for lookahead assumptions
					bd_[0] = 6; // must be <= 9 for lookahead assumptions

					t = table;
					t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);

					if (t != Z_OK) {
						if (t == Z_DATA_ERROR) {
							blens = null;
							mode = BADBLOCKS;
						}
						r = t;

						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
					// }
					mode = CODES;
				/* falls through */
				case CODES:
					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;

					if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {
						return that.inflate_flush(z, r);
					}
					r = Z_OK;
					codes.free(z);

					p = z.next_in_index;
					n = z.avail_in;
					b = that.bitb;
					k = that.bitk;
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);

					if (last === 0) {
						mode = TYPE;
						break;
					}
					mode = DRY;
				/* falls through */
				case DRY:
					that.write = q;
					r = that.inflate_flush(z, r);
					q = that.write;
					m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
					if (that.read != that.write) {
						that.bitb = b;
						that.bitk = k;
						z.avail_in = n;
						z.total_in += p - z.next_in_index;
						z.next_in_index = p;
						that.write = q;
						return that.inflate_flush(z, r);
					}
					mode = DONELOCKS;
				/* falls through */
				case DONELOCKS:
					r = Z_STREAM_END;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
				case BADBLOCKS:
					r = Z_DATA_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);

				default:
					r = Z_STREAM_ERROR;

					that.bitb = b;
					that.bitk = k;
					z.avail_in = n;
					z.total_in += p - z.next_in_index;
					z.next_in_index = p;
					that.write = q;
					return that.inflate_flush(z, r);
			}
		}
	};

	that.free = function (z) {
		that.reset(z, null);
		that.win = null;
		hufts = null;
		// ZFREE(z, s);
	};

	that.set_dictionary = function (d, start, n) {
		that.win.set(d.subarray(start, start + n), 0);
		that.read = that.write = n;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
	that.sync_point = function () {
		return mode == LENS ? 1 : 0;
	};

}

// Inflate

// preset dictionary flag in zlib header
const PRESET_DICT = 0x20;

const Z_DEFLATED = 8;

const METHOD = 0; // waiting for method byte
const FLAG = 1; // waiting for flag byte
const DICT4 = 2; // four dictionary check bytes to go
const DICT3 = 3; // three dictionary check bytes to go
const DICT2 = 4; // two dictionary check bytes to go
const DICT1 = 5; // one dictionary check byte to go
const DICT0 = 6; // waiting for inflateSetDictionary
const BLOCKS = 7; // decompressing blocks
const DONE = 12; // finished check, done
const BAD = 13; // got an error--stay here

const mark = [0, 0, 0xff, 0xff];

function Inflate() {
	const that = this;

	that.mode = 0; // current inflate mode

	// mode dependent information
	that.method = 0; // if FLAGS, method byte

	// if CHECK, check values to compare
	that.was = [0]; // new Array(1); // computed check value
	that.need = 0; // stream check value

	// if BAD, inflateSync's marker bytes count
	that.marker = 0;

	// mode independent information
	that.wbits = 0; // log2(win size) (8..15, defaults to 15)

	// this.blocks; // current inflate_blocks state

	function inflateReset(z) {
		if (!z || !z.istate)
			return Z_STREAM_ERROR;

		z.total_in = z.total_out = 0;
		z.msg = null;
		z.istate.mode = BLOCKS;
		z.istate.blocks.reset(z, null);
		return Z_OK;
	}

	that.inflateEnd = function (z) {
		if (that.blocks)
			that.blocks.free(z);
		that.blocks = null;
		// ZFREE(z, z->state);
		return Z_OK;
	};

	that.inflateInit = function (z, w) {
		z.msg = null;
		that.blocks = null;

		// set win size
		if (w < 8 || w > 15) {
			that.inflateEnd(z);
			return Z_STREAM_ERROR;
		}
		that.wbits = w;

		z.istate.blocks = new InfBlocks(z, 1 << w);

		// reset state
		inflateReset(z);
		return Z_OK;
	};

	that.inflate = function (z, f) {
		let r;
		let b;

		if (!z || !z.istate || !z.next_in)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
		r = Z_BUF_ERROR;
		// eslint-disable-next-line no-constant-condition
		while (true) {
			switch (istate.mode) {
				case METHOD:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					if (((istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {
						istate.mode = BAD;
						z.msg = "unknown compression method";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					if ((istate.method >> 4) + 8 > istate.wbits) {
						istate.mode = BAD;
						z.msg = "invalid win size";
						istate.marker = 5; // can't try inflateSync
						break;
					}
					istate.mode = FLAG;
				/* falls through */
				case FLAG:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					b = (z.read_byte(z.next_in_index++)) & 0xff;

					if ((((istate.method << 8) + b) % 31) !== 0) {
						istate.mode = BAD;
						z.msg = "incorrect header check";
						istate.marker = 5; // can't try inflateSync
						break;
					}

					if ((b & PRESET_DICT) === 0) {
						istate.mode = BLOCKS;
						break;
					}
					istate.mode = DICT4;
				/* falls through */
				case DICT4:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;
					istate.mode = DICT3;
				/* falls through */
				case DICT3:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;
					istate.mode = DICT2;
				/* falls through */
				case DICT2:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;
					istate.mode = DICT1;
				/* falls through */
				case DICT1:

					if (z.avail_in === 0)
						return r;
					r = f;

					z.avail_in--;
					z.total_in++;
					istate.need += (z.read_byte(z.next_in_index++) & 0xff);
					istate.mode = DICT0;
					return Z_NEED_DICT;
				case DICT0:
					istate.mode = BAD;
					z.msg = "need dictionary";
					istate.marker = 0; // can try inflateSync
					return Z_STREAM_ERROR;
				case BLOCKS:

					r = istate.blocks.proc(z, r);
					if (r == Z_DATA_ERROR) {
						istate.mode = BAD;
						istate.marker = 0; // can try inflateSync
						break;
					}
					if (r == Z_OK) {
						r = f;
					}
					if (r != Z_STREAM_END) {
						return r;
					}
					r = f;
					istate.blocks.reset(z, istate.was);
					istate.mode = DONE;
				/* falls through */
				case DONE:
					z.avail_in = 0;
					return Z_STREAM_END;
				case BAD:
					return Z_DATA_ERROR;
				default:
					return Z_STREAM_ERROR;
			}
		}
	};

	that.inflateSetDictionary = function (z, dictionary, dictLength) {
		let index = 0, length = dictLength;
		if (!z || !z.istate || z.istate.mode != DICT0)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		if (length >= (1 << istate.wbits)) {
			length = (1 << istate.wbits) - 1;
			index = dictLength - length;
		}
		istate.blocks.set_dictionary(dictionary, index, length);
		istate.mode = BLOCKS;
		return Z_OK;
	};

	that.inflateSync = function (z) {
		let n; // number of bytes to look at
		let p; // pointer to bytes
		let m; // number of marker bytes found in a row
		let r, w; // temporaries to save total_in and total_out

		// set up
		if (!z || !z.istate)
			return Z_STREAM_ERROR;
		const istate = z.istate;
		if (istate.mode != BAD) {
			istate.mode = BAD;
			istate.marker = 0;
		}
		if ((n = z.avail_in) === 0)
			return Z_BUF_ERROR;
		p = z.next_in_index;
		m = istate.marker;

		// search
		while (n !== 0 && m < 4) {
			if (z.read_byte(p) == mark[m]) {
				m++;
			} else if (z.read_byte(p) !== 0) {
				m = 0;
			} else {
				m = 4 - m;
			}
			p++;
			n--;
		}

		// restore
		z.total_in += p - z.next_in_index;
		z.next_in_index = p;
		z.avail_in = n;
		istate.marker = m;

		// return no joy or set up to restart on a new block
		if (m != 4) {
			return Z_DATA_ERROR;
		}
		r = z.total_in;
		w = z.total_out;
		inflateReset(z);
		z.total_in = r;
		z.total_out = w;
		istate.mode = BLOCKS;
		return Z_OK;
	};

	// Returns true if inflate is currently at the end of a block generated
	// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
	// implementation to provide an additional safety check. PPP uses
	// Z_SYNC_FLUSH
	// but removes the length bytes of the resulting empty stored block. When
	// decompressing, PPP checks that at the end of input packet, inflate is
	// waiting for these length bytes.
	that.inflateSyncPoint = function (z) {
		if (!z || !z.istate || !z.istate.blocks)
			return Z_STREAM_ERROR;
		return z.istate.blocks.sync_point();
	};
}

// ZStream

function ZStream() {
}

ZStream.prototype = {
	inflateInit(bits) {
		const that = this;
		that.istate = new Inflate();
		if (!bits)
			bits = MAX_BITS;
		return that.istate.inflateInit(that, bits);
	},

	inflate(f) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflate(that, f);
	},

	inflateEnd() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		const ret = that.istate.inflateEnd(that);
		that.istate = null;
		return ret;
	},

	inflateSync() {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflateSync(that);
	},
	inflateSetDictionary(dictionary, dictLength) {
		const that = this;
		if (!that.istate)
			return Z_STREAM_ERROR;
		return that.istate.inflateSetDictionary(that, dictionary, dictLength);
	},
	read_byte(start) {
		const that = this;
		return that.next_in[start];
	},
	read_buf(start, size) {
		const that = this;
		return that.next_in.subarray(start, start + size);
	}
};

// Inflater

function ZipInflate(options) {
	const that = this;
	const z = new ZStream();
	const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
	const flush = Z_NO_FLUSH;
	const buf = new Uint8Array(bufsize);
	let nomoreinput = false;

	z.inflateInit();
	z.next_out = buf;

	that.append = function (data, onprogress) {
		const buffers = [];
		let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
		if (data.length === 0)
			return;
		z.next_in_index = 0;
		z.next_in = data;
		z.avail_in = data.length;
		do {
			z.next_out_index = 0;
			z.avail_out = bufsize;
			if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it
				z.next_in_index = 0;
				nomoreinput = true;
			}
			err = z.inflate(flush);
			if (nomoreinput && (err === Z_BUF_ERROR)) {
				if (z.avail_in !== 0)
					throw new Error("inflating: bad input");
			} else if (err !== Z_OK && err !== Z_STREAM_END)
				throw new Error("inflating: " + z.msg);
			if ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))
				throw new Error("inflating: bad input");
			if (z.next_out_index)
				if (z.next_out_index === bufsize)
					buffers.push(new Uint8Array(buf));
				else
					buffers.push(buf.subarray(0, z.next_out_index));
			bufferSize += z.next_out_index;
			if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
				onprogress(z.next_in_index);
				lastIndex = z.next_in_index;
			}
		} while (z.avail_in > 0 || z.avail_out === 0);
		if (buffers.length > 1) {
			array = new Uint8Array(bufferSize);
			buffers.forEach(function (chunk) {
				array.set(chunk, bufferIndex);
				bufferIndex += chunk.length;
			});
		} else {
			array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
		}
		return array;
	};
	that.flush = function () {
		z.inflateEnd();
	};
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const MAX_32_BITS = 0xffffffff;
const MAX_16_BITS = 0xffff;
const COMPRESSION_METHOD_DEFLATE = 0x08;
const COMPRESSION_METHOD_STORE = 0x00;
const COMPRESSION_METHOD_AES = 0x63;

const LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
const SPLIT_ZIP_FILE_SIGNATURE = 0x08074b50;
const CENTRAL_FILE_HEADER_SIGNATURE = 0x02014b50;
const END_OF_CENTRAL_DIR_SIGNATURE = 0x06054b50;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 0x06064b50;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 0x07064b50;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;

const EXTRAFIELD_TYPE_ZIP64 = 0x0001;
const EXTRAFIELD_TYPE_AES = 0x9901;
const EXTRAFIELD_TYPE_NTFS = 0x000a;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 0x0001;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 0x5455;
const EXTRAFIELD_TYPE_UNICODE_PATH = 0x7075;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 0x6375;
const EXTRAFIELD_TYPE_USDZ = 0x1986;

const BITFLAG_ENCRYPTED = 0x01;
const BITFLAG_LEVEL = 0x06;
const BITFLAG_DATA_DESCRIPTOR = 0x0008;
const BITFLAG_LANG_ENCODING_FLAG = 0x0800;
const FILE_ATTR_MSDOS_DIR_MASK = 0x10;

const DIRECTORY_SIGNATURE = "/";

const UNDEFINED_VALUE = undefined;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class StreamAdapter {

	constructor(Codec) {
		return class extends TransformStream {
			constructor(_format, options) {
				const codec = new Codec(options);
				super({
					transform(chunk, controller) {
						controller.enqueue(codec.append(chunk));
					},
					flush(controller) {
						const chunk = codec.flush();
						if (chunk) {
							controller.enqueue(chunk);
						}
					}
				});
			}
		};
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MINIMUM_CHUNK_SIZE = 64;
let maxWorkers = 2;
try {
	if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
		maxWorkers = navigator.hardwareConcurrency;
	}
} catch (_error) {
	// ignored
}
const DEFAULT_CONFIGURATION = {
	chunkSize: 512 * 1024,
	maxWorkers,
	terminateWorkerTimeout: 5000,
	useWebWorkers: true,
	useCompressionStream: true,
	workerScripts: UNDEFINED_VALUE,
	CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
	DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};

const config = Object.assign({}, DEFAULT_CONFIGURATION);

function getConfiguration() {
	return config;
}

function getChunkSize(config) {
	return Math.max(config.chunkSize, MINIMUM_CHUNK_SIZE);
}

function configure(configuration) {
	const {
		baseURL,
		chunkSize,
		maxWorkers,
		terminateWorkerTimeout,
		useCompressionStream,
		useWebWorkers,
		Deflate,
		Inflate,
		CompressionStream,
		DecompressionStream,
		workerScripts
	} = configuration;
	setIfDefined("baseURL", baseURL);
	setIfDefined("chunkSize", chunkSize);
	setIfDefined("maxWorkers", maxWorkers);
	setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
	setIfDefined("useCompressionStream", useCompressionStream);
	setIfDefined("useWebWorkers", useWebWorkers);
	if (Deflate) {
		config.CompressionStream = new StreamAdapter(Deflate);
	}
	if (Inflate) {
		config.DecompressionStream = new StreamAdapter(Inflate);
	}
	setIfDefined("CompressionStream", CompressionStream);
	setIfDefined("DecompressionStream", DecompressionStream);
	if (workerScripts !== UNDEFINED_VALUE) {
		const { deflate, inflate } = workerScripts;
		if (deflate || inflate) {
			if (!config.workerScripts) {
				config.workerScripts = {};
			}
		}
		if (deflate) {
			if (!Array.isArray(deflate)) {
				throw new Error("workerScripts.deflate must be an array");
			}
			config.workerScripts.deflate = deflate;
		}
		if (inflate) {
			if (!Array.isArray(inflate)) {
				throw new Error("workerScripts.inflate must be an array");
			}
			config.workerScripts.inflate = inflate;
		}
	}
}

function setIfDefined(propertyName, propertyValue) {
	if (propertyValue !== UNDEFINED_VALUE) {
		config[propertyName] = propertyValue;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const table$1 = {
	"application": {
		"andrew-inset": "ez",
		"annodex": "anx",
		"atom+xml": "atom",
		"atomcat+xml": "atomcat",
		"atomserv+xml": "atomsrv",
		"bbolin": "lin",
		"cu-seeme": "cu",
		"davmount+xml": "davmount",
		"dsptype": "tsp",
		"ecmascript": [
			"es",
			"ecma"
		],
		"futuresplash": "spl",
		"hta": "hta",
		"java-archive": "jar",
		"java-serialized-object": "ser",
		"java-vm": "class",
		"m3g": "m3g",
		"mac-binhex40": "hqx",
		"mathematica": [
			"nb",
			"ma",
			"mb"
		],
		"msaccess": "mdb",
		"msword": [
			"doc",
			"dot",
			"wiz"
		],
		"mxf": "mxf",
		"oda": "oda",
		"ogg": "ogx",
		"pdf": "pdf",
		"pgp-keys": "key",
		"pgp-signature": [
			"asc",
			"sig"
		],
		"pics-rules": "prf",
		"postscript": [
			"ps",
			"ai",
			"eps",
			"epsi",
			"epsf",
			"eps2",
			"eps3"
		],
		"rar": "rar",
		"rdf+xml": "rdf",
		"rss+xml": "rss",
		"rtf": "rtf",
		"xhtml+xml": [
			"xhtml",
			"xht"
		],
		"xml": [
			"xml",
			"xsl",
			"xsd",
			"xpdl"
		],
		"xspf+xml": "xspf",
		"zip": "zip",
		"vnd.android.package-archive": "apk",
		"vnd.cinderella": "cdy",
		"vnd.google-earth.kml+xml": "kml",
		"vnd.google-earth.kmz": "kmz",
		"vnd.mozilla.xul+xml": "xul",
		"vnd.ms-excel": [
			"xls",
			"xlb",
			"xlt",
			"xlm",
			"xla",
			"xlc",
			"xlw"
		],
		"vnd.ms-pki.seccat": "cat",
		"vnd.ms-pki.stl": "stl",
		"vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot",
			"ppa",
			"pwz"
		],
		"vnd.oasis.opendocument.chart": "odc",
		"vnd.oasis.opendocument.database": "odb",
		"vnd.oasis.opendocument.formula": "odf",
		"vnd.oasis.opendocument.graphics": "odg",
		"vnd.oasis.opendocument.graphics-template": "otg",
		"vnd.oasis.opendocument.image": "odi",
		"vnd.oasis.opendocument.presentation": "odp",
		"vnd.oasis.opendocument.presentation-template": "otp",
		"vnd.oasis.opendocument.spreadsheet": "ods",
		"vnd.oasis.opendocument.spreadsheet-template": "ots",
		"vnd.oasis.opendocument.text": "odt",
		"vnd.oasis.opendocument.text-master": [
			"odm",
			"otm"
		],
		"vnd.oasis.opendocument.text-template": "ott",
		"vnd.oasis.opendocument.text-web": "oth",
		"vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
		"vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
		"vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
		"vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
		"vnd.openxmlformats-officedocument.presentationml.template": "potx",
		"vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
		"vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
		"vnd.smaf": "mmf",
		"vnd.stardivision.calc": "sdc",
		"vnd.stardivision.chart": "sds",
		"vnd.stardivision.draw": "sda",
		"vnd.stardivision.impress": "sdd",
		"vnd.stardivision.math": [
			"sdf",
			"smf"
		],
		"vnd.stardivision.writer": [
			"sdw",
			"vor"
		],
		"vnd.stardivision.writer-global": "sgl",
		"vnd.sun.xml.calc": "sxc",
		"vnd.sun.xml.calc.template": "stc",
		"vnd.sun.xml.draw": "sxd",
		"vnd.sun.xml.draw.template": "std",
		"vnd.sun.xml.impress": "sxi",
		"vnd.sun.xml.impress.template": "sti",
		"vnd.sun.xml.math": "sxm",
		"vnd.sun.xml.writer": "sxw",
		"vnd.sun.xml.writer.global": "sxg",
		"vnd.sun.xml.writer.template": "stw",
		"vnd.symbian.install": [
			"sis",
			"sisx"
		],
		"vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw",
			"vsdx",
			"vssx",
			"vstx",
			"vssm",
			"vstm"
		],
		"vnd.wap.wbxml": "wbxml",
		"vnd.wap.wmlc": "wmlc",
		"vnd.wap.wmlscriptc": "wmlsc",
		"vnd.wordperfect": "wpd",
		"vnd.wordperfect5.1": "wp5",
		"x-123": "wk",
		"x-7z-compressed": "7z",
		"x-abiword": "abw",
		"x-apple-diskimage": "dmg",
		"x-bcpio": "bcpio",
		"x-bittorrent": "torrent",
		"x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cb7"
		],
		"x-cbz": "cbz",
		"x-cdf": [
			"cdf",
			"cda"
		],
		"x-cdlink": "vcd",
		"x-chess-pgn": "pgn",
		"x-cpio": "cpio",
		"x-csh": "csh",
		"x-director": [
			"dir",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"x-dms": "dms",
		"x-doom": "wad",
		"x-dvi": "dvi",
		"x-httpd-eruby": "rhtml",
		"x-font": "pcf.Z",
		"x-freemind": "mm",
		"x-gnumeric": "gnumeric",
		"x-go-sgf": "sgf",
		"x-graphing-calculator": "gcf",
		"x-gtar": [
			"gtar",
			"taz"
		],
		"x-hdf": "hdf",
		"x-httpd-php": [
			"phtml",
			"pht",
			"php"
		],
		"x-httpd-php-source": "phps",
		"x-httpd-php3": "php3",
		"x-httpd-php3-preprocessed": "php3p",
		"x-httpd-php4": "php4",
		"x-httpd-php5": "php5",
		"x-ica": "ica",
		"x-info": "info",
		"x-internet-signup": [
			"ins",
			"isp"
		],
		"x-iphone": "iii",
		"x-iso9660-image": "iso",
		"x-java-jnlp-file": "jnlp",
		"x-jmol": "jmz",
		"x-killustrator": "kil",
		"x-latex": "latex",
		"x-lyx": "lyx",
		"x-lzx": "lzx",
		"x-maker": [
			"frm",
			"fb",
			"fbdoc"
		],
		"x-ms-wmd": "wmd",
		"x-msdos-program": [
			"com",
			"exe",
			"bat",
			"dll"
		],
		"x-netcdf": [
			"nc"
		],
		"x-ns-proxy-autoconfig": [
			"pac",
			"dat"
		],
		"x-nwc": "nwc",
		"x-object": "o",
		"x-oz-application": "oza",
		"x-pkcs7-certreqresp": "p7r",
		"x-python-code": [
			"pyc",
			"pyo"
		],
		"x-qgis": [
			"qgs",
			"shp",
			"shx"
		],
		"x-quicktimeplayer": "qtl",
		"x-redhat-package-manager": [
			"rpm",
			"rpa"
		],
		"x-ruby": "rb",
		"x-sh": "sh",
		"x-shar": "shar",
		"x-shockwave-flash": [
			"swf",
			"swfl"
		],
		"x-silverlight": "scr",
		"x-stuffit": "sit",
		"x-sv4cpio": "sv4cpio",
		"x-sv4crc": "sv4crc",
		"x-tar": "tar",
		"x-tex-gf": "gf",
		"x-tex-pk": "pk",
		"x-texinfo": [
			"texinfo",
			"texi"
		],
		"x-trash": [
			"~",
			"%",
			"bak",
			"old",
			"sik"
		],
		"x-ustar": "ustar",
		"x-wais-source": "src",
		"x-wingz": "wz",
		"x-x509-ca-cert": [
			"crt",
			"der",
			"cer"
		],
		"x-xcf": "xcf",
		"x-xfig": "fig",
		"x-xpinstall": "xpi",
		"applixware": "aw",
		"atomsvc+xml": "atomsvc",
		"ccxml+xml": "ccxml",
		"cdmi-capability": "cdmia",
		"cdmi-container": "cdmic",
		"cdmi-domain": "cdmid",
		"cdmi-object": "cdmio",
		"cdmi-queue": "cdmiq",
		"docbook+xml": "dbk",
		"dssc+der": "dssc",
		"dssc+xml": "xdssc",
		"emma+xml": "emma",
		"epub+zip": "epub",
		"exi": "exi",
		"font-tdpfr": "pfr",
		"gml+xml": "gml",
		"gpx+xml": "gpx",
		"gxf": "gxf",
		"hyperstudio": "stk",
		"inkml+xml": [
			"ink",
			"inkml"
		],
		"ipfix": "ipfix",
		"jsonml+json": "jsonml",
		"lost+xml": "lostxml",
		"mads+xml": "mads",
		"marc": "mrc",
		"marcxml+xml": "mrcx",
		"mathml+xml": [
			"mathml",
			"mml"
		],
		"mbox": "mbox",
		"mediaservercontrol+xml": "mscml",
		"metalink+xml": "metalink",
		"metalink4+xml": "meta4",
		"mets+xml": "mets",
		"mods+xml": "mods",
		"mp21": [
			"m21",
			"mp21"
		],
		"mp4": "mp4s",
		"oebps-package+xml": "opf",
		"omdoc+xml": "omdoc",
		"onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"oxps": "oxps",
		"patch-ops-error+xml": "xer",
		"pgp-encrypted": "pgp",
		"pkcs10": "p10",
		"pkcs7-mime": [
			"p7m",
			"p7c"
		],
		"pkcs7-signature": "p7s",
		"pkcs8": "p8",
		"pkix-attr-cert": "ac",
		"pkix-crl": "crl",
		"pkix-pkipath": "pkipath",
		"pkixcmp": "pki",
		"pls+xml": "pls",
		"prs.cww": "cww",
		"pskc+xml": "pskcxml",
		"reginfo+xml": "rif",
		"relax-ng-compact-syntax": "rnc",
		"resource-lists+xml": "rl",
		"resource-lists-diff+xml": "rld",
		"rls-services+xml": "rs",
		"rpki-ghostbusters": "gbr",
		"rpki-manifest": "mft",
		"rpki-roa": "roa",
		"rsd+xml": "rsd",
		"sbml+xml": "sbml",
		"scvp-cv-request": "scq",
		"scvp-cv-response": "scs",
		"scvp-vp-request": "spq",
		"scvp-vp-response": "spp",
		"sdp": "sdp",
		"set-payment-initiation": "setpay",
		"set-registration-initiation": "setreg",
		"shf+xml": "shf",
		"sparql-query": "rq",
		"sparql-results+xml": "srx",
		"srgs": "gram",
		"srgs+xml": "grxml",
		"sru+xml": "sru",
		"ssdl+xml": "ssdl",
		"ssml+xml": "ssml",
		"tei+xml": [
			"tei",
			"teicorpus"
		],
		"thraud+xml": "tfi",
		"timestamped-data": "tsd",
		"vnd.3gpp.pic-bw-large": "plb",
		"vnd.3gpp.pic-bw-small": "psb",
		"vnd.3gpp.pic-bw-var": "pvb",
		"vnd.3gpp2.tcap": "tcap",
		"vnd.3m.post-it-notes": "pwn",
		"vnd.accpac.simply.aso": "aso",
		"vnd.accpac.simply.imp": "imp",
		"vnd.acucobol": "acu",
		"vnd.acucorp": [
			"atc",
			"acutc"
		],
		"vnd.adobe.air-application-installer-package+zip": "air",
		"vnd.adobe.formscentral.fcdt": "fcdt",
		"vnd.adobe.fxp": [
			"fxp",
			"fxpl"
		],
		"vnd.adobe.xdp+xml": "xdp",
		"vnd.adobe.xfdf": "xfdf",
		"vnd.ahead.space": "ahead",
		"vnd.airzip.filesecure.azf": "azf",
		"vnd.airzip.filesecure.azs": "azs",
		"vnd.amazon.ebook": "azw",
		"vnd.americandynamics.acc": "acc",
		"vnd.amiga.ami": "ami",
		"vnd.anser-web-certificate-issue-initiation": "cii",
		"vnd.anser-web-funds-transfer-initiation": "fti",
		"vnd.antix.game-component": "atx",
		"vnd.apple.installer+xml": "mpkg",
		"vnd.apple.mpegurl": "m3u8",
		"vnd.aristanetworks.swi": "swi",
		"vnd.astraea-software.iota": "iota",
		"vnd.audiograph": "aep",
		"vnd.blueice.multipass": "mpm",
		"vnd.bmi": "bmi",
		"vnd.businessobjects": "rep",
		"vnd.chemdraw+xml": "cdxml",
		"vnd.chipnuts.karaoke-mmd": "mmd",
		"vnd.claymore": "cla",
		"vnd.cloanto.rp9": "rp9",
		"vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"vnd.cluetrust.cartomobile-config": "c11amc",
		"vnd.cluetrust.cartomobile-config-pkg": "c11amz",
		"vnd.commonspace": "csp",
		"vnd.contact.cmsg": "cdbcmsg",
		"vnd.cosmocaller": "cmc",
		"vnd.crick.clicker": "clkx",
		"vnd.crick.clicker.keyboard": "clkk",
		"vnd.crick.clicker.palette": "clkp",
		"vnd.crick.clicker.template": "clkt",
		"vnd.crick.clicker.wordbank": "clkw",
		"vnd.criticaltools.wbs+xml": "wbs",
		"vnd.ctc-posml": "pml",
		"vnd.cups-ppd": "ppd",
		"vnd.curl.car": "car",
		"vnd.curl.pcurl": "pcurl",
		"vnd.dart": "dart",
		"vnd.data-vision.rdz": "rdz",
		"vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"vnd.dece.ttml+xml": [
			"uvt",
			"uvvt"
		],
		"vnd.dece.unspecified": [
			"uvx",
			"uvvx"
		],
		"vnd.dece.zip": [
			"uvz",
			"uvvz"
		],
		"vnd.denovo.fcselayout-link": "fe_launch",
		"vnd.dna": "dna",
		"vnd.dolby.mlp": "mlp",
		"vnd.dpgraph": "dpg",
		"vnd.dreamfactory": "dfac",
		"vnd.ds-keypoint": "kpxx",
		"vnd.dvb.ait": "ait",
		"vnd.dvb.service": "svc",
		"vnd.dynageo": "geo",
		"vnd.ecowin.chart": "mag",
		"vnd.enliven": "nml",
		"vnd.epson.esf": "esf",
		"vnd.epson.msf": "msf",
		"vnd.epson.quickanime": "qam",
		"vnd.epson.salt": "slt",
		"vnd.epson.ssf": "ssf",
		"vnd.eszigno3+xml": [
			"es3",
			"et3"
		],
		"vnd.ezpix-album": "ez2",
		"vnd.ezpix-package": "ez3",
		"vnd.fdf": "fdf",
		"vnd.fdsn.mseed": "mseed",
		"vnd.fdsn.seed": [
			"seed",
			"dataless"
		],
		"vnd.flographit": "gph",
		"vnd.fluxtime.clip": "ftc",
		"vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"vnd.frogans.fnc": "fnc",
		"vnd.frogans.ltf": "ltf",
		"vnd.fsc.weblaunch": "fsc",
		"vnd.fujitsu.oasys": "oas",
		"vnd.fujitsu.oasys2": "oa2",
		"vnd.fujitsu.oasys3": "oa3",
		"vnd.fujitsu.oasysgp": "fg5",
		"vnd.fujitsu.oasysprs": "bh2",
		"vnd.fujixerox.ddd": "ddd",
		"vnd.fujixerox.docuworks": "xdw",
		"vnd.fujixerox.docuworks.binder": "xbd",
		"vnd.fuzzysheet": "fzs",
		"vnd.genomatix.tuxedo": "txd",
		"vnd.geogebra.file": "ggb",
		"vnd.geogebra.tool": "ggt",
		"vnd.geometry-explorer": [
			"gex",
			"gre"
		],
		"vnd.geonext": "gxt",
		"vnd.geoplan": "g2w",
		"vnd.geospace": "g3w",
		"vnd.gmx": "gmx",
		"vnd.grafeq": [
			"gqf",
			"gqs"
		],
		"vnd.groove-account": "gac",
		"vnd.groove-help": "ghf",
		"vnd.groove-identity-message": "gim",
		"vnd.groove-injector": "grv",
		"vnd.groove-tool-message": "gtm",
		"vnd.groove-tool-template": "tpl",
		"vnd.groove-vcard": "vcg",
		"vnd.hal+xml": "hal",
		"vnd.handheld-entertainment+xml": "zmm",
		"vnd.hbci": "hbci",
		"vnd.hhe.lesson-player": "les",
		"vnd.hp-hpgl": "hpgl",
		"vnd.hp-hpid": "hpid",
		"vnd.hp-hps": "hps",
		"vnd.hp-jlyt": "jlt",
		"vnd.hp-pcl": "pcl",
		"vnd.hp-pclxl": "pclxl",
		"vnd.hydrostatix.sof-data": "sfd-hdstx",
		"vnd.ibm.minipay": "mpy",
		"vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"vnd.ibm.rights-management": "irm",
		"vnd.ibm.secure-container": "sc",
		"vnd.iccprofile": [
			"icc",
			"icm"
		],
		"vnd.igloader": "igl",
		"vnd.immervision-ivp": "ivp",
		"vnd.immervision-ivu": "ivu",
		"vnd.insors.igm": "igm",
		"vnd.intercon.formnet": [
			"xpw",
			"xpx"
		],
		"vnd.intergeo": "i2g",
		"vnd.intu.qbo": "qbo",
		"vnd.intu.qfx": "qfx",
		"vnd.ipunplugged.rcprofile": "rcprofile",
		"vnd.irepository.package+xml": "irp",
		"vnd.is-xpr": "xpr",
		"vnd.isac.fcs": "fcs",
		"vnd.jam": "jam",
		"vnd.jcp.javame.midlet-rms": "rms",
		"vnd.jisp": "jisp",
		"vnd.joost.joda-archive": "joda",
		"vnd.kahootz": [
			"ktz",
			"ktr"
		],
		"vnd.kde.karbon": "karbon",
		"vnd.kde.kchart": "chrt",
		"vnd.kde.kformula": "kfo",
		"vnd.kde.kivio": "flw",
		"vnd.kde.kontour": "kon",
		"vnd.kde.kpresenter": [
			"kpr",
			"kpt"
		],
		"vnd.kde.kspread": "ksp",
		"vnd.kde.kword": [
			"kwd",
			"kwt"
		],
		"vnd.kenameaapp": "htke",
		"vnd.kidspiration": "kia",
		"vnd.kinar": [
			"kne",
			"knp"
		],
		"vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"vnd.kodak-descriptor": "sse",
		"vnd.las.las+xml": "lasxml",
		"vnd.llamagraphics.life-balance.desktop": "lbd",
		"vnd.llamagraphics.life-balance.exchange+xml": "lbe",
		"vnd.lotus-1-2-3": "123",
		"vnd.lotus-approach": "apr",
		"vnd.lotus-freelance": "pre",
		"vnd.lotus-notes": "nsf",
		"vnd.lotus-organizer": "org",
		"vnd.lotus-screencam": "scm",
		"vnd.lotus-wordpro": "lwp",
		"vnd.macports.portpkg": "portpkg",
		"vnd.mcd": "mcd",
		"vnd.medcalcdata": "mc1",
		"vnd.mediastation.cdkey": "cdkey",
		"vnd.mfer": "mwf",
		"vnd.mfmp": "mfm",
		"vnd.micrografx.flo": "flo",
		"vnd.micrografx.igx": "igx",
		"vnd.mif": "mif",
		"vnd.mobius.daf": "daf",
		"vnd.mobius.dis": "dis",
		"vnd.mobius.mbk": "mbk",
		"vnd.mobius.mqy": "mqy",
		"vnd.mobius.msl": "msl",
		"vnd.mobius.plc": "plc",
		"vnd.mobius.txf": "txf",
		"vnd.mophun.application": "mpn",
		"vnd.mophun.certificate": "mpc",
		"vnd.ms-artgalry": "cil",
		"vnd.ms-cab-compressed": "cab",
		"vnd.ms-excel.addin.macroenabled.12": "xlam",
		"vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
		"vnd.ms-excel.sheet.macroenabled.12": "xlsm",
		"vnd.ms-excel.template.macroenabled.12": "xltm",
		"vnd.ms-fontobject": "eot",
		"vnd.ms-htmlhelp": "chm",
		"vnd.ms-ims": "ims",
		"vnd.ms-lrm": "lrm",
		"vnd.ms-officetheme": "thmx",
		"vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
		"vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
		"vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
		"vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
		"vnd.ms-powerpoint.template.macroenabled.12": "potm",
		"vnd.ms-project": [
			"mpp",
			"mpt"
		],
		"vnd.ms-word.document.macroenabled.12": "docm",
		"vnd.ms-word.template.macroenabled.12": "dotm",
		"vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"vnd.ms-wpl": "wpl",
		"vnd.ms-xpsdocument": "xps",
		"vnd.mseq": "mseq",
		"vnd.musician": "mus",
		"vnd.muvee.style": "msty",
		"vnd.mynfc": "taglet",
		"vnd.neurolanguage.nlu": "nlu",
		"vnd.nitf": [
			"ntf",
			"nitf"
		],
		"vnd.noblenet-directory": "nnd",
		"vnd.noblenet-sealer": "nns",
		"vnd.noblenet-web": "nnw",
		"vnd.nokia.n-gage.data": "ngdat",
		"vnd.nokia.n-gage.symbian.install": "n-gage",
		"vnd.nokia.radio-preset": "rpst",
		"vnd.nokia.radio-presets": "rpss",
		"vnd.novadigm.edm": "edm",
		"vnd.novadigm.edx": "edx",
		"vnd.novadigm.ext": "ext",
		"vnd.oasis.opendocument.chart-template": "otc",
		"vnd.oasis.opendocument.formula-template": "odft",
		"vnd.oasis.opendocument.image-template": "oti",
		"vnd.olpc-sugar": "xo",
		"vnd.oma.dd2+xml": "dd2",
		"vnd.openofficeorg.extension": "oxt",
		"vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
		"vnd.osgeo.mapguide.package": "mgp",
		"vnd.osgi.dp": "dp",
		"vnd.osgi.subsystem": "esa",
		"vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"vnd.pawaafile": "paw",
		"vnd.pg.format": "str",
		"vnd.pg.osasli": "ei6",
		"vnd.picsel": "efif",
		"vnd.pmi.widget": "wg",
		"vnd.pocketlearn": "plf",
		"vnd.powerbuilder6": "pbd",
		"vnd.previewsystems.box": "box",
		"vnd.proteus.magazine": "mgz",
		"vnd.publishare-delta-tree": "qps",
		"vnd.pvi.ptid1": "ptid",
		"vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"vnd.realvnc.bed": "bed",
		"vnd.recordare.musicxml": "mxl",
		"vnd.recordare.musicxml+xml": "musicxml",
		"vnd.rig.cryptonote": "cryptonote",
		"vnd.rn-realmedia": "rm",
		"vnd.rn-realmedia-vbr": "rmvb",
		"vnd.route66.link66+xml": "link66",
		"vnd.sailingtracker.track": "st",
		"vnd.seemail": "see",
		"vnd.sema": "sema",
		"vnd.semd": "semd",
		"vnd.semf": "semf",
		"vnd.shana.informed.formdata": "ifm",
		"vnd.shana.informed.formtemplate": "itp",
		"vnd.shana.informed.interchange": "iif",
		"vnd.shana.informed.package": "ipk",
		"vnd.simtech-mindmapper": [
			"twd",
			"twds"
		],
		"vnd.smart.teacher": "teacher",
		"vnd.solent.sdkm+xml": [
			"sdkm",
			"sdkd"
		],
		"vnd.spotfire.dxp": "dxp",
		"vnd.spotfire.sfs": "sfs",
		"vnd.stepmania.package": "smzip",
		"vnd.stepmania.stepchart": "sm",
		"vnd.sus-calendar": [
			"sus",
			"susp"
		],
		"vnd.svd": "svd",
		"vnd.syncml+xml": "xsm",
		"vnd.syncml.dm+wbxml": "bdm",
		"vnd.syncml.dm+xml": "xdm",
		"vnd.tao.intent-module-archive": "tao",
		"vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"vnd.tmobile-livetv": "tmo",
		"vnd.trid.tpt": "tpt",
		"vnd.triscape.mxs": "mxs",
		"vnd.trueapp": "tra",
		"vnd.ufdl": [
			"ufd",
			"ufdl"
		],
		"vnd.uiq.theme": "utz",
		"vnd.umajin": "umj",
		"vnd.unity": "unityweb",
		"vnd.uoml+xml": "uoml",
		"vnd.vcx": "vcx",
		"vnd.visionary": "vis",
		"vnd.vsf": "vsf",
		"vnd.webturbo": "wtb",
		"vnd.wolfram.player": "nbp",
		"vnd.wqd": "wqd",
		"vnd.wt.stf": "stf",
		"vnd.xara": "xar",
		"vnd.xfdl": "xfdl",
		"vnd.yamaha.hv-dic": "hvd",
		"vnd.yamaha.hv-script": "hvs",
		"vnd.yamaha.hv-voice": "hvp",
		"vnd.yamaha.openscoreformat": "osf",
		"vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
		"vnd.yamaha.smaf-audio": "saf",
		"vnd.yamaha.smaf-phrase": "spf",
		"vnd.yellowriver-custom-menu": "cmp",
		"vnd.zul": [
			"zir",
			"zirz"
		],
		"vnd.zzazz.deck+xml": "zaz",
		"voicexml+xml": "vxml",
		"widget": "wgt",
		"winhlp": "hlp",
		"wsdl+xml": "wsdl",
		"wspolicy+xml": "wspolicy",
		"x-ace-compressed": "ace",
		"x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"x-authorware-map": "aam",
		"x-authorware-seg": "aas",
		"x-blorb": [
			"blb",
			"blorb"
		],
		"x-bzip": "bz",
		"x-bzip2": [
			"bz2",
			"boz"
		],
		"x-cfs-compressed": "cfs",
		"x-chat": "chat",
		"x-conference": "nsc",
		"x-dgc-compressed": "dgc",
		"x-dtbncx+xml": "ncx",
		"x-dtbook+xml": "dtb",
		"x-dtbresource+xml": "res",
		"x-eva": "eva",
		"x-font-bdf": "bdf",
		"x-font-ghostscript": "gsf",
		"x-font-linux-psf": "psf",
		"x-font-pcf": "pcf",
		"x-font-snf": "snf",
		"x-font-ttf": [
			"ttf",
			"ttc"
		],
		"x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"x-freearc": "arc",
		"x-gca-compressed": "gca",
		"x-glulx": "ulx",
		"x-gramps-xml": "gramps",
		"x-install-instructions": "install",
		"x-lzh-compressed": [
			"lzh",
			"lha"
		],
		"x-mie": "mie",
		"x-mobipocket-ebook": [
			"prc",
			"mobi"
		],
		"x-ms-application": "application",
		"x-ms-shortcut": "lnk",
		"x-ms-xbap": "xbap",
		"x-msbinder": "obd",
		"x-mscardfile": "crd",
		"x-msclip": "clp",
		"application/x-ms-installer": "msi",
		"x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"x-msmetafile": [
			"wmf",
			"wmz",
			"emf",
			"emz"
		],
		"x-msmoney": "mny",
		"x-mspublisher": "pub",
		"x-msschedule": "scd",
		"x-msterminal": "trm",
		"x-mswrite": "wri",
		"x-nzb": "nzb",
		"x-pkcs12": [
			"p12",
			"pfx"
		],
		"x-pkcs7-certificates": [
			"p7b",
			"spc"
		],
		"x-research-info-systems": "ris",
		"x-silverlight-app": "xap",
		"x-sql": "sql",
		"x-stuffitx": "sitx",
		"x-subrip": "srt",
		"x-t3vm-image": "t3",
		"x-tex-tfm": "tfm",
		"x-tgif": "obj",
		"x-xliff+xml": "xlf",
		"x-xz": "xz",
		"x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"xaml+xml": "xaml",
		"xcap-diff+xml": "xdf",
		"xenc+xml": "xenc",
		"xml-dtd": "dtd",
		"xop+xml": "xop",
		"xproc+xml": "xpl",
		"xslt+xml": "xslt",
		"xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"yang": "yang",
		"yin+xml": "yin",
		"envoy": "evy",
		"fractals": "fif",
		"internet-property-stream": "acx",
		"olescript": "axs",
		"vnd.ms-outlook": "msg",
		"vnd.ms-pkicertstore": "sst",
		"x-compress": "z",
		"x-perfmon": [
			"pma",
			"pmc",
			"pmr",
			"pmw"
		],
		"ynd.ms-pkipko": "pko",
		"gzip": [
			"gz",
			"tgz"
		],
		"smil+xml": [
			"smi",
			"smil"
		],
		"vnd.debian.binary-package": [
			"deb",
			"udeb"
		],
		"vnd.hzn-3d-crossword": "x3d",
		"vnd.sqlite3": [
			"db",
			"sqlite",
			"sqlite3",
			"db-wal",
			"sqlite-wal",
			"db-shm",
			"sqlite-shm"
		],
		"vnd.wap.sic": "sic",
		"vnd.wap.slc": "slc",
		"x-krita": [
			"kra",
			"krz"
		],
		"x-perl": [
			"pm",
			"pl"
		],
		"yaml": [
			"yaml",
			"yml"
		]
	},
	"audio": {
		"amr": "amr",
		"amr-wb": "awb",
		"annodex": "axa",
		"basic": [
			"au",
			"snd"
		],
		"flac": "flac",
		"midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"mpeg": [
			"mpga",
			"mpega",
			"mp3",
			"m4a",
			"mp2a",
			"m2a",
			"m3a"
		],
		"mpegurl": "m3u",
		"ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"prs.sid": "sid",
		"x-aiff": "aifc",
		"x-gsm": "gsm",
		"x-ms-wma": "wma",
		"x-ms-wax": "wax",
		"x-pn-realaudio": "ram",
		"x-realaudio": "ra",
		"x-sd2": "sd2",
		"adpcm": "adp",
		"mp4": "mp4a",
		"s3m": "s3m",
		"silk": "sil",
		"vnd.dece.audio": [
			"uva",
			"uvva"
		],
		"vnd.digital-winds": "eol",
		"vnd.dra": "dra",
		"vnd.dts": "dts",
		"vnd.dts.hd": "dtshd",
		"vnd.lucent.voice": "lvp",
		"vnd.ms-playready.media.pya": "pya",
		"vnd.nuera.ecelp4800": "ecelp4800",
		"vnd.nuera.ecelp7470": "ecelp7470",
		"vnd.nuera.ecelp9600": "ecelp9600",
		"vnd.rip": "rip",
		"webm": "weba",
		"x-caf": "caf",
		"x-matroska": "mka",
		"x-pn-realaudio-plugin": "rmp",
		"xm": "xm",
		"aac": "aac",
		"aiff": [
			"aiff",
			"aif",
			"aff"
		],
		"opus": "opus",
		"wav": "wav"
	},
	"chemical": {
		"x-alchemy": "alc",
		"x-cache": [
			"cac",
			"cache"
		],
		"x-cache-csf": "csf",
		"x-cactvs-binary": [
			"cbin",
			"cascii",
			"ctab"
		],
		"x-cdx": "cdx",
		"x-chem3d": "c3d",
		"x-cif": "cif",
		"x-cmdf": "cmdf",
		"x-cml": "cml",
		"x-compass": "cpa",
		"x-crossfire": "bsd",
		"x-csml": [
			"csml",
			"csm"
		],
		"x-ctx": "ctx",
		"x-cxf": [
			"cxf",
			"cef"
		],
		"x-embl-dl-nucleotide": [
			"emb",
			"embl"
		],
		"x-gamess-input": [
			"inp",
			"gam",
			"gamin"
		],
		"x-gaussian-checkpoint": [
			"fch",
			"fchk"
		],
		"x-gaussian-cube": "cub",
		"x-gaussian-input": [
			"gau",
			"gjc",
			"gjf"
		],
		"x-gaussian-log": "gal",
		"x-gcg8-sequence": "gcg",
		"x-genbank": "gen",
		"x-hin": "hin",
		"x-isostar": [
			"istr",
			"ist"
		],
		"x-jcamp-dx": [
			"jdx",
			"dx"
		],
		"x-kinemage": "kin",
		"x-macmolecule": "mcm",
		"x-macromodel-input": "mmod",
		"x-mdl-molfile": "mol",
		"x-mdl-rdfile": "rd",
		"x-mdl-rxnfile": "rxn",
		"x-mdl-sdfile": "sd",
		"x-mdl-tgf": "tgf",
		"x-mmcif": "mcif",
		"x-mol2": "mol2",
		"x-molconn-Z": "b",
		"x-mopac-graph": "gpt",
		"x-mopac-input": [
			"mop",
			"mopcrt",
			"zmt"
		],
		"x-mopac-out": "moo",
		"x-ncbi-asn1": "asn",
		"x-ncbi-asn1-ascii": [
			"prt",
			"ent"
		],
		"x-ncbi-asn1-binary": "val",
		"x-rosdal": "ros",
		"x-swissprot": "sw",
		"x-vamas-iso14976": "vms",
		"x-vmd": "vmd",
		"x-xtel": "xtel",
		"x-xyz": "xyz"
	},
	"font": {
		"otf": "otf",
		"woff": "woff",
		"woff2": "woff2"
	},
	"image": {
		"gif": "gif",
		"ief": "ief",
		"jpeg": [
			"jpeg",
			"jpg",
			"jpe",
			"jfif",
			"jfif-tbnl",
			"jif"
		],
		"pcx": "pcx",
		"png": "png",
		"svg+xml": [
			"svg",
			"svgz"
		],
		"tiff": [
			"tiff",
			"tif"
		],
		"vnd.djvu": [
			"djvu",
			"djv"
		],
		"vnd.wap.wbmp": "wbmp",
		"x-canon-cr2": "cr2",
		"x-canon-crw": "crw",
		"x-cmu-raster": "ras",
		"x-coreldraw": "cdr",
		"x-coreldrawpattern": "pat",
		"x-coreldrawtemplate": "cdt",
		"x-corelphotopaint": "cpt",
		"x-epson-erf": "erf",
		"x-icon": "ico",
		"x-jg": "art",
		"x-jng": "jng",
		"x-nikon-nef": "nef",
		"x-olympus-orf": "orf",
		"x-portable-anymap": "pnm",
		"x-portable-bitmap": "pbm",
		"x-portable-graymap": "pgm",
		"x-portable-pixmap": "ppm",
		"x-rgb": "rgb",
		"x-xbitmap": "xbm",
		"x-xpixmap": "xpm",
		"x-xwindowdump": "xwd",
		"bmp": "bmp",
		"cgm": "cgm",
		"g3fax": "g3",
		"ktx": "ktx",
		"prs.btif": "btif",
		"sgi": "sgi",
		"vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"vnd.dwg": "dwg",
		"vnd.dxf": "dxf",
		"vnd.fastbidsheet": "fbs",
		"vnd.fpx": "fpx",
		"vnd.fst": "fst",
		"vnd.fujixerox.edmics-mmr": "mmr",
		"vnd.fujixerox.edmics-rlc": "rlc",
		"vnd.ms-modi": "mdi",
		"vnd.ms-photo": "wdp",
		"vnd.net-fpx": "npx",
		"vnd.xiff": "xif",
		"webp": "webp",
		"x-3ds": "3ds",
		"x-cmx": "cmx",
		"x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"x-pict": [
			"pic",
			"pct"
		],
		"x-tga": "tga",
		"cis-cod": "cod",
		"avif": "avifs",
		"heic": [
			"heif",
			"heic"
		],
		"pjpeg": [
			"pjpg"
		],
		"vnd.adobe.photoshop": "psd",
		"x-adobe-dng": "dng",
		"x-fuji-raf": "raf",
		"x-icns": "icns",
		"x-kodak-dcr": "dcr",
		"x-kodak-k25": "k25",
		"x-kodak-kdc": "kdc",
		"x-minolta-mrw": "mrw",
		"x-panasonic-raw": [
			"raw",
			"rw2",
			"rwl"
		],
		"x-pentax-pef": [
			"pef",
			"ptx"
		],
		"x-sigma-x3f": "x3f",
		"x-sony-arw": "arw",
		"x-sony-sr2": "sr2",
		"x-sony-srf": "srf"
	},
	"message": {
		"rfc822": [
			"eml",
			"mime",
			"mht",
			"mhtml",
			"nws"
		]
	},
	"model": {
		"iges": [
			"igs",
			"iges"
		],
		"mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"vrml": [
			"wrl",
			"vrml"
		],
		"x3d+vrml": [
			"x3dv",
			"x3dvz"
		],
		"x3d+xml": "x3dz",
		"x3d+binary": [
			"x3db",
			"x3dbz"
		],
		"vnd.collada+xml": "dae",
		"vnd.dwf": "dwf",
		"vnd.gdl": "gdl",
		"vnd.gtw": "gtw",
		"vnd.mts": "mts",
		"vnd.usdz+zip": "usdz",
		"vnd.vtu": "vtu"
	},
	"text": {
		"cache-manifest": [
			"manifest",
			"appcache"
		],
		"calendar": [
			"ics",
			"icz",
			"ifb"
		],
		"css": "css",
		"csv": "csv",
		"h323": "323",
		"html": [
			"html",
			"htm",
			"shtml",
			"stm"
		],
		"iuls": "uls",
		"plain": [
			"txt",
			"text",
			"brf",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"bas",
			"diff",
			"ksh"
		],
		"richtext": "rtx",
		"scriptlet": [
			"sct",
			"wsc"
		],
		"texmacs": "tm",
		"tab-separated-values": "tsv",
		"vnd.sun.j2me.app-descriptor": "jad",
		"vnd.wap.wml": "wml",
		"vnd.wap.wmlscript": "wmls",
		"x-bibtex": "bib",
		"x-boo": "boo",
		"x-c++hdr": [
			"h++",
			"hpp",
			"hxx",
			"hh"
		],
		"x-c++src": [
			"c++",
			"cpp",
			"cxx",
			"cc"
		],
		"x-component": "htc",
		"x-dsrc": "d",
		"x-diff": "patch",
		"x-haskell": "hs",
		"x-java": "java",
		"x-literate-haskell": "lhs",
		"x-moc": "moc",
		"x-pascal": [
			"p",
			"pas",
			"pp",
			"inc"
		],
		"x-pcs-gcd": "gcd",
		"x-python": "py",
		"x-scala": "scala",
		"x-setext": "etx",
		"x-tcl": [
			"tcl",
			"tk"
		],
		"x-tex": [
			"tex",
			"ltx",
			"sty",
			"cls"
		],
		"x-vcalendar": "vcs",
		"x-vcard": "vcf",
		"n3": "n3",
		"prs.lines.tag": "dsc",
		"sgml": [
			"sgml",
			"sgm"
		],
		"troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"turtle": "ttl",
		"uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"vcard": "vcard",
		"vnd.curl": "curl",
		"vnd.curl.dcurl": "dcurl",
		"vnd.curl.scurl": "scurl",
		"vnd.curl.mcurl": "mcurl",
		"vnd.dvb.subtitle": "sub",
		"vnd.fly": "fly",
		"vnd.fmi.flexstor": "flx",
		"vnd.graphviz": "gv",
		"vnd.in3d.3dml": "3dml",
		"vnd.in3d.spot": "spot",
		"x-asm": [
			"s",
			"asm"
		],
		"x-c": [
			"c",
			"h",
			"dic"
		],
		"x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"x-opml": "opml",
		"x-nfo": "nfo",
		"x-sfv": "sfv",
		"x-uuencode": "uu",
		"webviewhtml": "htt",
		"javascript": "js",
		"json": "json",
		"markdown": [
			"md",
			"markdown",
			"mdown",
			"markdn"
		],
		"vnd.wap.si": "si",
		"vnd.wap.sl": "sl"
	},
	"video": {
		"avif": "avif",
		"3gpp": "3gp",
		"annodex": "axv",
		"dl": "dl",
		"dv": [
			"dif",
			"dv"
		],
		"fli": "fli",
		"gl": "gl",
		"mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v",
			"mp2",
			"mpa",
			"mpv2"
		],
		"mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"quicktime": [
			"qt",
			"mov"
		],
		"ogg": "ogv",
		"vnd.mpegurl": [
			"mxu",
			"m4u"
		],
		"x-flv": "flv",
		"x-la-asf": [
			"lsf",
			"lsx"
		],
		"x-mng": "mng",
		"x-ms-asf": [
			"asf",
			"asx",
			"asr"
		],
		"x-ms-wm": "wm",
		"x-ms-wmv": "wmv",
		"x-ms-wmx": "wmx",
		"x-ms-wvx": "wvx",
		"x-msvideo": "avi",
		"x-sgi-movie": "movie",
		"x-matroska": [
			"mpv",
			"mkv",
			"mk3d",
			"mks"
		],
		"3gpp2": "3g2",
		"h261": "h261",
		"h263": "h263",
		"h264": "h264",
		"jpeg": "jpgv",
		"jpm": [
			"jpm",
			"jpgm"
		],
		"mj2": [
			"mj2",
			"mjp2"
		],
		"vnd.dece.hd": [
			"uvh",
			"uvvh"
		],
		"vnd.dece.mobile": [
			"uvm",
			"uvvm"
		],
		"vnd.dece.pd": [
			"uvp",
			"uvvp"
		],
		"vnd.dece.sd": [
			"uvs",
			"uvvs"
		],
		"vnd.dece.video": [
			"uvv",
			"uvvv"
		],
		"vnd.dvb.file": "dvb",
		"vnd.fvt": "fvt",
		"vnd.ms-playready.media.pyv": "pyv",
		"vnd.uvvu.mp4": [
			"uvu",
			"uvvu"
		],
		"vnd.vivo": "viv",
		"webm": "webm",
		"x-f4v": "f4v",
		"x-m4v": "m4v",
		"x-ms-vob": "vob",
		"x-smv": "smv",
		"mp2t": "ts"
	},
	"x-conference": {
		"x-cooltalk": "ice"
	},
	"x-world": {
		"x-vrml": [
			"vrm",
			"flr",
			"wrz",
			"xaf",
			"xof"
		]
	}
};

(() => {
	const mimeTypes = {};
	for (const type of Object.keys(table$1)) {
		for (const subtype of Object.keys(table$1[type])) {
			const value = table$1[type][subtype];
			if (typeof value == "string") {
				mimeTypes[value] = type + "/" + subtype;
			} else {
				for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
					mimeTypes[value[indexMimeType]] = type + "/" + subtype;
				}
			}
		}
	}
	return mimeTypes;
})();

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const table = [];
for (let i = 0; i < 256; i++) {
	let t = i;
	for (let j = 0; j < 8; j++) {
		if (t & 1) {
			t = (t >>> 1) ^ 0xEDB88320;
		} else {
			t = t >>> 1;
		}
	}
	table[i] = t;
}

class Crc32 {

	constructor(crc) {
		this.crc = crc || -1;
	}

	append(data) {
		let crc = this.crc | 0;
		for (let offset = 0, length = data.length | 0; offset < length; offset++) {
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		}
		this.crc = crc;
	}

	get() {
		return ~this.crc;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


class Crc32Stream extends TransformStream {

	constructor() {
		// deno-lint-ignore prefer-const
		let stream;
		const crc32 = new Crc32();
		super({
			transform(chunk, controller) {
				crc32.append(chunk);
				controller.enqueue(chunk);
			},
			flush() {
				const value = new Uint8Array(4);
				const dataView = new DataView(value.buffer);
				dataView.setUint32(0, crc32.get());
				stream.value = value;
			}
		});
		stream = this;
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function encodeText(value) {
	// deno-lint-ignore valid-typeof
	if (typeof TextEncoder == UNDEFINED_TYPE) {
		value = unescape(encodeURIComponent(value));
		const result = new Uint8Array(value.length);
		for (let i = 0; i < result.length; i++) {
			result[i] = value.charCodeAt(i);
		}
		return result;
	} else {
		return new TextEncoder().encode(value);
	}
}

// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl

// deno-lint-ignore-file no-this-alias

/*
 * SJCL is open. You can use, modify and redistribute it under a BSD
 * license or under the GNU GPL, version 2.0.
 */

/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
const bitArray = {
	/**
	 * Concatenate two bit arrays.
	 * @param {bitArray} a1 The first array.
	 * @param {bitArray} a2 The second array.
	 * @return {bitArray} The concatenation of a1 and a2.
	 */
	concat(a1, a2) {
		if (a1.length === 0 || a2.length === 0) {
			return a1.concat(a2);
		}

		const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
		if (shift === 32) {
			return a1.concat(a2);
		} else {
			return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
		}
	},

	/**
	 * Find the length of an array of bits.
	 * @param {bitArray} a The array.
	 * @return {Number} The length of a, in bits.
	 */
	bitLength(a) {
		const l = a.length;
		if (l === 0) {
			return 0;
		}
		const x = a[l - 1];
		return (l - 1) * 32 + bitArray.getPartial(x);
	},

	/**
	 * Truncate an array.
	 * @param {bitArray} a The array.
	 * @param {Number} len The length to truncate to, in bits.
	 * @return {bitArray} A new array, truncated to len bits.
	 */
	clamp(a, len) {
		if (a.length * 32 < len) {
			return a;
		}
		a = a.slice(0, Math.ceil(len / 32));
		const l = a.length;
		len = len & 31;
		if (l > 0 && len) {
			a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);
		}
		return a;
	},

	/**
	 * Make a partial word for a bit array.
	 * @param {Number} len The number of bits in the word.
	 * @param {Number} x The bits.
	 * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
	 * @return {Number} The partial word.
	 */
	partial(len, x, _end) {
		if (len === 32) {
			return x;
		}
		return (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;
	},

	/**
	 * Get the number of bits used by a partial word.
	 * @param {Number} x The partial word.
	 * @return {Number} The number of bits used by the partial word.
	 */
	getPartial(x) {
		return Math.round(x / 0x10000000000) || 32;
	},

	/** Shift an array right.
	 * @param {bitArray} a The array to shift.
	 * @param {Number} shift The number of bits to shift.
	 * @param {Number} [carry=0] A byte to carry in
	 * @param {bitArray} [out=[]] An array to prepend to the output.
	 * @private
	 */
	_shiftRight(a, shift, carry, out) {
		if (out === undefined) {
			out = [];
		}

		for (; shift >= 32; shift -= 32) {
			out.push(carry);
			carry = 0;
		}
		if (shift === 0) {
			return out.concat(a);
		}

		for (let i = 0; i < a.length; i++) {
			out.push(carry | a[i] >>> shift);
			carry = a[i] << (32 - shift);
		}
		const last2 = a.length ? a[a.length - 1] : 0;
		const shift2 = bitArray.getPartial(last2);
		out.push(bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));
		return out;
	}
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bytes
 * @namespace
 */
const codec = {
	bytes: {
		/** Convert from a bitArray to an array of bytes. */
		fromBits(arr) {
			const bl = bitArray.bitLength(arr);
			const byteLength = bl / 8;
			const out = new Uint8Array(byteLength);
			let tmp;
			for (let i = 0; i < byteLength; i++) {
				if ((i & 3) === 0) {
					tmp = arr[i / 4];
				}
				out[i] = tmp >>> 24;
				tmp <<= 8;
			}
			return out;
		},
		/** Convert from an array of bytes to a bitArray. */
		toBits(bytes) {
			const out = [];
			let i;
			let tmp = 0;
			for (i = 0; i < bytes.length; i++) {
				tmp = tmp << 8 | bytes[i];
				if ((i & 3) === 3) {
					out.push(tmp);
					tmp = 0;
				}
			}
			if (i & 3) {
				out.push(bitArray.partial(8 * (i & 3), tmp));
			}
			return out;
		}
	}
};

const hash = {};

/**
 * Context for a SHA-1 operation in progress.
 * @constructor
 */
hash.sha1 = class {
	constructor(hash) {
		const sha1 = this;
		/**
		 * The hash's block size, in bits.
		 * @constant
		 */
		sha1.blockSize = 512;
		/**
		 * The SHA-1 initialization vector.
		 * @private
		 */
		sha1._init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
		/**
		 * The SHA-1 hash key.
		 * @private
		 */
		sha1._key = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
		if (hash) {
			sha1._h = hash._h.slice(0);
			sha1._buffer = hash._buffer.slice(0);
			sha1._length = hash._length;
		} else {
			sha1.reset();
		}
	}

	/**
	 * Reset the hash state.
	 * @return this
	 */
	reset() {
		const sha1 = this;
		sha1._h = sha1._init.slice(0);
		sha1._buffer = [];
		sha1._length = 0;
		return sha1;
	}

	/**
	 * Input several words to the hash.
	 * @param {bitArray|String} data the data to hash.
	 * @return this
	 */
	update(data) {
		const sha1 = this;
		if (typeof data === "string") {
			data = codec.utf8String.toBits(data);
		}
		const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
		const ol = sha1._length;
		const nl = sha1._length = ol + bitArray.bitLength(data);
		if (nl > 9007199254740991) {
			throw new Error("Cannot hash more than 2^53 - 1 bits");
		}
		const c = new Uint32Array(b);
		let j = 0;
		for (let i = sha1.blockSize + ol - ((sha1.blockSize + ol) & (sha1.blockSize - 1)); i <= nl;
			i += sha1.blockSize) {
			sha1._block(c.subarray(16 * j, 16 * (j + 1)));
			j += 1;
		}
		b.splice(0, 16 * j);
		return sha1;
	}

	/**
	 * Complete hashing and output the hash value.
	 * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
	 */
	finalize() {
		const sha1 = this;
		let b = sha1._buffer;
		const h = sha1._h;

		// Round out and push the buffer
		b = bitArray.concat(b, [bitArray.partial(1, 1)]);
		// Round out the buffer to a multiple of 16 words, less the 2 length words.
		for (let i = b.length + 2; i & 15; i++) {
			b.push(0);
		}

		// append the length
		b.push(Math.floor(sha1._length / 0x100000000));
		b.push(sha1._length | 0);

		while (b.length) {
			sha1._block(b.splice(0, 16));
		}

		sha1.reset();
		return h;
	}

	/**
	 * The SHA-1 logical functions f(0), f(1), ..., f(79).
	 * @private
	 */
	_f(t, b, c, d) {
		if (t <= 19) {
			return (b & c) | (~b & d);
		} else if (t <= 39) {
			return b ^ c ^ d;
		} else if (t <= 59) {
			return (b & c) | (b & d) | (c & d);
		} else if (t <= 79) {
			return b ^ c ^ d;
		}
	}

	/**
	 * Circular left-shift operator.
	 * @private
	 */
	_S(n, x) {
		return (x << n) | (x >>> 32 - n);
	}

	/**
	 * Perform one cycle of SHA-1.
	 * @param {Uint32Array|bitArray} words one block of words.
	 * @private
	 */
	_block(words) {
		const sha1 = this;
		const h = sha1._h;
		// When words is passed to _block, it has 16 elements. SHA1 _block
		// function extends words with new elements (at the end there are 80 elements). 
		// The problem is that if we use Uint32Array instead of Array, 
		// the length of Uint32Array cannot be changed. Thus, we replace words with a 
		// normal Array here.
		const w = Array(80); // do not use Uint32Array here as the instantiation is slower
		for (let j = 0; j < 16; j++) {
			w[j] = words[j];
		}

		let a = h[0];
		let b = h[1];
		let c = h[2];
		let d = h[3];
		let e = h[4];

		for (let t = 0; t <= 79; t++) {
			if (t >= 16) {
				w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
			}
			const tmp = (sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] +
				sha1._key[Math.floor(t / 20)]) | 0;
			e = d;
			d = c;
			c = sha1._S(30, b);
			b = a;
			a = tmp;
		}

		h[0] = (h[0] + a) | 0;
		h[1] = (h[1] + b) | 0;
		h[2] = (h[2] + c) | 0;
		h[3] = (h[3] + d) | 0;
		h[4] = (h[4] + e) | 0;
	}
};

/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

const cipher = {};

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */
cipher.aes = class {
	constructor(key) {
		/**
		 * The expanded S-box and inverse S-box tables.  These will be computed
		 * on the client so that we don't have to send them down the wire.
		 *
		 * There are two tables, _tables[0] is for encryption and
		 * _tables[1] is for decryption.
		 *
		 * The first 4 sub-tables are the expanded S-box with MixColumns.  The
		 * last (_tables[01][4]) is the S-box itself.
		 *
		 * @private
		 */
		const aes = this;
		aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];

		if (!aes._tables[0][0][0]) {
			aes._precompute();
		}

		const sbox = aes._tables[0][4];
		const decTable = aes._tables[1];
		const keyLen = key.length;

		let i, encKey, decKey, rcon = 1;

		if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
			throw new Error("invalid aes key size");
		}

		aes._key = [encKey = key.slice(0), decKey = []];

		// schedule encryption keys
		for (i = keyLen; i < 4 * keyLen + 28; i++) {
			let tmp = encKey[i - 1];

			// apply sbox
			if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {
				tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];

				// shift rows and add rcon
				if (i % keyLen === 0) {
					tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
					rcon = rcon << 1 ^ (rcon >> 7) * 283;
				}
			}

			encKey[i] = encKey[i - keyLen] ^ tmp;
		}

		// schedule decryption keys
		for (let j = 0; i; j++, i--) {
			const tmp = encKey[j & 3 ? i : i - 4];
			if (i <= 4 || j < 4) {
				decKey[j] = tmp;
			} else {
				decKey[j] = decTable[0][sbox[tmp >>> 24]] ^
					decTable[1][sbox[tmp >> 16 & 255]] ^
					decTable[2][sbox[tmp >> 8 & 255]] ^
					decTable[3][sbox[tmp & 255]];
			}
		}
	}
	// public
	/* Something like this might appear here eventually
	name: "AES",
	blockSize: 4,
	keySizes: [4,6,8],
	*/

	/**
	 * Encrypt an array of 4 big-endian words.
	 * @param {Array} data The plaintext.
	 * @return {Array} The ciphertext.
	 */
	encrypt(data) {
		return this._crypt(data, 0);
	}

	/**
	 * Decrypt an array of 4 big-endian words.
	 * @param {Array} data The ciphertext.
	 * @return {Array} The plaintext.
	 */
	decrypt(data) {
		return this._crypt(data, 1);
	}

	/**
	 * Expand the S-box tables.
	 *
	 * @private
	 */
	_precompute() {
		const encTable = this._tables[0];
		const decTable = this._tables[1];
		const sbox = encTable[4];
		const sboxInv = decTable[4];
		const d = [];
		const th = [];
		let xInv, x2, x4, x8;

		// Compute double and third tables
		for (let i = 0; i < 256; i++) {
			th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
		}

		for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
			// Compute sbox
			let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
			s = s >> 8 ^ s & 255 ^ 99;
			sbox[x] = s;
			sboxInv[s] = x;

			// Compute MixColumns
			x8 = d[x4 = d[x2 = d[x]]];
			let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
			let tEnc = d[s] * 0x101 ^ s * 0x1010100;

			for (let i = 0; i < 4; i++) {
				encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
				decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
			}
		}

		// Compactify.  Considerable speedup on Firefox.
		for (let i = 0; i < 5; i++) {
			encTable[i] = encTable[i].slice(0);
			decTable[i] = decTable[i].slice(0);
		}
	}

	/**
	 * Encryption and decryption core.
	 * @param {Array} input Four words to be encrypted or decrypted.
	 * @param dir The direction, 0 for encrypt and 1 for decrypt.
	 * @return {Array} The four encrypted or decrypted words.
	 * @private
	 */
	_crypt(input, dir) {
		if (input.length !== 4) {
			throw new Error("invalid aes block size");
		}

		const key = this._key[dir];

		const nInnerRounds = key.length / 4 - 2;
		const out = [0, 0, 0, 0];
		const table = this._tables[dir];

		// load up the tables
		const t0 = table[0];
		const t1 = table[1];
		const t2 = table[2];
		const t3 = table[3];
		const sbox = table[4];

		// state variables a,b,c,d are loaded with pre-whitened data
		let a = input[0] ^ key[0];
		let b = input[dir ? 3 : 1] ^ key[1];
		let c = input[2] ^ key[2];
		let d = input[dir ? 1 : 3] ^ key[3];
		let kIndex = 4;
		let a2, b2, c2;

		// Inner rounds.  Cribbed from OpenSSL.
		for (let i = 0; i < nInnerRounds; i++) {
			a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
			b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
			c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
			d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
			kIndex += 4;
			a = a2; b = b2; c = c2;
		}

		// Last round.
		for (let i = 0; i < 4; i++) {
			out[dir ? 3 & -i : i] =
				sbox[a >>> 24] << 24 ^
				sbox[b >> 16 & 255] << 16 ^
				sbox[c >> 8 & 255] << 8 ^
				sbox[d & 255] ^
				key[kIndex++];
			a2 = a; a = b; b = c; c = d; d = a2;
		}

		return out;
	}
};

/**
 * Random values
 * @namespace
 */
const random$1 = {
	/** 
	 * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
	 * @param {TypedArray} typedArray The array to fill.
	 * @return {TypedArray} The random values.
	 */
	getRandomValues(typedArray) {
		const words = new Uint32Array(typedArray.buffer);
		const r = (m_w) => {
			let m_z = 0x3ade68b1;
			const mask = 0xffffffff;
			return function () {
				m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
				m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
				const result = ((((m_z << 0x10) + m_w) & mask) / 0x100000000) + .5;
				return result * (Math.random() > .5 ? 1 : -1);
			};
		};
		for (let i = 0, rcache; i < typedArray.length; i += 4) {
			const _r = r((rcache || Math.random()) * 0x100000000);
			rcache = _r() * 0x3ade67b7;
			words[i / 4] = (_r() * 0x100000000) | 0;
		}
		return typedArray;
	}
};

/** @fileOverview CTR mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Brian Gladman's CTR Mode.
* @constructor
* @param {Object} _prf The aes instance to generate key.
* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.
*/

const mode = {};

/**
 * Brian Gladman's CTR Mode.
 * @namespace
 */
mode.ctrGladman = class {
	constructor(prf, iv) {
		this._prf = prf;
		this._initIv = iv;
		this._iv = iv;
	}

	reset() {
		this._iv = this._initIv;
	}

	/** Input some data to calculate.
	 * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
	 */
	update(data) {
		return this.calculate(this._prf, data, this._iv);
	}

	incWord(word) {
		if (((word >> 24) & 0xff) === 0xff) { //overflow
			let b1 = (word >> 16) & 0xff;
			let b2 = (word >> 8) & 0xff;
			let b3 = word & 0xff;

			if (b1 === 0xff) { // overflow b1   
				b1 = 0;
				if (b2 === 0xff) {
					b2 = 0;
					if (b3 === 0xff) {
						b3 = 0;
					} else {
						++b3;
					}
				} else {
					++b2;
				}
			} else {
				++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
		} else {
			word += (0x01 << 24);
		}
		return word;
	}

	incCounter(counter) {
		if ((counter[0] = this.incWord(counter[0])) === 0) {
			// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
			counter[1] = this.incWord(counter[1]);
		}
	}

	calculate(prf, data, iv) {
		let l;
		if (!(l = data.length)) {
			return [];
		}
		const bl = bitArray.bitLength(data);
		for (let i = 0; i < l; i += 4) {
			this.incCounter(iv);
			const e = prf.encrypt(iv);
			data[i] ^= e[0];
			data[i + 1] ^= e[1];
			data[i + 2] ^= e[2];
			data[i + 3] ^= e[3];
		}
		return bitArray.clamp(data, bl);
	}
};

const misc = {
	importKey(password) {
		return new misc.hmacSha1(codec.bytes.toBits(password));
	},
	pbkdf2(prf, salt, count, length) {
		count = count || 10000;
		if (length < 0 || count < 0) {
			throw new Error("invalid params to pbkdf2");
		}
		const byteLength = ((length >> 5) + 1) << 2;
		let u, ui, i, j, k;
		const arrayBuffer = new ArrayBuffer(byteLength);
		const out = new DataView(arrayBuffer);
		let outLength = 0;
		const b = bitArray;
		salt = codec.bytes.toBits(salt);
		for (k = 1; outLength < (byteLength || 1); k++) {
			u = ui = prf.encrypt(b.concat(salt, [k]));
			for (i = 1; i < count; i++) {
				ui = prf.encrypt(ui);
				for (j = 0; j < ui.length; j++) {
					u[j] ^= ui[j];
				}
			}
			for (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {
				out.setInt32(outLength, u[i]);
				outLength += 4;
			}
		}
		return arrayBuffer.slice(0, length / 8);
	}
};

/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=hash.sha1] The hash function to use.
 */
misc.hmacSha1 = class {

	constructor(key) {
		const hmac = this;
		const Hash = hmac._hash = hash.sha1;
		const exKey = [[], []];
		hmac._baseHash = [new Hash(), new Hash()];
		const bs = hmac._baseHash[0].blockSize / 32;

		if (key.length > bs) {
			key = new Hash().update(key).finalize();
		}

		for (let i = 0; i < bs; i++) {
			exKey[0][i] = key[i] ^ 0x36363636;
			exKey[1][i] = key[i] ^ 0x5C5C5C5C;
		}

		hmac._baseHash[0].update(exKey[0]);
		hmac._baseHash[1].update(exKey[1]);
		hmac._resultHash = new Hash(hmac._baseHash[0]);
	}
	reset() {
		const hmac = this;
		hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
		hmac._updated = false;
	}

	update(data) {
		const hmac = this;
		hmac._updated = true;
		hmac._resultHash.update(data);
	}

	digest() {
		const hmac = this;
		const w = hmac._resultHash.finalize();
		const result = new (hmac._hash)(hmac._baseHash[1]).update(w).finalize();

		hmac.reset();

		return result;
	}

	encrypt(data) {
		if (!this._updated) {
			this.update(data);
			return this.digest(data);
		} else {
			throw new Error("encrypt on already updated hmac called!");
		}
	}
};

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != UNDEFINED_TYPE && typeof crypto.getRandomValues == FUNCTION_TYPE;

const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";

function getRandomValues(array) {
	if (GET_RANDOM_VALUES_SUPPORTED) {
		return crypto.getRandomValues(array);
	} else {
		return random$1.getRandomValues(array);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = { name: "PBKDF2" };
const HASH_ALGORITHM = { name: "HMAC" };
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1000, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = ["deriveBits"];
const SALT_LENGTH = [8, 12, 16];
const KEY_LENGTH = [16, 24, 32];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
// deno-lint-ignore valid-typeof
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;

let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;

class AESDecryptionStream extends TransformStream {

	constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					signed,
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				if (password) {
					await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
					chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
					if (checkPasswordOnly) {
						controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
					} else {
						resolveReady();
					}
				} else {
					await ready;
				}
				const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - ((chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH));
				controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
			},
			async flush(controller) {
				const {
					signed,
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
					const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
					let decryptedChunkArray = new Uint8Array();
					if (chunkToDecrypt.length) {
						const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
						hmac.update(encryptedChunk);
						const decryptedChunk = ctr.update(encryptedChunk);
						decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
					}
					if (signed) {
						const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
						for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
							if (signature[indexSignature] != originalSignature[indexSignature]) {
								throw new Error(ERR_INVALID_SIGNATURE);
							}
						}
					}
					controller.enqueue(decryptedChunkArray);
				}
			}
		});
	}
}

class AESEncryptionStream extends TransformStream {

	constructor({ password, rawPassword, encryptionStrength }) {
		// deno-lint-ignore prefer-const
		let stream;
		super({
			start() {
				Object.assign(this, {
					ready: new Promise(resolve => this.resolveReady = resolve),
					password: encodePassword(password, rawPassword),
					strength: encryptionStrength - 1,
					pending: new Uint8Array()
				});
			},
			async transform(chunk, controller) {
				const aesCrypto = this;
				const {
					password,
					strength,
					resolveReady,
					ready
				} = aesCrypto;
				let preamble = new Uint8Array();
				if (password) {
					preamble = await createEncryptionKeys(aesCrypto, strength, password);
					resolveReady();
				} else {
					await ready;
				}
				const output = new Uint8Array(preamble.length + chunk.length - (chunk.length % BLOCK_LENGTH));
				output.set(preamble, 0);
				controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
			},
			async flush(controller) {
				const {
					ctr,
					hmac,
					pending,
					ready
				} = this;
				if (hmac && ctr) {
					await ready;
					let encryptedChunkArray = new Uint8Array();
					if (pending.length) {
						const encryptedChunk = ctr.update(toBits(codecBytes, pending));
						hmac.update(encryptedChunk);
						encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
					}
					stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
					controller.enqueue(concat(encryptedChunkArray, stream.signature));
				}
			}
		});
		stream = this;
	}
}

function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
	const {
		ctr,
		hmac,
		pending
	} = aesCrypto;
	const inputLength = input.length - paddingEnd;
	if (pending.length) {
		input = concat(pending, input);
		output = expand(output, inputLength - (inputLength % BLOCK_LENGTH));
	}
	let offset;
	for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
		const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
		if (verifySignature) {
			hmac.update(inputChunk);
		}
		const outputChunk = ctr.update(inputChunk);
		if (!verifySignature) {
			hmac.update(outputChunk);
		}
		output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
	}
	aesCrypto.pending = subarray(input, offset);
	return output;
}

async function createDecryptionKeys(decrypt, strength, password, preamble) {
	const passwordVerificationKey = await createKeys$1(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
	const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
	if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
		throw new Error(ERR_INVALID_PASSWORD);
	}
}

async function createEncryptionKeys(encrypt, strength, password) {
	const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
	const passwordVerification = await createKeys$1(encrypt, strength, password, salt);
	return concat(salt, passwordVerification);
}

async function createKeys$1(aesCrypto, strength, password, salt) {
	aesCrypto.password = null;
	const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
	const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * ((KEY_LENGTH[strength] * 2) + 2));
	const compositeKey = new Uint8Array(derivedBits);
	const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
	const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
	const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
	Object.assign(aesCrypto, {
		keys: {
			key,
			authentication,
			passwordVerification
		},
		ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
		hmac: new HmacSha1(authentication)
	});
	return passwordVerification;
}

async function importKey(format, password, algorithm, extractable, keyUsages) {
	if (IMPORT_KEY_SUPPORTED) {
		try {
			return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
		} catch (_error) {
			IMPORT_KEY_SUPPORTED = false;
			return misc.importKey(password);
		}
	} else {
		return misc.importKey(password);
	}
}

async function deriveBits(algorithm, baseKey, length) {
	if (DERIVE_BITS_SUPPORTED) {
		try {
			return await subtle.deriveBits(algorithm, baseKey, length);
		} catch (_error) {
			DERIVE_BITS_SUPPORTED = false;
			return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
		}
	} else {
		return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
	}
}

function encodePassword(password, rawPassword) {
	if (rawPassword === UNDEFINED_VALUE) {
		return encodeText(password);
	} else {
		return rawPassword;
	}
}

function concat(leftArray, rightArray) {
	let array = leftArray;
	if (leftArray.length + rightArray.length) {
		array = new Uint8Array(leftArray.length + rightArray.length);
		array.set(leftArray, 0);
		array.set(rightArray, leftArray.length);
	}
	return array;
}

function expand(inputArray, length) {
	if (length && length > inputArray.length) {
		const array = inputArray;
		inputArray = new Uint8Array(length);
		inputArray.set(array, 0);
	}
	return inputArray;
}

function subarray(array, begin, end) {
	return array.subarray(begin, end);
}

function fromBits(codecBytes, chunk) {
	return codecBytes.fromBits(chunk);
}
function toBits(codecBytes, chunk) {
	return codecBytes.toBits(chunk);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const HEADER_LENGTH = 12;

class ZipCryptoDecryptionStream extends TransformStream {

	constructor({ password, passwordVerification, checkPasswordOnly }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				if (zipCrypto.password) {
					const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
					zipCrypto.password = null;
					if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
						throw new Error(ERR_INVALID_PASSWORD);
					}
					chunk = chunk.subarray(HEADER_LENGTH);
				}
				if (checkPasswordOnly) {
					controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
				} else {
					controller.enqueue(decrypt(zipCrypto, chunk));
				}
			}
		});
	}
}

class ZipCryptoEncryptionStream extends TransformStream {

	constructor({ password, passwordVerification }) {
		super({
			start() {
				Object.assign(this, {
					password,
					passwordVerification
				});
				createKeys(this, password);
			},
			transform(chunk, controller) {
				const zipCrypto = this;
				let output;
				let offset;
				if (zipCrypto.password) {
					zipCrypto.password = null;
					const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
					header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
					output = new Uint8Array(chunk.length + header.length);
					output.set(encrypt(zipCrypto, header), 0);
					offset = HEADER_LENGTH;
				} else {
					output = new Uint8Array(chunk.length);
					offset = 0;
				}
				output.set(encrypt(zipCrypto, chunk), offset);
				controller.enqueue(output);
			}
		});
	}
}

function decrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte$1(target) ^ input[index];
		updateKeys(target, output[index]);
	}
	return output;
}

function encrypt(target, input) {
	const output = new Uint8Array(input.length);
	for (let index = 0; index < input.length; index++) {
		output[index] = getByte$1(target) ^ input[index];
		updateKeys(target, input[index]);
	}
	return output;
}

function createKeys(target, password) {
	const keys = [0x12345678, 0x23456789, 0x34567890];
	Object.assign(target, {
		keys,
		crcKey0: new Crc32(keys[0]),
		crcKey2: new Crc32(keys[2]),
	});
	for (let index = 0; index < password.length; index++) {
		updateKeys(target, password.charCodeAt(index));
	}
}

function updateKeys(target, byte) {
	let [key0, key1, key2] = target.keys;
	target.crcKey0.append([byte]);
	key0 = ~target.crcKey0.get();
	key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
	target.crcKey2.append([key1 >>> 24]);
	key2 = ~target.crcKey2.get();
	target.keys = [key0, key1, key2];
}

function getByte$1(target) {
	const temp = target.keys[2] | 2;
	return getInt8(Math.imul(temp, (temp ^ 1)) >>> 8);
}

function getInt8(number) {
	return number & 0xFF;
}

function getInt32(number) {
	return number & 0xFFFFFFFF;
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const COMPRESSION_FORMAT = "deflate-raw";

class DeflateStream extends TransformStream {

	constructor(options, { chunkSize, CompressionStream, CompressionStreamNative }) {
		super({});
		const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
		const stream = this;
		let crc32Stream, encryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { level, chunkSize }, CompressionStreamNative, CompressionStream);
		}
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
			} else {
				encryptionStream = new AESEncryptionStream(options);
				readable = pipeThrough(readable, encryptionStream);
			}
		}
		setReadable(stream, readable, () => {
			let signature;
			if (encrypted && !zipCrypto) {
				signature = encryptionStream.signature;
			}
			if ((!encrypted || zipCrypto) && signed) {
				signature = new DataView(crc32Stream.value.buffer).getUint32(0);
			}
			stream.signature = signature;
		});
	}
}

class InflateStream extends TransformStream {

	constructor(options, { chunkSize, DecompressionStream, DecompressionStreamNative }) {
		super({});
		const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
		let crc32Stream, decryptionStream;
		let readable = filterEmptyChunks(super.readable);
		if (encrypted) {
			if (zipCrypto) {
				readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
			} else {
				decryptionStream = new AESDecryptionStream(options);
				readable = pipeThrough(readable, decryptionStream);
			}
		}
		if (compressed) {
			readable = pipeThroughCommpressionStream(readable, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream);
		}
		if ((!encrypted || zipCrypto) && signed) {
			crc32Stream = new Crc32Stream();
			readable = pipeThrough(readable, crc32Stream);
		}
		setReadable(this, readable, () => {
			if ((!encrypted || zipCrypto) && signed) {
				const dataViewSignature = new DataView(crc32Stream.value.buffer);
				if (signature != dataViewSignature.getUint32(0, false)) {
					throw new Error(ERR_INVALID_SIGNATURE);
				}
			}
		});
	}
}

function filterEmptyChunks(readable) {
	return pipeThrough(readable, new TransformStream({
		transform(chunk, controller) {
			if (chunk && chunk.length) {
				controller.enqueue(chunk);
			}
		}
	}));
}

function setReadable(stream, readable, flush) {
	readable = pipeThrough(readable, new TransformStream({ flush }));
	Object.defineProperty(stream, "readable", {
		get() {
			return readable;
		}
	});
}

function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream) {
	try {
		const CompressionStream = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream;
		readable = pipeThrough(readable, new CompressionStream(COMPRESSION_FORMAT, options));
	} catch (_error) {
		if (useCompressionStream) {
			try {
				readable = pipeThrough(readable, new CodecStream(COMPRESSION_FORMAT, options));
			} catch (_error) {
				return readable;
			}
		} else {
			return readable;
		}
	}
	return readable;
}

function pipeThrough(readable, transformStream) {
	return readable.pipeThrough(transformStream);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";

class CodecStream extends TransformStream {

	constructor(options, config) {
		super({});
		const codec = this;
		const { codecType } = options;
		let Stream;
		if (codecType.startsWith(CODEC_DEFLATE)) {
			Stream = DeflateStream;
		} else if (codecType.startsWith(CODEC_INFLATE)) {
			Stream = InflateStream;
		}
		let outputSize = 0;
		let inputSize = 0;
		const stream = new Stream(options, config);
		const readable = super.readable;
		const inputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					inputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				Object.assign(codec, {
					inputSize
				});
			}
		});
		const outputSizeStream = new TransformStream({
			transform(chunk, controller) {
				if (chunk && chunk.length) {
					outputSize += chunk.length;
					controller.enqueue(chunk);
				}
			},
			flush() {
				const { signature } = stream;
				Object.assign(codec, {
					signature,
					outputSize,
					inputSize
				});
			}
		});
		Object.defineProperty(codec, "readable", {
			get() {
				return readable.pipeThrough(inputSizeStream).pipeThrough(stream).pipeThrough(outputSizeStream);
			}
		});
	}
}

class ChunkStream extends TransformStream {

	constructor(chunkSize) {
		let pendingChunk;
		super({
			transform,
			flush(controller) {
				if (pendingChunk && pendingChunk.length) {
					controller.enqueue(pendingChunk);
				}
			}
		});

		function transform(chunk, controller) {
			if (pendingChunk) {
				const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
				newChunk.set(pendingChunk);
				newChunk.set(chunk, pendingChunk.length);
				chunk = newChunk;
				pendingChunk = null;
			}
			if (chunk.length > chunkSize) {
				controller.enqueue(chunk.slice(0, chunkSize));
				transform(chunk.slice(chunkSize), controller);
			} else {
				pendingChunk = chunk;
			}
		}
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


// deno-lint-ignore valid-typeof
let WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;

class CodecWorker {

	constructor(workerData, { readable, writable }, { options, config, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
		const { signal } = streamOptions;
		Object.assign(workerData, {
			busy: true,
			readable: readable
				.pipeThrough(new ChunkStream(config.chunkSize))
				.pipeThrough(new ProgressWatcherStream(readable, streamOptions), { signal }),
			writable,
			options: Object.assign({}, options),
			scripts,
			transferStreams,
			terminate() {
				return new Promise(resolve => {
					const { worker, busy } = workerData;
					if (worker) {
						if (busy) {
							workerData.resolveTerminated = resolve;
						} else {
							worker.terminate();
							resolve();
						}
						workerData.interface = null;
					} else {
						resolve();
					}
				});
			},
			onTaskFinished() {
				const { resolveTerminated } = workerData;
				if (resolveTerminated) {
					workerData.resolveTerminated = null;
					workerData.terminated = true;
					workerData.worker.terminate();
					resolveTerminated();
				}
				workerData.busy = false;
				onTaskFinished(workerData);
			}
		});
		return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config);
	}
}

class ProgressWatcherStream extends TransformStream {

	constructor(readableSource, { onstart, onprogress, size, onend }) {
		let chunkOffset = 0;
		super({
			async start() {
				if (onstart) {
					await callHandler(onstart, size);
				}
			},
			async transform(chunk, controller) {
				chunkOffset += chunk.length;
				if (onprogress) {
					await callHandler(onprogress, chunkOffset, size);
				}
				controller.enqueue(chunk);
			},
			async flush() {
				readableSource.size = chunkOffset;
				if (onend) {
					await callHandler(onend, chunkOffset);
				}
			}
		});
	}
}

async function callHandler(handler, ...parameters) {
	try {
		await handler(...parameters);
	} catch (_error) {
		// ignored
	}
}

function createWorkerInterface(workerData, config) {
	return {
		run: () => runWorker$1(workerData, config)
	};
}

function createWebWorkerInterface(workerData, config) {
	const { baseURL, chunkSize } = config;
	if (!workerData.interface) {
		let worker;
		try {
			worker = getWebWorker(workerData.scripts[0], baseURL, workerData);
		} catch (_error) {
			WEB_WORKERS_SUPPORTED = false;
			return createWorkerInterface(workerData, config);
		}
		Object.assign(workerData, {
			worker,
			interface: {
				run: () => runWebWorker(workerData, { chunkSize })
			}
		});
	}
	return workerData.interface;
}

async function runWorker$1({ options, readable, writable, onTaskFinished }, config) {
	try {
		const codecStream = new CodecStream(options, config);
		await readable.pipeThrough(codecStream).pipeTo(writable, { preventClose: true, preventAbort: true });
		const {
			signature,
			inputSize,
			outputSize
		} = codecStream;
		return {
			signature,
			inputSize,
			outputSize
		};
	} finally {
		onTaskFinished();
	}
}

async function runWebWorker(workerData, config) {
	let resolveResult, rejectResult;
	const result = new Promise((resolve, reject) => {
		resolveResult = resolve;
		rejectResult = reject;
	});
	Object.assign(workerData, {
		reader: null,
		writer: null,
		resolveResult,
		rejectResult,
		result
	});
	const { readable, options, scripts } = workerData;
	const { writable, closed } = watchClosedStream(workerData.writable);
	const streamsTransferred = sendMessage({
		type: MESSAGE_START,
		scripts: scripts.slice(1),
		options,
		config,
		readable,
		writable
	}, workerData);
	if (!streamsTransferred) {
		Object.assign(workerData, {
			reader: readable.getReader(),
			writer: writable.getWriter()
		});
	}
	const resultValue = await result;
	if (!streamsTransferred) {
		await writable.getWriter().close();
	}
	await closed;
	return resultValue;
}

function watchClosedStream(writableSource) {
	let resolveStreamClosed;
	const closed = new Promise(resolve => resolveStreamClosed = resolve);
	const writable = new WritableStream({
		async write(chunk) {
			const writer = writableSource.getWriter();
			await writer.ready;
			await writer.write(chunk);
			writer.releaseLock();
		},
		close() {
			resolveStreamClosed();
		},
		abort(reason) {
			const writer = writableSource.getWriter();
			return writer.abort(reason);
		}
	});
	return { writable, closed };
}

let classicWorkersSupported = true;
let transferStreamsSupported = true;

function getWebWorker(url, baseURL, workerData) {
	const workerOptions = { type: "module" };
	let scriptUrl, worker;
	// deno-lint-ignore valid-typeof
	if (typeof url == FUNCTION_TYPE) {
		url = url();
	}
	try {
		scriptUrl = new URL(url, baseURL);
	} catch (_error) {
		scriptUrl = url;
	}
	if (classicWorkersSupported) {
		try {
			worker = new Worker(scriptUrl);
		} catch (_error) {
			classicWorkersSupported = false;
			worker = new Worker(scriptUrl, workerOptions);
		}
	} else {
		worker = new Worker(scriptUrl, workerOptions);
	}
	worker.addEventListener(MESSAGE_EVENT_TYPE, event => onMessage(event, workerData));
	return worker;
}

function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
	try {
		const { value, readable, writable } = message;
		const transferables = [];
		if (value) {
			if (value.byteLength < value.buffer.byteLength) {
				message.value = value.buffer.slice(0, value.byteLength);
			}
			else {
				message.value = value.buffer;
			}
			transferables.push(message.value);
		}
		if (transferStreams && transferStreamsSupported) {
			if (readable) {
				transferables.push(readable);
			}
			if (writable) {
				transferables.push(writable);
			}
		} else {
			message.readable = message.writable = null;
		}
		if (transferables.length) {
			try {
				worker.postMessage(message, transferables);
				return true;
			} catch (_error) {
				transferStreamsSupported = false;
				message.readable = message.writable = null;
				worker.postMessage(message);
			}
		} else {
			worker.postMessage(message);
		}
	} catch (error) {
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
		throw error;
	}
}

async function onMessage({ data }, workerData) {
	const { type, value, messageId, result, error } = data;
	const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
	try {
		if (error) {
			const { message, stack, code, name } = error;
			const responseError = new Error(message);
			Object.assign(responseError, { stack, code, name });
			close(responseError);
		} else {
			if (type == MESSAGE_PULL) {
				const { value, done } = await reader.read();
				sendMessage({ type: MESSAGE_DATA, value, done, messageId }, workerData);
			}
			if (type == MESSAGE_DATA) {
				await writer.ready;
				await writer.write(new Uint8Array(value));
				sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
			}
			if (type == MESSAGE_CLOSE) {
				close(null, result);
			}
		}
	} catch (error) {
		sendMessage({ type: MESSAGE_CLOSE, messageId }, workerData);
		close(error);
	}

	function close(error, result) {
		if (error) {
			rejectResult(error);
		} else {
			resolveResult(result);
		}
		if (writer) {
			writer.releaseLock();
		}
		onTaskFinished();
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let pool = [];
const pendingRequests = [];

let indexWorker = 0;

async function runWorker(stream, workerOptions) {
	const { options, config } = workerOptions;
	const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
	const { workerScripts, maxWorkers } = config;
	workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
	const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
	workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || (useWebWorkers === UNDEFINED_VALUE && config.useWebWorkers));
	workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
	options.useCompressionStream = useCompressionStream || (useCompressionStream === UNDEFINED_VALUE && config.useCompressionStream);
	return (await getWorker()).run();

	// deno-lint-ignore require-await
	async function getWorker() {
		const workerData = pool.find(workerData => !workerData.busy);
		if (workerData) {
			clearTerminateTimeout(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else if (pool.length < maxWorkers) {
			const workerData = { indexWorker };
			indexWorker++;
			pool.push(workerData);
			return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
		} else {
			return new Promise(resolve => pendingRequests.push({ resolve, stream, workerOptions }));
		}
	}

	function onTaskFinished(workerData) {
		if (pendingRequests.length) {
			const [{ resolve, stream, workerOptions }] = pendingRequests.splice(0, 1);
			resolve(new CodecWorker(workerData, stream, workerOptions, onTaskFinished));
		} else if (workerData.worker) {
			clearTerminateTimeout(workerData);
			terminateWorker(workerData, workerOptions);
		} else {
			pool = pool.filter(data => data != workerData);
		}
	}
}

function terminateWorker(workerData, workerOptions) {
	const { config } = workerOptions;
	const { terminateWorkerTimeout } = config;
	if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
		if (workerData.terminated) {
			workerData.terminated = false;
		} else {
			workerData.terminateTimeout = setTimeout(async () => {
				pool = pool.filter(data => data != workerData);
				try {
					await workerData.terminate();
				} catch (_error) {
					// ignored
				}
			}, terminateWorkerTimeout);
		}
	}
}

function clearTerminateTimeout(workerData) {
	const { terminateTimeout } = workerData;
	if (terminateTimeout) {
		clearTimeout(terminateTimeout);
		workerData.terminateTimeout = null;
	}
}

function e(e,t={}){const n='const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={p:{m(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},k(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.v=[1732584193,4023233417,2562383102,271733878,3285377520],t.S=[1518500249,1859775393,2400959708,3395469782],e?(t.C=e.C.slice(0),t.A=e.A.slice(0),t._=e._):t.reset()}reset(){const e=this;return e.C=e.v.slice(0),e.A=[],e._=0,e}update(e){const t=this;"string"==typeof e&&(e=I.I.k(e));const n=t.A=_.concat(t.A,e),r=t._,i=t._=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.P(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}D(){const e=this;let t=e.A;const n=e.C;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._/4294967296)),t.push(0|e._);t.length;)e.P(t.splice(0,16));return e.reset(),n}V(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}R(e,t){return t<<e|t>>>32-e}P(t){const n=this,s=n.C,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.R(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.R(5,o)+n.V(e,c,f,a)+l+i[e]+n.S[r.floor(e/20)]|0;l=a,a=f,f=n.R(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.B(I.p.k(e)),M(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.p.k(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},B:class{constructor(e){const t=this,n=t.U=P,r=[[],[]];t.K=[new n,new n];const s=t.K[0].blockSize/32;e.length>s&&(e=(new n).update(e).D());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.K[0].update(r[0]),t.K[1].update(r[1]),t.N=new n(t.K[0])}reset(){const e=this;e.N=new e.U(e.K[0]),e.O=!1}update(e){this.O=!0,this.N.update(e)}digest(){const e=this,t=e.N.D(),n=new e.U(e.K[1]).update(t).D();return e.reset(),n}encrypt(e){if(this.O)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.p,X=class{constructor(e){const t=this;t.T=[[[],[],[],[],[]],[[],[],[],[],[]]],t.T[0][0][0]||t.W();const n=t.T[0][4],r=t.T[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.S=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.j(e,0)}decrypt(e){return this.j(e,1)}W(){const e=this.T[0],t=this.T[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}j(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.S[t],r=n.length/4-2,i=[0,0,0,0],o=this.T[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.H=e,this.L=t,this.F=t}reset(){this.F=this.L}update(e){return this.q(this.H,e,this.F)}G(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}J(e){0===(e[0]=this.G(e[0]))&&(e[1]=this.G(e[1]))}q(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.J(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.B;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.X=e)),password:ie(e,n),signed:r,Y:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,Y:o,X:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Z:n,$:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.X=e)),password:ie(e,n),Y:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,Y:s,X:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Z:t,$:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Z:c,$:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.M(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.M(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,ee:u,passwordVerification:w},Z:new Y(new X(l),e.from(F)),$:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.m(t)}function ae(e,t){return e.k(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,te:new x(r[0]),ne:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.te.append([t]),n=~e.te.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.ne.append([s>>>24]),i=~e.ne.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.re=n=>{const s=e.se,i=e.oe.ie,o=e.oe.ce;let c,f,a,l=-1;for(n.fe=0,n.ae=573,c=0;o>c;c++)0!==s[2*c]?(n.le[++n.fe]=l=c,n.ue[c]=0):s[2*c+1]=0;for(;2>n.fe;)a=n.le[++n.fe]=2>l?++l:0,s[2*a]=1,n.ue[a]=0,n.we--,i&&(n.he-=i[2*a+1]);for(e.de=l,c=r.floor(n.fe/2);c>=1;c--)n.pe(s,c);a=o;do{c=n.le[1],n.le[1]=n.le[n.fe--],n.pe(s,1),f=n.le[1],n.le[--n.ae]=c,n.le[--n.ae]=f,s[2*a]=s[2*c]+s[2*f],n.ue[a]=r.max(n.ue[c],n.ue[f])+1,s[2*c+1]=s[2*f+1]=a,n.le[1]=a++,n.pe(s,1)}while(n.fe>=2);n.le[--n.ae]=n.le[1],(t=>{const n=e.se,r=e.oe.ie,s=e.oe.ye,i=e.oe.me,o=e.oe.be;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.ge[l]=0;for(n[2*t.le[t.ae]+1]=0,c=t.ae+1;573>c;c++)f=t.le[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.de||(t.ge[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.we+=w*(l+u),r&&(t.he+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.ge[l];)l--;t.ge[l]--,t.ge[l+1]+=2,t.ge[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.ge[l];0!==f;)a=t.le[--c],a>e.de||(n[2*a+1]!=l&&(t.we+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.de,n.ge)}}function Le(e,t,n,r,s){const i=this;i.ie=e,i.ye=t,i.me=n,i.ce=r,i.be=s}He.ke=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ve=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.Se=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.ze=e=>256>e?je[e]:je[256+(e>>>7)],He.Ce=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.xe=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.Ae=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He._e=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le.Ie=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Pe=e,i.De=t,i.Ve=n,i.Re=r,i.Be=s}Le.Ee=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Me=new Le(Le.Ie,He.Ce,257,286,15),Le.Ue=new Le(Le.Ee,He.xe,0,30,15),Le.Ke=new Le(null,He.Ae,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.we=e.he=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ne[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Oe[W]=t,e.Te[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ke[n]+256+1)]++,M[2*He.ze(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.xe[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Oe[c],s=e.Te[c],c++,0===r?Y(s,t):(i=He.ke[s],Y(i+256+1,t),o=He.Ce[i],0!==o&&(s-=He.ve[i],X(s,o)),r--,i=He.ze(r),Y(i,n),o=He.xe[i],0!==o&&(r-=He.Se[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ne.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.re(e),N.re(e),o=(()=>{let t;for(G(E,K.de),G(M,N.de),O.re(e),t=18;t>=3&&0===U[2*He._e[t]+1];t--);return e.we+=14+3*(t+1),t})(),s=e.we+3+7>>>3,i=e.he+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le.Ie,Le.Ee)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He._e[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.de+1,N.de+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.We()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.je)return;e=t.He(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.je)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.ue=[],e.ge=[],e.le=[],E=[],M=[],U=[],e.pe=(t,n)=>{const r=e.le,s=r[n];let i=n<<1;for(;i<=e.fe&&(i<e.fe&&$e(t,r[i+1],r[i],e.ue)&&i++,!$e(t,s,r[i],e.ue));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.Le=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Fe=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.qe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ne=new i(4*T),s=4*T,e.Oe=new o(T),e.Te=new i(T),D=S,V=G,(t=>(t.Ge=t.Je=0,t.Fe=null,e.pending=0,e.Qe=0,n=Xe,c=0,K.se=E,K.oe=Le.Me,N.se=M,N.oe=Le.Ue,O.se=U,O.oe=Le.Ke,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].De,R=Je[D].Pe,B=Je[D].Ve,I=Je[D].Re,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Xe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Te=null,e.Oe=null,e.Ne=null,d=null,h=null,u=null,e.qe=null,n==Xe?-3:0),e.Ye=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Be!=Je[t].Be&&0!==e.Ge&&(r=e.Ze(1)),D!=t&&(D=t,P=Je[D].De,R=Je[D].Pe,B=Je[D].Ve,I=Je[D].Re),V=n,r)},e.$e=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ze=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.et||!r.tt&&0!==r.je||n==Ye&&4!=i)return r.Fe=Qe[4],Oe;if(0===r.nt)return r.Fe=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.We(),0===t.nt)return c=-1,0}else if(0===t.je&&I>=i&&4!=i)return t.Fe=Qe[7],-5;if(n==Ye&&0!==t.je)return r.Fe=Qe[7],-5;if(0!==t.je||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Be){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.nt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.nt))return 0}return se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.nt))return 0}return se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.nt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.nt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.nt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.nt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le.Ie),$(),9>1+H+10-F&&(X(2,3),Y(256,Le.Ie),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.We(),0===t.nt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.rt=0,e.st=0,e.je=0,e.Ge=0,e.nt=0,e.Je=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.Le(f),t.et=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.rt=0,t.tt=e,t.je=e.length;do{if(t.st=0,t.nt=n,o=t.Ze(0),0!=o)throw new s("deflating: "+t.Fe);t.st&&(t.st==n?w.push(new i(c)):w.push(c.subarray(0,t.st))),u+=t.st,r&&t.rt>0&&t.rt!=a&&(r(t.rt),a=t.rt)}while(t.je>0||0===t.nt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.st=0,t.nt=n,e=t.Ze(4),1!=e&&0!=e)throw new s("deflating: "+t.Fe);n-t.nt>0&&a.push(c.slice(0,t.st)),f+=t.st}while(t.je>0||0===t.nt);return t.Xe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={Le(e,t){const n=this;return n.qe=new et,t||(t=15),n.qe.Le(n,e,t)},Ze(e){const t=this;return t.qe?t.qe.Ze(t,e):Oe},Xe(){const e=this;if(!e.qe)return Oe;const t=e.qe.Xe();return e.qe=null,t},Ye(e,t){const n=this;return n.qe?n.qe.Ye(n,e,t):Oe},$e(e,t){const n=this;return n.qe?n.qe.$e(n,e,t):Oe},He(e,t,n){const r=this;let s=r.je;return s>n&&(s=n),0===s?0:(r.je-=s,e.set(r.tt.subarray(r.rt,r.rt+s),t),r.rt+=s,r.Ge+=s,s)},We(){const e=this;let t=e.qe.pending;t>e.nt&&(t=e.nt),0!==t&&(e.et.set(e.qe.Ne.subarray(e.qe.Qe,e.qe.Qe+t),e.st),e.st+=t,e.qe.Qe+=t,e.Je+=t,e.nt-=t,e.qe.pending-=t,0===e.qe.pending&&(e.qe.Qe=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.it=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Fe="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Fe="incomplete dynamic bit lengths tree",a=st),a},this.ot=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Fe="oversubscribed literal/length tree":-4!=h&&(w.Fe="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Fe="oversubscribed distance tree":h==it?(w.Fe="incomplete distance tree",h=st):-4!=h&&(w.Fe="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.rt,p=c.je,w=o.ct,h=o.ft,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.lt(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.ut[y++]=o.ut[S++]}while(0!=--u);else o.ut.set(o.ut.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.ut[y++]=o.ut[S++],o.ut[y++]=o.ut[S++],k-=2):(o.ut.set(o.ut.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.ut[y++]=o.ut[S++]}while(0!=--k);else o.ut.set(o.ut.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Fe="invalid distance code",k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,1):(c.Fe="invalid literal/length code",k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.ut[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.ut[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.je-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ct=w,o.ft=h,c.je=p,c.Ge+=d-c.rt,c.rt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.wt=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.rt,v=y.je,x=e.ct,A=e.ft,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.rt,v=y.je,x=e.ct,A=e.ft,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Fe="invalid literal/length code",m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Fe="invalid distance code",m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,v--,x|=(255&y.lt(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);e.ut[S++]=e.ut[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);m=0,e.ut[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.ht(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);t=8;case 8:return m=1,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);case 9:return m=st,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m);default:return m=rt,e.ct=x,e.ft=A,y.je=v,y.Ge+=_-y.rt,y.rt=_,e.write=S,e.ht(y,m)}},e.dt=()=>{}}ht.yt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ft=0,n.ct=0,n.ut=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.dt(e),s=0,n.ft=0,n.ct=0,n.read=n.write=0},n.reset(e,null),n.ht=(e,t)=>{let r,s,i;return s=e.st,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.nt&&(r=e.nt),0!==r&&t==it&&(t=0),e.nt-=r,e.Je+=r,e.et.set(n.ut.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.nt&&(r=e.nt),0!==r&&t==it&&(t=0),e.nt-=r,e.Je+=r,e.et.set(n.ut.subarray(i,i+r),s),s+=r,i+=r),e.st=s,n.read=i,t},n.wt=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.rt,b=e.je,f=n.ct,y=n.ft,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.yt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Fe="invalid block type",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Fe="invalid stored block lengths",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.ht(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.ut.set(e.He(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Fe="too many length or distance symbols",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.it(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);t=0,b--,f|=(255&e.lt(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Fe="invalid bit length repeat",t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.ot(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,1!=(t=w.wt(n,e,t)))return n.ht(e,t);if(t=0,w.dt(e),m=e.rt,b=e.je,f=n.ct,y=n.ft,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.ht(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);s=8;case 8:return t=1,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);case 9:return t=st,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t);default:return t=rt,n.ct=f,n.ft=y,e.je=b,e.Ge+=m-e.rt,e.rt=m,n.write=g,n.ht(e,t)}}},n.dt=e=>{n.reset(e,null),n.ut=null,d=null},n.bt=(e,t,r)=>{n.ut.set(e.subarray(t,t+r),0),n.read=n.write=r},n.gt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.kt?(e.Ge=e.Je=0,e.Fe=null,e.kt.mode=7,e.kt.vt.reset(e,null),0):rt}e.mode=0,e.method=0,e.St=[0],e.zt=0,e.marker=0,e.Ct=0,e.xt=t=>(e.vt&&e.vt.dt(t),e.vt=null,0),e.At=(n,r)=>(n.Fe=null,e.vt=null,8>r||r>15?(e.xt(n),rt):(e.Ct=r,n.kt.vt=new yt(n,1<<r),t(n),0)),e._t=(e,t)=>{let n,r;if(!e||!e.kt||!e.tt)return rt;const s=e.kt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.je)return n;if(n=t,e.je--,e.Ge++,8!=(15&(s.method=e.lt(e.rt++)))){s.mode=mt,e.Fe="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.Ct){s.mode=mt,e.Fe="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.je)return n;if(n=t,e.je--,e.Ge++,r=255&e.lt(e.rt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Fe="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt=(255&e.lt(e.rt++))<<24&4278190080,s.mode=3;case 3:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt+=(255&e.lt(e.rt++))<<16&16711680,s.mode=4;case 4:if(0===e.je)return n;n=t,e.je--,e.Ge++,s.zt+=(255&e.lt(e.rt++))<<8&65280,s.mode=5;case 5:return 0===e.je?n:(n=t,e.je--,e.Ge++,s.zt+=255&e.lt(e.rt++),s.mode=6,2);case 6:return s.mode=mt,e.Fe="need dictionary",s.marker=0,rt;case 7:if(n=s.vt.wt(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.vt.reset(e,s.St),s.mode=12;case 12:return e.je=0,1;case mt:return st;default:return rt}},e.It=(e,t,n)=>{let r=0,s=n;if(!e||!e.kt||6!=e.kt.mode)return rt;const i=e.kt;return s<1<<i.Ct||(s=(1<<i.Ct)-1,r=n-s),i.vt.bt(t,r,s),i.mode=7,0},e.Pt=e=>{let n,r,s,i,o;if(!e||!e.kt)return rt;const c=e.kt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.je))return it;for(r=e.rt,s=c.marker;0!==n&&4>s;)e.lt(r)==bt[s]?s++:s=0!==e.lt(r)?0:4-s,r++,n--;return e.Ge+=r-e.rt,e.rt=r,e.je=n,c.marker=s,4!=s?st:(i=e.Ge,o=e.Je,t(e),e.Ge=i,e.Je=o,c.mode=7,0)},e.Dt=e=>e&&e.kt&&e.kt.vt?e.kt.vt.gt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.At(),t.et=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.rt=0,t.tt=e,t.je=e.length;do{if(t.st=0,t.nt=n,0!==t.je||c||(t.rt=0,c=!0),a=t._t(0),c&&a===it){if(0!==t.je)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Fe);if((c||1===a)&&t.je===e.length)throw new s("inflating: bad input");t.st&&(t.st===n?f.push(new i(o)):f.push(o.subarray(0,t.st))),h+=t.st,r&&t.rt>0&&t.rt!=u&&(r(t.rt),u=t.rt)}while(t.je>0||0===t.nt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.xt()}}kt.prototype={At(e){const t=this;return t.kt=new gt,e||(e=15),t.kt.At(t,e)},_t(e){const t=this;return t.kt?t.kt._t(t,e):rt},xt(){const e=this;if(!e.kt)return rt;const t=e.kt.xt(e);return e.kt=null,t},Pt(){const e=this;return e.kt?e.kt.Pt(e):rt},It(e,t){const n=this;return n.kt?n.kt.It(n,e,t):rt},lt(e){return this.tt[e]},He(e,t){return this.tt.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};\n',r=()=>t.useDataURI?"data:text/javascript,"+encodeURIComponent(n):URL.createObjectURL(new Blob([n],{type:"text/javascript"}));e({workerScripts:{inflate:[r],deflate:[r]}});}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const DEFAULT_CHUNK_SIZE = 64 * 1024;

const PROPERTY_NAME_WRITABLE = "writable";

class Stream {

	constructor() {
		this.size = 0;
	}

	init() {
		this.initialized = true;
	}
}

class Reader extends Stream {

	get readable() {
		const reader = this;
		const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
		const readable = new ReadableStream({
			start() {
				this.chunkOffset = 0;
			},
			async pull(controller) {
				const { offset = 0, size, diskNumberStart } = readable;
				const { chunkOffset } = this;
				controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
				if (chunkOffset + chunkSize > size) {
					controller.close();
				} else {
					this.chunkOffset += chunkSize;
				}
			}
		});
		return readable;
	}
}

class BlobReader extends Reader {

	constructor(blob) {
		super();
		Object.assign(this, {
			blob,
			size: blob.size
		});
	}

	async readUint8Array(offset, length) {
		const reader = this;
		const offsetEnd = offset + length;
		const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
		let arrayBuffer = await blob.arrayBuffer();
		if (arrayBuffer.byteLength > length) {
			arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
		}
		return new Uint8Array(arrayBuffer);
	}
}

class BlobWriter extends Stream {

	constructor(contentType) {
		super();
		const writer = this;
		const transformStream = new TransformStream();
		const headers = [];
		if (contentType) {
			headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
		}
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return transformStream.writable;
			}
		});
		writer.blob = new Response(transformStream.readable, { headers }).blob();
	}

	getData() {
		return this.blob;
	}
}

class SplitDataReader extends Reader {

	constructor(readers) {
		super();
		this.readers = readers;
	}

	async init() {
		const reader = this;
		const { readers } = reader;
		reader.lastDiskNumber = 0;
		reader.lastDiskOffset = 0;
		await Promise.all(readers.map(async (diskReader, indexDiskReader) => {
			await diskReader.init();
			if (indexDiskReader != readers.length - 1) {
				reader.lastDiskOffset += diskReader.size;
			}
			reader.size += diskReader.size;
		}));
		super.init();
	}

	async readUint8Array(offset, length, diskNumber = 0) {
		const reader = this;
		const { readers } = this;
		let result;
		let currentDiskNumber = diskNumber;
		if (currentDiskNumber == -1) {
			currentDiskNumber = readers.length - 1;
		}
		let currentReaderOffset = offset;
		while (currentReaderOffset >= readers[currentDiskNumber].size) {
			currentReaderOffset -= readers[currentDiskNumber].size;
			currentDiskNumber++;
		}
		const currentReader = readers[currentDiskNumber];
		const currentReaderSize = currentReader.size;
		if (currentReaderOffset + length <= currentReaderSize) {
			result = await readUint8Array(currentReader, currentReaderOffset, length);
		} else {
			const chunkLength = currentReaderSize - currentReaderOffset;
			result = new Uint8Array(length);
			result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
			result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
		}
		reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
		return result;
	}
}

class SplitDataWriter extends Stream {

	constructor(writerGenerator, maxSize = 4294967295) {
		super();
		const writer = this;
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			size: 0,
			maxSize,
			availableSize: maxSize
		});
		let diskSourceWriter, diskWritable, diskWriter;
		const writable = new WritableStream({
			async write(chunk) {
				const { availableSize } = writer;
				if (!diskWriter) {
					const { value, done } = await writerGenerator.next();
					if (done && !value) {
						throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
					} else {
						diskSourceWriter = value;
						diskSourceWriter.size = 0;
						if (diskSourceWriter.maxSize) {
							writer.maxSize = diskSourceWriter.maxSize;
						}
						writer.availableSize = writer.maxSize;
						await initStream(diskSourceWriter);
						diskWritable = value.writable;
						diskWriter = diskWritable.getWriter();
					}
					await this.write(chunk);
				} else if (chunk.length >= availableSize) {
					await writeChunk(chunk.slice(0, availableSize));
					await closeDisk();
					writer.diskOffset += diskSourceWriter.size;
					writer.diskNumber++;
					diskWriter = null;
					await this.write(chunk.slice(availableSize));
				} else {
					await writeChunk(chunk);
				}
			},
			async close() {
				await diskWriter.ready;
				await closeDisk();
			}
		});
		Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
			get() {
				return writable;
			}
		});

		async function writeChunk(chunk) {
			const chunkLength = chunk.length;
			if (chunkLength) {
				await diskWriter.ready;
				await diskWriter.write(chunk);
				diskSourceWriter.size += chunkLength;
				writer.size += chunkLength;
				writer.availableSize -= chunkLength;
			}
		}

		async function closeDisk() {
			diskWritable.size = diskSourceWriter.size;
			await diskWriter.close();
		}
	}
}

async function initStream(stream, initSize) {
	if (stream.init && !stream.initialized) {
		await stream.init(initSize);
	} else {
		return Promise.resolve();
	}
}

function initReader(reader) {
	if (Array.isArray(reader)) {
		reader = new SplitDataReader(reader);
	}
	if (reader instanceof ReadableStream) {
		reader = {
			readable: reader
		};
	}
	return reader;
}

function initWriter(writer) {
	if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
		writer = new SplitDataWriter(writer);
	}
	if (writer instanceof WritableStream) {
		writer = {
			writable: writer
		};
	}
	const { writable } = writer;
	if (writable.size === UNDEFINED_VALUE) {
		writable.size = 0;
	}
	if (!(writer instanceof SplitDataWriter)) {
		Object.assign(writer, {
			diskNumber: 0,
			diskOffset: 0,
			availableSize: Infinity,
			maxSize: Infinity
		});
	}
	return writer;
}

function readUint8Array(reader, offset, size, diskNumber) {
	return reader.readUint8Array(offset, size, diskNumber);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* global TextDecoder */

const CP437 = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");
const VALID_CP437 = CP437.length == 256;

function decodeCP437(stringValue) {
	if (VALID_CP437) {
		let result = "";
		for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
			result += CP437[stringValue[indexCharacter]];
		}
		return result;
	} else {
		return new TextDecoder().decode(stringValue);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


function decodeText(value, encoding) {
	if (encoding && encoding.trim().toLowerCase() == "cp437") {
		return decodeCP437(value);
	} else {
		return new TextDecoder(encoding).decode(value);
	}
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";
const PROPERTY_NAME_ENCRYPTED = "encrypted";
const PROPERTY_NAME_VERSION = "version";
const PROPERTY_NAME_VERSION_MADE_BY = "versionMadeBy";
const PROPERTY_NAME_ZIPCRYPTO = "zipCrypto";

const PROPERTY_NAMES = [
	PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, PROPERTY_NAME_COMPPRESSED_SIZE, PROPERTY_NAME_UNCOMPPRESSED_SIZE,
	PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT,
	PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_OFFSET, PROPERTY_NAME_DISK_NUMBER_START,
	PROPERTY_NAME_DISK_NUMBER_START, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
	PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64, PROPERTY_NAME_ENCRYPTED, PROPERTY_NAME_VERSION, PROPERTY_NAME_VERSION_MADE_BY,
	PROPERTY_NAME_ZIPCRYPTO, "directory", "bitFlag", "signature", "filenameUTF8", "commentUTF8", "compressionMethod", "extraField", "rawExtraField",
	"extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "extraFieldNTFS", "extraFieldExtendedTimestamp"];

class Entry {

	constructor(data) {
		PROPERTY_NAMES.forEach(name => this[name] = data[name]);
	}

}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
	[PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
	[PROPERTY_NAME_OFFSET, MAX_32_BITS],
	[PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
];
const ZIP64_EXTRACTION = {
	[MAX_16_BITS]: {
		getValue: getUint32,
		bytes: 4
	},
	[MAX_32_BITS]: {
		getValue: getBigUint64,
		bytes: 8
	}
};

class ZipReader {

	constructor(reader, options = {}) {
		Object.assign(this, {
			reader: initReader(reader),
			options,
			config: getConfiguration()
		});
	}

	async* getEntriesGenerator(options = {}) {
		const zipReader = this;
		let { reader } = zipReader;
		const { config } = zipReader;
		await initStream(reader);
		if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
			reader = new BlobReader(await new Response(reader.readable).blob());
			await initStream(reader);
		}
		if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
			throw new Error(ERR_BAD_FORMAT);
		}
		reader.chunkSize = getChunkSize(config);
		const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
		if (!endOfDirectoryInfo) {
			const signatureArray = await readUint8Array(reader, 0, 4);
			const signatureView = getDataView(signatureArray);
			if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
				throw new Error(ERR_SPLIT_ZIP_FILE);
			} else {
				throw new Error(ERR_EOCDR_NOT_FOUND);
			}
		}
		const endOfDirectoryView = getDataView(endOfDirectoryInfo);
		let directoryDataLength = getUint32(endOfDirectoryView, 12);
		let directoryDataOffset = getUint32(endOfDirectoryView, 16);
		const commentOffset = endOfDirectoryInfo.offset;
		const commentLength = getUint16(endOfDirectoryView, 20);
		const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
		let lastDiskNumber = getUint16(endOfDirectoryView, 4);
		const expectedLastDiskNumber = reader.lastDiskNumber || 0;
		let diskNumber = getUint16(endOfDirectoryView, 6);
		let filesLength = getUint16(endOfDirectoryView, 8);
		let prependedDataLength = 0;
		let startOffset = 0;
		if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
			const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
			const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
			if (getUint32(endOfDirectoryLocatorView, 0) == ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
				directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
				let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
				let endOfDirectoryView = getDataView(endOfDirectoryArray);
				const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
				if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
					const originalDirectoryDataOffset = directoryDataOffset;
					directoryDataOffset = expectedDirectoryDataOffset;
					prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
					endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
					endOfDirectoryView = getDataView(endOfDirectoryArray);
				}
				if (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
					throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
				}
				if (lastDiskNumber == MAX_16_BITS) {
					lastDiskNumber = getUint32(endOfDirectoryView, 16);
				}
				if (diskNumber == MAX_16_BITS) {
					diskNumber = getUint32(endOfDirectoryView, 20);
				}
				if (filesLength == MAX_16_BITS) {
					filesLength = getBigUint64(endOfDirectoryView, 32);
				}
				if (directoryDataLength == MAX_32_BITS) {
					directoryDataLength = getBigUint64(endOfDirectoryView, 40);
				}
				directoryDataOffset -= directoryDataLength;
			}
		}
		if (directoryDataOffset >= reader.size) {
			prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
			directoryDataOffset = reader.size - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
		}
		if (expectedLastDiskNumber != lastDiskNumber) {
			throw new Error(ERR_SPLIT_ZIP_FILE);
		}
		if (directoryDataOffset < 0) {
			throw new Error(ERR_BAD_FORMAT);
		}
		let offset = 0;
		let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
		let directoryView = getDataView(directoryArray);
		if (directoryDataLength) {
			const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
				const originalDirectoryDataOffset = directoryDataOffset;
				directoryDataOffset = expectedDirectoryDataOffset;
				prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
				directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
				directoryView = getDataView(directoryArray);
			}
		}
		const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
		if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
			directoryDataLength = expectedDirectoryDataLength;
			directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
			directoryView = getDataView(directoryArray);
		}
		if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
			throw new Error(ERR_BAD_FORMAT);
		}
		const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
		const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
		for (let indexFile = 0; indexFile < filesLength; indexFile++) {
			const fileEntry = new ZipEntry(reader, config, zipReader.options);
			if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
				throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
			}
			readCommonHeader(fileEntry, directoryView, offset + 6);
			const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
			const filenameOffset = offset + 46;
			const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
			const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
			const versionMadeBy = getUint16(directoryView, offset + 4);
			const msDosCompatible = (versionMadeBy & 0) == 0;
			const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
			const commentLength = getUint16(directoryView, offset + 32);
			const endOffset = commentOffset + commentLength;
			const rawComment = directoryArray.subarray(commentOffset, endOffset);
			const filenameUTF8 = languageEncodingFlag;
			const commentUTF8 = languageEncodingFlag;
			const directory = msDosCompatible && ((getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK);
			const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
			Object.assign(fileEntry, {
				versionMadeBy,
				msDosCompatible,
				compressedSize: 0,
				uncompressedSize: 0,
				commentLength,
				directory,
				offset: offsetFileEntry,
				diskNumberStart: getUint16(directoryView, offset + 34),
				internalFileAttribute: getUint16(directoryView, offset + 36),
				externalFileAttribute: getUint32(directoryView, offset + 38),
				rawFilename,
				filenameUTF8,
				commentUTF8,
				rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
			});
			const decode = getOptionValue(zipReader, options, "decodeText") || decodeText;
			const rawFilenameEncoding = filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437;
			const rawCommentEncoding = commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437;
			let filename = decode(rawFilename, rawFilenameEncoding);
			if (filename === UNDEFINED_VALUE) {
				filename = decodeText(rawFilename, rawFilenameEncoding);
			}
			let comment = decode(rawComment, rawCommentEncoding);
			if (comment === UNDEFINED_VALUE) {
				comment = decodeText(rawComment, rawCommentEncoding);
			}
			Object.assign(fileEntry, {
				rawComment,
				filename,
				comment,
				directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
			});
			startOffset = Math.max(offsetFileEntry, startOffset);
			readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
			fileEntry.zipCrypto = fileEntry.encrypted && !fileEntry.extraFieldAES;
			const entry = new Entry(fileEntry);
			entry.getData = (writer, options) => fileEntry.getData(writer, entry, options);
			offset = endOffset;
			const { onprogress } = options;
			if (onprogress) {
				try {
					await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
				} catch (_error) {
					// ignored
				}
			}
			yield entry;
		}
		const extractPrependedData = getOptionValue(zipReader, options, "extractPrependedData");
		const extractAppendedData = getOptionValue(zipReader, options, "extractAppendedData");
		if (extractPrependedData) {
			zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
		}
		zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
		if (extractAppendedData) {
			zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
		}
		return true;
	}

	async getEntries(options = {}) {
		const entries = [];
		for await (const entry of this.getEntriesGenerator(options)) {
			entries.push(entry);
		}
		return entries;
	}

	async close() {
	}
}

class ZipEntry {

	constructor(reader, config, options) {
		Object.assign(this, {
			reader,
			config,
			options
		});
	}

	async getData(writer, fileEntry, options = {}) {
		const zipEntry = this;
		const {
			reader,
			offset,
			diskNumberStart,
			extraFieldAES,
			compressionMethod,
			config,
			bitFlag,
			signature,
			rawLastModDate,
			uncompressedSize,
			compressedSize
		} = zipEntry;
		const localDirectory = fileEntry.localDirectory = {};
		const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
		const dataView = getDataView(dataArray);
		let password = getOptionValue(zipEntry, options, "password");
		let rawPassword = getOptionValue(zipEntry, options, "rawPassword");
		const passThrough = getOptionValue(zipEntry, options, "passThrough");
		password = password && password.length && password;
		rawPassword = rawPassword && rawPassword.length && rawPassword;
		if (extraFieldAES) {
			if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
				throw new Error(ERR_UNSUPPORTED_COMPRESSION);
			}
		}
		if ((compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) && !passThrough) {
			throw new Error(ERR_UNSUPPORTED_COMPRESSION);
		}
		if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
			throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
		}
		readCommonHeader(localDirectory, dataView, 4);
		localDirectory.rawExtraField = localDirectory.extraFieldLength ?
			await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) :
			new Uint8Array();
		readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
		Object.assign(fileEntry, {
			lastAccessDate: localDirectory.lastAccessDate,
			creationDate: localDirectory.creationDate
		});
		const encrypted = zipEntry.encrypted && localDirectory.encrypted && !passThrough;
		const zipCrypto = encrypted && !extraFieldAES;
		if (!passThrough) {
			fileEntry.zipCrypto = zipCrypto;
		}
		if (encrypted) {
			if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
				throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
			} else if (!password && !rawPassword) {
				throw new Error(ERR_ENCRYPTED);
			}
		}
		const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
		const size = compressedSize;
		const readable = reader.readable;
		Object.assign(readable, {
			diskNumberStart,
			offset: dataOffset,
			size
		});
		const signal = getOptionValue(zipEntry, options, "signal");
		const checkPasswordOnly = getOptionValue(zipEntry, options, "checkPasswordOnly");
		if (checkPasswordOnly) {
			writer = new WritableStream();
		}
		writer = initWriter(writer);
		await initStream(writer, passThrough ? compressedSize : uncompressedSize);
		const { writable } = writer;
		const { onstart, onprogress, onend } = options;
		const workerOptions = {
			options: {
				codecType: CODEC_INFLATE,
				password,
				rawPassword,
				zipCrypto,
				encryptionStrength: extraFieldAES && extraFieldAES.strength,
				signed: getOptionValue(zipEntry, options, "checkSignature") && !passThrough,
				passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? ((rawLastModDate >>> 8) & 0xFF) : ((signature >>> 24) & 0xFF)),
				signature,
				compressed: compressionMethod != 0 && !passThrough,
				encrypted: zipEntry.encrypted && !passThrough,
				useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
				useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream"),
				transferStreams: getOptionValue(zipEntry, options, "transferStreams"),
				checkPasswordOnly
			},
			config,
			streamOptions: { signal, size, onstart, onprogress, onend }
		};
		let outputSize = 0;
		try {
			({ outputSize } = (await runWorker({ readable, writable }, workerOptions)));
		} catch (error) {
			if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
				throw error;
			}
		} finally {
			const preventClose = getOptionValue(zipEntry, options, "preventClose");
			writable.size += outputSize;
			if (!preventClose && !writable.locked) {
				await writable.getWriter().close();
			}
		}
		return checkPasswordOnly ? UNDEFINED_VALUE : writer.getData ? writer.getData() : writable;
	}
}

function readCommonHeader(directory, dataView, offset) {
	const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
	const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
	const rawLastModDate = getUint32(dataView, offset + 6);
	Object.assign(directory, {
		encrypted,
		version: getUint16(dataView, offset),
		bitFlag: {
			level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
			dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
			languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
		},
		rawLastModDate,
		lastModDate: getDate(rawLastModDate),
		filenameLength: getUint16(dataView, offset + 22),
		extraFieldLength: getUint16(dataView, offset + 24)
	});
}

function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
	const { rawExtraField } = directory;
	const extraField = directory.extraField = new Map();
	const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
	let offsetExtraField = 0;
	try {
		while (offsetExtraField < rawExtraField.length) {
			const type = getUint16(rawExtraFieldView, offsetExtraField);
			const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
			extraField.set(type, {
				type,
				data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
			});
			offsetExtraField += 4 + size;
		}
	} catch (_error) {
		// ignored
	}
	const compressionMethod = getUint16(dataView, offset + 4);
	Object.assign(directory, {
		signature: getUint32(dataView, offset + 10),
		uncompressedSize: getUint32(dataView, offset + 18),
		compressedSize: getUint32(dataView, offset + 14)
	});
	const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
	if (extraFieldZip64) {
		readExtraFieldZip64(extraFieldZip64, directory);
		directory.extraFieldZip64 = extraFieldZip64;
	}
	const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
	if (extraFieldUnicodePath) {
		readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
		directory.extraFieldUnicodePath = extraFieldUnicodePath;
	}
	const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
	if (extraFieldUnicodeComment) {
		readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
		directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
	}
	const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
	if (extraFieldAES) {
		readExtraFieldAES(extraFieldAES, directory, compressionMethod);
		directory.extraFieldAES = extraFieldAES;
	} else {
		directory.compressionMethod = compressionMethod;
	}
	const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
	if (extraFieldNTFS) {
		readExtraFieldNTFS(extraFieldNTFS, directory);
		directory.extraFieldNTFS = extraFieldNTFS;
	}
	const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
	if (extraFieldExtendedTimestamp) {
		readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
		directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
	}
	const extraFieldUSDZ = extraField.get(EXTRAFIELD_TYPE_USDZ);
	if (extraFieldUSDZ) {
		directory.extraFieldUSDZ = extraFieldUSDZ;
	}
}

function readExtraFieldZip64(extraFieldZip64, directory) {
	directory.zip64 = true;
	const extraFieldView = getDataView(extraFieldZip64.data);
	const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
	for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
		const [propertyName, max] = missingProperties[indexMissingProperty];
		if (directory[propertyName] == max) {
			const extraction = ZIP64_EXTRACTION[max];
			directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
			offset += extraction.bytes;
		} else if (extraFieldZip64[propertyName]) {
			throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
		}
	}
}

function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
	const extraFieldView = getDataView(extraFieldUnicode.data);
	const crc32 = new Crc32();
	crc32.append(fileEntry[rawPropertyName]);
	const dataViewSignature = getDataView(new Uint8Array(4));
	dataViewSignature.setUint32(0, crc32.get(), true);
	const signature = getUint32(extraFieldView, 1);
	Object.assign(extraFieldUnicode, {
		version: getUint8(extraFieldView, 0),
		[propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
		valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
	});
	if (extraFieldUnicode.valid) {
		directory[propertyName] = extraFieldUnicode[propertyName];
		directory[propertyName + "UTF8"] = true;
	}
}

function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
	const extraFieldView = getDataView(extraFieldAES.data);
	const strength = getUint8(extraFieldView, 4);
	Object.assign(extraFieldAES, {
		vendorVersion: getUint8(extraFieldView, 0),
		vendorId: getUint8(extraFieldView, 2),
		strength,
		originalCompressionMethod: compressionMethod,
		compressionMethod: getUint16(extraFieldView, 5)
	});
	directory.compressionMethod = extraFieldAES.compressionMethod;
}

function readExtraFieldNTFS(extraFieldNTFS, directory) {
	const extraFieldView = getDataView(extraFieldNTFS.data);
	let offsetExtraField = 4;
	let tag1Data;
	try {
		while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
			const tagValue = getUint16(extraFieldView, offsetExtraField);
			const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
			if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
				tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
			}
			offsetExtraField += 4 + attributeSize;
		}
	} catch (_error) {
		// ignored
	}
	try {
		if (tag1Data && tag1Data.length == 24) {
			const tag1View = getDataView(tag1Data);
			const rawLastModDate = tag1View.getBigUint64(0, true);
			const rawLastAccessDate = tag1View.getBigUint64(8, true);
			const rawCreationDate = tag1View.getBigUint64(16, true);
			Object.assign(extraFieldNTFS, {
				rawLastModDate,
				rawLastAccessDate,
				rawCreationDate
			});
			const lastModDate = getDateNTFS(rawLastModDate);
			const lastAccessDate = getDateNTFS(rawLastAccessDate);
			const creationDate = getDateNTFS(rawCreationDate);
			const extraFieldData = { lastModDate, lastAccessDate, creationDate };
			Object.assign(extraFieldNTFS, extraFieldData);
			Object.assign(directory, extraFieldData);
		}
	} catch (_error) {
		// ignored
	}
}

function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
	const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
	const flags = getUint8(extraFieldView, 0);
	const timeProperties = [];
	const timeRawProperties = [];
	if (localDirectory) {
		if ((flags & 0x1) == 0x1) {
			timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
		}
		if ((flags & 0x2) == 0x2) {
			timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
		}
		if ((flags & 0x4) == 0x4) {
			timeProperties.push(PROPERTY_NAME_CREATION_DATE);
			timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
		}
	} else if (extraFieldExtendedTimestamp.data.length >= 5) {
		timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
		timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
	}
	let offset = 1;
	timeProperties.forEach((propertyName, indexProperty) => {
		if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
			const time = getUint32(extraFieldView, offset);
			directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
			const rawPropertyName = timeRawProperties[indexProperty];
			extraFieldExtendedTimestamp[rawPropertyName] = time;
		}
		offset += 4;
	});
}

async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
	const signatureArray = new Uint8Array(4);
	const signatureView = getDataView(signatureArray);
	setUint32(signatureView, 0, signature);
	const maximumBytes = minimumBytes + maximumLength;
	return (await seek(minimumBytes)) || await seek(Math.min(maximumBytes, startOffset));

	async function seek(length) {
		const offset = startOffset - length;
		const bytes = await readUint8Array(reader, offset, length);
		for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
			if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] &&
				bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
				return {
					offset: offset + indexByte,
					buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
				};
			}
		}
	}
}

function getOptionValue(zipReader, options, name) {
	return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}

function getDate(timeRaw) {
	const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
	try {
		return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
	} catch (_error) {
		// ignored
	}
}

function getDateNTFS(timeRaw) {
	return new Date((Number((timeRaw / BigInt(10000)) - BigInt(11644473600000))));
}

function getUint8(view, offset) {
	return view.getUint8(offset);
}

function getUint16(view, offset) {
	return view.getUint16(offset, true);
}

function getUint32(view, offset) {
	return view.getUint32(offset, true);
}

function getBigUint64(view, offset) {
	return Number(view.getBigUint64(offset, true));
}

function setUint32(view, offset, value) {
	view.setUint32(offset, value, true);
}

function getDataView(array) {
	return new DataView(array.buffer);
}

/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


let baseURL;
configure({ baseURL });
e(configure);

/// <reference types="./index.d.ts" />


configure({ Deflate: ZipDeflate, Inflate: ZipInflate });

// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
// Copyright (C) 2016-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
((function() {
	// Built with clang version 18.1.2
	// Built from meshoptimizer 0.21
	var wasm = "b9H79TebbbeJq9Geueu9Geub9Gbb9Gvuuuuueu9Gduueu9Gluuuueu9Gvuuuuub9Gouuuuuub9Gluuuub9GiuuueuiKLdilevlevlooroowwvwbDDbelve9Weiiviebeoweuec:G;kekr;RiOo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9FW9U9J9V9KW9wWVtW949c919M9MWVbe8F9TW79O9V9Wt9FW9U9J9V9KW9wWVtW949c919M9MWV9c9V919U9KbdE9TW79O9V9Wt9FW9U9J9V9KW9wWVtW949wWV79P9V9UbiY9TW79O9V9Wt9FW9U9J9V9KW69U9KW949c919M9MWVbl8E9TW79O9V9Wt9FW9U9J9V9KW69U9KW949c919M9MWV9c9V919U9Kbv8A9TW79O9V9Wt9FW9U9J9V9KW69U9KW949wWV79P9V9UboE9TW79O9V9Wt9FW9U9J9V9KW69U9KW949tWG91W9U9JWbra9TW79O9V9Wt9FW9U9J9V9KW69U9KW949tWG91W9U9JW9c9V919U9KbwL9TW79O9V9Wt9FW9U9J9V9KWS9P2tWV9p9JtbDK9TW79O9V9Wt9FW9U9J9V9KWS9P2tWV9r919HtbqL9TW79O9V9Wt9FW9U9J9V9KWS9P2tWVT949WbkE9TW79O9V9Wt9F9V9Wt9P9T9P96W9wWVtW94J9H9J9OWbPa9TW79O9V9Wt9F9V9Wt9P9T9P96W9wWVtW94J9H9J9OW9ttV9P9Wbsa9TW79O9V9Wt9F9V9Wt9P9T9P96W9wWVtW94SWt9J9O9sW9T9H9WbzK9TW79O9V9Wt9F79W9Ht9P9H29t9VVt9sW9T9H9WbHl79IV9RbODwebcekdQXq;C9oLdbk;GqeKu8Jjjjjbcjo9Rgv8Kjjjjbcbhodnalcefae0mbabcbRbN:kjjbc:GeV86bbavcjdfcbcjdzNjjjb8AdnaiTmbavcjdfadalz:tjjjb8Akabaefhrabcefhwavalfcbcbcjdal9RalcFe0EzNjjjb8Aavavcjdfalz:tjjjbhDcj;abal9Uc;WFbGgecjdaecjd6Ehqcbhkindndnaiak9nmbaDcjlfcbcjdzNjjjb8Aaqaiak9Rakaqfai6Egxcsfgecl4cifcd4hmadakal2fhPdndndnaec9WGgsTmbcbhzaPhHawhOxekdnaxmbalheinaraw9Ram6miawcbamzNjjjbamfhwaecufgembxvkkcbhAaPhOinaDaAfRbbhCaDcjlfheaOhoaxhXinaeaoRbbgQaC9RgCcetaC;acr4786bbaoalfhoaecefheaQhCaXcufgXmbkaraw9Ram6mdaOcefhOawcbamzNjjjbamfhwaAcefgAal9hmbxlkkindnaxTmbaDazfRbbhCaDcjlfheaHhoaxhXinaeaoRbbgQaC9RgCcetaC;acr4786bbaoalfhoaecefheaQhCaXcufgXmbkkaraO9Ram6mearaOcbamzNjjjbgLamfgw9RcK6mecbhKaDcjlfhOinaDcjlfaKfhYcwhAczhQceheindndnaegXce9hmbcuhoaYRbbmecbhodninaogecsSmeaecefhoaOaefcefRbbTmbkkcucbaecs6EhoxekaXcethocuaXtc;:bGcFb7hCcbheinaoaCaOaefRbb9nfhoaecefgecz9hmbkkaoaQaoaQ6geEhQaXaAaeEhAaXcetheaXcl6mbkdndndndnaAcufPdiebkaLaKco4fgeaeRbbcdciaAclSEaKci4coGtV86bbaAcw9hmeawaY8Pbb83bbawcwfaYcwf8Pbb83bbawczfhwxdkaLaKco4fgeaeRbbceaKci4coGtV86bbkdncwaA9Tg8Ambinawcb86bbawcefhwxbkkcuaAtcu7hYcbhEaOh3ina3hea8AhCcbhoinaeRbbgQaYcFeGgXaQaX6EaoaAtVhoaecefheaCcufgCmbkawao86bba3a8Afh3awcefhwaEa8AfgEcz6mbkcbheindnaOaefRbbgoaX6mbawao86bbawcefhwkaecefgecz9hmbkkdnaKczfgKas9pmbaOczfhOaraw9RcL0mekkaKas6meawTmeaHcefhHawhOazcefgzalSmixbkkcbhoxikcbhoaraw9Ralcaalca0E6mddnalc8F0mbawcbcaal9RgezNjjjbaefhwkawaDcjdfalz:tjjjbalfab9RhoxdkaDaPaxcufal2falz:tjjjb8Aaxakfhkawmbkcbhokavcjof8Kjjjjbaok9heeuaecaaeca0Eabcj;abae9Uc;WFbGgdcjdadcjd6Egdfcufad9Uae2adcl4cifcd4adV2fcefkmbcbabBdN:kjjbk:zse5u8Jjjjjbc;ae9Rgl8Kjjjjbcbhvdnaici9UgocHfae0mbabcbyd:e:kjjbgrc;GeV86bbalc;abfcFecjezNjjjb8AalcUfgw9cu83ibalc8WfgD9cu83ibalcyfgq9cu83ibalcafgk9cu83ibalcKfgx9cu83ibalczfgm9cu83ibal9cu83iwal9cu83ibabaefc9WfhPabcefgsaofhednaiTmbcmcsarcb9kgzEhHcbhOcbhAcbhCcbhXcbhQindnaeaP9nmbcbhvxikaQcufhvadaCcdtfgLydbhKaLcwfydbhYaLclfydbh8AcbhEdndndninalc;abfavcsGcitfgoydlh3dndndnaoydbgoaK9hmba3a8ASmekdnaoa8A9hmba3aY9hmbaEcefhExekaoaY9hmea3aK9hmeaEcdfhEkaEc870mdaXcufhvaLaEciGcx2goc:y1jjbfydbcdtfydbh3aLaocN1jjbfydbcdtfydbh8AaLaoc:q1jjbfydbcdtfydbhKcbhodnindnalavcsGcdtfydba39hmbaohYxdkcuhYavcufhvaocefgocz9hmbkkaOa3aOSgvaYce9iaYaH9oVgoGfhOdndndncbcsavEaYaoEgvcs9hmbarce9imba3a3aAa3cefaASgvEgAcefSmecmcsavEhvkasavaEcdtc;WeGV86bbavcs9hmea3aA9Rgvcetavc8F917hvinaeavcFb0crtavcFbGV86bbaecefheavcje6hoavcr4hvaoTmbka3hAxvkcPhvasaEcdtcPV86bba3hAkavTmiavaH9omicdhocehEaQhYxlkavcufhvaEclfgEc;ab9hmbkkdnaLceaYaOSceta8AaOSEcx2gvc:q1jjbfydbcdtfydbgKTaLavcN1jjbfydbcdtfydbg8AceSGaLavc:y1jjbfydbcdtfydbg3cdSGaOcb9hGazGg5ce9hmbaw9cu83ibaD9cu83ibaq9cu83ibak9cu83ibax9cu83ibam9cu83ibal9cu83iwal9cu83ibcbhOkcbhEaXcufgvhodnindnalaocsGcdtfydba8A9hmbaEhYxdkcuhYaocufhoaEcefgEcz9hmbkkcbhodnindnalavcsGcdtfydba39hmbaohExdkcuhEavcufhvaocefgocz9hmbkkaOaKaOSg8EfhLdndnaYcm0mbaYcefhYxekcbcsa8AaLSgvEhYaLavfhLkdndnaEcm0mbaEcefhExekcbcsa3aLSgvEhEaLavfhLkc9:cua8EEh8FcbhvaEaYcltVgacFeGhodndndninavcj1jjbfRbbaoSmeavcefgvcz9hmbxdkka5aKaO9havcm0VVmbasavc;WeV86bbxekasa8F86bbaeaa86bbaecefhekdna8EmbaKaA9Rgvcetavc8F917hvinaeavcFb0gocrtavcFbGV86bbavcr4hvaecefheaombkaKhAkdnaYcs9hmba8AaA9Rgvcetavc8F917hvinaeavcFb0gocrtavcFbGV86bbavcr4hvaecefheaombka8AhAkdnaEcs9hmba3aA9Rgvcetavc8F917hvinaeavcFb0gocrtavcFbGV86bbavcr4hvaecefheaombka3hAkalaXcdtfaKBdbaXcefcsGhvdndnaYPzbeeeeeeeeeeeeeebekalavcdtfa8ABdbaXcdfcsGhvkdndnaEPzbeeeeeeeeeeeeeebekalavcdtfa3BdbavcefcsGhvkcihoalc;abfaQcitfgEaKBdlaEa8ABdbaQcefcsGhYcdhEavhXaLhOxekcdhoalaXcdtfa3BdbcehEaXcefcsGhXaQhYkalc;abfaYcitfgva8ABdlava3Bdbalc;abfaQaEfcsGcitfgva3BdlavaKBdbascefhsaQaofcsGhQaCcifgCai6mbkkcbhvaeaP0mbcbhvinaeavfavcj1jjbfRbb86bbavcefgvcz9hmbkaeab9Ravfhvkalc;aef8KjjjjbavkZeeucbhddninadcefgdc8F0meceadtae6mbkkadcrfcFeGcr9Uci2cdfabci9U2cHfkmbcbabBd:e:kjjbk:ydewu8Jjjjjbcz9Rhlcbhvdnaicvfae0mbcbhvabcbRb:e:kjjbc;qeV86bbal9cb83iwabcefhoabaefc98fhrdnaiTmbcbhwcbhDindnaoar6mbcbskadaDcdtfydbgqalcwfawaqav9Rgvavc8F91gv7av9Rc507gwcdtfgkydb9Rgvc8E91c9:Gavcdt7awVhvinaoavcFb0gecrtavcFbGV86bbavcr4hvaocefhoaembkakaqBdbaqhvaDcefgDai9hmbkkcbhvaoar0mbaocbBbbaoab9RclfhvkavkBeeucbhddninadcefgdc8F0meceadtae6mbkkadcwfcFeGcr9Uab2cvfk:bvli99dui99ludnaeTmbcuadcetcuftcu7:Yhvdndncuaicuftcu7:YgoJbbbZMgr:lJbbb9p9DTmbar:Ohwxekcjjjj94hwkcbhicbhDinalclfIdbgrJbbbbJbbjZalIdbgq:lar:lMalcwfIdbgk:lMgr:varJbbbb9BEgrNhxaqarNhrdndnakJbbbb9GTmbaxhqxekJbbjZar:l:tgqaq:maxJbbbb9GEhqJbbjZax:l:tgxax:marJbbbb9GEhrkdndnalcxfIdbgxJbbj:;axJbbj:;9GEgkJbbjZakJbbjZ9FEavNJbbbZJbbb:;axJbbbb9GEMgx:lJbbb9p9DTmbax:Ohmxekcjjjj94hmkdndnaqJbbj:;aqJbbj:;9GEgxJbbjZaxJbbjZ9FEaoNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:OhPxekcjjjj94hPkdndnarJbbj:;arJbbj:;9GEgqJbbjZaqJbbjZ9FEaoNJbbbZJbbb:;arJbbbb9GEMgr:lJbbb9p9DTmbar:Ohsxekcjjjj94hskdndnadcl9hmbabaifgzas86bbazcifam86bbazcdfaw86bbazcefaP86bbxekabaDfgzas87ebazcofam87ebazclfaw87ebazcdfaP87ebkalczfhlaiclfhiaDcwfhDaecufgembkkk;hlld99eud99eudnaeTmbdndncuaicuftcu7:YgvJbbbZMgo:lJbbb9p9DTmbao:Ohixekcjjjj94hikaic;8FiGhrinabcofcicdalclfIdb:lalIdb:l9EgialcwfIdb:lalaicdtfIdb:l9EEgialcxfIdb:lalaicdtfIdb:l9EEgiarV87ebdndnJbbj:;JbbjZalaicdtfIdbJbbbb9DEgoalaicd7cdtfIdbJ;Zl:1ZNNgwJbbj:;awJbbj:;9GEgDJbbjZaDJbbjZ9FEavNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohqxekcjjjj94hqkabcdfaq87ebdndnalaicefciGcdtfIdbJ;Zl:1ZNaoNgwJbbj:;awJbbj:;9GEgDJbbjZaDJbbjZ9FEavNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohqxekcjjjj94hqkabaq87ebdndnaoalaicufciGcdtfIdbJ;Zl:1ZNNgoJbbj:;aoJbbj:;9GEgwJbbjZawJbbjZ9FEavNJbbbZJbbb:;aoJbbbb9GEMgo:lJbbb9p9DTmbao:Ohixekcjjjj94hikabclfai87ebabcwfhbalczfhlaecufgembkkk:dvdxue998Jjjjjbcjd9Rgo8Kjjjjbadcd4hrdndndndnavcd9hmbadcl6meaohwarhDinawc:CuBdbawclfhwaDcufgDmbkaeTmiadcl6mdarcdthqalhkcbhxinaohwakhDarhminawawydbgPaDydbgscL4cFeGc:cufcbasEgsaPas9kEBdbaDclfhDawclfhwamcufgmmbkakaqfhkaxcefgxaeSmixbkkaeTmdxekaeTmekavcb9hadcl6gqVhzarcdthxavce9hhHcbhdindndndnaHmbaqmdc:CuhDalhwarhminaDawydbgPcL4cFeGc:cufcbaPEgPaDaP9kEhDawclfhwamcufgmmbxdkkc:CuhDazmbaohwalhmarhPinawamydbgscL4cFeGgkc8Aakc8A9kEc:cufcbasEBdbamclfhmawclfhwaPcufgPmbkkaqmbcbhwarhPinaDhmdnavceSmbaoawfydbhmkdndnalawfIdbgOcjjj;8iamai9RcefgmcLt9R::NJbbbZJbbb:;aOJbbbb9GEMgO:lJbbb9p9DTmbaO:Ohsxekcjjjj94hskabawfascFFFrGamcKtVBdbawclfhwaPcufgPmbkkabaxfhbalaxfhladcefgdae9hmbkkaocjdf8Kjjjjbk;HqdCui998Jjjjjbc:qd9Rgv8Kjjjjbavc:Sefcbc;KbzNjjjb8AcbhodnadTmbcbhoaiTmbdnabae9hmbavcuadcdtgradcFFFFi0Ecbyd:m:kjjbHjjjjbbgeBd:SeavceBd:mdaeabarz:tjjjb8Akavc:GefcwfcbBdbav9cb83i:Geavc:Gefaeadaiavc:Sefz:njjjbavyd:Gehwadci9UgDcbyd:m:kjjbHjjjjbbhravc:Sefavyd:mdgqcdtfarBdbavaqcefgkBd:mdarcbaDzNjjjbhxavc:SefakcdtfcuaicdtaicFFFFi0Ecbyd:m:kjjbHjjjjbbgmBdbavaqcdfgPBd:mdawhramhkinakalIdbalarydbgscwascw6Ecdtfc;ebfIdbMUdbarclfhrakclfhkaicufgimbkavc:SefaPcdtfcuaDcdtadcFFFF970Ecbyd:m:kjjbHjjjjbbgPBdbdnadci6mbaehraPhkaDhiinakamarydbcdtfIdbamarclfydbcdtfIdbMamarcwfydbcdtfIdbMUdbarcxfhrakclfhkaicufgimbkkaqcifhoavc;qbfhzavhravyd:KehHavyd:OehOcbhscbhkcbhAcehCinarhXcihQaeakci2gLcdtfgrydbhdarclfydbhqabaAcx2fgicwfarcwfydbgKBdbaiclfaqBdbaiadBdbaxakfce86bbazaKBdwazaqBdlazadBdbaPakcdtfcbBdbdnasTmbcihQaXhiinazaQcdtfaiydbgrBdbaQaraK9harad9haraq9hGGfhQaiclfhiascufgsmbkkaAcefhAcbhsinaOaHaeasaLfcdtfydbcdtgifydbcdtfgKhrawaifgqydbgdhidnadTmbdninarydbakSmearclfhraicufgiTmdxbkkaraKadcdtfc98fydbBdbaqaqydbcufBdbkascefgsci9hmbkdndnaQTmbcuhkJbbbbhYcbhqavyd:KehKavyd:OehLindndnawazaqcdtfydbcdtgsfydbgrmbaqcefhqxekaqcs0hiamasfgdIdbh8AadalcbaqcefgqaiEcdtfIdbalarcwarcw6Ecdtfc;ebfIdbMgEUdbaEa8A:thEarcdthiaLaKasfydbcdtfhrinaParydbgscdtfgdaEadIdbMg8AUdba8AaYaYa8A9DgdEhYasakadEhkarclfhraic98fgimbkkaqaQ9hmbkakcu9hmekaCaD9pmdindnaxaCfRbbmbaChkxdkaDaCcefgC9hmbxikkaQczaQcz6EhsazhraXhzakcu9hmbkkaocdtavc:Seffc98fhrdninaoTmearydbcbyd1:kjjbH:bjjjbbarc98fhraocufhoxbkkavc:qdf8Kjjjjbk;IlevucuaicdtgvaicFFFFi0Egocbyd:m:kjjbHjjjjbbhralalyd9GgwcdtfarBdbalawcefBd9GabarBdbaocbyd:m:kjjbHjjjjbbhralalyd9GgocdtfarBdbalaocefBd9GabarBdlcuadcdtadcFFFFi0Ecbyd:m:kjjbHjjjjbbhralalyd9GgocdtfarBdbalaocefBd9GabarBdwabydbcbavzNjjjb8Aadci9UhDdnadTmbabydbhoaehladhrinaoalydbcdtfgvavydbcefBdbalclfhlarcufgrmbkkdnaiTmbabydbhlabydlhrcbhvaihoinaravBdbarclfhralydbavfhvalclfhlaocufgombkkdnadci6mbabydlhrabydwhvcbhlinaecwfydbhoaeclfydbhdaraeydbcdtfgwawydbgwcefBdbavawcdtfalBdbaradcdtfgdadydbgdcefBdbavadcdtfalBdbaraocdtfgoaoydbgocefBdbavaocdtfalBdbaecxfheaDalcefgl9hmbkkdnaiTmbabydlheabydbhlinaeaeydbalydb9RBdbalclfhlaeclfheaicufgimbkkkQbabaeadaic:01jjbz:mjjjbkQbabaeadaic:C:jjjbz:mjjjbk9DeeuabcFeaicdtzNjjjbhlcbhbdnadTmbindnalaeydbcdtfgiydbcu9hmbaiabBdbabcefhbkaeclfheadcufgdmbkkabk;Wkivuo99lu8Jjjjjbc;W;Gb9Rgl8Kjjjjbcbhvalcj;Gbfcbc;KbzNjjjb8AalcuadcdtadcFFFFi0Egocbyd:m:kjjbHjjjjbbgrBdj9GalceBd;G9GalcFFF;7rBdwal9cFFF;7;3FF:;Fb83dbalcFFF97Bd;S9Gal9cFFF;7FFF:;u83d;K9Gaicd4hwdndnadmbJFFuFhDJFFuuhqJFFuuhkJFFuFhxJFFuuhmJFFuFhPxekawcdthsaehzincbhiinalaifgHazaifIdbgDaHIdbgxaxaD9EEUdbalc;K;GbfaifgHaDaHIdbgxaxaD9DEUdbaiclfgicx9hmbkazasfhzavcefgvad9hmbkalIdwhqalId;S9GhDalIdlhkalId;O9GhxalIdbhmalId;K9GhPkdndnadTmbJbbbbJbbjZJbbbbaPam:tgPaPJbbbb9DEgPaxak:tgxaxaP9DEgxaDaq:tgDaDax9DEgD:vaDJbbbb9BEhDawcdthsarhHadhzindndnaDaeIdbam:tNJb;au9eNJbbbZMgx:lJbbb9p9DTmbax:Ohixekcjjjj94hikaicztaicwtcj;GiGVaicsGVc:p;G:dKGcH2c;d;H:WKGcv2c;j:KM;jbGhvdndnaDaeclfIdbak:tNJb;au9eNJbbbZMgx:lJbbb9p9DTmbax:Ohixekcjjjj94hikaicztaicwtcj;GiGVaicsGVc:p;G:dKGcH2c;d;H:WKGcq2cM;j:KMeGavVhvdndnaDaecwfIdbaq:tNJb;au9eNJbbbZMgx:lJbbb9p9DTmbax:Ohixekcjjjj94hikaHavaicztaicwtcj;GiGVaicsGVc:p;G:dKGcH2c;d;H:WKGcC2c:KM;j:KdGVBdbaeasfheaHclfhHazcufgzmbkalcbcj;GbzNjjjbhiarhHadheinaiaHydbgzcFrGcx2fgvavydbcefBdbaiazcq4cFrGcx2fgvavydlcefBdlaiazcC4cFrGcx2fgzazydwcefBdwaHclfhHaecufgembxdkkalcbcj;GbzNjjjb8AkcbhHcbhzcbhecbhvinalaHfgiydbhsaiazBdbaicwfgwydbhOawavBdbaiclfgiydbhwaiaeBdbasazfhzaOavfhvawaefheaHcxfgHcj;Gb9hmbkcbhHalaocbyd:m:kjjbHjjjjbbgiBd:e9GdnadTmbabhzinazaHBdbazclfhzadaHcefgH9hmbkabhHadhzinalaraHydbgecdtfydbcFrGcx2fgvavydbgvcefBdbaiavcdtfaeBdbaHclfhHazcufgzmbkaihHadhzinalaraHydbgecdtfydbcq4cFrGcx2fgvavydlgvcefBdlabavcdtfaeBdbaHclfhHazcufgzmbkabhHadhzinalaraHydbgecdtfydbcC4cFrGcx2fgvavydwgvcefBdwaiavcdtfaeBdbaHclfhHazcufgzmbkcbhHinabaiydbcdtfaHBdbaiclfhiadaHcefgH9hmbkkclhidninaic98Smealcj;Gbfaifydbcbyd1:kjjbH:bjjjbbaic98fhixbkkalc;W;Gbf8Kjjjjbk9teiucbcbyd:q:kjjbgeabcifc98GfgbBd:q:kjjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabk9teiucbcbyd:q:kjjbgeabcrfc94GfgbBd:q:kjjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik9:eiuZbhedndncbyd:q:kjjbgdaecztgi9nmbcuheadai9RcFFifcz4nbcuSmekadhekcbabae9Rcifc98Gcbyd:q:kjjbfgdBd:q:kjjbdnadZbcztge9nmbadae9RcFFifcz4nb8Akkk:Iddbcjwk:edb4:h9w9N94:P:gW:j9O:ye9Pbbbbbbebbbdbbbebbbdbbbbbbbdbbbbbbbebbbbbbb:l29hZ;69:9kZ;N;76Z;rg97Z;z;o9xZ8J;B85Z;:;u9yZ;b;k9HZ:2;Z9DZ9e:l9mZ59A8KZ:r;T3Z:A:zYZ79OHZ;j4::8::Y:D9V8:bbbb9s:49:Z8R:hBZ9M9M;M8:L;z;o8:;8:PG89q;x:J878R:hQ8::M:B;e87bbbbbbjZbbjZbbjZ:E;V;N8::Y:DsZ9i;H;68:xd;R8:;h0838:;W:NoZbbbb:WV9O8:uf888:9i;H;68:9c9G;L89;n;m9m89;D8Ko8:bbbbf:8tZ9m836ZS:2AZL;zPZZ818EZ9e:lxZ;U98F8:819E;68:bc:eqkzebbbebbbdbbbaWbb";

	var wasmpack = new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);

	if (typeof WebAssembly !== 'object') {
		return {
			supported: false,
		};
	}

	var instance;

	var ready =
		WebAssembly.instantiate(unpack(wasm), {})
		.then(function(result) {
			instance = result.instance;
			instance.exports.__wasm_call_ctors();
			instance.exports.meshopt_encodeVertexVersion(0);
			instance.exports.meshopt_encodeIndexVersion(1);
		});

	function unpack(data) {
		var result = new Uint8Array(data.length);
		for (var i = 0; i < data.length; ++i) {
			var ch = data.charCodeAt(i);
			result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
		}
		var write = 0;
		for (var i = 0; i < data.length; ++i) {
			result[write++] = (result[i] < 60) ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
		}
		return result.buffer.slice(0, write);
	}

	function assert(cond) {
		if (!cond) {
			throw new Error("Assertion failed");
		}
	}

	function bytes(view) {
		return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
	}

	function reorder(fun, indices, vertices, optf) {
		var sbrk = instance.exports.sbrk;
		var ip = sbrk(indices.length * 4);
		var rp = sbrk(vertices * 4);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		var indices8 = bytes(indices);
		heap.set(indices8, ip);
		if (optf) {
			optf(ip, ip, indices.length, vertices);
		}
		var unique = fun(rp, ip, indices.length, vertices);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var remap = new Uint32Array(vertices);
		new Uint8Array(remap.buffer).set(heap.subarray(rp, rp + vertices * 4));
		indices8.set(heap.subarray(ip, ip + indices.length * 4));
		sbrk(ip - sbrk(0));

		for (var i = 0; i < indices.length; ++i)
			indices[i] = remap[indices[i]];

		return [remap, unique];
	}

	function spatialsort(fun, positions, count, stride) {
		var sbrk = instance.exports.sbrk;
		var ip = sbrk(count * 4);
		var sp = sbrk(count * stride);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(positions), sp);
		fun(ip, sp, count, stride);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var remap = new Uint32Array(count);
		new Uint8Array(remap.buffer).set(heap.subarray(ip, ip + count * 4));
		sbrk(ip - sbrk(0));
		return remap;
	}

	function encode(fun, bound, source, count, size) {
		var sbrk = instance.exports.sbrk;
		var tp = sbrk(bound);
		var sp = sbrk(count * size);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(source), sp);
		var res = fun(tp, bound, sp, count, size);
		var target = new Uint8Array(res);
		target.set(heap.subarray(tp, tp + res));
		sbrk(tp - sbrk(0));
		return target;
	}

	function maxindex(source) {
		var result = 0;
		for (var i = 0; i < source.length; ++i) {
			var index = source[i];
			result = result < index ? index : result;
		}
		return result;
	}

	function index32(source, size) {
		assert(size == 2 || size == 4);
		if (size == 4) {
			return new Uint32Array(source.buffer, source.byteOffset, source.byteLength / 4);
		} else {
			var view = new Uint16Array(source.buffer, source.byteOffset, source.byteLength / 2);
			return new Uint32Array(view); // copies each element
		}
	}

	function filter(fun, source, count, stride, bits, insize, mode) {
		var sbrk = instance.exports.sbrk;
		var tp = sbrk(count * stride);
		var sp = sbrk(count * insize);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(source), sp);
		fun(tp, count, stride, bits, sp, mode);
		var target = new Uint8Array(count * stride);
		target.set(heap.subarray(tp, tp + count * stride));
		sbrk(tp - sbrk(0));
		return target;
	}

	return {
		ready: ready,
		supported: true,
		reorderMesh: function(indices, triangles, optsize) {
			var optf = triangles ? (optsize ? instance.exports.meshopt_optimizeVertexCacheStrip : instance.exports.meshopt_optimizeVertexCache) : undefined;
			return reorder(instance.exports.meshopt_optimizeVertexFetchRemap, indices, maxindex(indices) + 1, optf);
		},
		reorderPoints: function(positions, positions_stride) {
			assert(positions instanceof Float32Array);
			assert(positions.length % positions_stride == 0);
			assert(positions_stride >= 3);
			return spatialsort(instance.exports.meshopt_spatialSortRemap, positions, positions.length / positions_stride, positions_stride * 4);
		},
		encodeVertexBuffer: function(source, count, size) {
			assert(size > 0 && size <= 256);
			assert(size % 4 == 0);
			var bound = instance.exports.meshopt_encodeVertexBufferBound(count, size);
			return encode(instance.exports.meshopt_encodeVertexBuffer, bound, source, count, size);
		},
		encodeIndexBuffer: function(source, count, size) {
			assert(size == 2 || size == 4);
			assert(count % 3 == 0);
			var indices = index32(source, size);
			var bound = instance.exports.meshopt_encodeIndexBufferBound(count, maxindex(indices) + 1);
			return encode(instance.exports.meshopt_encodeIndexBuffer, bound, indices, count, 4);
		},
		encodeIndexSequence: function(source, count, size) {
			assert(size == 2 || size == 4);
			var indices = index32(source, size);
			var bound = instance.exports.meshopt_encodeIndexSequenceBound(count, maxindex(indices) + 1);
			return encode(instance.exports.meshopt_encodeIndexSequence, bound, indices, count, 4);
		},
		encodeGltfBuffer: function(source, count, size, mode) {
			var table = {
				ATTRIBUTES: this.encodeVertexBuffer,
				TRIANGLES: this.encodeIndexBuffer,
				INDICES: this.encodeIndexSequence,
			};
			assert(table[mode]);
			return table[mode](source, count, size);
		},
		encodeFilterOct: function(source, count, stride, bits) {
			assert(stride == 4 || stride == 8);
			assert(bits >= 1 && bits <= 16);
			return filter(instance.exports.meshopt_encodeFilterOct, source, count, stride, bits, 16);
		},
		encodeFilterQuat: function(source, count, stride, bits) {
			assert(stride == 8);
			assert(bits >= 4 && bits <= 16);
			return filter(instance.exports.meshopt_encodeFilterQuat, source, count, stride, bits, 16);
		},
		encodeFilterExp: function(source, count, stride, bits, mode) {
			assert(stride > 0 && stride % 4 == 0);
			assert(bits >= 1 && bits <= 24);
			var table = {
				Separate: 0,
				SharedVector: 1,
				SharedComponent: 2,
			};
			return filter(instance.exports.meshopt_encodeFilterExp, source, count, stride, bits, stride, mode ? table[mode] : 1);
		},
	};
}))();

// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
// Copyright (C) 2016-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
var MeshoptDecoder = (function() {
	// Built with clang version 18.1.2
	// Built from meshoptimizer 0.21
	var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq;w8Wqdbk;esezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9Uc;WFbGgocjdaocjd6EhDaicefhocbhqdnindndndnaeaq9nmbaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxalc9WGgmTmecbhPawcjdfhsaohzinaraz9Rax6mvarazaxfgo9RcK6mvczhlcbhHinalgic9WfgOawcj;cbffhldndndndndnazaOco4fRbbaHcoG4ciGPlbedibkal9cb83ibalcwf9cb83ibxikalaoRblaoRbbgOco4gAaAciSgAE86bbawcj;cbfaifglcGfaoclfaAfgARbbaOcl4ciGgCaCciSgCE86bbalcVfaAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc7faAaCfgARbbaOciGgOaOciSgOE86bbalctfaAaOfgARbbaoRbegOco4gCaCciSgCE86bbalc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc93faAaCfgARbbaOciGgOaOciSgOE86bbalc94faAaOfgARbbaoRbdgOco4gCaCciSgCE86bbalc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc97faAaCfgARbbaOciGgOaOciSgOE86bbalc98faAaOfgORbbaoRbigoco4gAaAciSgAE86bbalc99faOaAfgORbbaocl4ciGgAaAciSgAE86bbalc9:faOaAfgORbbaocd4ciGgAaAciSgAE86bbalcufaOaAfglRbbaociGgoaociSgoE86bbalaofhoxdkalaoRbwaoRbbgOcl4gAaAcsSgAE86bbawcj;cbfaifglcGfaocwfaAfgARbbaOcsGgOaOcsSgOE86bbalcVfaAaOfgORbbaoRbegAcl4gCaCcsSgCE86bbalc7faOaCfgORbbaAcsGgAaAcsSgAE86bbalctfaOaAfgORbbaoRbdgAcl4gCaCcsSgCE86bbalc91faOaCfgORbbaAcsGgAaAcsSgAE86bbalc4faOaAfgORbbaoRbigAcl4gCaCcsSgCE86bbalc93faOaCfgORbbaAcsGgAaAcsSgAE86bbalc94faOaAfgORbbaoRblgAcl4gCaCcsSgCE86bbalc95faOaCfgORbbaAcsGgAaAcsSgAE86bbalc96faOaAfgORbbaoRbvgAcl4gCaCcsSgCE86bbalc97faOaCfgORbbaAcsGgAaAcsSgAE86bbalc98faOaAfgORbbaoRbogAcl4gCaCcsSgCE86bbalc99faOaCfgORbbaAcsGgAaAcsSgAE86bbalc9:faOaAfgORbbaoRbrgocl4gAaAcsSgAE86bbalcufaOaAfglRbbaocsGgoaocsSgoE86bbalaofhoxekalao8Pbb83bbalcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaHcdfhHaiczfhlarao9RcL0mekkaiam6mvaoTmvdnakTmbawaPfRbbhHawcj;cbfhlashiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkkascefhsaohzaPcefgPad9hmbxikkcbc99arao9Radcaadca0ESEhoxlkaoaxad2fhCdnakmbadhlinaoTmlarao9Rax6mlaoaxfhoalcufglmbkaChoxekcbhmawcjdfhAinarao9Rax6miawamfRbbhHawcj;cbfhlaAhiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkaAcefhAaoaxfhoamcefgmad9hmbkaChokabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekc9:hokavcj;ebf8Kjjjjbaok;cseHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;oiliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabaiavcefciGfcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavciGfgkcd7cetfaD87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavcufciGfcetfaD87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohvxekcjjjj94hvkabakcetfav87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj98Gcjjj;8if::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
	var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq:p9sqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk:N8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhlaicefhodnaeTmbadTmbalc;WFbGglcjdalcjd6EhwcbhDinawaeaD9RaDawfae6Egqcsfglc9WGgkci2hxakcethmalcl4cifcd4hPabaDad2fhsakc;ab6hzcbhHincbhOaohAdndninaraA9RaP6meavcj;cbfaOak2fhCaAaPfhocbhidnazmbarao9Rc;Gb6mbcbhlinaCalfhidndndndndnaAalco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklbaoczfhokdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklzaoczfhokdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklaaoczfhokdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaoclfaYpQbfaXc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaocwfaYpQbfaXc:q:yjjbfRbbfhoxekaiaopbbbpkl8Waoczfhokalc;abfhialcjefak0meaihlarao9Rc;Fb0mbkkdnaiak9pmbaici4hlinarao9RcK6miaCaifhXdndndndndnaAaico4fRbbalcoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpkbbxikaXaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaXaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaXaopbbbpkbbaoczfhokalcdfhlaiczfgiak6mbkkaoTmeaohAaOcefgOclSmdxbkkc9:hoxlkdnakTmbavcjdfaHfhiavaHfpbdbhYcbhXinaiavcj;cbfaXfglpblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLalakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEalamfpblbg3cep9Ta3aQp9op9Hp9rg3alaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfhiaXczfgXak6mbkkaHclfgHad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfgDae6mbkkcbc99arao9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk::seHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalaeSmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oaoarpmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalaeSmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oaoarpmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalaeSmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepkbbadczfhdaeclfgeav6mbkkdnavalSmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";

	var detector = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]);
	var wasmpack = new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);

	if (typeof WebAssembly !== 'object') {
		return {
			supported: false,
		};
	}

	var wasm = WebAssembly.validate(detector) ? unpack(wasm_simd) : unpack(wasm_base);

	var instance;

	var ready =
		WebAssembly.instantiate(wasm, {})
		.then(function(result) {
			instance = result.instance;
			instance.exports.__wasm_call_ctors();
		});

	function unpack(data) {
		var result = new Uint8Array(data.length);
		for (var i = 0; i < data.length; ++i) {
			var ch = data.charCodeAt(i);
			result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
		}
		var write = 0;
		for (var i = 0; i < data.length; ++i) {
			result[write++] = (result[i] < 60) ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
		}
		return result.buffer.slice(0, write);
	}

	function decode(instance, fun, target, count, size, source, filter) {
		var sbrk = instance.exports.sbrk;
		var count4 = (count + 3) & ~3;
		var tp = sbrk(count4 * size);
		var sp = sbrk(source.length);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(source, sp);
		var res = fun(tp, count, size, sp, source.length);
		if (res == 0 && filter) {
			filter(tp, count4, size);
		}
		target.set(heap.subarray(tp, tp + count * size));
		sbrk(tp - sbrk(0));
		if (res != 0) {
			throw new Error("Malformed buffer data: " + res);
		}
	}

	var filters = {
		NONE: "",
		OCTAHEDRAL: "meshopt_decodeFilterOct",
		QUATERNION: "meshopt_decodeFilterQuat",
		EXPONENTIAL: "meshopt_decodeFilterExp",
	};

	var decoders = {
		ATTRIBUTES: "meshopt_decodeVertexBuffer",
		TRIANGLES: "meshopt_decodeIndexBuffer",
		INDICES: "meshopt_decodeIndexSequence",
	};

	var workers = [];
	var requestId = 0;

	function createWorker(url) {
		var worker = {
			object: new Worker(url),
			pending: 0,
			requests: {}
		};

		worker.object.onmessage = function(event) {
			var data = event.data;

			worker.pending -= data.count;
			worker.requests[data.id][data.action](data.value);
			delete worker.requests[data.id];
		};

		return worker;
	}

	function initWorkers(count) {
		var source =
			"self.ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(wasm) + "]), {})" +
			".then(function(result) { result.instance.exports.__wasm_call_ctors(); return result.instance; });" +
			"self.onmessage = " + workerProcess.name + ";" + decode.toString() + workerProcess.toString();

		var blob = new Blob([source], {type: 'text/javascript'});
		var url = URL.createObjectURL(blob);

		for (var i = workers.length; i < count; ++i) {
			workers[i] = createWorker(url);
		}

		for (var i = count; i < workers.length; ++i) {
			workers[i].object.postMessage({});
		}

		workers.length = count;

		URL.revokeObjectURL(url);
	}

	function decodeWorker(count, size, source, mode, filter) {
		var worker = workers[0];

		for (var i = 1; i < workers.length; ++i) {
			if (workers[i].pending < worker.pending) {
				worker = workers[i];
			}
		}

		return new Promise(function (resolve, reject) {
			var data = new Uint8Array(source);
			var id = ++requestId;

			worker.pending += count;
			worker.requests[id] = { resolve: resolve, reject: reject };
			worker.object.postMessage({ id: id, count: count, size: size, source: data, mode: mode, filter: filter }, [ data.buffer ]);
		});
	}

	function workerProcess(event) {
		var data = event.data;
		if (!data.id) {
			return self.close();
		}
		self.ready.then(function(instance) {
			try {
				var target = new Uint8Array(data.count * data.size);
				decode(instance, instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
				self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [ target.buffer ]);
			} catch (error) {
				self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
			}
		});
	}

	return {
		ready: ready,
		supported: true,
		useWorkers: function(count) {
			initWorkers(count);
		},
		decodeVertexBuffer: function(target, count, size, source, filter) {
			decode(instance, instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
		},
		decodeIndexBuffer: function(target, count, size, source) {
			decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
		},
		decodeIndexSequence: function(target, count, size, source) {
			decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
		},
		decodeGltfBuffer: function(target, count, size, source, mode, filter) {
			decode(instance, instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
		},
		decodeGltfBufferAsync: function(count, size, source, mode, filter) {
			if (workers.length > 0) {
				return decodeWorker(count, size, source, decoders[mode], filters[filter]);
			}

			return ready.then(function() {
				var target = new Uint8Array(count * size);
				decode(instance, instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
				return target;
			});
		}
	};
})();

// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
// Copyright (C) 2016-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
((function() {
	// Built with clang version 18.1.2
	// Built from meshoptimizer 0.21
	var wasm = "b9H79Tebbbe9Hk9Geueu9Geub9Gbb9Gsuuuuuuuuuuuu99uueu9Gvuuuuub9Gvuuuuue999Gquuuuuuu99uueu9Gwuuuuuu99ueu9Giuuue999Gluuuueu9GiuuueuizsdilvoirwDbqqbeqlve9Weiiviebeoweuecj;jekr:Tewo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bbz9TW79O9V9Wt9F79P9T9W29P9M95bl8E9TW79O9V9Wt9F79P9T9W29P9M959x9Pt9OcttV9P9I91tW7bvQ9TW79O9V9Wt9F79P9T9W29P9M959q9V9P9Ut7boX9TW79O9V9Wt9F79P9T9W29P9M959t9J9H2Wbra9TW79O9V9Wt9F9V9Wt9P9T9P96W9wWVtW94SWt9J9O9sW9T9H9Wbwl79IV9RbDDwebcekdmxq:f97sdbk:39si8Au8A99zu8Jjjjjbc;W;ab9Rgs8Kjjjjbcbhzascxfcbc;Kbz:ljjjb8AdnabaeSmbabaeadcdtz:kjjjb8AkdndnamcdGmbcbhHxekasalcrfci4gecbyd;S1jjbHjjjjbbgOBdxasceBd2aOcbaez:ljjjbhAcbhlcbhednadTmbcbhlabheadhOinaAaeydbgCci4fgXaXRbbgXceaCcrGgCtV86bbaXcu7aC4ceGalfhlaeclfheaOcufgOmbkcualcdtalcFFFFi0Ehekasaecbyd;S1jjbHjjjjbbgHBdzascdBd2alcd4alfhCcehOinaOgecethOaeaC6mbkcdhzcbhQascuaecdtgOaecFFFFi0Ecbyd;S1jjbHjjjjbbgCBdCasciBd2aCcFeaOz:ljjjbhLdnadTmbaecufhXcbhKinabaQcdtfgYydbgAc:v;t;h;Ev2hCcbhedndninaLaCaXGgCcdtfg8AydbgOcuSmeaHaOcdtfydbaASmdaecefgeaCfhCaeaX9nmbxdkkaHaKcdtfaABdba8AaKBdbaKhOaKcefhKkaYaOBdbaQcefgQad9hmbkkaLcbyd;O1jjbH:bjjjbbascdBd2kascxfazcdtfcualcefgecdtaecFFFFi0Ecbyd;S1jjbHjjjjbbgEBdbasaEBdlasazceVgeBd2ascxfaecdtfcuadcitadcFFFFe0Ecbyd;S1jjbHjjjjbbg3Bdbasa3BdwasazcdfgeBd2asclfabadalcbz:cjjjbascxfaecdtfcualcdtg5alcFFFFi0Eg8Ecbyd;S1jjbHjjjjbbgOBdbasazcifgeBd2ascxfaecdtfa8Ecbyd;S1jjbHjjjjbbg8FBdbasazclVgaBd2alcd4alfhXcehCinaCgecethCaeaX6mbkcbhKascxfaacdtfghcuaecdtgCaecFFFFi0Ecbyd;S1jjbHjjjjbbgXBdbasazcvVggBd2aXcFeaCz:ljjjbhQdnalTmbavcd4hAaecufhCinaKhednaHTmbaHaKcdtfydbhekaiaeaA2cdtfgeydlgXcH4aX7c:F:b:DD2aeydbgXcH4aX7c;D;O:B8J27aeydwgecH4ae7c:3F;N8N27aCGheaKcdth8JdndndndndnaHTmbaHa8JfhYcbhXinaQaecdtfgLydbg8AcuSmlaiaHa8AcdtfydbaA2cdtfaiaYydbaA2cdtfcxz:ojjjbTmiaXcefgXaefaCGheaXaC9nmbxdkkaiaKaA2cdtfhYcbhXinaQaecdtfgLydbg8AcuSmiaia8AaA2cdtfaYcxz:ojjjbTmdaXcefgXaefaCGheaXaC9nmbkkcbhLkaLydbgecu9hmekaLaKBdbaKhekaOa8JfaeBdbaKcefgKal9hmbkcbhea8FhCinaCaeBdbaCclfhCalaecefge9hmbkcbheaOhCa8FhXindnaeaCydbgASmbaXa8FaAcdtfgAydbBdbaAaeBdbkaCclfhCaXclfhXalaecefge9hmbkkcbh8KaQcbyd;O1jjbH:bjjjbbasaaBd2ahalcbyd;S1jjbHjjjjbbgABdbasagBd2ascxfagcdtfa8Ecbyd;S1jjbHjjjjbbgeBdbasazcofgCBd2ascxfaCcdtfa8Ecbyd;S1jjbHjjjjbbgCBdbasazcrfg8LBd2aecFea5z:ljjjbh8MaCcFea5z:ljjjbh8NdnalTmba3cwfhyindnaEa8KgXcefg8Kcdtfydbg8AaEaXcdtgefydbgCSmba8AaC9Rh8Ja3aCcitfh5a8Naefhga8MaefhKcbhLindndna5aLcitfydbgQaX9hmbaKaXBdbagaXBdbxekdnaEaQcdtgafgeclfydbgCaeydbgeSmba3aecitg8AfydbaXSmeaCae9Rhhaecu7aCfhYaya8AfhCcbheinaYaeSmeaecefheaCydbh8AaCcwfhCa8AaX9hmbkaeah6meka8NaafgeaXaQaeydbcuSEBdbaKaQaXaKydbcuSEBdbkaLcefgLa8J9hmbkka8Kal9hmbkaOhCaHhLa8FhXa8Nh8Aa8MhQcbheindndnaeaCydbgY9hmbdnaqTmbaehYdnaHTmbaLydbhYkaqaYfRbbTmbaAaefcl86bbxdkdnaeaXydbgY9hmbaQydbhYdna8AydbgKcu9hmbaYcu9hmbaAaefcb86bbxikaAaefh8JdnaeaKSmbaeaYSmba8Jce86bbxika8Jcl86bbxdkdnaea8FaYcdtgKfydb9hmbdna8Aydbg8JcuSmbaea8JSmbaQydbg5cuSmbaea5Smba8NaKfydbgacuSmbaaaYSmba8MaKfydbgKcuSmbaKaYSmbdnaOa8JcdtfydbaOaKcdtfydb9hmbaOa5cdtfydbaOaacdtfydb9hmbaAaefcd86bbxlkaAaefcl86bbxikaAaefcl86bbxdkaAaefcl86bbxekaAaefaAaYfRbb86bbkaCclfhCaLclfhLaXclfhXa8Aclfh8AaQclfhQalaecefge9hmbkamceGTmbaAhealhCindnaeRbbce9hmbaecl86bbkaecefheaCcufgCmbkkascxfa8Lcdtfcualcx2alc;v:Q;v:Qe0Ecbyd;S1jjbHjjjjbbggBdbasazcwVg8JBd2agaialavaHz:djjjbh8PdndnaDmbcbhvxekascxfa8JcdtfcualaD2gecdtaecFFFFi0Ecbyd;S1jjbHjjjjbbgvBdbasazcDVg8JBd2alTmbarcd4hYdnaHTmbaDcdthKcbhLavhQinaoaHaLcdtfydbaY2cdtfheawhCaQhXaDh8AinaXaeIdbaCIdbNUdbaeclfheaCclfhCaXclfhXa8Acufg8AmbkaQaKfhQaLcefgLal9hmbxdkkaYcdthYaDcdthKcbhQavhLinaoheawhCaLhXaDh8AinaXaeIdbaCIdbNUdbaeclfheaCclfhCaXclfhXa8Acufg8AmbkaoaYfhoaLaKfhLaQcefgQal9hmbkkascxfa8Jcdtfcualc8S2gealc;D;O;f8U0EgXcbyd;S1jjbHjjjjbbgCBdbasa8Jcefg8ABd2aCcbaez:ljjjbh8KdndndnaDTmbascxfa8AcdtfaXcbyd;S1jjbHjjjjbbgqBdbasa8JcdfgCBd2aqcbaez:ljjjb8AascxfaCcdtfcualaD2gecltgCaecFFFFb0Ecbyd;S1jjbHjjjjbbgwBdbasa8JcifBd2awcbaCz:ljjjb8AadmexdkcbhqcbhwadTmekcbhLabhCindnagaCclfydbgQcx2fgeIdbagaCydbgYcx2fgXIdbgI:tg8RagaCcwfydbgKcx2fg8AIdlaXIdlg8S:tgRNa8AIdbaI:tg8UaeIdla8S:tg8VN:tg8Wa8WNa8Va8AIdwaXIdwg8X:tg8YNaRaeIdwa8X:tg8VN:tgRaRNa8Va8UNa8Ya8RN:tg8Ra8RNMM:rg8UJbbbb9ETmba8Wa8U:vh8Wa8Ra8U:vh8RaRa8U:vhRka8KaOaYcdtfydbc8S2fgeaRa8U:rg8UaRNNg8VaeIdbMUdbaea8Ra8Ua8RNg8ZNg8YaeIdlMUdlaea8Wa8Ua8WNg80Ng81aeIdwMUdwaea8ZaRNg8ZaeIdxMUdxaea80aRNgBaeIdzMUdzaea80a8RNg80aeIdCMUdCaeaRa8Ua8Wa8XNaRaINa8Sa8RNMM:mg8SNgINgRaeIdKMUdKaea8RaINg8RaeId3MUd3aea8WaINg8WaeIdaMUdaaeaIa8SNgIaeId8KMUd8Kaea8UaeIdyMUdya8KaOaQcdtfydbc8S2fgea8VaeIdbMUdbaea8YaeIdlMUdlaea81aeIdwMUdwaea8ZaeIdxMUdxaeaBaeIdzMUdzaea80aeIdCMUdCaeaRaeIdKMUdKaea8RaeId3MUd3aea8WaeIdaMUdaaeaIaeId8KMUd8Kaea8UaeIdyMUdya8KaOaKcdtfydbc8S2fgea8VaeIdbMUdbaea8YaeIdlMUdlaea81aeIdwMUdwaea8ZaeIdxMUdxaeaBaeIdzMUdzaea80aeIdCMUdCaeaRaeIdKMUdKaea8RaeId3MUd3aea8WaeIdaMUdaaeaIaeId8KMUd8Kaea8UaeIdyMUdyaCcxfhCaLcifgLad6mbkcbh8JabhYinaba8JcdtfhQcbhCinaAaQaCcj1jjbfydbcdtfydbgXfRbbhedndnaAaYaCfydbg8AfRbbgLc99fcFeGcpe0mbaeceSmbaecd9hmekdnaLcufcFeGce0mba8Ma8AcdtfydbaX9hmekdnaecufcFeGce0mba8NaXcdtfydba8A9hmekdnaLcv2aefc:q1jjbfRbbTmbaOaXcdtfydbaOa8Acdtfydb0mekdnagaXcx2fgKIdwaga8Acx2fgiIdwg8S:tgRaRNaKIdbaiIdbg8X:tg8Ra8RNaKIdlaiIdlg8V:tg8Ua8UNMM:rgIJbbbb9ETmbaRaI:vhRa8UaI:vh8Ua8RaI:vh8RkJbbacJbbacJbbjZaeceSEaLceSEh80dnagaQaCc:e1jjbfydbcdtfydbcx2fgeIdwa8S:tg8WaRa8WaRNaeIdba8X:tg81a8RNa8UaeIdla8V:tg8ZNMMg8YN:tg8Wa8WNa81a8Ra8YN:tgRaRNa8Za8Ua8YN:tg8Ra8RNMM:rg8UJbbbb9ETmba8Wa8U:vh8Wa8Ra8U:vh8RaRa8U:vhRka8KaOa8Acdtfydbc8S2fgeaRa80aINg8UaRNNg8YaeIdbMUdbaea8Ra8Ua8RNg80Ng81aeIdlMUdlaea8Wa8Ua8WNgINg8ZaeIdwMUdwaea80aRNg80aeIdxMUdxaeaIaRNgBaeIdzMUdzaeaIa8RNg83aeIdCMUdCaeaRa8Ua8Wa8SNaRa8XNa8Va8RNMM:mg8SNgINgRaeIdKMUdKaea8RaINg8RaeId3MUd3aea8WaINg8WaeIdaMUdaaeaIa8SNgIaeId8KMUd8Kaea8UaeIdyMUdya8KaOaXcdtfydbc8S2fgea8YaeIdbMUdbaea81aeIdlMUdlaea8ZaeIdwMUdwaea80aeIdxMUdxaeaBaeIdzMUdzaea83aeIdCMUdCaeaRaeIdKMUdKaea8RaeId3MUd3aea8WaeIdaMUdaaeaIaeId8KMUd8Kaea8UaeIdyMUdykaCclfgCcx9hmbkaYcxfhYa8Jcifg8Jad6mbkaDTmbcbhYinJbbbbh8XagabaYcdtfgeclfydbgKcx2fgCIdwagaeydbgicx2fgXIdwg8Z:tg8Ra8RNaCIdbaXIdbgB:tg8Wa8WNaCIdlaXIdlg83:tg8Ua8UNMMg80agaecwfydbg8Jcx2fgeIdwa8Z:tgINa8Ra8RaINa8WaeIdbaB:tg8SNa8UaeIdla83:tg8VNMMgRN:tJbbbbJbbjZa80aIaINa8Sa8SNa8Va8VNMMg81NaRaRN:tg8Y:va8YJbbbb9BEg8YNhUa81a8RNaIaRN:ta8YNh85a80a8VNa8UaRN:ta8YNh86a81a8UNa8VaRN:ta8YNh87a80a8SNa8WaRN:ta8YNh88a81a8WNa8SaRN:ta8YNh89a8Wa8VNa8Sa8UN:tgRaRNa8UaINa8Va8RN:tgRaRNa8Ra8SNaIa8WN:tgRaRNMM:r:rhRavaiaD2cdtfhCava8JaD2cdtfhXavaKaD2cdtfh8Aa8Z:mh8:a83:mhZaB:mhncbhLaDhQJbbbbh8VJbbbbh8YJbbbbh80Jbbbbh81Jbbbbh8ZJbbbbhBJbbbbh83JbbbbhcJbbbbh9cinasc;WbfaLfgecwfaRa85a8AIdbaCIdbgI:tg8UNaUaXIdbaI:tg8SNMg8RNUdbaeclfaRa87a8UNa86a8SNMg8WNUdbaeaRa89a8UNa88a8SNMg8UNUdbaecxfaRa8:a8RNaZa8WNaIana8UNMMMgINUdbaRa8Ra8WNNa81Mh81aRa8Ra8UNNa8ZMh8ZaRa8Wa8UNNaBMhBaRaIaINNa8XMh8XaRa8RaINNa8VMh8VaRa8WaINNa8YMh8YaRa8UaINNa80Mh80aRa8Ra8RNNa83Mh83aRa8Wa8WNNacMhcaRa8Ua8UNNa9cMh9caCclfhCa8Aclfh8AaXclfhXaLczfhLaQcufgQmbkaqaOaicdtfydbgCc8S2fgea9caeIdbMUdbaeacaeIdlMUdlaea83aeIdwMUdwaeaBaeIdxMUdxaea8ZaeIdzMUdzaea81aeIdCMUdCaea80aeIdKMUdKaea8YaeId3MUd3aea8VaeIdaMUdaaea8XaeId8KMUd8KaeaRaeIdyMUdyaqaOaKcdtfydbgKc8S2fgea9caeIdbMUdbaeacaeIdlMUdlaea83aeIdwMUdwaeaBaeIdxMUdxaea8ZaeIdzMUdzaea81aeIdCMUdCaea80aeIdKMUdKaea8YaeId3MUd3aea8VaeIdaMUdaaea8XaeId8KMUd8KaeaRaeIdyMUdyaqaOa8Jcdtfydbgic8S2fgea9caeIdbMUdbaeacaeIdlMUdlaea83aeIdwMUdwaeaBaeIdxMUdxaea8ZaeIdzMUdzaea81aeIdCMUdCaea80aeIdKMUdKaea8YaeId3MUd3aea8VaeIdaMUdaaea8XaeId8KMUd8KaeaRaeIdyMUdyawaCaD2cltfhQcbhCaDh8AinaQaCfgeasc;WbfaCfgXIdbaeIdbMUdbaeclfgLaXclfIdbaLIdbMUdbaecwfgLaXcwfIdbaLIdbMUdbaecxfgeaXcxfIdbaeIdbMUdbaCczfhCa8Acufg8AmbkawaKaD2cltfhQcbhCaDh8AinaQaCfgeasc;WbfaCfgXIdbaeIdbMUdbaeclfgLaXclfIdbaLIdbMUdbaecwfgLaXcwfIdbaLIdbMUdbaecxfgeaXcxfIdbaeIdbMUdbaCczfhCa8Acufg8AmbkawaiaD2cltfhQcbhCaDh8AinaQaCfgeasc;WbfaCfgXIdbaeIdbMUdbaeclfgLaXclfIdbaLIdbMUdbaecwfgLaXcwfIdbaLIdbMUdbaecxfgeaXcxfIdbaeIdbMUdbaCczfhCa8Acufg8AmbkaYcifgYad6mbkkasydlhJcbhednalTmbaJclfheaJydbh8AaAhCalhLcbhXincbaeydbgQa8A9RaCRbbcpeGEaXfhXaCcefhCaeclfheaQh8AaLcufgLmbkaXce4hekcuadae9Rcifg8Lcx2a8Lc;v:Q;v:Qe0Ecbyd;S1jjbHjjjjbbhhascxfasyd2gecdtfahBdbasaecefgCBd2ascxfaCcdtfcua8Lcdta8LcFFFFi0Ecbyd;S1jjbHjjjjbbgzBdbasaecdfgCBd2ascxfaCcdtfa8Ecbyd;S1jjbHjjjjbbg3BdbasaecifgCBd2ascxfaCcdtfalcbyd;S1jjbHjjjjbbg9eBdbasaeclfBd2a8PJbbjZamclGEhcJbbbbh83dnadak9nmbdna8Lci6mbaxaxNacacN:vhBaDclthTahcwfhSJbbbbh83inasclfabadgoalaOz:cjjjbabhicbhEcbhyinabaycdtfh8JcbheindnaOaiaefydbgXcdtgKfydbg8AaOa8Jaec:S1jjbfydbcdtfydbgCcdtfydbgLSmbaAaCfRbbgYcv2aAaXfRbbgQfc;a1jjbfRbbgaaQcv2aYfg5c;a1jjbfRbbgdVcFeGTmbdnaLa8A9nmba5c:q1jjbfRbbcFeGmekdnaQaY9hmbaQcufcFeGce0mba8MaKfydbaC9hmekahaEcx2fg8AaCaXadcFeGgLEBdla8AaXaCaLEBdba8AaLaaGcb9hBdwaEcefhEkaeclfgecx9hmbkdnaycifgyao9pmbaicxfhiaEcifa8L9nmekkdnaEmbaohdxikcbhYinJbbbbJbbjZa8KaOahaYcx2fg8AydlgLa8AydbgQa8AydwgCEgicdtfydbgac8S2gdfgeIdygR:vaRJbbbb9BEaeIdwagaQaLaCEgKcx2fgCIdwg8UNaeIdzaCIdbgINaeIdaMgRaRMMa8UNaeIdlaCIdlg8SNaeIdCa8UNaeId3MgRaRMMa8SNaeIdbaINaeIdxa8SNaeIdKMgRaRMMaINaeId8KMMM:lNh80JbbbbJbbjZa8KaOaQcdtfydbgyc8S2gXfgeIdygR:vaRJbbbb9BEaeIdwagaLcx2fgCIdwg8WNaeIdzaCIdbg8XNaeIdaMgRaRMMa8WNaeIdlaCIdlg8VNaeIdCa8WNaeId3MgRaRMMa8VNaeIdba8XNaeIdxa8VNaeIdKMgRaRMMa8XNaeId8KMMM:lNh81a8Acwfh8Ja8Aclfh5dnaDTmbaqaXfgXIdwa8WNaXIdza8XNaXIdaMgRaRMMa8WNaXIdla8VNaXIdCa8WNaXId3MgRaRMMa8VNaXIdba8XNaXIdxa8VNaXIdKMgRaRMMa8XNaXId8KMMMh8RavaLaD2cdtfhCawayaD2cltfheaXIdyh8YaDhXinaCIdbgRJbbb;aNaecxfIdba8WaecwfIdbNa8XaeIdbNa8VaeclfIdbNMMMNaRaRNa8YNa8RMMh8RaCclfhCaeczfheaXcufgXmbkaqadfgXIdwa8UNaXIdzaINaXIdaMgRaRMMa8UNaXIdla8SNaXIdCa8UNaXId3MgRaRMMa8SNaXIdbaINaXIdxa8SNaXIdKMgRaRMMaINaXId8KMMMh8WavaKaD2cdtfhCawaaaD2cltfheaXIdyh8XaDhXinaCIdbgRJbbb;aNaecxfIdba8UaecwfIdbNaIaeIdbNa8SaeclfIdbNMMMNaRaRNa8XNa8WMMh8WaCclfhCaeczfheaXcufgXmbka80a8W:lMh80a81a8R:lMh81ka5aLaKa81a809FgeEBdba8AaQaiaeEBdba8Ja81a80aeEUdbaYcefgYaE9hmbkasc;Wbfcbcj;abz:ljjjb8AaSheaEhCinasc;WbfaeydbcO4c;8ZGfgXaXydbcefBdbaecxfheaCcufgCmbkcbhecbhCinasc;WbfaefgXydbh8AaXaCBdba8AaCfhCaeclfgecj;ab9hmbkcbheaShCinasc;WbfaCydbcO4c;8ZGfgXaXydbgXcefBdbazaXcdtfaeBdbaCcxfhCaEaecefge9hmbkaoak9RgXci9Uh9hdnalTmbcbhea3hCinaCaeBdbaCclfhCalaecefge9hmbkkcbh9ia9ecbalz:ljjjbh6aXcO9Uh9ka9hce4h0asydwh9mcbhdcbh5dninahaza5cdtfydbcx2fg8JIdwg8RaB9Emeada9h9pmeJFFuuhRdna0aE9pmbahaza0cdtfydbcx2fIdwJbb;aZNhRkdna8RaR9ETmbada9k0mdkdna6aOa8Jydlg9ncdtg9ofydbg8Afg9pRbba6aOa8Jydbgicdtg9qfydbg9rfg9sRbbVmbdnaJa9rcdtfgeclfydbgCaeydbgeSmbaCae9RhQa9maecitfheaga8Acx2fgKcwfhyaKclfh8Eaga9rcx2fgacwfhmaaclfhrcbhCcehYdnindna3aeydbcdtfydbgXa8ASmba3aeclfydbcdtfydbgLa8ASmbaXaLSmbagaLcx2fgLIdbagaXcx2fgXIdbg8W:tgRarIdbaXIdlg8U:tg8XNaaIdba8W:tg8VaLIdla8U:tg8RN:tgIaRa8EIdba8U:tg8YNaKIdba8W:tg80a8RN:tg8UNa8RamIdbaXIdwg8S:tg81Na8XaLIdwa8S:tg8WN:tg8Xa8RayIdba8S:tg8ZNa8Ya8WN:tg8RNa8Wa8VNa81aRN:tg8Sa8Wa80Na8ZaRN:tgRNMMaIaINa8Xa8XNa8Sa8SNMMa8Ua8UNa8Ra8RNaRaRNMMN:rJbbj8:N9FmdkaecwfheaCcefgCaQ6hYaQaC9hmbkkaYceGTmba0cefh0xeka8Ka8Ac8S2gXfgea8Ka9rc8S2gLfgCIdbaeIdbMUdbaeaCIdlaeIdlMUdlaeaCIdwaeIdwMUdwaeaCIdxaeIdxMUdxaeaCIdzaeIdzMUdzaeaCIdCaeIdCMUdCaeaCIdKaeIdKMUdKaeaCId3aeId3MUd3aeaCIdaaeIdaMUdaaeaCId8KaeId8KMUd8KaeaCIdyaeIdyMUdydnaDTmbaqaXfgeaqaLfgCIdbaeIdbMUdbaeaCIdlaeIdlMUdlaeaCIdwaeIdwMUdwaeaCIdxaeIdxMUdxaeaCIdzaeIdzMUdzaeaCIdCaeIdCMUdCaeaCIdKaeIdKMUdKaeaCId3aeId3MUd3aeaCIdaaeIdaMUdaaeaCId8KaeId8KMUd8KaeaCIdyaeIdyMUdyaTa9r2hYaTa8A2hKawhCaDhLinaCaKfgeaCaYfgXIdbaeIdbMUdbaeclfgQaXclfIdbaQIdbMUdbaecwfgQaXcwfIdbaQIdbMUdbaecxfgeaXcxfIdbaeIdbMUdbaCczfhCaLcufgLmbkka8JcwfhCdndndndnaAaifgXRbbc9:fPdebdkaiheina3aecdtgefa8ABdba8Faefydbgeai9hmbxikka8Fa9ofydbhea8Fa9qfydbhia3a9qfa9nBdbaeh9nka3aicdtfa9nBdbka9sce86bba9pce86bbaCIdbgRa83a83aR9DEh83a9icefh9icecdaXRbbceSEadfhdka5cefg5aE9hmbkkdna9imbaohdxikdnalTmbcbhCa8MheindnaeydbgXcuSmbdnaCa3aXcdtg8AfydbgX9hmba8Ma8AfydbhXkaeaXBdbkaeclfhealaCcefgC9hmbkcbhCa8NheindnaeydbgXcuSmbdnaCa3aXcdtg8AfydbgX9hmba8Na8AfydbhXkaeaXBdbkaeclfhealaCcefgC9hmbkkcbhdabhecbhLindna3aeydbcdtfydbgCa3aeclfydbcdtfydbgXSmbaCa3aecwfydbcdtfydbg8ASmbaXa8ASmbabadcdtfgQaCBdbaQcwfa8ABdbaQclfaXBdbadcifhdkaecxfheaLcifgLao6mbkadak9nmdxbkkasclfabadalaOz:cjjjbkdnaHTmbadTmbadheinabaHabydbcdtfydbBdbabclfhbaecufgembkkdnaPTmbaPaca83:rNUdbkasyd2gecdtascxffc98fhOdninaeTmeaOydbcbyd;O1jjbH:bjjjbbaOc98fhOaecufhexbkkasc;W;abf8Kjjjjbadk;Yieouabydlhvabydbclfcbaicdtz:ljjjbhoadci9UhrdnadTmbdnalTmbaehwadhDinaoalawydbcdtfydbcdtfgqaqydbcefBdbawclfhwaDcufgDmbxdkkaehwadhDinaoawydbcdtfgqaqydbcefBdbawclfhwaDcufgDmbkkdnaiTmbcbhDaohwinawydbhqawaDBdbawclfhwaqaDfhDaicufgimbkkdnadci6mbinaecwfydbhwaeclfydbhDaeydbhidnalTmbalawcdtfydbhwalaDcdtfydbhDalaicdtfydbhikavaoaicdtfgqydbcitfaDBdbavaqydbcitfawBdlaqaqydbcefBdbavaoaDcdtfgqydbcitfawBdbavaqydbcitfaiBdlaqaqydbcefBdbavaoawcdtfgwydbcitfaiBdbavawydbcitfaDBdlawawydbcefBdbaecxfhearcufgrmbkkabydbcbBdbk;Podvuv998Jjjjjbca9RgvcFFF;7rBd3av9cFFF;7;3FF:;Fb83dCavcFFF97Bdzav9cFFF;7FFF:;u83dwdnadTmbaicd4hodnabmbdnalTmbcbhrinaealarcdtfydbao2cdtfhwcbhiinavcCfaifgDawaifIdbgqaDIdbgkakaq9EEUdbavcwfaifgDaqaDIdbgkakaq9DEUdbaiclfgicx9hmbkarcefgrad9hmbxikkaocdthrcbhwincbhiinavcCfaifgDaeaifIdbgqaDIdbgkakaq9EEUdbavcwfaifgDaqaDIdbgkakaq9DEUdbaiclfgicx9hmbkaearfheawcefgwad9hmbxdkkdnalTmbcbhrinabarcx2fgiaealarcdtfydbao2cdtfgwIdbUdbaiawIdlUdlaiawIdwUdwcbhiinavcCfaifgDawaifIdbgqaDIdbgkakaq9EEUdbavcwfaifgDaqaDIdbgkakaq9DEUdbaiclfgicx9hmbkarcefgrad9hmbxdkkaocdthlcbhraehwinabarcx2fgiaearao2cdtfgDIdbUdbaiaDIdlUdlaiaDIdwUdwcbhiinavcCfaifgDawaifIdbgqaDIdbgkakaq9EEUdbavcwfaifgDaqaDIdbgkakaq9DEUdbaiclfgicx9hmbkawalfhwarcefgrad9hmbkkJbbbbavIdwavIdCgk:tgqaqJbbbb9DEgqavIdxavIdKgx:tgmamaq9DEgqavIdzavId3gm:tgPaPaq9DEhPdnabTmbadTmbJbbbbJbbjZaP:vaPJbbbb9BEhqinabaqabIdbak:tNUdbabclfgvaqavIdbax:tNUdbabcwfgvaqavIdbam:tNUdbabcxfhbadcufgdmbkkaPk8MbabaeadaialavcbcbcbcbcbaoarawaDz:bjjjbk8MbabaeadaialavaoarawaDaqakaxamaPz:bjjjbk;3Aowud99wue99iul998Jjjjjbc;Wb9Rgw8KjjjjbdndnarmbcbhDxekawcxfcbc;Kbz:ljjjb8Aawcuadcx2adc;v:Q;v:Qe0Ecbyd;S1jjbHjjjjbbgqBdxawceBd2aqaeadaicbz:djjjb8AawcuadcdtadcFFFFi0Egkcbyd;S1jjbHjjjjbbgxBdzawcdBd2adcd4adfhmceheinaegicetheaiam6mbkcbhmawcuaicdtgPaicFFFFi0Ecbyd;S1jjbHjjjjbbgsBdCawciBd2dndnar:Zgz:rJbbbZMgH:lJbbb9p9DTmbaH:Ohexekcjjjj94hekaicufhOc:bwhAcbhCcbhXadhQinaChLaeaAgKcufaeaK9iEamgDcefaeaD9kEhYdndnadTmbaYcuf:YhHaqhiaxheadhmindndnaiIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhAxekcjjjj94hAkaAcCthAdndnaiclfIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhCxekcjjjj94hCkaCcqtaAVhAdndnaicwfIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhCxekcjjjj94hCkaeaAaCVBdbaicxfhiaeclfheamcufgmmbkascFeaPz:ljjjbhEcbh3cbh5indnaEaxa5cdtfydbgAcm4aA7c:v;t;h;Ev2gics4ai7aOGgmcdtfgCydbgecuSmbaeaASmbcehiinaEamaifaOGgmcdtfgCydbgecuSmeaicefhiaeaA9hmbkkaCaABdba3aecuSfh3a5cefg5ad9hmbxdkkascFeaPz:ljjjb8Acbh3kaDaYa3ar0giEhmaLa3aiEhCdna3arSmbaYaKaiEgAam9Rcd9imbdndnaXcl0mbdnaQ:ZgHaL:Zg8A:taY:Yg8EaD:Y:tg8Fa8EaK:Y:tgaa3:Zghaz:tNNNaHaz:taaNa8Aah:tNa8Aaz:ta8FNahaH:tNM:va8EMJbbbZMgH:lJbbb9p9DTmbaH:Ohexdkcjjjj94hexekamaAfcd9Theka3aQaiEhQaXcefgXcs9hmekkdndnaCmbcihicbhDxekcbhiawakcbyd;S1jjbHjjjjbbg5BdKawclBd2dndnadTmbamcuf:YhHaqhiaxheadhmindndnaiIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhAxekcjjjj94hAkaAcCthAdndnaiclfIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhCxekcjjjj94hCkaCcqtaAVhAdndnaicwfIdbaHNJbbbZMg8A:lJbbb9p9DTmba8A:OhCxekcjjjj94hCkaeaAaCVBdbaicxfhiaeclfheamcufgmmbkascFeaPz:ljjjbhEcbhDcbh3inaxa3cdtgYfydbgAcm4aA7c:v;t;h;Ev2gics4ai7hecbhidndninaEaeaOGgmcdtfgCydbgecuSmednaxaecdtgCfydbaASmbaicefgiamfheaiaO9nmekka5aCfydbhixekaCa3BdbaDhiaDcefhDka5aYfaiBdba3cefg3ad9hmbkcuaDc32giaDc;j:KM;jb0EhexekascFeaPz:ljjjb8AcbhDcbhekawaecbyd;S1jjbHjjjjbbgeBd3awcvBd2aecbaiz:ljjjbhCavcd4hxdnadTmbdnalTmbaxcdthEa5hAalheaqhmadhOinaCaAydbc32fgiamIdbaiIdbMUdbaiamclfIdbaiIdlMUdlaiamcwfIdbaiIdwMUdwaiaeIdbaiIdxMUdxaiaeclfIdbaiIdzMUdzaiaecwfIdbaiIdCMUdCaiaiIdKJbbjZMUdKaAclfhAaeaEfheamcxfhmaOcufgOmbxdkka5hmaqheadhAinaCamydbc32fgiaeIdbaiIdbMUdbaiaeclfIdbaiIdlMUdlaiaecwfIdbaiIdwMUdwaiaiIdxJbbbbMUdxaiaiIdzJbbbbMUdzaiaiIdCJbbbbMUdCaiaiIdKJbbjZMUdKamclfhmaecxfheaAcufgAmbkkdnaDTmbaChiaDheinaiaiIdbJbbbbJbbjZaicKfIdbgH:vaHJbbbb9BEgHNUdbaiclfgmaHamIdbNUdbaicwfgmaHamIdbNUdbaicxfgmaHamIdbNUdbaiczfgmaHamIdbNUdbaicCfgmaHamIdbNUdbaic3fhiaecufgembkkcbhAawcuaDcdtgYaDcFFFFi0Egicbyd;S1jjbHjjjjbbgeBdaawcoBd2awaicbyd;S1jjbHjjjjbbgEBd8KaecFeaYz:ljjjbh3dnadTmbaoaoNh8Aaxcdthxalheina8Aaec;C1jjbalEgmIdwaCa5ydbgOc32fgiIdC:tgHaHNamIdbaiIdx:tgHaHNamIdlaiIdz:tgHaHNMMNaqcwfIdbaiIdw:tgHaHNaqIdbaiIdb:tgHaHNaqclfIdbaiIdl:tgHaHNMMMhHdndna3aOcdtgifgmydbcuSmbaEaifIdbaH9ETmekamaABdbaEaifaHUdbka5clfh5aeaxfheaqcxfhqadaAcefgA9hmbkkaba3aYz:kjjjb8AcrhikaicdthiinaiTmeaic98fgiawcxffydbcbyd;O1jjbH:bjjjbbxbkkawc;Wbf8KjjjjbaDk:Odieui99iu8Jjjjjbca9RgicFFF;7rBd3ai9cFFF;7;3FF:;Fb83dCaicFFF97Bdzai9cFFF;7FFF:;u83dwdndnaembJbbjFhlJbbjFhvJbbjFhoxekadcd4cdthrcbhwincbhdinaicCfadfgDabadfIdbglaDIdbgvaval9EEUdbaicwfadfgDalaDIdbgvaval9DEUdbadclfgdcx9hmbkabarfhbawcefgwae9hmbkaiIdzaiId3:thoaiIdxaiIdK:thvaiIdwaiIdC:thlkJbbbbalalJbbbb9DEglavaval9DEglaoaoal9DEk9DeeuabcFeaicdtz:ljjjbhlcbhbdnadTmbindnalaeydbcdtfgiydbcu9hmbaiabBdbabcefhbkaeclfheadcufgdmbkkabk9teiucbcbyd;W1jjbgeabcifc98GfgbBd;W1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabk9teiucbcbyd;W1jjbgeabcrfc94GfgbBd;W1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik9:eiuZbhedndncbyd;W1jjbgdaecztgi9nmbcuheadai9RcFFifcz4nbcuSmekadhekcbabae9Rcifc98Gcbyd;W1jjbfgdBd;W1jjbdnadZbcztge9nmbadae9RcFFifcz4nb8Akk6eiucbhidnadTmbdninabRbbglaeRbbgv9hmeaecefheabcefhbadcufgdmbxdkkalav9Rhikaikk:bedbcjwk9Oebbbdbbbbbbbebbbeeebeebebbeeebebbbbbebebbbbbebbbdbbbbbbbbbbbbbbbeeeeebebbbbbebbbbbeebbbbbbbbbbbbbbbbbbbbbc;Owkxebbbdbbbj9Kbb";

	var wasmpack = new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);

	if (typeof WebAssembly !== 'object') {
		return {
			supported: false,
		};
	}

	var instance;

	var ready =
		WebAssembly.instantiate(unpack(wasm), {})
		.then(function(result) {
			instance = result.instance;
			instance.exports.__wasm_call_ctors();
		});

	function unpack(data) {
		var result = new Uint8Array(data.length);
		for (var i = 0; i < data.length; ++i) {
			var ch = data.charCodeAt(i);
			result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
		}
		var write = 0;
		for (var i = 0; i < data.length; ++i) {
			result[write++] = (result[i] < 60) ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
		}
		return result.buffer.slice(0, write);
	}

	function assert(cond) {
		if (!cond) {
			throw new Error("Assertion failed");
		}
	}

	function bytes(view) {
		return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
	}

	function reorder(fun, indices, vertices) {
		var sbrk = instance.exports.sbrk;
		var ip = sbrk(indices.length * 4);
		var rp = sbrk(vertices * 4);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		var indices8 = bytes(indices);
		heap.set(indices8, ip);
		var unique = fun(rp, ip, indices.length, vertices);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var remap = new Uint32Array(vertices);
		new Uint8Array(remap.buffer).set(heap.subarray(rp, rp + vertices * 4));
		indices8.set(heap.subarray(ip, ip + indices.length * 4));
		sbrk(ip - sbrk(0));

		for (var i = 0; i < indices.length; ++i)
			indices[i] = remap[indices[i]];

		return [remap, unique];
	}

	function maxindex(source) {
		var result = 0;
		for (var i = 0; i < source.length; ++i) {
			var index = source[i];
			result = result < index ? index : result;
		}
		return result;
	}

	function simplify(fun, indices, index_count, vertex_positions, vertex_count, vertex_positions_stride, target_index_count, target_error, options) {
		var sbrk = instance.exports.sbrk;
		var te = sbrk(4);
		var ti = sbrk(index_count * 4);
		var sp = sbrk(vertex_count * vertex_positions_stride);
		var si = sbrk(index_count * 4);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(vertex_positions), sp);
		heap.set(bytes(indices), si);
		var result = fun(ti, si, index_count, sp, vertex_count, vertex_positions_stride, target_index_count, target_error, options, te);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var target = new Uint32Array(result);
		bytes(target).set(heap.subarray(ti, ti + result * 4));
		var error = new Float32Array(1);
		bytes(error).set(heap.subarray(te, te + 4));
		sbrk(te - sbrk(0));
		return [target, error[0]];
	}

	function simplifyAttr(fun, indices, index_count, vertex_positions, vertex_count, vertex_positions_stride, vertex_attributes, vertex_attributes_stride, attribute_weights, vertex_lock, target_index_count, target_error, options) {
		var sbrk = instance.exports.sbrk;
		var te = sbrk(4);
		var ti = sbrk(index_count * 4);
		var sp = sbrk(vertex_count * vertex_positions_stride);
		var sa = sbrk(vertex_count * vertex_attributes_stride);
		var sw = sbrk(attribute_weights.length * 4);
		var si = sbrk(index_count * 4);
		var vl = vertex_lock ? sbrk(vertex_count) : 0;
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(vertex_positions), sp);
		heap.set(bytes(vertex_attributes), sa);
		heap.set(bytes(attribute_weights), sw);
		heap.set(bytes(indices), si);
		if (vertex_lock) {
			heap.set(bytes(vertex_lock), vl);
		}
		var result = fun(ti, si, index_count, sp, vertex_count, vertex_positions_stride, sa, vertex_attributes_stride, sw, attribute_weights.length, vl, target_index_count, target_error, options, te);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var target = new Uint32Array(result);
		bytes(target).set(heap.subarray(ti, ti + result * 4));
		var error = new Float32Array(1);
		bytes(error).set(heap.subarray(te, te + 4));
		sbrk(te - sbrk(0));
		return [target, error[0]];
	}

	function simplifyScale(fun, vertex_positions, vertex_count, vertex_positions_stride) {
		var sbrk = instance.exports.sbrk;
		var sp = sbrk(vertex_count * vertex_positions_stride);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(vertex_positions), sp);
		var result = fun(sp, vertex_count, vertex_positions_stride);
		sbrk(sp - sbrk(0));
		return result;
	}

	function simplifyPoints(fun, vertex_positions, vertex_count, vertex_positions_stride, vertex_colors, vertex_colors_stride, color_weight, target_vertex_count) {
		var sbrk = instance.exports.sbrk;
		var ti = sbrk(target_vertex_count * 4);
		var sp = sbrk(vertex_count * vertex_positions_stride);
		var sc = sbrk(vertex_count * vertex_colors_stride);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(bytes(vertex_positions), sp);
		if (vertex_colors) {
			heap.set(bytes(vertex_colors), sc);
		}
		var result = fun(ti, sp, vertex_count, vertex_positions_stride, sc, vertex_colors_stride, color_weight, target_vertex_count);
		// heap may have grown
		heap = new Uint8Array(instance.exports.memory.buffer);
		var target = new Uint32Array(result);
		bytes(target).set(heap.subarray(ti, ti + result * 4));
		sbrk(ti - sbrk(0));
		return target;
	}

	var simplifyOptions = {
		LockBorder: 1,
		Sparse: 2,
		ErrorAbsolute: 4,
	};

	return {
		ready: ready,
		supported: true,

		// set this to true to be able to use simplifyPoints and simplifyWithAttributes
		// note that these functions are experimental and may change interface/behavior in a way that will require revising calling code
		useExperimentalFeatures: false,

		compactMesh: function(indices) {
			assert(indices instanceof Uint32Array || indices instanceof Int32Array || indices instanceof Uint16Array || indices instanceof Int16Array);
			assert(indices.length % 3 == 0);

			var indices32 = indices.BYTES_PER_ELEMENT == 4 ? indices : new Uint32Array(indices);
			return reorder(instance.exports.meshopt_optimizeVertexFetchRemap, indices32, maxindex(indices) + 1);
		},

		simplify: function(indices, vertex_positions, vertex_positions_stride, target_index_count, target_error, flags) {
			assert(indices instanceof Uint32Array || indices instanceof Int32Array || indices instanceof Uint16Array || indices instanceof Int16Array);
			assert(indices.length % 3 == 0);
			assert(vertex_positions instanceof Float32Array);
			assert(vertex_positions.length % vertex_positions_stride == 0);
			assert(vertex_positions_stride >= 3);
			assert(target_index_count >= 0 && target_index_count <= indices.length);
			assert(target_index_count % 3 == 0);
			assert(target_error >= 0);

			var options = 0;
			for (var i = 0; i < (flags ? flags.length : 0); ++i) {
				assert(flags[i] in simplifyOptions);
				options |= simplifyOptions[flags[i]];
			}

			var indices32 = indices.BYTES_PER_ELEMENT == 4 ? indices : new Uint32Array(indices);
			var result = simplify(instance.exports.meshopt_simplify, indices32, indices.length, vertex_positions, vertex_positions.length / vertex_positions_stride, vertex_positions_stride * 4, target_index_count, target_error, options);
			result[0] = (indices instanceof Uint32Array) ? result[0] : new indices.constructor(result[0]);

			return result;
		},

		simplifyWithAttributes: function(indices, vertex_positions, vertex_positions_stride, vertex_attributes, vertex_attributes_stride, attribute_weights, vertex_lock, target_index_count, target_error, flags) {
			assert(this.useExperimentalFeatures); // set useExperimentalFeatures to use this; note that this function is experimental and may change interface in a way that will require revising calling code
			assert(indices instanceof Uint32Array || indices instanceof Int32Array || indices instanceof Uint16Array || indices instanceof Int16Array);
			assert(indices.length % 3 == 0);
			assert(vertex_positions instanceof Float32Array);
			assert(vertex_positions.length % vertex_positions_stride == 0);
			assert(vertex_positions_stride >= 3);
			assert(vertex_attributes instanceof Float32Array);
			assert(vertex_attributes.length % vertex_attributes_stride == 0);
			assert(vertex_attributes_stride >= 0);
			assert(vertex_lock == null || vertex_lock.length == vertex_positions.length);
			assert(target_index_count >= 0 && target_index_count <= indices.length);
			assert(target_index_count % 3 == 0);
			assert(target_error >= 0);
			assert(Array.isArray(attribute_weights));
			assert(vertex_attributes_stride >= attribute_weights.length);
			assert(attribute_weights.length <= 16);

			var options = 0;
			for (var i = 0; i < (flags ? flags.length : 0); ++i) {
				assert(flags[i] in simplifyOptions);
				options |= simplifyOptions[flags[i]];
			}

			var indices32 = indices.BYTES_PER_ELEMENT == 4 ? indices : new Uint32Array(indices);
			var result = simplifyAttr(instance.exports.meshopt_simplifyWithAttributes, indices32, indices.length, vertex_positions, vertex_positions.length / vertex_positions_stride, vertex_positions_stride * 4, vertex_attributes, vertex_attributes_stride * 4, new Float32Array(attribute_weights), vertex_lock ? new Uint8Array(vertex_lock) : null, target_index_count, target_error, options);
			result[0] = (indices instanceof Uint32Array) ? result[0] : new indices.constructor(result[0]);

			return result;
		},

		getScale: function(vertex_positions, vertex_positions_stride) {
			assert(vertex_positions instanceof Float32Array);
			assert(vertex_positions.length % vertex_positions_stride == 0);
			assert(vertex_positions_stride >= 3);
			return simplifyScale(instance.exports.meshopt_simplifyScale, vertex_positions, vertex_positions.length / vertex_positions_stride, vertex_positions_stride * 4);
		},

		simplifyPoints: function(vertex_positions, vertex_positions_stride, target_vertex_count, vertex_colors, vertex_colors_stride, color_weight) {
			assert(this.useExperimentalFeatures); // set useExperimentalFeatures to use this; note that this function is experimental and may change interface in a way that will require revising calling code
			assert(vertex_positions instanceof Float32Array);
			assert(vertex_positions.length % vertex_positions_stride == 0);
			assert(vertex_positions_stride >= 3);
			assert(target_vertex_count >= 0 && target_vertex_count <= vertex_positions.length / vertex_positions_stride);
			if (vertex_colors) {
				assert(vertex_colors instanceof Float32Array);
				assert(vertex_colors.length % vertex_colors_stride == 0);
				assert(vertex_colors_stride >= 3);
				assert(vertex_positions.length / vertex_positions_stride == vertex_colors.length / vertex_colors_stride);
				return simplifyPoints(instance.exports.meshopt_simplifyPoints, vertex_positions, vertex_positions.length / vertex_positions_stride, vertex_positions_stride * 4, vertex_colors, vertex_colors_stride * 4, color_weight, target_vertex_count);
			} else {
				return simplifyPoints(instance.exports.meshopt_simplifyPoints, vertex_positions, vertex_positions.length / vertex_positions_stride, vertex_positions_stride * 4, undefined, 0, 0, target_vertex_count);
			}
		},
	};
}))();

/**
 * JS Implementation of MurmurHash2
 *
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} str ASCII only
 * @param {number} seed Positive integer only
 * @return {number} 32-bit positive integer hash
 */

function murmurhash2_32_gc(str, seed) {
	var
		l = str.length,
		h = seed ^ l,
		i = 0,
		k;

	while (l >= 4) {
		k =
			((str.charCodeAt(i) & 0xff)) |
			((str.charCodeAt(++i) & 0xff) << 8) |
			((str.charCodeAt(++i) & 0xff) << 16) |
			((str.charCodeAt(++i) & 0xff) << 24);

		k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
		k ^= k >>> 24;
		k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

		h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

		l -= 4;
		++i;
	}

	switch (l) {
	case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
	case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
	case 1: h ^= (str.charCodeAt(i) & 0xff);
			h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	}

	h ^= h >>> 13;
	h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
	h ^= h >>> 15;

	return h >>> 0;
}

// From http://paulbourke.net/geometry/polygonise/
class TRIANGLE {
    p = [create$4(), create$4(), create$4()];
}
class GRIDCELL {
    p = [];
    val;
    constructor() {
        for (let i = 0; i < 8; ++i) {
            this.p.push(create$4());
        }
        this.val = new Float32Array(8);
    }
}
let edgeTable = new Uint16Array([
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
]);
let triTable = new Int8Array([
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
    3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
    4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
    9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
    10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,
    5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,
    8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
    2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,
    11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,
    5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,
    11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,
    11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
    9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
    6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,
    6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,
    8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,
    7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
    3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,
    9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
    8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,
    0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
    6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
    10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,
    10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,
    0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,
    3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
    9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,
    8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
    3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,
    10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
    10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,
    7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,
    1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,
    11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
    8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
    0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,
    7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
    7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
    10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,
    0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,
    7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,
    9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
    6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
    4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,
    10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
    8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
    1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,
    10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,
    10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
    9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,
    7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,
    3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
    7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
    3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,
    6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
    9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,
    1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,
    4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
    7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
    6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,
    0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,
    6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,
    0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,
    11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,
    6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
    5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
    9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,
    1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,
    10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
    0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,
    5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
    11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,
    9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
    7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
    2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,
    9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
    1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,
    10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
    2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,
    0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,
    0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
    9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,
    5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,
    5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,
    9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,
    1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,
    3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
    4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,
    9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
    11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
    2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,
    9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,
    3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
    1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
    4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,
    0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,
    1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
]);
/*
    Given a grid cell and an isolevel, calculate the triangular
    facets required to represent the isosurface through the cell.
    Return the number of triangular facets, the array "triangles"
    will be loaded up with the vertices at most 5 triangular facets.
    0 will be returned if the grid cell is either totally above
    of totally below the isolevel.
*/
function Polygonise(/*GRIDCELL */ grid, /*double */ isolevel, /*TRIANGLE **/ triangles) {
    let ntriang;
    let cubeindex;
    //XYZ vertlist[12];
    let vertlist = [];
    for (let i = 0; i < 12; ++i) {
        vertlist.push(create$4());
    }
    /*
        Determine the index into the edge table which
        tells us which vertices are inside of the surface
    */
    cubeindex = 0;
    if (grid.val[0] < isolevel)
        cubeindex |= 1;
    if (grid.val[1] < isolevel)
        cubeindex |= 2;
    if (grid.val[2] < isolevel)
        cubeindex |= 4;
    if (grid.val[3] < isolevel)
        cubeindex |= 8;
    if (grid.val[4] < isolevel)
        cubeindex |= 16;
    if (grid.val[5] < isolevel)
        cubeindex |= 32;
    if (grid.val[6] < isolevel)
        cubeindex |= 64;
    if (grid.val[7] < isolevel)
        cubeindex |= 128;
    /* Cube is entirely in/out of the surface */
    if (edgeTable[cubeindex] == 0)
        return (0);
    /* Find the vertices where the surface intersects the cube */
    if (edgeTable[cubeindex] & 1)
        vertlist[0] =
            VertexInterp(isolevel, grid.p[0], grid.p[1], grid.val[0], grid.val[1]);
    if (edgeTable[cubeindex] & 2)
        vertlist[1] =
            VertexInterp(isolevel, grid.p[1], grid.p[2], grid.val[1], grid.val[2]);
    if (edgeTable[cubeindex] & 4)
        vertlist[2] =
            VertexInterp(isolevel, grid.p[2], grid.p[3], grid.val[2], grid.val[3]);
    if (edgeTable[cubeindex] & 8)
        vertlist[3] =
            VertexInterp(isolevel, grid.p[3], grid.p[0], grid.val[3], grid.val[0]);
    if (edgeTable[cubeindex] & 16)
        vertlist[4] =
            VertexInterp(isolevel, grid.p[4], grid.p[5], grid.val[4], grid.val[5]);
    if (edgeTable[cubeindex] & 32)
        vertlist[5] =
            VertexInterp(isolevel, grid.p[5], grid.p[6], grid.val[5], grid.val[6]);
    if (edgeTable[cubeindex] & 64)
        vertlist[6] =
            VertexInterp(isolevel, grid.p[6], grid.p[7], grid.val[6], grid.val[7]);
    if (edgeTable[cubeindex] & 128)
        vertlist[7] =
            VertexInterp(isolevel, grid.p[7], grid.p[4], grid.val[7], grid.val[4]);
    if (edgeTable[cubeindex] & 256)
        vertlist[8] =
            VertexInterp(isolevel, grid.p[0], grid.p[4], grid.val[0], grid.val[4]);
    if (edgeTable[cubeindex] & 512)
        vertlist[9] =
            VertexInterp(isolevel, grid.p[1], grid.p[5], grid.val[1], grid.val[5]);
    if (edgeTable[cubeindex] & 1024)
        vertlist[10] =
            VertexInterp(isolevel, grid.p[2], grid.p[6], grid.val[2], grid.val[6]);
    if (edgeTable[cubeindex] & 2048)
        vertlist[11] =
            VertexInterp(isolevel, grid.p[3], grid.p[7], grid.val[3], grid.val[7]);
    /* Create the triangle */
    ntriang = 0;
    cubeindex <<= 4;
    for (let i = 0; triTable[cubeindex] != -1; i += 3) {
        let triangle = triangles[ntriang] ?? new TRIANGLE();
        triangles[ntriang] = triangle;
        triangle.p[0] = vertlist[triTable[cubeindex]];
        triangle.p[1] = vertlist[triTable[cubeindex + 1]];
        triangle.p[2] = vertlist[triTable[cubeindex + 2]];
        ntriang++;
        cubeindex += 3;
    }
    return (ntriang);
}
/*
    Linearly interpolate the position where an isosurface cuts
    an edge between two vertices, each with their own scalar value
*/
function VertexInterp(isolevel, p1, p2, valp1, valp2) {
    let mu;
    let p = create$4();
    if (Math.abs(isolevel - valp1) < 0.00001)
        return (p1);
    if (Math.abs(isolevel - valp2) < 0.00001)
        return (p2);
    if (Math.abs(valp1 - valp2) < 0.00001)
        return (p1);
    mu = (isolevel - valp1) / (valp2 - valp1);
    p[0] = p1[0] + mu * (p2[0] - p1[0]);
    p[1] = p1[1] + mu * (p2[1] - p1[1]);
    p[2] = p1[2] + mu * (p2[2] - p1[2]);
    return (p);
}

class AudioGroup {
    name;
    muted = false;
    groups = new Map();
    audioList = new Set();
    constructor(name) {
        this.name = name;
    }
    mute(mute) {
        this.muted = (mute == true);
        for (let audio of this.audioList) {
            audio.muted = this.muted;
        }
    }
    getGroup(groupPath) {
        if (groupPath[0] = this.name) {
            if (groupPath.length == 1) {
                return this;
            }
            let group;
            if (this.groups.has(groupPath[1])) {
                group = this.groups.get(groupPath[1]);
            }
            else {
                group = this.createSubGroup(groupPath[1]);
            }
            return group.getGroup(groupPath.shift());
        }
    }
    createSubGroup(name) {
        console.log('Creating group ' + name);
        let subGroup = new AudioGroup(name);
        this.groups.set(name, subGroup);
        return subGroup;
    }
    playAudio(audio) {
        audio.muted = this.muted;
        audio.currentTime = 0;
        try {
            audio.play();
        }
        catch (e) { }
        this.audioList.add(audio);
    }
}

class AudioMixer {
    static master = new AudioGroup('master');
    static muteGroup(groupName, mute = true) {
        this.getGroup(groupName).mute(mute);
    }
    static mute(mute = true) {
        this.master.mute(mute);
    }
    static getGroup(groupName = '') {
        return this.master.getGroup(groupName.split('.'));
    }
    static playAudio(groupName, audio) {
        this.getGroup(groupName).playAudio(audio);
    }
}

class BackGround {
    render(renderer, camera) {
    }
    dispose() {
    }
    is(s) {
        return s == 'BackGround';
    }
}

create$4();
class ColorBackground extends BackGround {
    #color = fromValues$3(0, 0, 0, 1);
    constructor(params = {}) {
        super();
        if (params.color) {
            copy$3(this.#color, params.color);
        }
    }
    render(renderer, camera) {
        renderer.clearColor(this.#color);
        renderer.clear(true, false, false);
    }
    setColor(color) {
        copy$3(this.#color, color);
    }
    getColor(out = create$3()) {
        copy$3(out, this.#color);
    }
    dispose() {
    }
    is(s) {
        if (s == 'ColorBackground') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}

//See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
const GL_NONE = 0;
const GL_ZERO = 0;
const GL_ONE = 1;
const GL_FALSE = 0;
const GL_TRUE = 1;
/* ErrorCode */
const GL_NO_ERROR = 0;
const GL_INVALID_ENUM = 0x0500;
const GL_INVALID_VALUE = 0x0501;
const GL_INVALID_OPERATION = 0x0502;
const GL_STACK_OVERFLOW = 0x0503;
const GL_STACK_UNDERFLOW = 0x0504;
const GL_OUT_OF_MEMORY = 0x0505;
//Shaders
const GL_FRAGMENT_SHADER = 0x8B30;
const GL_VERTEX_SHADER = 0x8B31;
//clear
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_RED = 0x1903;
const GL_GREEN = 0x1904;
const GL_BLUE = 0x1905;
const GL_ALPHA = 0x1906;
const GL_RGB = 0x1907;
const GL_RGBA = 0x1908;
const GL_LUMINANCE = 0x1909;
const GL_LUMINANCE_ALPHA = 0x190A;
const GL_R8 = 0x8229;
const GL_R8_SNORM = 0x8F94;
const GL_RGBA32F = 0x8814;
const GL_RGB32F = 0x8815;
const GL_RGBA16F = 0x881A;
// drawArrays mode
const GL_POINTS = 0x0000;
const GL_LINES = 0x0001;
const GL_LINE_LOOP = 0x0002;
const GL_LINE_STRIP = 0x0003;
const GL_TRIANGLES = 0x0004;
const GL_TRIANGLE_STRIP = 0x0005;
const GL_TRIANGLE_FAN = 0x0006;
//bufferData usage
const GL_STREAM_DRAW = 0x88E0;
const GL_STREAM_READ = 0x88E1;
const GL_STREAM_COPY = 0x88E2;
const GL_STATIC_DRAW = 0x88E4;
const GL_STATIC_READ = 0x88E5;
const GL_STATIC_COPY = 0x88E6;
const GL_DYNAMIC_DRAW = 0x88E8;
const GL_DYNAMIC_READ = 0x88E9;
const GL_DYNAMIC_COPY = 0x88EA;
//bindBuffer target
const GL_ARRAY_BUFFER = 0x8892;
const GL_ELEMENT_ARRAY_BUFFER = 0x8893;
const GL_COPY_READ_BUFFER = 0x8F36;
const GL_COPY_WRITE_BUFFER = 0x8F37;
const GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
const GL_UNIFORM_BUFFER = 0x8A11;
const GL_PIXEL_PACK_BUFFER = 0x88EB;
const GL_PIXEL_UNPACK_BUFFER = 0x88EC;
//buffer type / uniform type
const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;
const GL_FLOAT = 0x1406;
const GL_HALF_FLOAT = 0x140B;
const GL_FLOAT_VEC2 = 0x8B50;
const GL_FLOAT_VEC3 = 0x8B51;
const GL_FLOAT_VEC4 = 0x8B52;
const GL_INT_VEC2 = 0x8B53;
const GL_INT_VEC3 = 0x8B54;
const GL_INT_VEC4 = 0x8B55;
const GL_BOOL = 0x8B56;
const GL_BOOL_VEC2 = 0x8B57;
const GL_BOOL_VEC3 = 0x8B58;
const GL_BOOL_VEC4 = 0x8B59;
const GL_FLOAT_MAT2 = 0x8B5A;
const GL_FLOAT_MAT3 = 0x8B5B;
const GL_FLOAT_MAT4 = 0x8B5C;
const GL_SAMPLER_2D = 0x8B5E;
const GL_SAMPLER_CUBE = 0x8B60;
const GL_UNSIGNED_INT_VEC2 = 0x8DC6;
const GL_UNSIGNED_INT_VEC3 = 0x8DC7;
const GL_UNSIGNED_INT_VEC4 = 0x8DC8;
const GL_UNSIGNED_INT_24_8 = 0x84FA;
const GL_FLOAT_MAT2x3 = 0x8B65;
const GL_FLOAT_MAT2x4 = 0x8B66;
const GL_FLOAT_MAT3x2 = 0x8B67;
const GL_FLOAT_MAT3x4 = 0x8B68;
const GL_FLOAT_MAT4x2 = 0x8B69;
const GL_FLOAT_MAT4x3 = 0x8B6A;
const GL_SAMPLER_3D = 0x8B5F;
const GL_SAMPLER_2D_SHADOW = 0x8B62;
const GL_SAMPLER_2D_ARRAY = 0x8DC1;
const GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
const GL_SAMPLER_CUBE_SHADOW = 0x8DC5;
const GL_INT_SAMPLER_2D = 0x8DCA;
const GL_INT_SAMPLER_3D = 0x8DCB;
const GL_INT_SAMPLER_CUBE = 0x8DCC;
const GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;
const GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
const GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
const GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
const GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
const GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
const GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
const GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368;
const GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
const GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
// Extensions
const GL_HALF_FLOAT_OES = 0x8D61;
//get parameters
const GL_MAX_VERTEX_ATTRIBS = 0x8869;
//depthFunc
const GL_NEVER = 0x0200;
const GL_LESS = 0x0201;
const GL_EQUAL = 0x0202;
const GL_LEQUAL = 0x0203;
const GL_GREATER = 0x0204;
const GL_NOTEQUAL = 0x0205;
const GL_GEQUAL = 0x0206;
const GL_ALWAYS = 0x0207;
//enable
const GL_BLEND = 0x0BE2;
const GL_CULL_FACE = 0x0B44;
const GL_DEPTH_TEST = 0x0B71;
const GL_DITHER = 0x0BD0;
const GL_POLYGON_OFFSET_FILL = 0x8037;
const GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
const GL_SAMPLE_COVERAGE = 0x80A0;
const GL_SCISSOR_TEST = 0x0C11;
const GL_STENCIL_TEST = 0x0B90;
const GL_RASTERIZER_DISCARD = 0x8C89;
//textures
const GL_TEXTURE0 = 0x84C0; //GL_RENDERING_CONTEXT.TEXTURE0;
//Framebuffers and renderbuffers
const GL_MAX_RENDERBUFFER_SIZE = 0x84E8;
//texture targets
const GL_TEXTURE_2D = 0x0DE1;
const GL_TEXTURE_CUBE_MAP = 0x8513;
const GL_TEXTURE_3D = 0x806F;
const GL_TEXTURE_2D_ARRAY = 0x8C1A;
const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
//texParameter
const GL_TEXTURE_MAG_FILTER = 0x2800;
const GL_TEXTURE_MIN_FILTER = 0x2801;
const GL_TEXTURE_WRAP_S = 0x2802;
const GL_TEXTURE_WRAP_T = 0x2803;
//export const GL_TEXTURE_MAX_ANISOTROPY_EXT = GL_RENDERING_CONTEXT.TEXTURE_MAX_ANISOTROPY_EXT;//TODO
const GL_TEXTURE_BASE_LEVEL = 0x813C;
const GL_TEXTURE_COMPARE_FUNC = 0x884D;
const GL_TEXTURE_COMPARE_MODE = 0x884C;
const GL_TEXTURE_MAX_LEVEL = 0x813D;
const GL_TEXTURE_MAX_LOD = 0x813B;
const GL_TEXTURE_MIN_LOD = 0x813A;
const GL_TEXTURE_WRAP_R = 0x8072;
//texture filter
const GL_NEAREST = 0x2600;
const GL_LINEAR = 0x2601;
const GL_NEAREST_MIPMAP_NEAREST = 0x2700;
const GL_LINEAR_MIPMAP_NEAREST = 0x2701;
const GL_NEAREST_MIPMAP_LINEAR = 0x2702;
const GL_LINEAR_MIPMAP_LINEAR = 0x2703;
// texture wrap
const GL_REPEAT = 0x2901;
const GL_CLAMP_TO_EDGE = 0x812F;
const GL_MIRRORED_REPEAT = 0x8370;
//TEXTURE_MAX_ANISOTROPY_EXT //TODO EXT_texture_filter_anisotropic
//pixelStorei
const GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
const GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
const GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
//blendFunc
const GL_SRC_COLOR = 0x0300;
const GL_ONE_MINUS_SRC_COLOR = 0x0301;
const GL_DST_COLOR = 0x0306;
const GL_ONE_MINUS_DST_COLOR = 0x0307;
const GL_SRC_ALPHA = 0x0302;
const GL_ONE_MINUS_SRC_ALPHA = 0x0303;
const GL_DST_ALPHA = 0x0304;
const GL_ONE_MINUS_DST_ALPHA = 0x0305;
const GL_CONSTANT_COLOR = 0x8001;
const GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
const GL_CONSTANT_ALPHA = 0x8003;
const GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
const GL_SRC_ALPHA_SATURATE = 0x0308;
//blendEquation
const GL_FUNC_ADD = 0x8006; //GL_RENDERING_CONTEXT.GL_FUNC_ADD;
const GL_FUNC_SUBTRACT = 0x800A; //GL_RENDERING_CONTEXT.FUNC_SUBTRACT;
const GL_FUNC_REVERSE_SUBTRACT = 0x800B; //GL_RENDERING_CONTEXT.FUNC_REVERSE_SUBTRACT;
const GL_MIN_EXT = 0x8007; //GL_RENDERING_CONTEXT.MIN_EXT;//TODOv3 EXT_blend_minmax
const GL_MAX_EXT = 0x8008; //GL_RENDERING_CONTEXT.MAX_EXT;//TODOv3 EXT_blend_minmax
const GL_MIN = 0x8007; //GL_RENDERING_CONTEXT.MIN;
const GL_MAX = 0x8008; //GL_RENDERING_CONTEXT.MAX;
//cullFace
const GL_FRONT = 0x0404;
const GL_BACK = 0x0405;
const GL_FRONT_AND_BACK = 0x0408;
//frontFace
const GL_CW = 0x0900;
const GL_CCW = 0x0901;
const GL_RGB4 = 0x804F;
const GL_RGB5 = 0x8050;
const GL_RGB8 = 0x8051;
const GL_RGB10 = 0x8052;
const GL_RGB12 = 0x8053;
const GL_RGB16 = 0x8054;
const GL_RGBA2 = 0x8055;
const GL_RGBA4 = 0x8056;
const GL_RGB5_A1 = 0x8057;
const GL_RGBA8 = 0x8058;
const GL_RGB10_A2 = 0x8059;
const GL_RGBA12 = 0x805A;
const GL_RGBA16 = 0x805B;
const GL_RGBA32UI = 0x8D70;
const GL_RGBA16UI = 0x8D76;
const GL_RGB16UI = 0x8D77;
const GL_RGBA8UI = 0x8D7C;
const GL_RGBA32I = 0x8D82;
const GL_RGB32I = 0x8D83;
const GL_RGBA16I = 0x8D88;
const GL_RGB16I = 0x8D89;
const GL_RGBA8I = 0x8D8E;
const GL_RGB10_A2UI = 0x906F;
const GL_VERTEX_ARRAY = 0x8074;
const GL_DEPTH_COMPONENT = 0x1902;
const GL_DEPTH_COMPONENT16 = 0x81A5;
const GL_DEPTH_COMPONENT24 = 0x81A6;
const GL_DEPTH_COMPONENT32 = 0x81A7;
const GL_DEPTH_COMPONENT32F = 0x8CAC;
const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;
const GL_SRGB = 0x8C40;
const GL_SRGB8 = 0x8C41;
const GL_SRGB_ALPHA = 0x8C42;
const GL_SRGB8_ALPHA8 = 0x8C43;
const GL_RG8 = 0x822B;
const GL_R8I = 0x8231;
const GL_R8UI = 0x8232;
const GL_R16I = 0x8233;
const GL_R16UI = 0x8234;
const GL_R32I = 0x8235;
const GL_R32UI = 0x8236;
const GL_RG8I = 0x8237;
const GL_RG8UI = 0x8238;
const GL_RG16I = 0x8239;
const GL_RG16UI = 0x823A;
const GL_RG32I = 0x823B;
const GL_RG32UI = 0x823C;
// drawBuffers
const GL_MAX_COLOR_ATTACHMENTS = 0x8CDF;
const GL_COLOR_ATTACHMENT0 = 0x8CE0;
const GL_COLOR_ATTACHMENT1 = 0x8CE1;
const GL_COLOR_ATTACHMENT2 = 0x8CE2;
const GL_COLOR_ATTACHMENT3 = 0x8CE3;
const GL_COLOR_ATTACHMENT4 = 0x8CE4;
const GL_COLOR_ATTACHMENT5 = 0x8CE5;
const GL_COLOR_ATTACHMENT6 = 0x8CE6;
const GL_COLOR_ATTACHMENT7 = 0x8CE7;
const GL_COLOR_ATTACHMENT8 = 0x8CE8;
const GL_COLOR_ATTACHMENT9 = 0x8CE9;
const GL_COLOR_ATTACHMENT10 = 0x8CEA;
const GL_COLOR_ATTACHMENT11 = 0x8CEB;
const GL_COLOR_ATTACHMENT12 = 0x8CEC;
const GL_COLOR_ATTACHMENT13 = 0x8CED;
const GL_COLOR_ATTACHMENT14 = 0x8CEE;
const GL_COLOR_ATTACHMENT15 = 0x8CEF;
const GL_COLOR_ATTACHMENT16 = 0x8CF0;
const GL_COLOR_ATTACHMENT17 = 0x8CF1;
const GL_COLOR_ATTACHMENT18 = 0x8CF2;
const GL_COLOR_ATTACHMENT19 = 0x8CF3;
const GL_COLOR_ATTACHMENT20 = 0x8CF4;
const GL_COLOR_ATTACHMENT21 = 0x8CF5;
const GL_COLOR_ATTACHMENT22 = 0x8CF6;
const GL_COLOR_ATTACHMENT23 = 0x8CF7;
const GL_COLOR_ATTACHMENT24 = 0x8CF8;
const GL_COLOR_ATTACHMENT25 = 0x8CF9;
const GL_COLOR_ATTACHMENT26 = 0x8CFA;
const GL_COLOR_ATTACHMENT27 = 0x8CFB;
const GL_COLOR_ATTACHMENT28 = 0x8CFC;
const GL_COLOR_ATTACHMENT29 = 0x8CFD;
const GL_COLOR_ATTACHMENT30 = 0x8CFE;
const GL_COLOR_ATTACHMENT31 = 0x8CFF;
const GL_DEPTH_ATTACHMENT = 0x8D00;
const GL_STENCIL_ATTACHMENT = 0x8D20;
//Framebuffers and renderbuffers
const GL_FRAMEBUFFER = 0x8D40;
const GL_RENDERBUFFER = 0x8D41;
const GL_READ_FRAMEBUFFER = 0x8CA8;
const GL_DRAW_FRAMEBUFFER = 0x8CA9;
const GL_RGB565 = 0x8D62;
const GL_STENCIL_INDEX8 = 0x8D48;
const GL_DEPTH_STENCIL = 0x84F9;
const GL_DEPTH24_STENCIL8 = 0x88F0;
const GL_DEPTH32F_STENCIL8 = 0x8CAD;

const __DISABLE_WEBGL2__ = false;
const DISABLE_WEBGL2 = __DISABLE_WEBGL2__; // Set to true to force webgl1

const TypedArrayProto = Object.getPrototypeOf(Int8Array); // we can't use TypedArray directly
var BufferUsage;
(function (BufferUsage) {
    BufferUsage[BufferUsage["StaticDraw"] = 35044] = "StaticDraw";
    BufferUsage[BufferUsage["DynamicDraw"] = 35048] = "DynamicDraw";
    BufferUsage[BufferUsage["StreamDraw"] = 35040] = "StreamDraw";
    BufferUsage[BufferUsage["StaticRead"] = 35045] = "StaticRead";
    BufferUsage[BufferUsage["DynamicRead"] = 35049] = "DynamicRead";
    BufferUsage[BufferUsage["StreamRead"] = 35041] = "StreamRead";
    BufferUsage[BufferUsage["StaticCopy"] = 35046] = "StaticCopy";
    BufferUsage[BufferUsage["DynamicCopy"] = 35050] = "DynamicCopy";
    BufferUsage[BufferUsage["StreamCopy"] = 35042] = "StreamCopy";
})(BufferUsage || (BufferUsage = {}));
class BufferAttribute {
    #type;
    #usage = BufferUsage.StaticDraw;
    #target;
    #wireframeDirty = true;
    #solidWireframeDirty = true;
    itemSize;
    dirty;
    _array;
    count = 0;
    _buffer;
    #source;
    divisor = 0;
    constructor(array, itemSize) {
        this.itemSize = itemSize;
        if (isNaN(this.itemSize)) {
            throw new TypeError('Argument itemSize must be an Integer');
        }
        this.#target = GL_ARRAY_BUFFER;
        this.#type = 0;
        //TODO: normalized ?
        this.dirty = true;
        if (array) {
            this.array = array;
        }
        return this;
    }
    get type() {
        return this.#type;
    }
    set usage(usage) {
        this.#usage = usage;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
    }
    set target(target) {
        this.#target = target;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
    }
    set array(array) {
        this.setArray(array);
    }
    setArray(array) {
        if (!(array instanceof TypedArrayProto)) {
            throw new TypeError('Argument array must be a TypedArray');
        }
        this._array = array;
        this.count = array.length / this.itemSize;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
        switch (true) {
            case array instanceof Float32Array:
                this.#type = GL_FLOAT;
                break;
            case array instanceof Int8Array:
                this.#type = GL_BYTE;
                break;
            case array instanceof Int16Array:
                this.#type = GL_SHORT;
                break;
            case array instanceof Int32Array:
                this.#type = GL_INT;
                break;
            case array instanceof Uint8Array:
                this.#type = GL_UNSIGNED_BYTE;
                break;
            case array instanceof Uint16Array:
                this.#type = GL_UNSIGNED_SHORT;
                break;
            case array instanceof Uint32Array:
                this.#type = GL_UNSIGNED_INT;
                break;
            default:
                throw 'Unsupported array type';
        }
    }
    update(glContext) {
        if (this.dirty) {
            if (this._buffer === undefined) {
                this._buffer = glContext.createBuffer(); //TODOv3: createBuffer in graphics
            }
            glContext.bindBuffer(this.#target, this._buffer);
            glContext.bufferData(this.#target, this._array, this.#usage);
            this.dirty = false;
            this.#wireframeDirty = true;
            this.#solidWireframeDirty = true;
        }
    }
    updateWireframe(glContext) {
        if (this.#wireframeDirty) {
            if (this._buffer === undefined) {
                this._buffer = glContext.createBuffer(); //TODOv3: createBuffer in graphics
            }
            let lineArray = new Uint32Array(2 * this._array.length);
            let a, b, c;
            let arr = this._array;
            let j = 0;
            for (let i = 0; i < arr.length; i += 3) {
                a = arr[i + 0];
                b = arr[i + 1];
                c = arr[i + 2];
                //lineArray.push(a, b, b, c, c, a);
                lineArray[j++] = a;
                lineArray[j++] = b;
                lineArray[j++] = b;
                lineArray[j++] = c;
                lineArray[j++] = c;
                lineArray[j++] = a;
            }
            glContext.bindBuffer(this.#target, this._buffer);
            glContext.bufferData(this.#target, lineArray, this.#usage);
            this.dirty = true;
            this.#wireframeDirty = false;
        }
    }
    clone() {
        return new this.constructor(this.#source, this.itemSize /*, this._array.byteOffset, this._array.byteLength*/);
    }
    setSource(source) {
        this.#source = source;
    }
    getBuffer() {
        return this._buffer;
    }
}
class Uint8BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint8Array(array);
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint16Array(array, offset, length);
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint32Array(array, offset, length);
    }
}
class Float32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Float32Array(array, offset, length);
    }
}

class BufferGeometry {
    #elementArrayType;
    #users = new Set();
    attributes = new Map();
    dirty = true;
    count = 0;
    properties = new Map();
    getAttribute(name) {
        return this.attributes.get(name);
    }
    setAttribute(name, attribute) {
        this.attributes.set(name, attribute);
    }
    hasAttribute(name) {
        return this.attributes.has(name);
    }
    deleteAttribute(name) {
        this.attributes.delete(name);
    }
    get elementArrayType() {
        return this.#elementArrayType;
    }
    /*getUniform(name) {
        return this.uniforms.get(name);
    }

    setUniform(name, uniform) {
        this.uniforms.set(name, uniform);
    }

    deleteUniform(name) {
        this.uniforms.delete(name);
    }*/
    setIndex(attribute) {
        this.#elementArrayType = attribute instanceof Uint32BufferAttribute ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
        attribute.target = GL_ELEMENT_ARRAY_BUFFER;
        this.setAttribute('index', attribute);
        return;
        /*let attribute;
        if (Array.isArray(index)) {
            attribute = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1, offset, length);
        } else {
            attribute = index;
        }

        this.#elementArrayType = attribute instanceof Uint32BufferAttribute ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
        attribute.target = GL_ELEMENT_ARRAY_BUFFER;
        this.setAttribute('index', attribute);
*/
    }
    update(glContext) {
        throw 'error';
    }
    computeVertexNormals() {
        /* TODO
        var index = this.index;
        var attributes = this.attributes;

        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) {
                this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));//TODOV3: replace with a Float32BufferAttribute
            } else {
                // reset existing normals to zero
                var array = attributes.normal.array;
                for (var i = 0, il = array.length; i < il; i++) {
                    array[i] = 0;
                }
            }

            var normals = attributes.normal.array;

            var vA, vB, vC;
            var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            var cb = new Vector3(), ab = new Vector3();

            // indexed elements

            if (index) {
                var indices = index.array;
                for (var i = 0, il = index.count; i < il; i += 3) {
                    vA = indices[i + 0] * 3;
                    vB = indices[i + 1] * 3;
                    vC = indices[i + 2] * 3;

                    pA.fromArray(positions, vA);
                    pB.fromArray(positions, vB);
                    pC.fromArray(positions, vC);

                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);

                    normals[vA] += cb.x;
                    normals[vA + 1] += cb.y;
                    normals[vA + 2] += cb.z;

                    normals[vB] += cb.x;
                    normals[vB + 1] += cb.y;
                    normals[vB + 2] += cb.z;

                    normals[vC] += cb.x;
                    normals[vC + 1] += cb.y;
                    normals[vC + 2] += cb.z;
                }
            } else {
                // non-indexed elements (unconnected triangle soup)
                for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);

                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);

                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;

                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;

                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                }
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
            */
    }
    clone() {
        const clone = new BufferGeometry();
        for (let [attributeName, attribute] of this.attributes) {
            clone.attributes.set(attributeName, attribute);
        }
        clone.count = this.count;
        clone.#elementArrayType = this.#elementArrayType;
        this.dirty = true; //TODO: or should we copy this.dirty ?
        return clone;
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    hasOnlyUser(user) {
        return (this.#users.size == 1) && (this.#users.has(user));
    }
    dispose() {
        if (this.hasNoUser()) ;
    }
}

class BoxBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    #numberOfVertices;
    updateGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        // helper variables
        this.#numberOfVertices = 0;
        // build each side of the box geometry
        this.#buildPlane(2, 1, 0, -1, -1, depth, height, width, depthSegments, heightSegments); // px
        this.#buildPlane(2, 1, 0, 1, -1, depth, height, -width, depthSegments, heightSegments); // nx
        this.#buildPlane(0, 2, 1, 1, 1, width, depth, height, widthSegments, depthSegments); // py
        this.#buildPlane(0, 2, 1, 1, -1, width, depth, -height, widthSegments, depthSegments); // ny
        this.#buildPlane(0, 1, 2, 1, -1, width, height, depth, widthSegments, heightSegments); // pz
        this.#buildPlane(0, 1, 2, -1, -1, width, height, -depth, widthSegments, heightSegments); // nz
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    #buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
        var segmentWidth = width / gridX;
        var segmentHeight = height / gridY;
        var widthHalf = width / 2;
        var heightHalf = height / 2;
        var depthHalf = depth / 2;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var vertexCounter = 0;
        var ix, iy;
        var vector = create$4();
        // generate vertices, normals and uvs
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segmentHeight - heightHalf;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segmentWidth - widthHalf;
                // set values to correct vector component
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                // now apply vector to vertex buffer
                this.#vertices.push(...vector);
                // set values to correct vector component
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth > 0 ? 1 : -1;
                // now apply vector to normal buffer
                this.#normals.push(...vector);
                // uvs
                this.#uvs.push(ix / gridX);
                this.#uvs.push(1 - (iy / gridY));
                // counters
                vertexCounter += 1;
            }
        }
        // indices
        // 1. you need three indices to draw a single face
        // 2. a single segment consists of two faces
        // 3. so we need to generate six (2*3) indices per segment
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = this.#numberOfVertices + ix + gridX1 * iy;
                var b = this.#numberOfVertices + ix + gridX1 * (iy + 1);
                var c = this.#numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                var d = this.#numberOfVertices + (ix + 1) + gridX1 * iy;
                // faces
                this.#indices.push(a, b, d);
                this.#indices.push(b, c, d);
            }
        }
        // add a group to the geometry. this will ensure multi material support
        // calculate new start value for groups
        // update total number of vertices
        this.#numberOfVertices += vertexCounter;
    }
}

const entities = new Map();
function registerEntity(ent) {
    if (entities.has(ent.getEntityName().toLowerCase())) {
        console.error(`${ent.getEntityName().toLowerCase()} is already registered`);
    }
    entities.set(ent.getEntityName().toLowerCase(), ent);
}
function getEntity(name) {
    return entities.get(name.toLowerCase());
}

class JSONLoader {
    static async fromJSON(rootEntity) {
        let loadedResolve = () => { }; // Note: typescript falsely complains about loadedResolve not being assigned without this.
        const loadedPromise = new Promise(resolve => {
            loadedResolve = resolve;
        });
        const entities = new Map();
        const root = await this.loadEntity(rootEntity, entities, loadedPromise);
        loadedResolve(true);
        return root;
    }
    static async loadEntity(jsonEntity, entities, loadedPromise) {
        if (jsonEntity) {
            const constructor = getEntity(jsonEntity.constructor);
            if (constructor) {
                let entity = await constructor.constructFromJSON(jsonEntity, entities, loadedPromise);
                entity.fromJSON(jsonEntity);
                entities.set(entity.id, entity);
                if (jsonEntity.children) {
                    for (let child of jsonEntity.children) {
                        let childEntity = await this.loadEntity(child, entities, loadedPromise);
                        if (childEntity && entity['addChild']) {
                            entity['addChild'](childEntity);
                        }
                    }
                }
                return entity;
            }
            else {
                console.error('Unknown constructor', jsonEntity.constructor);
            }
        }
    }
    static registerEntity(ent) {
        registerEntity(ent);
    }
}

function isTypedArray(arr) {
    return ArrayBuffer.isView(arr) && !(arr instanceof DataView);
}
function isVec(vec) {
    return Array.isArray(vec) || isTypedArray(vec);
}
function isVec4(vec) {
    return isVec(vec) && vec.length === 4;
}

var MateriaParameterType;
(function (MateriaParameterType) {
    MateriaParameterType[MateriaParameterType["None"] = 0] = "None";
    MateriaParameterType[MateriaParameterType["Boolean"] = 1] = "Boolean";
    MateriaParameterType[MateriaParameterType["Integer"] = 2] = "Integer";
    MateriaParameterType[MateriaParameterType["Float"] = 3] = "Float";
    MateriaParameterType[MateriaParameterType["NormalizedFloat"] = 4] = "NormalizedFloat";
    MateriaParameterType[MateriaParameterType["ClampedFloat"] = 5] = "ClampedFloat";
    MateriaParameterType[MateriaParameterType["Vec2"] = 6] = "Vec2";
    MateriaParameterType[MateriaParameterType["Vec3"] = 7] = "Vec3";
    MateriaParameterType[MateriaParameterType["Vec4"] = 8] = "Vec4";
    MateriaParameterType[MateriaParameterType["Mat2"] = 9] = "Mat2";
    MateriaParameterType[MateriaParameterType["Mat3"] = 10] = "Mat3";
    MateriaParameterType[MateriaParameterType["Mat4"] = 11] = "Mat4";
    MateriaParameterType[MateriaParameterType["Color2"] = 12] = "Color2";
    MateriaParameterType[MateriaParameterType["Color3"] = 13] = "Color3";
    MateriaParameterType[MateriaParameterType["Color4"] = 14] = "Color4";
    MateriaParameterType[MateriaParameterType["Texture"] = 15] = "Texture";
    MateriaParameterType[MateriaParameterType["Texture1D"] = 16] = "Texture1D";
    MateriaParameterType[MateriaParameterType["Texture2D"] = 17] = "Texture2D";
    MateriaParameterType[MateriaParameterType["Texture3D"] = 18] = "Texture3D";
})(MateriaParameterType || (MateriaParameterType = {}));
class MateriaParameter {
    #name;
    #type = MateriaParameterType.None;
    #value;
    #changed;
    constructor(name, type, value, changed) {
        this.#name = name;
        this.#type = type;
        this.#changed = changed;
        this.setValue(value);
    }
    setValue(value) {
        if (!this.#checkValue(value)) {
            console.warn('Material parameter value has an incorrect type');
        }
        // Todo: check value type
        // Todo: check if value actually changed
        if (this.#changed) {
            this.#changed(value, this.#value);
        }
        this.#value = value;
    }
    #checkValue(value) {
        if (value === undefined || value === null) {
            return true;
        }
        switch (this.#type) {
            case MateriaParameterType.NormalizedFloat:
                return (typeof value == 'number') && (value >= 0) && (value <= 1);
            case MateriaParameterType.Color4:
                return isVec4(value);
            case MateriaParameterType.Texture:
                return value.isTexture;
            default:
                throw 'unknown type: ' + this.#type;
        }
    }
}

var RenderFace;
(function (RenderFace) {
    RenderFace[RenderFace["Both"] = 0] = "Both";
    RenderFace[RenderFace["Front"] = 1] = "Front";
    RenderFace[RenderFace["Back"] = 2] = "Back";
    RenderFace[RenderFace["None"] = 3] = "None";
})(RenderFace || (RenderFace = {}));
var BlendingMode;
(function (BlendingMode) {
    BlendingMode[BlendingMode["None"] = 0] = "None";
    BlendingMode[BlendingMode["Normal"] = 1] = "Normal";
    BlendingMode[BlendingMode["Additive"] = 2] = "Additive";
    BlendingMode[BlendingMode["Substractive"] = 3] = "Substractive";
    BlendingMode[BlendingMode["Multiply"] = 4] = "Multiply";
})(BlendingMode || (BlendingMode = {}));

var BlendingFactor;
(function (BlendingFactor) {
    BlendingFactor[BlendingFactor["Zero"] = 0] = "Zero";
    BlendingFactor[BlendingFactor["One"] = 1] = "One";
    BlendingFactor[BlendingFactor["SrcColor"] = 768] = "SrcColor";
    BlendingFactor[BlendingFactor["OneMinusSrcColor"] = 769] = "OneMinusSrcColor";
    BlendingFactor[BlendingFactor["DstColor"] = 774] = "DstColor";
    BlendingFactor[BlendingFactor["OneMinusDstColor"] = 775] = "OneMinusDstColor";
    BlendingFactor[BlendingFactor["SrcAlpha"] = 770] = "SrcAlpha";
    BlendingFactor[BlendingFactor["OneMinusSrcAlpha"] = 771] = "OneMinusSrcAlpha";
    BlendingFactor[BlendingFactor["DstAlpha"] = 772] = "DstAlpha";
    BlendingFactor[BlendingFactor["OneMinusDstAlpha"] = 773] = "OneMinusDstAlpha";
    BlendingFactor[BlendingFactor["ConstantColor"] = 32769] = "ConstantColor";
    BlendingFactor[BlendingFactor["OneMinusConstantColor"] = 32770] = "OneMinusConstantColor";
    BlendingFactor[BlendingFactor["ConstantAlpha"] = 32771] = "ConstantAlpha";
    BlendingFactor[BlendingFactor["OneMinusConstantAlpha"] = 32772] = "OneMinusConstantAlpha";
    BlendingFactor[BlendingFactor["SrcAlphaSaturate"] = 776] = "SrcAlphaSaturate";
})(BlendingFactor || (BlendingFactor = {}));
var BlendingEquation;
(function (BlendingEquation) {
    BlendingEquation[BlendingEquation["Add"] = 32774] = "Add";
    BlendingEquation[BlendingEquation["Subtract"] = 32778] = "Subtract";
    BlendingEquation[BlendingEquation["ReverseSubtract"] = 32779] = "ReverseSubtract";
    BlendingEquation[BlendingEquation["Min"] = 32775] = "Min";
    BlendingEquation[BlendingEquation["Max"] = 32776] = "Max";
})(BlendingEquation || (BlendingEquation = {}));

const MATERIAL_BLENDING_NONE = 0;
const MATERIAL_BLENDING_NORMAL = 1;
const MATERIAL_BLENDING_ADDITIVE = 2;
const MATERIAL_CULLING_NONE = 0;
const MATERIAL_CULLING_FRONT = GL_FRONT;
const MATERIAL_CULLING_BACK = GL_BACK;
const MATERIAL_CULLING_FRONT_AND_BACK = GL_FRONT_AND_BACK;
var MaterialColorMode;
(function (MaterialColorMode) {
    MaterialColorMode[MaterialColorMode["None"] = 0] = "None";
    MaterialColorMode[MaterialColorMode["PerVertex"] = 1] = "PerVertex";
    MaterialColorMode[MaterialColorMode["PerMesh"] = 2] = "PerMesh";
})(MaterialColorMode || (MaterialColorMode = {}));
const DEFAULT_COLOR = fromValues$3(1.0, 1.0, 1.0, 1.0);
//export type BlendFuncSeparateFactor = typeof GL_ZERO | typeof GL_ONE | typeof GL_SRC_COLOR | typeof GL_ONE_MINUS_SRC_COLOR | typeof GL_DST_COLOR | typeof GL_ONE_MINUS_DST_COLOR | typeof GL_SRC_ALPHA | typeof GL_ONE_MINUS_SRC_ALPHA | typeof GL_DST_ALPHA | typeof GL_ONE_MINUS_DST_ALPHA | typeof GL_CONSTANT_COLOR | typeof GL_ONE_MINUS_CONSTANT_COLOR | typeof GL_CONSTANT_ALPHA | typeof GL_ONE_MINUS_CONSTANT_ALPHA | typeof GL_SRC_ALPHA_SATURATE;
class Material {
    id = '';
    name = '';
    #renderFace = RenderFace.Front;
    #renderLights = true;
    #color = create$3();
    #alphaTest = false;
    #alphaTestReference = 0;
    #users = new Set();
    #parameters = new Map();
    uniforms = {}; // TODO: transform to map ?
    defines = {}; //TODOv3: put defines in meshes too ?
    parameters;
    depthTest;
    depthFunc;
    depthMask;
    colorMask;
    blend = false;
    srcRGB = BlendingFactor.One;
    dstRGB = BlendingFactor.Zero;
    srcAlpha = BlendingFactor.One;
    dstAlpha = BlendingFactor.Zero;
    modeRGB; //TODO: create type like above
    modeAlpha;
    polygonOffset;
    polygonOffsetFactor;
    polygonOffsetUnits;
    _dirtyProgram;
    #colorMode = MaterialColorMode.None;
    colorMap;
    properties = new Map();
    static materialList = {};
    constructor(params = {}) {
        this.parameters = params;
        this.depthTest = params.depthTest ?? true;
        this.depthFunc = GL_LESS;
        this.depthMask = true;
        this.colorMask = fromValues$3(1.0, 1.0, 1.0, 1.0);
        this.modeRGB = GL_FUNC_ADD;
        this.modeAlpha = GL_FUNC_ADD;
        //this.culling = parameters.culling ?? DEFAULT_CULLING_MODE;
        if (params.culling) {
            throw 'handle me';
        }
        this.color = DEFAULT_COLOR;
        this.polygonOffset = params.polygonOffset ?? false;
        this.polygonOffsetFactor = params.polygonpolygonOffsetFactorOffset ?? -5;
        this.polygonOffsetUnits = params.polygonOffsetUnits ?? -5;
        this._dirtyProgram = true; //TODOv3 use another method
    }
    get transparent() {
        return this.blend;
    }
    set renderLights(renderLights) {
        this.#renderLights = renderLights;
    }
    get renderLights() {
        return this.#renderLights;
    }
    setDefine(define, value = '') {
        if (this.defines[define] !== value) {
            this.defines[define] = value;
            this._dirtyProgram = true; //TODOv3: invalidate program here ?
        }
    }
    removeDefine(define) {
        if (this.defines[define] !== undefined) {
            delete this.defines[define];
            this._dirtyProgram = true; //TODOv3: invalidate program here ?
        }
    }
    setValues(values) {
        if (values === undefined)
            return;
    }
    clone() {
        console.error('cant\'t clone Material, missing clone() in ' + this.constructor.name);
        //return new this.constructor(this.parameters);
    }
    setTransparency(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        this.blend = true;
        this.depthMask = false;
        this.srcRGB = srcRGB;
        this.dstRGB = dstRGB;
        this.srcAlpha = srcAlpha ?? srcRGB;
        this.dstAlpha = dstAlpha ?? dstRGB;
    }
    setBlending(mode, premultipliedAlpha = false) {
        if (premultipliedAlpha) {
            switch (mode) {
                case BlendingMode.None:
                    this.blend = false;
                    break;
                case BlendingMode.Normal:
                    this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Additive:
                    this.setTransparency(GL_ONE, GL_ONE);
                    break;
                case BlendingMode.Substractive:
                    this.setTransparency(GL_ZERO, GL_ZERO, GL_ONE_MINUS_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Multiply:
                    this.setTransparency(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_SRC_ALPHA);
                    break;
            }
        }
        else {
            switch (mode) {
                case BlendingMode.None:
                    this.blend = false;
                    break;
                case BlendingMode.Normal:
                    this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Additive:
                    this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                    break;
                case BlendingMode.Substractive:
                    this.setTransparency(GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
                    break;
                case BlendingMode.Multiply:
                    this.setTransparency(GL_ZERO, GL_SRC_COLOR);
                    break;
            }
        }
    }
    updateMaterial(time, mesh) {
    }
    beforeRender(camera) {
    }
    /**
     * @deprecated Please use `renderFace` instead.
     */
    set culling(mode) {
        throw 'deprecated';
        /*
        this.#cullingMode = mode;
        if (mode === MATERIAL_CULLING_NONE) {
            this.setDefine('CULLING_DISABLED');
            this.removeDefine('REVERSE_CULLING');
            this.disableCulling = true;
        } else {
            this.disableCulling = false;
            this.cullMode = mode;
            this.removeDefine('CULLING_DISABLED');
            mode === MATERIAL_CULLING_BACK ? this.removeDefine('REVERSE_CULLING') : this.setDefine('REVERSE_CULLING');
        }
        */
    }
    renderFace(renderFace) {
        this.#renderFace = renderFace;
        if (renderFace == RenderFace.Both) {
            this.setDefine('CULLING_DISABLED');
            this.removeDefine('REVERSE_CULLING');
        }
        else {
            this.removeDefine('CULLING_DISABLED');
            if (renderFace == RenderFace.Front) {
                this.removeDefine('REVERSE_CULLING');
            }
            else {
                this.setDefine('REVERSE_CULLING');
            }
        }
    }
    getRenderFace() {
        return this.#renderFace;
    }
    setColorMode(colorMode) {
        this.#colorMode = colorMode;
        switch (colorMode) {
            case MaterialColorMode.None:
                this.removeDefine('USE_VERTEX_COLOR');
                this.removeDefine('USE_MESH_COLOR');
                break;
            case MaterialColorMode.PerVertex:
                this.setDefine('USE_VERTEX_COLOR');
                this.removeDefine('USE_MESH_COLOR');
                break;
            case MaterialColorMode.PerMesh:
                this.removeDefine('USE_VERTEX_COLOR');
                this.setDefine('USE_MESH_COLOR');
                break;
        }
    }
    getColorMode() {
        return this.#colorMode;
    }
    /**
     * @deprecated Please use `setColorMode` instead.
     */
    set colorMode(colorMode) {
        this.setColorMode(colorMode);
    }
    /**
     * @deprecated Please use `getColorMode` instead.
     */
    get colorMode() {
        return this.getColorMode();
    }
    setColor(color) {
        copy$3(this.#color, color);
        this.uniforms['uColor'] = this.#color;
    }
    set color(color) {
        this.setColor(color);
    }
    get color() {
        return clone$3(this.#color);
    }
    setMeshColor(color = DEFAULT_COLOR) {
        this.setColorMode(MaterialColorMode.PerMesh);
        this.color = color;
    }
    setTexture(uniformName, texture, shaderDefine) {
        let previousTexture = this.uniforms[uniformName];
        if (previousTexture != texture) {
            if (previousTexture) {
                previousTexture.removeUser(this);
            }
            if (texture) {
                texture.addUser(this);
                this.uniforms[uniformName] = texture;
                if (shaderDefine) {
                    this.setDefine(shaderDefine);
                }
            }
            else {
                this.uniforms[uniformName] = null;
                if (shaderDefine) {
                    this.removeDefine(shaderDefine);
                }
            }
        }
    }
    setTextureArray(uniformName, textureArray) {
        let previousTextureArray = this.uniforms[uniformName];
        let keepMe = new Set();
        if (textureArray) {
            textureArray.forEach(texture => {
                if (texture) {
                    texture.addUser(this);
                    keepMe.add(texture);
                }
            });
            this.uniforms[uniformName] = textureArray;
        }
        else {
            this.uniforms[uniformName] = null;
        }
        if (previousTextureArray) {
            previousTextureArray.forEach(texture => {
                if (texture && !keepMe.has(texture)) {
                    texture.removeUser(this);
                }
            });
        }
    }
    setColorMap(texture) {
        this.setTexture('colorMap', texture, 'USE_COLOR_MAP');
        this.colorMap = texture;
    }
    setColor2Map(texture) {
        this.setTexture('color2Map', texture, 'USE_COLOR2_MAP');
    }
    setDetailMap(texture) {
        this.setTexture('detailMap', texture, 'USE_DETAIL_MAP');
    }
    setNormalMap(texture) {
        this.setTexture('normalMap', texture, 'USE_NORMAL_MAP');
    }
    setCubeMap(texture) {
        this.setTexture('cubeMap', texture, 'USE_CUBE_MAP');
    }
    setAlphaTest(alphaTest) {
        this.#alphaTest = alphaTest;
        this.#setAlphaTest();
    }
    /**
     * @deprecated Please use `setAlphaTest` instead.
     */
    set alphaTest(alphaTest) {
        this.setAlphaTest(alphaTest);
    }
    setAlphaTestReference(alphaTestReference) {
        this.#alphaTestReference = alphaTestReference;
        this.#setAlphaTest();
    }
    /**
     * @deprecated Please use `setAlphaTestReference` instead.
     */
    set alphaTestReference(alphaTestReference) {
        this.setAlphaTestReference(alphaTestReference);
    }
    #setAlphaTest() {
        if (this.#alphaTest) {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = this.#alphaTestReference ?? 0.5;
            this.depthMask = true;
        }
        else {
            this.removeDefine('ALPHA_TEST');
        }
    }
    getColorMapSize(size = create()) {
        if (this.colorMap) {
            size[0] = this.colorMap.width;
            size[1] = this.colorMap.height;
        }
        return size;
    }
    addParameter(name, type, value, changed) {
        const param = new MateriaParameter(name, type, value, changed);
        this.#parameters.set(name, param);
        return param;
    }
    removeParameter(name) {
        this.#parameters.delete(name);
    }
    getParameter(name) {
        return this.#parameters.get(name);
    }
    setParameterValue(name, value) {
        const parameter = this.#parameters.get(name);
        if (parameter !== undefined) {
            parameter.setValue(value);
        }
    }
    setColor4Uniform(uniformName, value) {
        this.uniforms[uniformName] = value;
    }
    toJSON() {
        let json = {
            constructor: this.constructor.getEntityName(),
        };
        //TODO
        json.parameters = this.parameters;
        json.color = this.color;
        json.colormode = this.colorMode;
        json.alphatest = this.#alphaTest;
        json.alphaTestReference = this.#alphaTestReference;
        if (this.#renderFace != RenderFace.Front) {
            json.render_face = this.#renderFace;
        }
        return json;
    }
    static async constructFromJSON(json) {
        return new Material(json.parameters);
    }
    fromJSON(json) {
        this.color = json.color;
        this.setColorMode(json.colormode);
        this.setAlphaTest(json.alphatest);
        this.setAlphaTestReference(json.alphaTestReference);
        this.renderFace(json.render_face ?? RenderFace.Front);
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    #disposeUniform(uniform) {
        if (Array.isArray(uniform)) {
            uniform.forEach((subValue) => this.#disposeUniform(subValue));
        }
        else {
            uniform?.removeUser?.(this);
        }
    }
    dispose() {
        if (this.hasNoUser()) {
            let uniforms = this.uniforms;
            let uniformArray = Object.keys(uniforms);
            for (let uniformName of uniformArray) {
                let uniform = uniforms[uniformName];
                this.#disposeUniform(uniform);
            }
        }
    }
    static getEntityName() {
        return 'Material';
    }
    get shaderSource() {
        // TODO: remove this
        throw 'get shaderSource() must be overridden';
    }
    getShaderSource() {
        return this.shaderSource;
    }
}
registerEntity(Material);

class MeshBasicMaterial extends Material {
    map = null;
    lightMap = null;
    lightMapIntensity = 1.0;
    aoMap = null;
    aoMapIntensity = 1.0;
    specularMap = null;
    alphaMap = null;
    envMap = null;
    combine = 0 /*MultiplyOperation*/;
    reflectivity = 1;
    refractionRatio = 0.98;
    wireframe = false;
    wireframeLinewidth = 1;
    wireframeLinecap = 'round';
    wireframeLinejoin = 'round';
    skinning = false;
    morphTargets = false;
    constructor(params) {
        super(params);
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshbasic';
    }
    toJSON() {
        let json = super.toJSON();
        json.skinning = this.skinning;
        return json;
    }
    static async constructFromJSON(json) {
        return new MeshBasicMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.skinning = json.skinning;
    }
    static getEntityName() {
        return 'MeshBasicMaterial';
    }
}
Material.materialList['MeshBasic'] = MeshBasicMaterial;
registerEntity(MeshBasicMaterial);

const PARENT_CHANGED = 'parentchanged';
const CHILD_ADDED = 'childadded';
const CHILD_REMOVED = 'childremoved';
const ENTITY_DELETED = 'entitydeleted';
const PROPERTY_CHANGED$1 = 'propertychanged';
const ATTRIBUTE_CHANGED = 'attributechanged';
class EntityObserverClass {
    #eventTarget = new EventTarget();
    parentChanged(child, oldParent, newParent) {
        this.#eventTarget.dispatchEvent(new CustomEvent(PARENT_CHANGED, { detail: { child: child, oldParent: oldParent, newParent: newParent } }));
    }
    childAdded(parent, child) {
        this.#eventTarget.dispatchEvent(new CustomEvent(CHILD_ADDED, { detail: { child: child, parent: parent } }));
    }
    childRemoved(parent, child) {
        this.#eventTarget.dispatchEvent(new CustomEvent(CHILD_REMOVED, { detail: { child: child, parent: parent } }));
    }
    entityDeleted(entity) {
        this.#eventTarget.dispatchEvent(new CustomEvent(ENTITY_DELETED, { detail: { entity: entity } }));
    }
    propertyChanged(entity, propertyName, oldValue, newValue) {
        this.#eventTarget.dispatchEvent(new CustomEvent(PROPERTY_CHANGED$1, { detail: { entity: entity, name: propertyName, value: newValue, oldValue: oldValue } }));
    }
    attributeChanged(entity, attributeName, oldValue, newValue) {
        this.#eventTarget.dispatchEvent(new CustomEvent(ATTRIBUTE_CHANGED, { detail: { entity: entity, name: attributeName, value: newValue, oldValue: oldValue } }));
    }
    addEventListener(type, callback, options) {
        this.#eventTarget.addEventListener(type, callback, options);
    }
}
const EntityObserver = new EntityObserverClass();

const pickList = new Map();

const tempVec3$x = create$4();
const tempMin = create$4();
const tempMax = create$4();
class BoundingBox {
    min = create$4();
    max = create$4();
    empty = true;
    setPoints(points) {
        this.reset();
        this.addPoints(points);
    }
    addPoints(pointArray) {
        set$5(tempMin, +Infinity, +Infinity, +Infinity);
        set$5(tempMax, -Infinity, -Infinity, -Infinity);
        for (let i = 0; i < pointArray.length; i += 3) {
            tempVec3$x[0] = pointArray[i + 0];
            tempVec3$x[1] = pointArray[i + 1];
            tempVec3$x[2] = pointArray[i + 2];
            min$3(tempMin, tempMin, tempVec3$x);
            max$3(tempMax, tempMax, tempVec3$x);
        }
        if (pointArray.length) {
            if (!this.empty) {
                min$3(tempMin, tempMin, this.min);
                max$3(tempMax, tempMax, this.max);
            }
            copy$4(this.min, tempMin);
            copy$4(this.max, tempMax);
            this.empty = false;
        }
    }
    addBoundingBox(boundingBox) {
        if (boundingBox.empty) {
            return;
        }
        if (!this.empty) {
            min$3(this.min, boundingBox.min, this.min);
            max$3(this.max, boundingBox.max, this.max);
        }
        else {
            copy$4(this.min, boundingBox.min);
            copy$4(this.max, boundingBox.max);
        }
        this.empty = false;
    }
    reset() {
        zero$4(this.min);
        zero$4(this.max);
        this.empty = true;
    }
    get center() {
        return this.getCenter();
    }
    getCenter(center = create$4()) {
        return lerp$5(center, this.min, this.max, 0.5);
    }
    get size() {
        return this.getSize();
    }
    getSize(size = create$4()) {
        return sub$2(size, this.max, this.min);
    }
}

const PI = Math.PI;
const TAU = Math.PI * 2.0;
const TWO_PI = TAU;
const HALF_PI = Math.PI * 0.5;
const DEG_TO_RAD = Math.PI / 180;
const RAD_TO_DEG = 180 / Math.PI;
const EPSILON$2 = 1e-7;
const FLT_EPSILON = 1.19209290e-07;
const ONE_EPS = 1.0000001;

function degToRad(deg) {
    return deg * DEG_TO_RAD;
}
function radToDeg(rad) {
    return rad * RAD_TO_DEG;
}
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
function pow2(n) {
    return (n >= 0 && n < 31) ? (1 << n) : Math.pow(2, n);
}
function RemapValClamped(val, A, B, C, D) {
    if (A == B) {
        return val >= B ? D : C;
    }
    let cVal = (val - A) / (B - A);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //clamp(cVal, 0.0, 1.0);
    return C + (D - C) * cVal;
}
function RemapValClampedBias(val, A, B, C, D, bias) {
    if (A == B) {
        return val >= B ? D : C;
    }
    let cVal = (val - A) / (B - A);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //clamp(cVal, 0.0, 1.0);
    if (bias != 0.5) {
        cVal = Bias(cVal, bias);
    }
    return C + (D - C) * cVal;
}
// SIMD versions of mathlib simplespline functions
// hermite basis function for smooth interpolation
// Similar to Gain() above, but very cheap to call
// value should be between 0 & 1 inclusive
function SimpleSpline(value) {
    const valueSquared = value * value;
    return (3 * valueSquared) - (2 * value * valueSquared);
    /*// Arranged to avoid a data dependency between these two MULs:
    fltx4 valueDoubled = MulSIMD(value, Four_Twos);
    fltx4 valueSquared = MulSIMD(value, value);

    // Nice little ease-in, ease-out spline-like curve
    return SubSIMD(
        MulSIMD(Four_Threes,	valueSquared),
        MulSIMD(valueDoubled, valueSquared));*/
}
/**
 * Generates a random vector within two given vectors
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} a the second operand
 * @returns {vec3} out
 */
function vec3RandomBox(out, a, b) {
    let ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
    out[0] = (bx - ax) * Math.random() + ax;
    out[1] = (by - ay) * Math.random() + ay;
    out[2] = (bz - az) * Math.random() + az;
    return out;
}
/**
 * Clamp each component of vec3 to scalar values
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to clamp
 * @param {Number} min Min value
 * @param {Number} max Max value
 * @returns {vec3} out
 */
function vec3ClampScalar(out, a, min, max) {
    out[0] = clamp(a[0], min, max);
    out[1] = clamp(a[1], min, max);
    out[2] = clamp(a[2], min, max);
    return out;
}
function RandomFloat(min, max) {
    return Math.random() * (max - min) + min;
}
function RandomFloatExp(min, max, exponent) {
    let rand = Math.pow(Math.random(), exponent);
    return rand * (max - min) + min;
}
/**
 * Computes the mid point of two vectors
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function Vec3Middle(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
    out[0] = (bx + ax) * 0.5;
    out[1] = (by + ay) * 0.5;
    out[2] = (bz + az) * 0.5;
    return out;
}
/**
 * Same as quat.fromEuler with angles in radians
 */
function quatFromEulerRad(out, x, y, z) {
    let halfToRad = 0.5;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function lerp(min, max, v) {
    return min + (max - min) * v;
}
function ceilPowerOfTwo(n) {
    if (n === 0) {
        return 1;
    }
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n + 1;
}
function RandomVectorInUnitSphere(out) {
    // Guarantee uniform random distribution within a sphere
    // Graphics gems III contains this algorithm ('Nonuniform random point sets via warping')
    const u = Math.random(); //RandomFloat(nRandomSampleId, 0.0f, 1.0f);
    const v = Math.random(); //RandomFloat(nRandomSampleId+1, 0.0f, 1.0f);
    const w = Math.random(); //RandomFloat(nRandomSampleId+2, 0.0f, 1.0f);
    const flPhi = Math.acos(1 - 2 * u);
    const flTheta = 2 * Math.PI * v;
    const flRadius = Math.pow(w, 1.0 / 3.0);
    const flSinPhi = Math.sin(flPhi);
    const flCosPhi = Math.cos(flPhi);
    const flSinTheta = Math.sin(flTheta);
    const flCosTheta = Math.cos(flTheta);
    //SinCos(flPhi, &flSinPhi, &flCosPhi);
    //SinCos(flTheta, &flSinTheta, &flCosTheta);
    out[0] = flRadius * flSinPhi * flCosTheta;
    out[1] = flRadius * flSinPhi * flSinTheta;
    out[2] = flRadius * flCosPhi;
    return flRadius;
}
function ExponentialDecay(decayTo, decayTime, dt) {
    return Math.exp(Math.log(decayTo) / decayTime * dt);
}
function Bias(value, bias) {
    return Math.pow(value, Math.log(bias) * -1.4427);
}
function generateRandomUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function FileNameFromPath(path) {
    let startIndex = path.lastIndexOf('/') + 1;
    let endIndex = path.lastIndexOf('.');
    return path.slice(startIndex, endIndex == -1 ? undefined : endIndex);
}
function stringToVec3(s, v = create$4()) {
    let arr = s.split(' ');
    if (arr.length == 3) {
        return set$5(v, Number(arr[0]), Number(arr[1]), Number(arr[2]));
    }
    return v;
}
function stringToQuat(s, q = create$2()) {
    let arr = s.split(' ');
    if (arr.length == 4) {
        return set$3(q, Number(arr[0]), Number(arr[1]), Number(arr[2]), Number(arr[3]));
    }
    return q;
}

const X_VECTOR = fromValues$4(1, 0, 0);
const Y_VECTOR = fromValues$4(0, 1, 0);
const Z_VECTOR$2 = fromValues$4(0, 0, 1);
const tempVec3_1$3 = create$4();
const tempVec3_2$a = create$4();
const tempVec3_3$2 = create$4();
const tempVec3_4$1 = create$4();
const tempQuat$d = create$2();
const tempQuat2$1 = create$2();
const tempQuat3 = create$2();
const tempMat4$4 = create$5();
const _upVector = fromValues$4(0, 0, 1);
let incrementalPickingId = 0;
const IDENTITY_QUAT$1 = create$2();
const IDENTITY_VEC3 = create$4();
const UNITY_VEC3 = fromValues$4(1, 1, 1);
const LAYER_MAX = 50;
var EngineEntityAttributes;
(function (EngineEntityAttributes) {
    EngineEntityAttributes["IsTool"] = "is tool";
})(EngineEntityAttributes || (EngineEntityAttributes = {}));
class Entity {
    static addSubMenu;
    id = generateRandomUUID();
    #wireframe = 0;
    #hideInExplorer = false;
    #serializable = true;
    #castShadow;
    #receiveShadow;
    #visible;
    #playing = true;
    #worldMatrix = create$5();
    #name = '';
    #children = new Set();
    #attributes = new Map();
    #pickingColor;
    enumerable = true;
    animable = false;
    resetable = false;
    _position = create$4();
    _quaternion = create$2();
    _scale = clone$4(UNITY_VEC3);
    _mvMatrix = create$5();
    _normalMatrix = create$6();
    _parent = null;
    materialsParams = {};
    isRenderable = false;
    lockPos = false;
    lockRot = false;
    //lockScale = false;
    drawOutline = false;
    locked = false; // Prevents updates from animation system
    lockPosition = false;
    lockRotation = false;
    lockScale = false;
    static editMaterial;
    properties = new Map();
    loadedPromise;
    #layer = undefined;
    constructor(params) {
        this.setParameters(params);
    }
    setParameters(parameters) {
        if (!parameters) {
            return;
        }
        if (parameters.name) {
            this.#name = parameters.name;
        }
        if (parameters.parent) {
            this.parent = parameters.parent;
        }
        if (parameters.position) {
            this.position = parameters.position;
        }
        if (parameters.quaternion) {
            this.quaternion = parameters.quaternion;
        }
        if (parameters.scale) {
            this.scale = parameters.scale;
        }
        if (parameters.hideInExplorer) {
            this.hideInExplorer = parameters.hideInExplorer;
        }
        if (parameters.castShadow) {
            this.castShadow = parameters.castShadow;
        }
        if (parameters.receiveShadow) {
            this.receiveShadow = parameters.receiveShadow;
        }
        if (parameters.visible !== undefined) {
            this.setVisible(parameters.visible);
        }
    }
    set name(name) {
        const oldValue = this.#name;
        this.#name = name;
        if (oldValue != name) {
            EntityObserver.propertyChanged(this, 'name', oldValue, name);
        }
    }
    get name() {
        return this.#name;
    }
    setPosition(position) {
        if (this.lockPosition) {
            return;
        }
        const oldValue = copy$4(tempVec3_4$1, this._position);
        copy$4(this._position, position);
        if (!exactEquals$4(oldValue, position)) {
            EntityObserver.propertyChanged(this, 'position', oldValue, position);
        }
    }
    getPosition(position = create$4()) {
        return copy$4(position, this._position);
    }
    set position(position) {
        // TODO: deprecate
        this.setPosition(position);
    }
    get position() {
        // TODO: deprecate
        return this.getPosition();
    }
    getWorldPosition(vec = create$4()) {
        if (this._parent) {
            this._parent.getWorldPosition(vec);
            this._parent.getWorldQuaternion(tempQuat$d);
            mul$4(tempVec3_3$2, this._position, this._parent.getWorldScale(tempVec3_3$2));
            transformQuat$1(tempVec3_3$2, tempVec3_3$2, tempQuat$d);
            add$5(vec, vec, tempVec3_3$2);
        }
        else {
            copy$4(vec, this._position);
        }
        return vec;
    }
    getPositionFrom(other, vec = create$4()) {
        this.getWorldPosition(tempVec3_1$3);
        other.getWorldPosition(tempVec3_2$a);
        return sub$2(vec, tempVec3_2$a, tempVec3_1$3);
    }
    setWorldPosition(position) {
        if (this._parent) {
            this._parent.getWorldPosition(tempVec3_1$3);
            this._parent.getWorldQuaternion(tempQuat$d);
            sub$2(tempVec3_1$3, position, tempVec3_1$3);
            invert$2(tempQuat$d, tempQuat$d);
            transformQuat$1(tempVec3_1$3, tempVec3_1$3, tempQuat$d);
            this.position = tempVec3_1$3;
        }
        else {
            this.position = position;
        }
    }
    getWorldQuaternion(q = create$2()) {
        if (this._parent) {
            this._parent.getWorldQuaternion(q);
            mul$2(q, q, this._quaternion);
        }
        else {
            copy$2(q, this._quaternion);
        }
        return q;
    }
    setWorldQuaternion(quaternion) {
        if (this._parent) {
            this._parent.getWorldQuaternion(tempQuat$d);
            invert$2(tempQuat$d, tempQuat$d);
            mul$2(this._quaternion, tempQuat$d, quaternion);
        }
        else {
            copy$2(this._quaternion, quaternion);
        }
    }
    getWorldScale(vec = create$4()) {
        if (this._parent) {
            this._parent.getWorldScale(vec);
            mul$4(vec, vec, this._scale);
        }
        else {
            copy$4(vec, this._scale);
        }
        return vec;
    }
    get positionAsString() {
        return `${this._position[0].toFixed(2)} ${this._position[1].toFixed(2)} ${this._position[2].toFixed(2)}`;
    }
    setQuaternion(quaternion) {
        if (this.lockRotation) {
            return;
        }
        const oldValue = copy$2(tempQuat3, this._quaternion);
        normalize$3(this._quaternion, quaternion);
        if (!exactEquals$2(oldValue, this._quaternion)) {
            EntityObserver.propertyChanged(this, 'quaternion', oldValue, this._quaternion);
        }
    }
    getQuaternion(quaternion = create$2()) {
        return copy$2(quaternion, this._quaternion);
    }
    set quaternion(quaternion) {
        // TODO: deprecate
        this.setQuaternion(quaternion);
    }
    get quaternion() {
        // TODO: deprecate
        return this.getQuaternion();
    }
    get quaternionAsString() {
        return `${this._quaternion[0].toFixed(2)} ${this._quaternion[1].toFixed(2)} ${this._quaternion[2].toFixed(2)} ${this._quaternion[3].toFixed(2)}`;
    }
    set scale(scale) {
        if (this.lockScale) {
            return;
        }
        copy$4(this._scale, scale);
    }
    get scale() {
        return clone$4(this._scale);
    }
    get worldMatrix() {
        //TODO: optimize
        this.getWorldPosition(tempVec3_1$3);
        this.getWorldQuaternion(tempQuat$d);
        //console.error(...tempVec3_1);
        fromRotationTranslationScale(this.#worldMatrix, tempQuat$d, tempVec3_1$3, this.getWorldScale());
        return this.#worldMatrix;
    }
    render(canvas) {
    }
    get transparent() {
        return false;
    }
    setVisible(visible) {
        const oldValue = this.#visible;
        this.#visible = visible;
        if (oldValue != visible) {
            EntityObserver.propertyChanged(this, 'visible', oldValue, visible);
        }
    }
    /**
     * @deprecated Please use `setVisible` instead.
     */
    set visible(visible) {
        this.setVisible(visible);
    }
    isVisible() {
        if (this.#visible === undefined) {
            return this._parent?.isVisible() ?? true;
        }
        else {
            return this.#visible;
        }
    }
    isVisibleSelf() {
        return this.#visible;
    }
    /**
     * @deprecated Please use `isVisible` instead.
     */
    get visible() {
        return this.isVisible();
    }
    /**
     * @deprecated Please use `isVisibleSelf` instead.
     */
    get visibleSelf() {
        return this.#visible;
    }
    toggleVisibility() {
        const oldValue = this.#visible;
        if (this.#visible === undefined) {
            if (this.isVisible()) {
                this.setVisible(false);
            }
            else {
                this.setVisible(true);
            }
        }
        else if (this.#visible === true) {
            if (this._parent) {
                if (this._parent.isVisible()) {
                    this.setVisible(false);
                }
                else {
                    this.setVisible(undefined);
                }
            }
            else {
                this.setVisible(false);
            }
        }
        else { // false
            if (this._parent) {
                if (this._parent.isVisible()) {
                    this.setVisible(undefined);
                }
                else {
                    this.setVisible(true);
                }
            }
            else {
                this.setVisible(undefined);
            }
        }
        if (oldValue != this.#visible) {
            EntityObserver.propertyChanged(this, 'visible', oldValue, this.#visible);
        }
    }
    setPlaying(playing) {
        const oldValue = this.#playing;
        this.#playing = playing;
        if (oldValue != playing) {
            EntityObserver.propertyChanged(this, 'playing', oldValue, playing);
        }
    }
    isPlaying() {
        return this.#playing;
    }
    togglePlaying() {
        this.setPlaying(!this.#playing);
    }
    do(action, params) { }
    #setParent(parent) {
        EntityObserver.parentChanged(this, this._parent, parent);
        if (this._parent != null) {
            this._parent.removeChild(this);
        }
        if (this._parent != parent) {
            this._parent = parent;
        }
        this.propagate();
        this.parentChanged(parent);
    }
    parentChanged(parent) { }
    *getParentIterator() {
        const ws = new WeakSet();
        let current = this._parent;
        while (current) {
            ws.add(current);
            yield current;
            current = current.parent;
            if (!current || ws.has(current)) {
                return null;
            }
        }
    }
    remove() {
        if (this._parent != null) {
            this.#setParent(null);
        }
    }
    removeThis() {
        for (let child of this.#children) {
            child.parent = this.parent;
        }
        this.remove();
    }
    removeChildren() {
        for (let child of this.#children) {
            child.remove();
        }
    }
    disposeChildren() {
        for (let child of this.#children) {
            child.dispose();
        }
    }
    removeSiblings() {
        if (this._parent != null) {
            for (let child of this._parent.#children) {
                if (child !== this) {
                    child.remove();
                }
            }
        }
    }
    removeSimilarSiblings() {
        if (this._parent != null) {
            let constructorName = this.constructor.name;
            for (let child of this._parent.#children) {
                if (child !== this && child.constructor.name === constructorName) {
                    child.remove();
                }
            }
        }
    }
    set parent(parent) {
        if (parent) {
            parent.addChild(this);
        }
        /*if (parent instanceof Entity) {
        } else {
            if (DEBUG) {
                console.log(parent, ' is not instanceof Entity');
            }
        }*/
    }
    get parent() {
        return this._parent;
    }
    get root() {
        let currentEntity = this;
        let parent;
        while (currentEntity) {
            parent = currentEntity._parent;
            if (parent) {
                currentEntity = parent;
            }
            else {
                return currentEntity;
            }
        }
        return currentEntity;
    }
    addChild(child) {
        if (!child) {
            return;
        }
        if (!(child instanceof Entity)) {
            return;
        }
        if (child === this) {
            return;
        }
        if (this.#children.has(child)) {
            return;
        }
        if (this.isParent(child)) {
            return;
        }
        this.#children.add(child);
        EntityObserver.childAdded(this, child);
        child.#setParent(this);
        return child;
    }
    addChilds(...childs) {
        childs.forEach(child => this.addChild(child));
    }
    isParent(parent) {
        let _parent = this._parent;
        if (_parent) {
            if (_parent === parent) {
                return true;
            }
            else {
                return _parent.isParent(parent);
            }
        }
        return false;
    }
    removeChild(child) {
        if (child && this.#children.has(child)) {
            this.#children.delete(child);
            child.#setParent(null);
            EntityObserver.childRemoved(this, child);
        }
    }
    toString() {
        return this.#name !== undefined ? this.#name : '';
    }
    translate(v) {
        add$5(tempVec3_1$3, this._position, v);
        this.position = tempVec3_1$3;
    }
    translateOnAxis(axis, distance) {
        transformQuat$1(tempVec3_1$3, axis, this._quaternion);
        scaleAndAdd$2(tempVec3_1$3, this._position, tempVec3_1$3, distance);
        this.position = tempVec3_1$3;
        return this;
    }
    translateX(distance) {
        return this.translateOnAxis(X_VECTOR, distance);
    }
    translateY(distance) {
        return this.translateOnAxis(Y_VECTOR, distance);
    }
    translateZ(distance) {
        return this.translateOnAxis(Z_VECTOR$2, distance);
    }
    rotateX(rad) {
        rotateX$1(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateY(rad) {
        rotateY$1(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateZ(rad) {
        rotateZ$1(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateGlobalX(rad) {
        rotateX$1(tempQuat$d, IDENTITY_QUAT$1, rad);
        mul$2(this._quaternion, tempQuat$d, this._quaternion);
        this.locked = true;
    }
    rotateGlobalY(rad) {
        rotateY$1(tempQuat$d, IDENTITY_QUAT$1, rad);
        mul$2(this._quaternion, tempQuat$d, this._quaternion);
        this.locked = true;
    }
    rotateGlobalZ(rad) {
        rotateZ$1(tempQuat$d, IDENTITY_QUAT$1, rad);
        mul$2(this._quaternion, tempQuat$d, this._quaternion);
        this.locked = true;
    }
    /**
     * Makes this object look at the specified location.
     *
     * @param {Float32Array(3)} target Point in space to look at.
     *
     * @return {void}.
     */
    lookAt(target, upVector = undefined) {
        let parent = this._parent;
        lookAt(tempMat4$4, this._position, target, upVector ?? _upVector);
        getRotation(tempQuat$d, tempMat4$4);
        invert$2(tempQuat$d, tempQuat$d);
        if (parent) {
            conjugate$1(tempQuat2$1, parent._quaternion);
            mul$2(tempQuat$d, tempQuat2$1, tempQuat$d);
        }
        this.quaternion = tempQuat$d;
    }
    getMeshList() {
        let meshList = new Set();
        const treated = new WeakSet();
        let currentEntity = this;
        let objectStack = [];
        while (currentEntity) {
            if (currentEntity.isRenderable && (currentEntity.isVisible() !== false)) {
                meshList.add(currentEntity);
            }
            for (let child of currentEntity.#children) {
                if (!treated.has(child)) {
                    objectStack.push(child);
                    treated.add(child);
                }
            }
            currentEntity = objectStack.shift();
        }
        return meshList;
    }
    showOutline(show, color) {
        if (show) {
            this.drawOutline = true;
            this.materialsParams.drawOutline = true;
            if (color) {
                this.materialsParams.outlineColor = color;
            }
        }
        else {
            this.drawOutline = false;
            this.materialsParams.drawOutline = false;
        }
    }
    getAllChilds(includeSelf) {
        let ws = new WeakSet();
        let childs = new Set();
        let objectStack = [];
        let currentEntity = this;
        if (includeSelf) {
            childs.add(this);
        }
        while (currentEntity) {
            for (let child of currentEntity.#children) {
                if (!ws.has(child)) {
                    objectStack.push(child);
                    childs.add(child);
                    ws.add(child);
                }
            }
            currentEntity = objectStack.shift();
        }
        return childs;
    }
    getBoundsModelSpace(min = create$4(), max = create$4()) {
        //TODO: deprecate
        if (this.#children.size > 0) {
            min[0] = Infinity;
            min[1] = Infinity;
            min[2] = Infinity;
            max[0] = -Infinity;
            max[1] = -Infinity;
            max[2] = -Infinity;
            for (let child of this.#children) {
                child.getBoundsModelSpace(tempVec3_1$3, tempVec3_2$a);
                min$3(min, min, tempVec3_1$3);
                max$3(max, max, tempVec3_2$a);
            }
        }
        else {
            min[0] = 0;
            min[1] = 0;
            min[2] = 0;
            max[0] = 0;
            max[1] = 0;
            max[2] = 0;
        }
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        let childBoundingBox = new BoundingBox();
        for (let child of this.#children) {
            boundingBox.addBoundingBox(child.getBoundingBox(childBoundingBox));
        }
        return boundingBox;
    }
    getParentModel() {
        return this._parent?.getParentModel();
    }
    getChildList(type) {
        let ws = new WeakSet();
        let childs = new Set();
        let objectStack = [];
        let currentEntity = this;
        while (currentEntity) {
            for (let child of currentEntity.#children) {
                if (!ws.has(child) && child.enumerable) {
                    objectStack.push(child);
                    ws.add(child);
                }
            }
            if (type === undefined || currentEntity.is(type)) {
                childs.add(currentEntity);
            }
            currentEntity = objectStack.shift();
        }
        return childs;
    }
    forEach(callback) {
        callback(this);
        for (let child of this.#children) {
            child.forEach(callback);
        }
    }
    forEachVisible(callback) {
        if (this.#visible) {
            callback(this);
            for (let child of this.#children) {
                child.forEach(callback);
            }
        }
    }
    forEachParent(callback) {
        let parent = this._parent;
        if (parent) {
            callback(parent);
            parent.forEachParent(callback);
        }
    }
    setupPickingId() {
        let pickingId = ++incrementalPickingId;
        pickList.set(pickingId, this);
        this.#pickingColor = fromValues$4(((pickingId >> 16) & 0xFF) / 255.0, ((pickingId >> 8) & 0xFF) / 255.0, ((pickingId >> 0) & 0xFF) / 255.0);
    }
    get pickingColor() {
        return this.#pickingColor ?? this._parent?.pickingColor;
    }
    update(scene, camera, delta) {
    }
    set castShadow(castShadow) {
        this.#castShadow = castShadow;
    }
    get castShadow() {
        if (this.#castShadow === undefined) {
            return this._parent ? this._parent.castShadow : true;
        }
        else {
            return this.#castShadow;
        }
    }
    toggleCastShadow() {
        if (this.#castShadow === undefined) {
            if (this.castShadow) {
                this.castShadow = false;
            }
            else {
                this.castShadow = true;
            }
        }
        else if (this.#castShadow === true) {
            if (this._parent?.castShadow) {
                this.castShadow = false;
            }
            else {
                this.castShadow = undefined;
            }
        }
        else {
            if (this._parent?.castShadow) {
                this.castShadow = undefined;
            }
            else {
                this.castShadow = true;
            }
        }
    }
    set receiveShadow(receiveShadow) {
        this.#receiveShadow = receiveShadow;
    }
    get receiveShadow() {
        if (this.#receiveShadow === undefined) {
            return this._parent ? this._parent.receiveShadow : true;
        }
        else {
            return this.#receiveShadow;
        }
    }
    toggleReceiveShadow() {
        if (this.#receiveShadow === undefined) {
            if (this.receiveShadow) {
                this.receiveShadow = false;
            }
            else {
                this.receiveShadow = true;
            }
        }
        else if (this.#receiveShadow === true) {
            if (this._parent?.receiveShadow) {
                this.receiveShadow = false;
            }
            else {
                this.receiveShadow = undefined;
            }
        }
        else {
            if (this._parent?.receiveShadow) {
                this.receiveShadow = undefined;
            }
            else {
                this.receiveShadow = true;
            }
        }
    }
    set serializable(serializable) {
        this.#serializable = serializable;
    }
    get serializable() {
        return this.#serializable;
    }
    set hideInExplorer(hideInExplorer) {
        this.#hideInExplorer = hideInExplorer;
    }
    get hideInExplorer() {
        return this.#hideInExplorer;
    }
    buildContextMenu() {
        let menu = {
            visibility: { i18n: '#visibility', selected: this.isVisible(), f: () => this.toggleVisibility() },
            remove: { i18n: '#remove', f: () => this.remove() },
            destroy: { i18n: '#destroy', f: () => this.dispose() },
            remove_more: {
                i18n: '#remove_more', submenu: [
                    { i18n: '#remove_this', f: () => this.removeThis() },
                    { i18n: '#remove_childs', f: () => this.removeChildren() },
                    { i18n: '#remove_siblings', f: () => this.removeSiblings() },
                    { i18n: '#remove_similar_siblings', f: () => this.removeSimilarSiblings() },
                ]
            },
            name: { i18n: '#name', f: () => { let n = prompt('Name', this.name); if (n !== null) {
                    this.name = n;
                } } },
            add: { i18n: '#add', submenu: Entity.addSubMenu },
            entitynull_1: null,
            position: { i18n: '#position', f: () => { let v = prompt('Position', this.position.join(' ')); if (v !== null) {
                    this.lockPos = true;
                    this.position = stringToVec3(v);
                } } },
            translate: { i18n: '#translate', f: () => { let t = prompt('Translation', '0 0 0'); if (t !== null) {
                    this.lockPos = true;
                    this.translate(stringToVec3(t));
                } } },
            reset_position: { i18n: '#reset_position', f: () => this.position = IDENTITY_VEC3 },
            entitynull_2: null,
            quaternion: { i18n: '#quaternion', f: () => { let v = prompt('Quaternion', this.quaternion.join(' ')); if (v !== null) {
                    this.lockRot = true;
                    this.quaternion = stringToQuat(v);
                } } },
            rotate: {
                i18n: '#rotate', submenu: [
                    { i18n: '#rotate_x_global', f: () => { let r = Number(prompt('Rotation around X global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalX(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_y_global', f: () => { let r = Number(prompt('Rotation around Y global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalY(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_z_global', f: () => { let r = Number(prompt('Rotation around Z global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalZ(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_x', f: () => { let r = Number(prompt('Rotation around X', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateX(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_y', f: () => { let r = Number(prompt('Rotation around Y', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateY(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_z', f: () => { let r = Number(prompt('Rotation around Z', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateZ(r * DEG_TO_RAD);
                        } } },
                ]
            },
            reset_rotation: { i18n: '#reset_rotation', f: () => this.quaternion = IDENTITY_QUAT$1 },
            entitynull_3: null,
            scale: {
                i18n: '#scale', f: () => {
                    let s = prompt('Scale', this.scale.join(' '));
                    if (s !== null) {
                        let arr = s.split(' ');
                        if (arr.length == 3) {
                            this.scale = set$5(tempVec3_1$3, Number(arr[0]), Number(arr[1]), Number(arr[2]));
                        }
                        else if (arr.length == 1) {
                            this.scale = set$5(tempVec3_1$3, Number(arr[0]), Number(arr[0]), Number(arr[0]));
                        }
                    }
                }
            },
            reset_scale: { i18n: '#reset_scale', f: () => this.scale = UNITY_VEC3 },
            entitynull_4: null,
            wireframe: { i18n: '#wireframe', selected: this.wireframe > 0, f: () => this.toggleWireframe() },
            cast_shadows: { i18n: '#cast_shadows', selected: this.castShadow, f: () => this.toggleCastShadow() },
            receive_shadows: { i18n: '#receive_shadows', selected: this.receiveShadow, f: () => this.toggleReceiveShadow() },
            material: { i18n: '#material', submenu: {} },
        };
        if (this.material) {
            Object.assign(menu.material.submenu, {
                entitynull_5: null,
                edit_material: { i18n: '#edit_material', f: () => Entity.editMaterial(this) }
            });
        }
        return menu;
    }
    raycast(raycaster, intersections) {
    }
    setWireframe(wireframe, recursive = true) {
        this.wireframe = wireframe;
        if (recursive) {
            for (let child of this.#children) {
                child.setWireframe(wireframe, recursive);
            }
        }
    }
    set wireframe(wireframe) {
        this.#wireframe = wireframe;
    }
    get wireframe() {
        return this.#wireframe ?? this._parent?.wireframe ?? 0;
    }
    get children() {
        return this.#children;
    }
    toggleWireframe() {
        if (this.#wireframe === undefined) {
            switch (this.wireframe) {
                case 0:
                    this.wireframe = 1;
                    break;
                case 1:
                    this.wireframe = 2;
                    break;
                case 2:
                    this.wireframe = 0;
                    break;
            }
        }
        else {
            //switch (this._parent?.wireframe) {
            let target;
            switch (this.wireframe) {
                case 0:
                    target = 1;
                    break;
                case 1:
                    target = 2;
                    break;
                case 2:
                    target = 0;
                    break;
            }
            if (this._parent?.wireframe === target) {
                this.wireframe = undefined;
            }
            else {
                this.wireframe = target;
            }
        }
    }
    dispose() {
        this.remove();
        EntityObserver.entityDeleted(this);
    }
    replaceMaterial(material, recursive = true) {
        if (recursive) {
            for (let child of this.#children) {
                child.replaceMaterial(material, recursive);
            }
        }
    }
    resetMaterial(recursive = true) {
        if (recursive) {
            for (let child of this.#children) {
                child.resetMaterial(recursive);
            }
        }
    }
    setAttribute(attributeName, attributeValue) {
        const oldValue = this.#attributes.get(attributeName);
        this.#attributes.set(attributeName, attributeValue);
        EntityObserver.attributeChanged(this, attributeName, oldValue, attributeValue);
        this.propagate();
    }
    getAttribute(attributeName, inherited = true) {
        if (this.#attributes.has(attributeName)) {
            return this.#attributes.get(attributeName);
        }
        if (inherited && this._parent) {
            return this._parent.getAttribute(attributeName, inherited);
        }
    }
    propagate() {
        for (let child of this.#children) {
            child.propagate();
        }
    }
    copy(source) {
        //TODO: should we copy world pos / quat ?
        copy$4(this._position, source._position);
        copy$2(this._quaternion, source._quaternion);
        copy$4(this._scale, source._scale);
    }
    getProperty(name) {
        return this.properties.get(name);
    }
    setProperty(name, value) {
        return this.properties.set(name, value);
    }
    setLayer(layer) {
        if (Number.isNaN(Number(layer))) {
            this.#layer = undefined;
        }
        else {
            this.#layer = clamp(layer, 0, LAYER_MAX);
        }
    }
    getLayer() {
        if (this.#layer === undefined) {
            return this._parent?.getLayer() ?? undefined;
        }
        else {
            return this.#layer;
        }
    }
    toJSON() {
        let children = [];
        for (let child of this.#children) {
            if (child.#serializable) {
                children.push(child.toJSON());
            }
        }
        let json = {
            constructor: this.constructor.getEntityName(),
            id: this.id,
            name: this.name
        };
        if (this.#visible !== undefined) {
            json.visible = this.#visible ? true : false;
        }
        if (!exactEquals$4(this._position, IDENTITY_VEC3)) {
            json.position = this.position;
        }
        if (!exactEquals$2(this._quaternion, IDENTITY_QUAT$1)) {
            json.quaternion = this.quaternion;
        }
        if (!exactEquals$4(this._scale, UNITY_VEC3)) {
            json.scale = this.scale;
        }
        if (this.#castShadow !== undefined) {
            json.castshadow = this.#castShadow ? true : false;
        }
        if (this.#receiveShadow !== undefined) {
            json.receiveshadow = this.#receiveShadow ? true : false;
        }
        if (this.#hideInExplorer) {
            json.hideinexplorer = true;
        }
        if (this.materialsParams && Object.keys(this.materialsParams).length) {
            json.materialsparams = this.materialsParams;
        }
        if (children.length) {
            json.children = children;
        }
        if (this.wireframe !== undefined) {
            json.wireframe = this.wireframe;
        }
        if (this.#layer !== undefined) {
            json.layer = this.#layer;
        }
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let entity = new Entity({ name: json.name });
        entity.fromJSON(json);
        return entity;
    }
    async createChild(entityName, parameters) {
        const entity = await JSONLoader.fromJSON({
            constructor: entityName,
            ...parameters,
        });
        if (entity) {
            this.addChild(entity);
            return entity;
        }
    }
    fromJSON(json) {
        this.id = json.id ?? generateRandomUUID();
        this.#name = json.name;
        this.#visible = json.visible;
        if (json.position) {
            this.position = json.position;
        }
        if (json.quaternion) {
            this.quaternion = json.quaternion;
        }
        if (json.scale) {
            this.scale = json.scale;
        }
        this.castShadow = json.castshadow;
        this.receiveShadow = json.receiveshadow;
        this.materialsParams = json.materialsparams;
        this.#hideInExplorer = json.hideinexplorer ?? false;
        this.wireframe = json.wireframe;
        this.#layer = json.layer;
    }
    static getEntityName() {
        return 'Entity';
    }
    is(s) {
        return s == 'Entity';
    }
}
registerEntity(Entity);

class MaterialManager {
    static #materials = new Map();
    static registerMaterial(materialName, materialClass, manager /*TODO: better type*/) {
        this.#materials.set(materialName, { materialClass: materialClass, manager: manager });
    }
    static getMaterial(materialName, callback) {
        let material = this.#materials.get(materialName);
        if (material) {
            let manager = material.manager;
            let materialClass = material.materialClass;
            if (manager) {
                manager.pickMaterial(materialName, materialClass, callback);
            }
            else {
                callback(new materialClass);
            }
        }
    }
    static getMaterialList() {
        return this.#materials.keys();
    }
}

let v0 = create$4();
let v1$3 = create$4();
let v2$2 = create$4();
let v3$2 = create$4();
function getBarycentricCoordinates(out, position, a, b, c) {
    sub$2(v0, c, a);
    sub$2(v1$3, b, a);
    sub$2(v2$2, position, a);
    let dot00 = dot$4(v0, v0);
    let dot01 = dot$4(v0, v1$3);
    let dot02 = dot$4(v0, v2$2);
    let dot11 = dot$4(v1$3, v1$3);
    let dot12 = dot$4(v1$3, v2$2);
    let invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    let u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    let v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    // barycentric coordinates must always sum to 1
    return set$5(out, 1 - u - v, v, u);
}
function getUV(out, position, a, b, c, uv1, uv2, uv3) {
    getBarycentricCoordinates(v3$2, position, a, b, c);
    out[0] = uv1[0] * v3$2[0] + uv2[0] * v3$2[1] + uv3[0] * v3$2[2];
    out[1] = uv1[1] * v3$2[0] + uv2[1] * v3$2[1] + uv3[1] * v3$2[2];
    return out;
}
function getNormal(out, position, a, b, c, normal1, normal2, normal3) {
    getBarycentricCoordinates(v3$2, position, a, b, c);
    out[0] = normal1[0] * v3$2[0] + normal2[0] * v3$2[1] + normal3[0] * v3$2[2];
    out[1] = normal1[1] * v3$2[0] + normal2[1] * v3$2[1] + normal3[1] * v3$2[2];
    out[2] = normal1[2] * v3$2[0] + normal2[2] * v3$2[1] + normal3[2] * v3$2[2];
    return out;
}

class Intersection {
    position;
    normal;
    uv;
    distance;
    entity;
    distanceFromRay;
    constructor(position, normal, uv, distance, entity, distanceFromRay) {
        this.position = clone$4(position);
        if (normal) {
            this.normal = clone$4(normal);
        }
        if (uv) {
            this.uv = clone(uv);
        }
        this.distance = distance;
        this.entity = entity;
        this.distanceFromRay = distanceFromRay;
    }
}

const EPSILON$1 = 1e-7;
const edge1 = create$4();
const edge2 = create$4();
const h = create$4();
const h2 = create$4();
const s = create$4();
const q$2 = create$4();
const m = create$5();
const _segCenter = create$4();
const _segDir = create$4();
const _diff = create$4();
class Ray {
    origin = create$4();
    direction = create$4();
    constructor(origin, direction) {
        if (origin) {
            copy$4(this.origin, origin);
        }
        if (direction) {
            copy$4(this.direction, direction);
        }
    }
    set(origin, direction) {
        copy$4(this.origin, origin);
        copy$4(this.direction, direction);
    }
    copy(other) {
        copy$4(this.origin, other.origin);
        copy$4(this.direction, other.direction);
    }
    copyTransform(other, worldMatrix) {
        invert$3(m, worldMatrix);
        transformMat4$2(this.origin, other.origin, m);
        let x = other.direction[0];
        let y = other.direction[1];
        let z = other.direction[2];
        this.direction[0] = m[0] * x + m[4] * y + m[8] * z;
        this.direction[1] = m[1] * x + m[5] * y + m[9] * z;
        this.direction[2] = m[2] * x + m[6] * y + m[10] * z;
    }
    setOrigin(origin) {
        copy$4(this.origin, origin);
    }
    setDirection(direction) {
        copy$4(this.direction, direction);
    }
    positionAt(distance, position) {
        scaleAndAdd$2(position, this.origin, this.direction, distance);
    }
    intersectTriangle(v0, v1, v2, intersectionPoint) {
        //Möller-Trumbore intersection algorithm
        sub$2(edge1, v1, v0);
        sub$2(edge2, v2, v0);
        cross$2(h, this.direction, edge2);
        let a = dot$4(edge1, h);
        if (a > -EPSILON$1 && a < EPSILON$1) {
            return false;
        }
        let f = 1.0 / a;
        sub$2(s, this.origin, v0);
        let u = f * dot$4(s, h);
        if (u < 0.0 || u > 1.0) {
            return false;
        }
        cross$2(q$2, s, edge1);
        let v = f * dot$4(this.direction, q$2);
        if (v < 0.0 || u + v > 1.0) {
            return false;
        }
        // At this stage we can compute t to find out where the intersection point is on the line.
        let t = f * dot$4(edge2, q$2);
        if (t > EPSILON$1) { // ray intersection
            this.positionAt(t, intersectionPoint);
            return true;
        }
        else { // This means that there is a line intersection but not a ray intersection.
            return false;
        }
    }
    intersectSphere(position, radius, scale, intersectionPoint1, intersectionPoint2) {
        sub$2(h, this.origin, position);
        div$2(h, h, scale);
        div$2(h2, this.direction, scale);
        normalize$5(h2, h2);
        let p = dot$4(h2, h);
        let q = dot$4(h, h) - (radius * radius);
        let discriminant = (p * p) - q;
        if (discriminant < 0.0) {
            return false;
        }
        let dRoot = Math.sqrt(discriminant);
        let dist1 = -p - dRoot;
        let dist2 = -p + dRoot;
        scaleAndAdd$2(intersectionPoint1, h, h2, dist1);
        scaleAndAdd$2(intersectionPoint2, h, h2, dist2);
        mul$4(intersectionPoint1, intersectionPoint1, scale);
        mul$4(intersectionPoint2, intersectionPoint2, scale);
        add$5(intersectionPoint1, intersectionPoint1, position);
        add$5(intersectionPoint2, intersectionPoint2, position);
        return true;
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        //_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
        add$5(_segCenter, v0, v1);
        scale$5(_segCenter, _segCenter, 0.5);
        //_segDir.copy( v1 ).sub( v0 ).normalize();
        sub$2(_segDir, v1, v0);
        normalize$5(_segDir, _segDir);
        //_diff.copy( this.origin ).sub( _segCenter );
        sub$2(_diff, this.origin, _segCenter);
        //const segExtent = v0.distanceTo( v1 ) * 0.5;
        const segExtent = dist$2(v0, v1) * 0.5;
        //const a01 = - this.direction.dot( _segDir );
        const a01 = -dot$4(this.direction, _segDir); //this.direction.dot( _segDir );
        //const b0 = _diff.dot( this.direction );
        const b0 = dot$4(_diff, this.direction);
        //const b1 = - _diff.dot( _segDir );
        const b1 = -dot$4(_diff, _segDir);
        //const c = _diff.lengthSq();
        const c = sqrLen$4(_diff);
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    }
                    else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
            else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                }
                else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        }
        else {
            // Ray and segment are parallel.
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
            //optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );
            scaleAndAdd$2(optionalPointOnRay, this.origin, this.direction, s0);
        }
        if (optionalPointOnSegment) {
            //optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );
            scaleAndAdd$2(optionalPointOnRay, _segCenter, _segDir, s1);
        }
        return sqrDist;
    }
    createIntersection(position, normal, uv, entity, distanceFromRay) {
        return new Intersection(position, normal, uv, distance$3(this.origin, position), entity, distanceFromRay);
    }
}

class HTMLFileSelectorTileElement extends HTMLElement {
    #visible = true;
    #selector;
    #file;
    constructor() {
        super();
        this.addEventListener('click', (event) => {
            if (this.#selector && this.#file) {
                this.#selector.fileSelected(this.#file);
            }
        });
    }
    get file() {
        return this.#file;
    }
    setFile(file) {
        this.#file = file;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    connectedCallback() {
        this.#updateHtml();
    }
    set visible(visible) {
        this.#visible = visible;
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    #updateHtml() {
        if (this.#visible && this.#file) {
            this.innerHTML = this.#file.name;
        }
    }
}
let definedTile = false;
function defineFileSelectorTile() {
    if (window.customElements && !definedTile) {
        customElements.define('file-selector-tile', HTMLFileSelectorTileElement);
        definedTile = true;
    }
}

class HTMLFileSelectorFileElement extends HTMLElement {
    #selector;
    #file;
    constructor() {
        super();
        this.addEventListener('click', (event) => {
            if (this.#selector && this.#file) {
                this.#selector.fileSelected(this.#file);
            }
        });
    }
    setFile(file) {
        this.#file = file;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    connectedCallback() {
        this.#updateHtml();
    }
    set visible(visible) {
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    #updateHtml() {
        if (this.#file) {
            this.innerHTML = this.#file.name;
        }
    }
    refreshFilter() {
        if (!this.#selector || !this.#file) {
            return false;
        }
        let filterName = this.#selector.filter.name;
        let visible = this.#file.name.toLowerCase().includes(filterName) || this.#file.path.toLowerCase().includes(filterName);
        this.visible = visible;
        return visible;
    }
    get file() {
        return this.#file;
    }
}
let definedFile = false;
function defineFileSelectorFile() {
    if (window.customElements && !definedFile) {
        customElements.define('file-selector-file', HTMLFileSelectorFileElement);
        definedFile = true;
    }
}

class FileSelectorDirectory extends HTMLElement {
    #initialized = false;
    #expanded = false;
    #name = '';
    #childs = [];
    #sortingDirection = 1;
    #visible = true;
    #header;
    #content;
    #file;
    #selector;
    #parentDirectory;
    constructor() {
        super();
        this.#header = createElement('div', {
            class: 'file-selector-directory-header',
            events: {
                click: () => {
                    this.#expanded = !this.#expanded;
                    this.#updateHtml();
                    if (this.#expanded && this.#parentDirectory) {
                        this.#parentDirectory.#childExpanded(this);
                    }
                }
            },
        });
        this.#content = createElement('div', { class: 'file-selector-directory-content' });
    }
    #childExpanded(child) {
        for (let enumeratedChild of this.#content.children) {
            if (enumeratedChild.tagName == 'FILE-SELECTOR-DIRECTORY' && enumeratedChild != child) {
                enumeratedChild.collapse();
            }
        }
    }
    expand() {
        this.#expanded = true;
        this.#updateHtml();
    }
    collapse() {
        this.#expanded = false;
        hide(this.#content);
    }
    setFile(file) {
        this.#file = file;
        this.#initialized = false;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    get file() {
        return this.#file;
    }
    connectedCallback() {
        this.append(this.#header, this.#content);
        this.#updateHtml();
    }
    set visible(visible) {
        this.#visible = visible;
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    sort() {
        this.#childs.sort((a, b) => {
            let aIsDir = a.tagName == 'FILE-SELECTOR-DIRECTORY';
            let bIsDir = b.tagName == 'FILE-SELECTOR-DIRECTORY';
            if (aIsDir) {
                if (bIsDir) {
                    let aname = a.file?.name;
                    let bname = b.file?.name;
                    if (aname && bname) {
                        return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                    }
                }
                else {
                    return -this.#sortingDirection;
                }
            }
            else {
                if (bIsDir) {
                    return this.#sortingDirection;
                }
                else {
                    let aname = a.file?.name;
                    let bname = b.file?.name;
                    if (aname && bname) {
                        return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                    }
                }
            }
            return 0;
        });
        for (let child of this.#childs) {
            this.#content.append(child);
        }
    }
    refreshFilter() {
        let visible = false;
        if (this.#expanded) {
            for (let child of this.#childs) {
                visible = child.refreshFilter() || visible;
            }
        }
        else {
            if (this.#file) {
                visible = this.#matchFilter(this.#file);
            }
        }
        this.#visible = visible;
        display(this, visible);
        return visible;
    }
    #matchFilter(file) {
        if (file.files) {
            for (let child of file.files) {
                if (this.#matchFilter(child)) {
                    return true;
                }
            }
        }
        else {
            let filterName = this.#selector?.filter.name ?? '';
            return file.name.toLowerCase().includes(filterName) || file.path?.toLowerCase().includes(filterName) || false;
        }
        return false;
    }
    #updateHtml() {
        defineFileSelectorFile();
        if (this.#file && !this.#initialized) {
            this.#name = this.#file.name.replace(/\/$/g, ''); //remove trailing /
            if (this.#expanded) {
                this.#content.replaceChildren();
                this.#childs = [];
                if (this.#file && this.#file.files) {
                    let files = this.#file.files;
                    let l = files.length == 1;
                    for (let file of files) {
                        let fileChilds = file.files;
                        let child;
                        if (fileChilds) {
                            child = document.createElement('file-selector-directory');
                            child.#parentDirectory = this;
                        }
                        else {
                            child = document.createElement('file-selector-file');
                            //child.file = file;
                        }
                        if (this.#selector) {
                            child.selector = this.#selector;
                        }
                        child.setFile(file);
                        this.#content.append(child);
                        this.#childs.push(child);
                        if (fileChilds && l) {
                            child.expand();
                        }
                    }
                }
                this.#initialized = true;
                this.sort();
            }
            if (this.#file) {
                this.#header.innerHTML = this.#name;
            }
        }
        if (this.#expanded) {
            show(this.#content);
            this.refreshFilter();
        }
        else {
            hide(this.#content);
        }
    }
}
if (customElements) {
    customElements.define('file-selector-directory', FileSelectorDirectory);
}

const FILTER_NAME_DELAY = 200;
class FileSelector extends HTMLElement {
    #fileList;
    #tileView = false;
    #filter = { name: '' };
    #sortingDirection = 1;
    #htmlTiles = [];
    #htmlDirectories = [];
    #header;
    #content;
    #filterNameTimeout;
    #initialized = false;
    constructor() {
        super();
        this.#header = createElement('div', { class: 'file-selector-header' });
        this.#content = createElement('div', { class: 'file-selector-content' });
        let htmlDisplayPropertiesSpan = createElement('span', { parent: this.#header });
        let treeViewId = 'display_tree_view';
        createElement('input', {
            parent: htmlDisplayPropertiesSpan,
            type: 'checkbox',
            id: treeViewId,
            checked: !this.#tileView,
            events: {
                change: () => this.tileView = !this.#tileView
            }
        });
        createElement('label', { i18n: '#display_tree_view', parent: htmlDisplayPropertiesSpan, htmlFor: treeViewId });
        let htmlFilter = createElement('div', { class: 'file-selector-filter', parent: this.#header });
        createElement('input', {
            parent: htmlFilter,
            events: {
                input: (event) => {
                    this.#filter.name = event.target.value;
                    clearTimeout(this.#filterNameTimeout);
                    this.#filterNameTimeout = setTimeout(() => this.refreshFilter(), FILTER_NAME_DELAY);
                }
            },
        });
    }
    fileSelected(file) {
        this.dispatchEvent(new CustomEvent('fileSelected', { detail: { file: file } }));
    }
    set fileList(fileList) {
        this.#fileList = fileList;
        this.#initialized = false;
        this.#updateHtml();
    }
    set tileView(tileView) {
        this.#tileView = tileView;
        this.#initialized = false;
        this.#updateHtml();
    }
    connectedCallback() {
        this.append(this.#header, this.#content);
        this.#updateHtml();
    }
    #getFileList(root) {
        let list = [];
        let stack = [root];
        root.path = '';
        let rootName = root.name; //.replace(/\/$/g, '');
        let current;
        do {
            current = stack.pop();
            if (current) {
                if (current.files) {
                    for (let file of current.files) {
                        let path2 = current.path?.replace(/\/$/g, ''); //remove trailing /
                        let name2 = current.name?.replace(/\/$/g, ''); //remove trailing /
                        if (current == root) {
                            file.path = '/';
                        }
                        else {
                            file.path = (path2 ? path2 + '/' + name2 : name2) + '/';
                            file.root = rootName;
                        }
                        if (file.files) {
                            stack.push(file);
                        }
                        else {
                            list.push(file);
                        }
                    }
                }
            }
        } while (current);
        return list;
    }
    refreshFilter() {
        if (this.#tileView) {
            for (let tile of this.#htmlTiles) {
                tile.visible = this.#matchFilter(tile.file);
            }
        }
        else {
            for (let directory of this.#htmlDirectories) {
                directory.refreshFilter();
            }
        }
    }
    #sortItems() {
        if (this.#tileView) {
            this.#htmlTiles.sort((a, b) => {
                let aname = a.file?.name;
                let bname = b.file?.name;
                if (aname && bname) {
                    return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                }
                return 0;
            });
            for (let tile of this.#htmlTiles) {
                this.#content.append(tile);
            }
        }
    }
    #matchFilter(file) {
        if (!file) {
            return false;
        }
        let ret = false;
        if (file.name?.toLowerCase().includes(this.#filter.name)) {
            ret = true;
        }
        return ret;
    }
    #updateHtml() {
        if (this.#initialized) {
            return;
        }
        defineFileSelectorTile();
        this.#content.replaceChildren();
        this.#htmlTiles = [];
        this.#htmlDirectories = [];
        if (this.#tileView) {
            if (this.#fileList) {
                for (let rootFile of this.#fileList.files) {
                    let fileList = this.#getFileList(rootFile);
                    for (let file of fileList) {
                        const tile = createElement('file-selector-tile', { parent: this.#content });
                        tile.selector = this;
                        tile.setFile(file);
                        this.#htmlTiles.push(tile);
                        tile.visible = this.#matchFilter(file);
                    }
                }
            }
        }
        else {
            if (this.#fileList) {
                let expandDirectory = this.#fileList.files.length == 1;
                for (let rootFile of this.#fileList.files) {
                    this.#getFileList(rootFile); //Just add path
                    const root = createElement('file-selector-directory', { parent: this.#content });
                    root.selector = this;
                    root.setFile(rootFile);
                    this.#htmlDirectories.push(root);
                    if (expandDirectory) {
                        root.expand();
                    }
                }
            }
        }
        this.#sortItems();
        this.#initialized = true;
    }
    get filter() {
        return this.#filter;
    }
}
if (customElements) {
    customElements.define('file-selector', FileSelector);
}

var interactionCSS = ":host {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tz-index: 10000;\n\ttop: 0px;\n\tleft: 0px;\n\tpointer-events: none;\n}\n\nharmony-color-picker{\n\tpointer-events: all;\n}\n\ninput{\n\tpointer-events: all;\n}\n";

const DATALIST_ID = 'interaction-datalist';
class Interaction {
    static #instance;
    #htmlColorPicker;
    #shadowRoot;
    #htmlInput;
    #htmlInputDataList;
    #htmlFileSelector;
    //#htmlColorPickeronDone?: (color: any) => void;
    #htmlColorPickeronChange;
    #htmlColorPickerCancel;
    constructor() {
        if (Interaction.#instance) {
            return Interaction.#instance;
        }
        Interaction.#instance = this;
    }
    #initHtml() {
        if (this.#shadowRoot) {
            return;
        }
        this.#shadowRoot = createShadowRoot('div', {
            parent: document.body,
            hidden: true,
            adoptStyle: interactionCSS
        });
        defineHarmonyColorPicker();
        this.#htmlColorPicker = createElement('harmony-color-picker', {
            parent: this.#shadowRoot,
            hidden: true,
            events: {
                change: (event) => {
                    if (this.#htmlColorPickeronChange) {
                        this.#htmlColorPickeronChange(event.detail);
                    }
                },
                ok: () => hide(this.#htmlColorPicker),
                cancel: () => {
                    if (this.#htmlColorPickerCancel) {
                        this.#htmlColorPickerCancel();
                    }
                    hide(this.#htmlColorPicker);
                },
            },
        });
        this.#htmlInput = createElement('input', {
            style: 'pointer-events: all;',
            list: DATALIST_ID,
            parent: this.#shadowRoot,
            hidden: true,
        });
        this.#htmlInputDataList = createElement('datalist', {
            id: DATALIST_ID,
            parent: this.#shadowRoot,
        });
        this.#htmlFileSelector = createElement('div', {
            style: 'pointer-events: all;width: 100%;overflow: auto;height: 100%;',
        });
    }
    show() {
        this.#initHtml();
        show(this.#shadowRoot?.host);
        hide(this.#htmlInput);
        hide(this.#htmlColorPicker);
    }
    hide() {
        hide(this.#shadowRoot?.host);
    }
    async getColor(x, y, defaultValue, onChange, onCancel) {
        this.show();
        //this.#htmlColorPicker.setOptions({alpha:false});
        show(this.#htmlColorPicker);
        let promise = new Promise((resolve, reject) => {
        });
        /*
        this.#htmlColorPickeronDone = (color) => {
            let rgba = color.rgba;
            let c = vec4.fromValues(rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, 1.0);
            //console.error(color, color.rgba);
            promiseResolve(c);
            this.hide();
        };
        */
        this.#htmlColorPickeronChange = (color) => {
            let rgba = color.rgba;
            let c = fromValues$3(rgba[0], rgba[1], rgba[2], rgba[3]);
            if (onChange) {
                onChange(c);
            }
        };
        this.#htmlColorPickerCancel = () => {
            if (onCancel) {
                onCancel();
            }
        };
        return promise;
    }
    getString(x, y, list, defaultValue) {
        this.show();
        show(this.#htmlInput);
        this.#htmlInput.value = defaultValue ? defaultValue : '';
        if (list) {
            let isMap = list.constructor.name == 'Map';
            this.#htmlInputDataList.innerText = '';
            for (let value of list) {
                let animOption = document.createElement('option');
                this.#htmlInputDataList.append(animOption);
                if (isMap) {
                    animOption.innerHTML = value[0];
                    animOption.value = value[1];
                }
                else {
                    animOption.innerHTML = value;
                }
            }
        }
        let promiseResolve;
        this.#htmlInput.onchange = (event) => {
            for (let option of this.#htmlInputDataList.options) {
                if (option.value == event.target.value) {
                    promiseResolve(option.value);
                }
            }
            hide(this.#htmlInput);
        };
        let promise = new Promise(resolve => {
            promiseResolve = resolve;
        });
        return promise;
    }
    /*
    async #expandFile(parent, files, callback, repository = '', path = '') {
        parent.replaceChildren();

        files.sort(
            (a, b) => {
                if (a.files) {
                    if (!b.files) {
                        return -1;
                    }
                } else {
                    if (b.files) {
                        return 1;
                    }
                }
                return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
            }
        );

        for (let file of files) {
            let f = document.createElement('div');
            f.className = 'file-explorer-file';
            parent.append(f);
            if (file.name) {
                let fheader = document.createElement('div');
                fheader.className = 'file-explorer-file-header';
                fheader.append(file.name);
                f.append(fheader);

                fheader.addEventListener('click', (event) => {
                    if (event.target == fheader) {
                        if (file.files) {
                            if (!f.getAttribute('data-initialized')) {
                                f.setAttribute('data-initialized', 'true');
                                let f1 = document.createElement('div');
                                f1.className = 'file-explorer-childs';
                                if (repository == '') {
                                    this.#expandFile(f1, file.files, callback, file.name);
                                } else {
                                    this.#expandFile(f1, file.files, callback, repository, path + file.name + '/');
                                }
                                //f1.style.display = 'none';
                                f.addEventListener('click', (event) => {
                                    if (event.target == f) {
                                        toggle(f1);
                                    }
                                });
                                f.append(f1);
                            }
                        }
                        console.error(path);
                        callback({ repository: repository, path: path, name: file.name });
                    }
                });
            }
        }
    }
        */
    async selectFile(htmlContainer, fileList, callback) {
        this.#initHtml();
        //htmlContainer.append(this.#htmlFileSelector);
        //this.show();
        //this.#htmlFileSelector.style.display = '';
        this.#htmlFileSelector.innerText = '';
        htmlContainer.innerText = '';
        //let value = await
        //this._expandFile(this.#htmlFileSelector, fileList.files, callback);
        //this.#htmlFileSelector.style.display = 'none';
        //this.hide();
        //return value;
        let fileSelector = document.createElement('file-selector'); //TODO: create only once
        htmlContainer.append(fileSelector);
        fileSelector.fileList = fileList;
        fileSelector.addEventListener('fileSelected', event => {
            let file = event.detail.file;
            callback(file.root, file.path + file.name);
        });
    }
    get htmlElement() {
        return this.#shadowRoot?.host;
    }
}

const tempVec3$w = create$4();
let v1$2 = create$4();
let v2$1 = create$4();
let v3$1 = create$4();
let n1$1 = create$4();
let n2$1 = create$4();
let n3$1 = create$4();
let uv1$1 = create();
let uv2$1 = create();
let uv3$1 = create();
let intersectionPoint$1 = create$4();
let intersectionNormal$2 = create$4();
let ray$1 = new Ray();
let uv$1 = create();
class Mesh extends Entity {
    #geometry;
    #material;
    #dirtyProgram = true; //TODOv3 use another method
    renderMode = GL_TRIANGLES;
    isRenderable = true;
    uniforms = {};
    defines = Object.create(null);
    isMesh = true;
    constructor(geometry, material) {
        super();
        this.setGeometry(geometry);
        this.setMaterial(material);
    }
    set material(material) {
        this.setMaterial(material);
    }
    get material() {
        return this.getMaterial();
    }
    setGeometry(geometry) {
        if (this.#geometry == geometry) {
            return;
        }
        if (this.#geometry) {
            this.#geometry.removeUser(this);
        }
        if (geometry) {
            geometry.addUser(this);
        }
        this.#geometry = geometry;
    }
    get geometry() {
        return this.#geometry;
    }
    setMaterial(material) {
        if (this.#material != material) {
            if (this.#material) {
                this.#material.removeUser(this);
            }
            if (material) {
                material.addUser(this);
            }
            this.#material = material;
        }
    }
    getMaterial() {
        return this.#material;
    }
    getUniform(name) {
        return this.uniforms[name];
    }
    setUniform(name, uniform) {
        this.uniforms[name] = uniform;
    }
    deleteUniform(name) {
        delete this.uniforms[name];
    }
    setDefine(define, value = '') {
        this.defines[define] = value;
    }
    removeDefine(define) {
        delete this.defines[define];
    }
    exportObj() {
        let ret = {};
        let attributes = { f: 'index', v: 'aVertexPosition', vn: 'aVertexNormal', vt: 'aTextureCoord' };
        let geometry = this.geometry;
        for (let objAttribute in attributes) {
            let geometryAttribute = attributes[objAttribute];
            if (geometry.getAttribute(geometryAttribute)) {
                let webglAttrib = geometry.getAttribute(geometryAttribute);
                if (webglAttrib) {
                    ret[objAttribute] = webglAttrib._array;
                }
            }
            else {
                ret[objAttribute] = [];
            }
        }
        return ret;
    }
    dispose() {
        super.dispose();
        this.#material?.removeUser(this);
        this.#geometry?.removeUser(this);
    }
    toString() {
        return 'Mesh ' + super.toString();
    }
    getBoundsModelSpace(min = create$4(), max = create$4()) {
        min[0] = Infinity;
        min[1] = Infinity;
        min[2] = Infinity;
        max[0] = -Infinity;
        max[1] = -Infinity;
        max[2] = -Infinity;
        let vertexPosition = this.geometry.getAttribute('aVertexPosition')._array;
        for (let i = 0, l = vertexPosition.length; i < l; i += 3) {
            tempVec3$w[0] = vertexPosition[i + 0];
            tempVec3$w[1] = vertexPosition[i + 1];
            tempVec3$w[2] = vertexPosition[i + 2];
            min$3(min, min, tempVec3$w);
            max$3(max, max, tempVec3$w);
        }
        //console.error(min, max);
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        boundingBox.setPoints(this.geometry.getAttribute('aVertexPosition')._array);
        return boundingBox;
    }
    propagate() {
        super.propagate();
        this.#desaturate(this.getAttribute('desaturate'));
    }
    #desaturate(attributeValue) {
        if (attributeValue) {
            this.setDefine('DESATURATE');
        }
        else {
            this.removeDefine('DESATURATE');
        }
    }
    buildContextMenu() {
        let contextMenu = super.buildContextMenu();
        Object.assign(contextMenu.material.submenu, {
            Mesh_1: null,
            set_material: {
                i18n: '#set_material', f: async (entity) => {
                    let materialName = await new Interaction().getString(0, 0, MaterialManager.getMaterialList());
                    if (materialName) {
                        await MaterialManager.getMaterial(materialName, (material) => { if (material) {
                            this.setMaterial(material);
                        } });
                    }
                }
            },
        });
        return contextMenu;
    }
    raycast(raycaster, intersections) {
        let geometry = this.geometry;
        let indices = geometry.getAttribute('index')._array;
        let vertices = geometry.getAttribute('aVertexPosition')._array;
        let textureCoords = geometry.getAttribute('aTextureCoord')._array;
        let normals = geometry.getAttribute('aVertexNormal')?._array;
        let worldMatrix = this.worldMatrix;
        ray$1.copyTransform(raycaster.ray, worldMatrix);
        if (normals) {
            for (let i = 0, l = indices.length; i < l; i += 3) {
                let i1 = 3 * indices[i];
                let i2 = 3 * indices[i + 1];
                let i3 = 3 * indices[i + 2];
                set$5(v1$2, vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                set$5(v2$1, vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                set$5(v3$1, vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                if (ray$1.intersectTriangle(v1$2, v2$1, v3$1, intersectionPoint$1)) {
                    set$5(n1$1, normals[i1], normals[i1 + 1], normals[i1 + 2]);
                    set$5(n2$1, normals[i2], normals[i2 + 1], normals[i2 + 2]);
                    set$5(n3$1, normals[i3], normals[i3 + 1], normals[i3 + 2]);
                    i1 = 2 * indices[i];
                    i2 = 2 * indices[i + 1];
                    i3 = 2 * indices[i + 2];
                    set$1(uv1$1, textureCoords[i1], textureCoords[i1 + 1]);
                    set$1(uv2$1, textureCoords[i2], textureCoords[i2 + 1]);
                    set$1(uv3$1, textureCoords[i3], textureCoords[i3 + 1]);
                    getUV(uv$1, intersectionPoint$1, v1$2, v2$1, v3$1, uv1$1, uv2$1, uv3$1);
                    getNormal(intersectionNormal$2, intersectionPoint$1, v1$2, v2$1, v3$1, n1$1, n2$1, n3$1);
                    let x = intersectionNormal$2[0];
                    let y = intersectionNormal$2[1];
                    let z = intersectionNormal$2[2];
                    //Tranform the normal with the world matrix
                    intersectionNormal$2[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                    intersectionNormal$2[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                    intersectionNormal$2[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                    transformMat4$2(intersectionPoint$1, intersectionPoint$1, worldMatrix);
                    intersections.push(ray$1.createIntersection(intersectionPoint$1, intersectionNormal$2, uv$1, this, 0));
                }
            }
        }
        else {
            normals = Float32Array.from([1, 0, 0]);
            for (let i = 0, l = indices.length; i < l; i += 3) {
                let i1 = 3 * indices[i];
                let i2 = 3 * indices[i + 1];
                let i3 = 3 * indices[i + 2];
                set$5(v1$2, vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                set$5(v2$1, vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                set$5(v3$1, vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                if (ray$1.intersectTriangle(v1$2, v2$1, v3$1, intersectionPoint$1)) {
                    set$5(n1$1, normals[0], normals[1], normals[2]);
                    set$5(n2$1, normals[0], normals[1], normals[2]);
                    set$5(n3$1, normals[0], normals[1], normals[2]);
                    i1 = 2 * indices[i];
                    i2 = 2 * indices[i + 1];
                    i3 = 2 * indices[i + 2];
                    set$1(uv1$1, textureCoords[i1], textureCoords[i1 + 1]);
                    set$1(uv2$1, textureCoords[i2], textureCoords[i2 + 1]);
                    set$1(uv3$1, textureCoords[i3], textureCoords[i3 + 1]);
                    getUV(uv$1, intersectionPoint$1, v1$2, v2$1, v3$1, uv1$1, uv2$1, uv3$1);
                    getNormal(intersectionNormal$2, intersectionPoint$1, v1$2, v2$1, v3$1, n1$1, n2$1, n3$1);
                    let x = intersectionNormal$2[0];
                    let y = intersectionNormal$2[1];
                    let z = intersectionNormal$2[2];
                    //Tranform the normal with the world matrix
                    intersectionNormal$2[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                    intersectionNormal$2[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                    intersectionNormal$2[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                    transformMat4$2(intersectionPoint$1, intersectionPoint$1, worldMatrix);
                    intersections.push(ray$1.createIntersection(intersectionPoint$1, intersectionNormal$2, uv$1, this, 0));
                }
            }
        }
    }
    static getEntityName() {
        return 'Static mesh';
    }
    is(s) {
        if (s == 'Mesh') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}

class Box extends Mesh {
    #widthSegments;
    #heightSegments;
    #depthSegments;
    #width;
    #height;
    #depth;
    constructor(params = {}) {
        super(new BoxBufferGeometry(), params.material ?? new MeshBasicMaterial());
        this.#width = params.width ?? 1;
        this.#height = params.height ?? this.#width;
        this.#depth = params.depth ?? this.#width;
        this.#widthSegments = params.widthSegments ?? 1;
        this.#heightSegments = params.heightSegments ?? 1;
        this.#depthSegments = params.depthSegments ?? 1;
        this.#updateGeometry();
        super.setParameters(params);
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#width, this.#height, this.#depth, this.#widthSegments, this.#heightSegments, this.#depthSegments);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Box_1: null,
            width: { i18n: '#width', f: () => { let width = prompt('Width', String(this.#width)); if (width) {
                    this.#width = Number(width);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { let height = prompt('Height', String(this.#height)); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
            depth: { i18n: '#depth', f: () => { let depth = prompt('Depth', String(this.#depth)); if (depth) {
                    this.#depth = Number(depth);
                    this.#updateGeometry();
                } } },
            cube: { i18n: '#cube', f: () => { let size = prompt('Cube size', '0'); if (size) {
                    size = Number(size);
                    this.#width = size;
                    this.#height = size;
                    this.#depth = size;
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        let json = super.toJSON();
        json.width = this.#width;
        json.height = this.#height;
        json.depth = this.#depth;
        json.widthSegments = this.#widthSegments;
        json.heightSegments = this.#heightSegments;
        json.depthSegments = this.#depthSegments;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Box({ width: json.width, height: json.height, depth: json.depth, material: material, widthSegments: json.widthSegments, heightSegments: json.heightSegments, depthSegments: json.depthSegments });
    }
    /*dispose() {
        super.dispose();
        this.geometry.dispose();
        this.material.dispose();
    }*/
    static getEntityName() {
        return 'Box';
    }
    setSize(width, height, depth) {
        this.#width = width;
        this.#height = height;
        this.#depth = depth;
        this.#updateGeometry();
    }
    setwidth(width) {
        this.#width = width;
        this.#updateGeometry();
    }
    setHeight(height) {
        this.#height = height;
        this.#updateGeometry();
    }
    setDepth(depth) {
        this.#depth = depth;
        this.#updateGeometry();
    }
}
registerEntity(Box);

const ShaderEventTarget = new EventTarget();

const Includes = {};

const includeSources = new Map();
const customIncludeSources = new Map();
function addIncludeSource(name, source = '') {
    includeSources.set(name, source);
    ShaderEventTarget.dispatchEvent(new CustomEvent('includeadded'));
}
function getIncludeSource(name) {
    if (!includeSources.has(name)) {
        addIncludeSource(name, Includes[name]);
        if (!customIncludeSources.has(name) && Includes[name] === undefined) {
            console.error('unknown include ' + name);
        }
    }
    return customIncludeSources.get(name) ?? includeSources.get(name);
}
function setCustomIncludeSource(name, source) {
    if (source == '') {
        customIncludeSources.delete(name);
    }
    else {
        customIncludeSources.set(name, source);
    }
}
function getIncludeList() {
    return includeSources.keys();
}

var ShaderType;
(function (ShaderType) {
    ShaderType[ShaderType["Vertex"] = 35633] = "Vertex";
    ShaderType[ShaderType["Fragment"] = 35632] = "Fragment";
})(ShaderType || (ShaderType = {}));
function getHeader(type) {
    switch (type) {
        case ShaderType.Vertex:
            return '#include header_vertex';
        case ShaderType.Fragment:
            return '#include header_fragment';
    }
}
const PRAGMA_REGEX = /#pragma (\w+)/;
class WebGLShaderSource {
    static isWebGL2;
    #includes = new Set();
    #type;
    #source = '';
    #extensions = '';
    #sizeOfSourceRow = [];
    #sourceRowToInclude = new Map();
    #compileSource = '';
    #isErroneous = false;
    #error = '';
    #lineDelta = 0;
    constructor(type, source) {
        this.#type = type;
        this.setSource(source);
    }
    setSource(source) {
        this.#source = source;
        this.#extensions = '';
        this.#sizeOfSourceRow = [];
        this.#sourceRowToInclude.clear();
        this.#includes.clear();
        let allIncludes = new Set();
        let sourceLineArray = source.split('\n');
        sourceLineArray.unshift(getHeader(this.#type) ?? '');
        let compileRow = 1;
        //TODOv3: use regexp to do a better job
        let outArray = [];
        for (let i = 0; i < sourceLineArray.length; ++i) {
            let line = sourceLineArray[i];
            let actualSize = 1;
            if (line.startsWith('#extension')) {
                this.#extensions += line + '\n';
                sourceLineArray.splice(i, 1);
                actualSize = 0;
            }
            else if (line.trim().startsWith('#include')) {
                //this.extensions += line + '\n';
                let includeName = line.replace('#include', '').trim();
                let include = this.getInclude(includeName, compileRow, new Set(), allIncludes);
                if (include) {
                    this.#sourceRowToInclude.set(compileRow, [includeName, include.length]);
                    outArray.push(...include);
                    compileRow += include.length;
                    actualSize = include.length;
                }
                else {
                    if (include === undefined) {
                        console.error(`Include not found : ${line}`);
                    }
                }
            }
            else {
                outArray.push(line);
                ++compileRow;
            }
            this.#sizeOfSourceRow[i] = actualSize;
        }
        this.#compileSource = outArray.join('\n');
        this.#isErroneous = false;
        this.#error = '';
        this.#lineDelta = 0;
        return this;
    }
    isErroneous() {
        return this.#isErroneous;
    }
    getSource() {
        return this.#source;
    }
    getInclude(includeName, compileRow = 0, recursion = new Set(), allIncludes = new Set()) {
        this.#includes.add(includeName);
        if (recursion.has(includeName)) {
            console.error('Include recursion in ' + includeName);
            return undefined;
        }
        recursion.add(includeName);
        let include = getIncludeSource(includeName);
        if (include == undefined) {
            return undefined;
        }
        let includeLineArray = include.trim().split('\n');
        includeLineArray.unshift(''); //Add an empty line to insure nested include won't occupy the same line #
        let outArray = [];
        for (let i = 0, l = includeLineArray.length; i < l; ++i) {
            let line = includeLineArray[i];
            if (line.trim().startsWith('#include')) {
                let includeName = line.replace('#include', '').trim();
                let include = this.getInclude(includeName, compileRow + i, recursion, allIncludes);
                if (include) {
                    this.#sourceRowToInclude.set(compileRow, [includeName, include.length]);
                    outArray.push(...include);
                    compileRow += include.length;
                }
                continue;
            }
            if (line.trim().startsWith('#pragma')) {
                let result = PRAGMA_REGEX.exec(line);
                if (result && result[1] == 'once') {
                    if (allIncludes.has(includeName)) {
                        return null;
                    }
                    continue;
                }
            }
            outArray.push(line);
            ++compileRow;
        }
        allIncludes.add(includeName);
        return outArray;
    }
    getCompileSource(includeCode = '') {
        function getDefineValue(defineName, includeCode = '') {
            let sourceLineArray = includeCode.split('\n');
            const definePattern = /\s*#define\s+(\S+)\s+(\S+)/;
            for (let i = 0, l = sourceLineArray.length; i < l; ++i) {
                let line = sourceLineArray[i];
                let regexResult = definePattern.exec(line);
                if (regexResult && defineName) {
                    if (regexResult[1] == defineName) {
                        return regexResult[2];
                    }
                }
            }
            return defineName;
        }
        function unrollLoops(source, includeCode = '') {
            let nextUnroll = Infinity;
            let unrollSubstring;
            const forPattern = /for\s*\(\s*int\s+(\S+)\s*=\s*(\S+)\s*;\s*(\S+)\s*<\s*(\S+)\s*;\s*(\S+)\s*\+\+\s*\)\s*{/g;
            while ((nextUnroll = source.lastIndexOf('#pragma unroll', nextUnroll - 1)) != -1) {
                forPattern.lastIndex = 0;
                unrollSubstring = source.substring(nextUnroll);
                let regexResult = forPattern.exec(unrollSubstring);
                if (regexResult && regexResult.length == 6) {
                    let loopVariable = regexResult[1];
                    if ((loopVariable == regexResult[3]) && (loopVariable == regexResult[5])) { //Check the variable name is the same everywhere
                        let startIndex = forPattern.lastIndex;
                        let curlyCount = 1; //we already ate one
                        const startLoopName = regexResult[2];
                        const endLoopName = regexResult[4];
                        let loopSnippet = '';
                        curlyLoop: while (startIndex != -1) {
                            let car = unrollSubstring.charAt(startIndex++);
                            switch (car) {
                                case '/':
                                    car = unrollSubstring.charAt(startIndex++);
                                    switch (car) {
                                        case '*':
                                            startIndex = unrollSubstring.indexOf('*/', startIndex);
                                            if (startIndex != -1) {
                                                startIndex += 2;
                                            }
                                            break;
                                        case '/':
                                            startIndex = unrollSubstring.indexOf('\n', startIndex);
                                            break;
                                    }
                                    break;
                                case '{':
                                    ++curlyCount;
                                    break;
                                case '}':
                                    --curlyCount;
                                    if (curlyCount == 0) {
                                        loopSnippet = source.substring(nextUnroll + forPattern.lastIndex, nextUnroll + startIndex - 1);
                                        break curlyLoop;
                                    }
                                    break;
                            }
                        }
                        if (loopSnippet) {
                            const loopVariableRegexp = new RegExp('\\[\\s*' + loopVariable + '\\s*\\]', 'g');
                            const loopVariableRegexp2 = new RegExp('\\{\\s*' + loopVariable + '\\s*\\}', 'g');
                            const startLoopIndex = Number.parseInt(getDefineValue(startLoopName, includeCode));
                            const endLoopIndex = Number.parseInt(getDefineValue(endLoopName, includeCode));
                            let unrolled = '';
                            for (let i = startLoopIndex; i < endLoopIndex; i++) {
                                unrolled += loopSnippet.replace(loopVariableRegexp, `[${i}]`).replace(loopVariableRegexp2, `${i}`);
                            }
                            source = source.substring(0, nextUnroll - 1) + unrolled + source.substring(nextUnroll + startIndex);
                        }
                    }
                }
            }
            return source;
        }
        return (WebGLShaderSource.isWebGL2 ? '#version 300 es\n' : '\n') + this.#extensions + includeCode + unrollLoops(this.#compileSource, includeCode);
    }
    getCompileSourceLineNumber(includeCode) {
        let source = this.getCompileSource(includeCode);
        let sourceLineArray = source.split('\n');
        for (let i = sourceLineArray.length - 1; i >= 0; i--) {
            sourceLineArray[i] = (i + 1).toString().padStart(4) + ' ' + sourceLineArray[i];
        }
        return sourceLineArray.join('\n');
    }
    setCompileError(error, includeCode = '') {
        let lineDelta = ((includeCode).match(/\n/g) || []).length;
        lineDelta += 1; //#version line
        this.#isErroneous = true;
        this.#error = error;
        this.#lineDelta = lineDelta;
    }
    getCompileError(convertRows = true) {
        const errorArray = [];
        const splitRegex = /(ERROR|WARNING) *: *(\d*):(\d*): */;
        function consumeLine(arr) {
            let line;
            while ((line = arr.shift()) !== undefined) {
                if (line === '') {
                    continue;
                }
                return line;
            }
            return null;
        }
        const arr = this.#error.replace('\n', '').split(splitRegex);
        while (arr.length) {
            let errorType = consumeLine(arr);
            let errorCol = consumeLine(arr);
            let errorRow = Number(consumeLine(arr));
            let errorText = consumeLine(arr);
            if (errorType && errorCol && errorRow && errorText) {
                let row = Math.max(errorRow - this.#lineDelta, 0);
                if (convertRows) {
                    row = this.compileRowToSourceRow(row);
                }
                row = Math.max(row, 0);
                errorArray.push({ type: errorType.toLowerCase(), column: errorCol, row: row, text: errorText });
            }
        }
        return errorArray;
    }
    getIncludeAnnotations() {
        const annotations = [];
        let sourceLineArray = this.#source.split('\n');
        sourceLineArray.unshift(getHeader(this.#type) ?? '');
        for (let i = sourceLineArray.length - 1; i >= 0; i--) {
            let line = sourceLineArray[i];
            if (line.trim().startsWith('#include')) {
                let include = this.getInclude(line.replace('#include', '').trim());
                if (include) {
                    include.shift(); //Remove the first empty line
                    annotations.push({ type: 'info', column: 0, row: Math.max(i - 1, 0), text: include.join('\n') });
                }
            }
        }
        return annotations;
    }
    compileRowToSourceRow(row) {
        let totalSoFar = 0;
        for (let i = 0; i < this.#sizeOfSourceRow.length; i++) {
            totalSoFar += this.#sizeOfSourceRow[i];
            if (totalSoFar >= row) {
                return i - 1;
            }
        }
        return 0;
    }
    isValid() {
        return (this.#source != '') && !this.#isErroneous;
    }
    reset() {
        this.#isErroneous = false;
        this.setSource(this.#source);
    }
    containsInclude(includeName) {
        return this.#includes.has(includeName);
    }
    getType() {
        return this.#type;
    }
    getSourceRowToInclude() {
        return new Map(this.#sourceRowToInclude);
    }
}

const Shaders = {};

class ShaderManager {
    static #displayCompileError = false;
    static #shaderList = new Map();
    static #customShaderList = new Map();
    static addSource(type, name, source) {
        this.#shaderList.set(name, new WebGLShaderSource(type, source));
        ShaderEventTarget.dispatchEvent(new CustomEvent('shaderadded'));
    }
    static getShaderSource(type, name, invalidCustomShaders = false) {
        if (this.#shaderList.get(name) === undefined) {
            let source = Shaders[name];
            if (source) {
                this.addSource(type, name, source);
            }
            else {
                console.error('Shader not found : ', name);
            }
        }
        const customSource = this.#customShaderList.get(name);
        const source = this.#shaderList.get(name);
        return customSource && (customSource.isValid() ?? invalidCustomShaders) ? customSource : source;
    }
    static setCustomSource(type, name, source) {
        if (source == '') {
            this.#customShaderList.delete(name);
        }
        else {
            const customSource = this.#customShaderList.get(name) ?? new WebGLShaderSource(type, '');
            customSource.setSource(source);
            this.#customShaderList.set(name, customSource);
        }
    }
    static getCustomSourceAnnotations(name) {
        const customSource = this.#customShaderList.get(name);
        if (customSource) {
            return customSource.getCompileError().concat(customSource.getIncludeAnnotations());
        }
        return null;
    }
    static getIncludeAnnotations(includeName) {
        let annotations;
        for (let [shaderName, shaderSource] of this.#shaderList) {
            annotations = this.#getIncludeAnnotations(includeName, shaderName, shaderSource);
            if (annotations.length) {
                return annotations;
            }
        }
        for (let [shaderName, shaderSource] of this.#customShaderList) {
            annotations = this.#getIncludeAnnotations(includeName, shaderName, shaderSource);
            if (annotations.length) {
                return annotations;
            }
        }
    }
    static #getIncludeAnnotations(includeName, shaderName, shaderSource) {
        let errorArray = [];
        if (shaderSource.isErroneous()) {
            if (shaderSource.containsInclude(includeName)) {
                let errors = shaderSource.getCompileError(false);
                for (let error of errors) {
                    const sourceRowToInclude = shaderSource.getSourceRowToInclude();
                    for (let [startLine, [includeName2, includeLength]] of sourceRowToInclude) {
                        //let [includeName2, includeLength] = shaderSource.sourceRowToInclude[startLine];
                        if (startLine <= error.row && (startLine + includeLength) > error.row && includeName == includeName2) {
                            errorArray.push({ type: error.type, column: error.column, row: error.row - startLine, text: error.text });
                        }
                    }
                }
            }
        }
        return errorArray;
    }
    static get shaderList() {
        return this.#shaderList.keys();
    }
    static resetShadersSource() {
        for (let source of this.#shaderList.values()) {
            source.reset();
        }
        for (let source of this.#customShaderList.values()) {
            source.reset();
        }
    }
    static set displayCompileError(displayCompileError) {
        this.#displayCompileError = displayCompileError;
    }
    static get displayCompileError() {
        return this.#displayCompileError;
    }
    static setCompileError(shaderName, shaderInfoLog) {
        return;
    }
}

let id$1 = 0;
class ShaderMaterial extends Material {
    #shaderSource;
    constructor(params = {}) {
        super(params);
        this.shaderSource = params.shaderSource;
        const name = `shadermaterial_${++id$1}`;
        if (params.vertex) {
            ShaderManager.addSource(GL_VERTEX_SHADER, name + '.vs', params.vertex);
            this.shaderSource = name;
        }
        if (params.fragment) {
            ShaderManager.addSource(GL_FRAGMENT_SHADER, name + '.fs', params.fragment);
        }
        if (params.uniforms) {
            for (const name in params.uniforms) {
                this.uniforms[name] = params.uniforms[name];
            }
        }
        if (params.defines) {
            for (const name in params.defines) {
                this.setDefine(name, params.defines[name]);
            }
        }
    }
    getShaderSource() {
        return this.#shaderSource;
    }
    set shaderSource(shaderSource) {
        this.#shaderSource = shaderSource;
    }
}

var TextureTarget;
(function (TextureTarget) {
    TextureTarget[TextureTarget["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TextureTarget || (TextureTarget = {}));
var TextureFormat;
(function (TextureFormat) {
    TextureFormat[TextureFormat["Rgb"] = 6407] = "Rgb";
    TextureFormat[TextureFormat["Rgba"] = 6408] = "Rgba";
    TextureFormat[TextureFormat["Luminance"] = 6409] = "Luminance";
    TextureFormat[TextureFormat["LuminanceAlpha"] = 6410] = "LuminanceAlpha";
    TextureFormat[TextureFormat["Alpha"] = 6406] = "Alpha";
    TextureFormat[TextureFormat["R8"] = 33321] = "R8";
    TextureFormat[TextureFormat["R8SignedNormalized"] = 33321] = "R8SignedNormalized";
    TextureFormat[TextureFormat["Rgba_32F"] = 34836] = "Rgba_32F";
    TextureFormat[TextureFormat["Rgb_32F"] = 34837] = "Rgb_32F";
    TextureFormat[TextureFormat["Rgba_16F"] = 34842] = "Rgba_16F";
    TextureFormat[TextureFormat["Rgba_32UI"] = 36208] = "Rgba_32UI";
})(TextureFormat || (TextureFormat = {}));
var TextureType;
(function (TextureType) {
    TextureType[TextureType["UnsignedByte"] = 5121] = "UnsignedByte";
    TextureType[TextureType["UnsignedShort_5_6_5"] = 33635] = "UnsignedShort_5_6_5";
    TextureType[TextureType["UnsignedShort_4_4_4_4"] = 32819] = "UnsignedShort_4_4_4_4";
    TextureType[TextureType["UnsignedShort_5_5_5_1"] = 32820] = "UnsignedShort_5_5_5_1";
    TextureType[TextureType["UnsignedShort"] = 5123] = "UnsignedShort";
    TextureType[TextureType["UnsignedInt"] = 5125] = "UnsignedInt";
    TextureType[TextureType["UnsignedInt_24_8"] = 34042] = "UnsignedInt_24_8";
    TextureType[TextureType["Float"] = 5126] = "Float";
    TextureType[TextureType["HalfFloatOes"] = 36193] = "HalfFloatOes";
    TextureType[TextureType["HalfFloat"] = 5131] = "HalfFloat";
    TextureType[TextureType["Byte"] = 5120] = "Byte";
    TextureType[TextureType["Short"] = 5122] = "Short";
    TextureType[TextureType["Int"] = 5124] = "Int";
    TextureType[TextureType["UnsignedInt_2_10_10_10"] = 33640] = "UnsignedInt_2_10_10_10";
    TextureType[TextureType["UnsignedInt_10F_11F_11F"] = 35899] = "UnsignedInt_10F_11F_11F";
    TextureType[TextureType["UnsignedInt_5_9_9_9"] = 35902] = "UnsignedInt_5_9_9_9";
    TextureType[TextureType["UnsignedFloat_32_UnsignedInt_24_8"] = 36269] = "UnsignedFloat_32_UnsignedInt_24_8";
})(TextureType || (TextureType = {}));
var FrameBufferTarget;
(function (FrameBufferTarget) {
    FrameBufferTarget[FrameBufferTarget["FrameBuffer"] = 36160] = "FrameBuffer";
    FrameBufferTarget[FrameBufferTarget["DrawFrameBuffer"] = 36009] = "DrawFrameBuffer";
    FrameBufferTarget[FrameBufferTarget["ReadFrameBuffer"] = 36008] = "ReadFrameBuffer";
})(FrameBufferTarget || (FrameBufferTarget = {}));
var ColorSpace;
(function (ColorSpace) {
    ColorSpace[ColorSpace["None"] = 0] = "None";
    ColorSpace[ColorSpace["Linear"] = 1] = "Linear";
    ColorSpace[ColorSpace["Srgb"] = 2] = "Srgb";
    ColorSpace[ColorSpace["SrgbLinear"] = 3] = "SrgbLinear";
})(ColorSpace || (ColorSpace = {}));
var ToneMapping;
(function (ToneMapping) {
    ToneMapping[ToneMapping["None"] = 0] = "None";
    ToneMapping[ToneMapping["Linear"] = 1] = "Linear";
    ToneMapping[ToneMapping["Reinhard"] = 2] = "Reinhard";
    ToneMapping[ToneMapping["ReinhardExtended"] = 3] = "ReinhardExtended";
})(ToneMapping || (ToneMapping = {}));
var TextureMapping;
(function (TextureMapping) {
    TextureMapping[TextureMapping["UvMapping"] = 0] = "UvMapping";
    TextureMapping[TextureMapping["CubeMapping"] = 1] = "CubeMapping";
    TextureMapping[TextureMapping["CubeUvMapping"] = 2] = "CubeUvMapping";
})(TextureMapping || (TextureMapping = {}));
var RenderBufferInternalFormat;
(function (RenderBufferInternalFormat) {
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgba4"] = 32854] = "Rgba4";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgb565"] = 36194] = "Rgb565";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgb5_A1"] = 32855] = "Rgb5_A1";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Depth_Component16"] = 33189] = "Depth_Component16";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Stencil_Index_8"] = 36168] = "Stencil_Index_8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Depth_Stencil"] = 34041] = "Depth_Stencil";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8"] = 33321] = "R8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8I"] = 33329] = "R8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8UI"] = 33330] = "R8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R16I"] = 33331] = "R16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R16UI"] = 33332] = "R16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R32I"] = 33333] = "R32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R32UI"] = 33334] = "R32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8"] = 33323] = "RG8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8I"] = 33335] = "RG8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8UI"] = 33336] = "RG8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG16I"] = 33337] = "RG16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG16UI"] = 33338] = "RG16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG32I"] = 33339] = "RG32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG32UI"] = 33340] = "RG32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB8"] = 32849] = "RGB8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8"] = 32856] = "RGBA8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB10_A2"] = 32857] = "RGB10_A2";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8UI"] = 36220] = "RGBA8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8I"] = 36238] = "RGBA8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA16UI"] = 36214] = "RGBA16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA16I"] = 36232] = "RGBA16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA32I"] = 36226] = "RGBA32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA32UI"] = 36208] = "RGBA32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
})(RenderBufferInternalFormat || (RenderBufferInternalFormat = {}));

class Scene extends Entity {
    #layers = new Map();
    #world;
    background;
    layers = new Set();
    environment;
    activeCamera;
    constructor(parameters) {
        super(parameters);
        this.#layers[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => {
                return a[1] < b[1] ? -1 : 1;
            });
        };
    }
    addLayer(layer, index) {
        this.#layers.set(layer, index);
        this.#updateLayers();
        return layer;
    }
    removeLayer(layer) {
        this.#layers.delete(layer);
        this.#updateLayers();
    }
    #updateLayers() {
        this.layers.clear();
        for (const [layer, index] of this.#layers) {
            this.layers.add(layer);
        }
    }
    setWorld(world) {
        this.#world = world;
    }
    getWorld() {
        return this.#world;
    }
    toString() {
        return 'Scene ' + super.toString();
    }
    static async constructFromJSON(json) {
        return new Scene({ name: json.name });
    }
    static getEntityName() {
        return 'Scene';
    }
    is(s) {
        if (s == 'Scene') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(Scene);

const tempVec3$v = create$4();
class CubeBackground extends BackGround {
    #box = new Box();
    #scene = new Scene();
    #material = new ShaderMaterial({ shaderSource: 'skybox' });
    constructor(params = {}) {
        super();
        this.#material.depthTest = false;
        this.#material.depthMask = false;
        this.#material.renderFace(RenderFace.Back);
        this.#material.renderLights = false;
        this.#box.material = this.#material;
        this.#scene.addChild(this.#box);
        if (params.texture) {
            this.setTexture(params.texture);
        }
    }
    render(renderer, camera) {
        this.#box.setPosition(camera.getPosition(tempVec3$v));
        renderer.render(this.#scene, camera, 0, { DisableToolRendering: true });
    }
    setTexture(texture) {
        this.#material.setTexture('uCubeTexture', texture);
        if (texture.mapping == TextureMapping.CubeUvMapping) {
            this.#material.setDefine('TEXTURE_MAPPING_CUBE_UV');
            const envMapCubeUVSize = generateCubeUVSize(texture.height);
            this.#material.setDefine('CUBEUV_TEXEL_WIDTH', envMapCubeUVSize.texelWidth.toFixed(8));
            this.#material.setDefine('CUBEUV_TEXEL_HEIGHT', envMapCubeUVSize.texelHeight.toFixed(8));
            this.#material.setDefine('CUBEUV_MAX_MIP', envMapCubeUVSize.maxMip.toFixed(2));
        }
        else {
            this.#material.removeDefine('TEXTURE_MAPPING_CUBE_UV');
        }
    }
    dispose() {
        this.#box.dispose();
    }
    is(s) {
        if (s == 'CubeBackground') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
function generateCubeUVSize(height) {
    const maxMip = Math.log2(height) - 2;
    const texelHeight = 1.0 / height;
    const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
}

var CameraProjection;
(function (CameraProjection) {
    CameraProjection[CameraProjection["Perspective"] = 0] = "Perspective";
    CameraProjection[CameraProjection["Orthographic"] = 1] = "Orthographic";
    CameraProjection[CameraProjection["Mixed"] = 2] = "Mixed";
})(CameraProjection || (CameraProjection = {}));
const tempQuat$c = create$2();
const tempVec3$u = create$4();
const proj1 = create$5();
const proj2 = create$5();
const DEFAULT_NEAR_PLANE = 1;
const DEFAULT_FAR_PLANE = 1000;
const DEFAULT_ORTHO_ZOOM = 1;
const DEFAULT_PROJECTION = CameraProjection.Perspective;
const DEFAULT_PROJECTION_MIX = 0;
const DEFAULT_VERTICAL_FOV = 60;
const DEFAULT_ASPECT_RATIO = 1;
const DEFAULT_UP_VECTOR = fromValues$4(0, 0, 1);
const DEFAULT_LEFT = -1;
const DEFAULT_RIGHT = 1;
const DEFAULT_TOP = 1;
const DEFAULT_BOTTOM = -1;
const FrontVector = fromValues$4(0, 0, -1);
const LAMBDA = 10;
const LAMBDA_DIVIDOR = 1 - Math.exp(-LAMBDA);
class Camera extends Entity {
    #nearPlane;
    #farPlane;
    #orthoZoom;
    #projection;
    #projectionMix; // 0: full perspective 1: full ortho
    #left;
    #right;
    #top;
    #bottom;
    #cameraMatrix = create$5();
    #projectionMatrix = create$5();
    #verticalFov;
    #aspectRatio;
    #dirtyCameraMatrix = true;
    #dirtyProjectionMatrix = true;
    #projectionMatrixInverse = create$5();
    #worldMatrixInverse = create$5();
    #upVector = create$4();
    isPerspective;
    isOrthographic;
    #tanHalfVerticalFov;
    constructor(params = {} /*TODO: create type*/) {
        super();
        super.setParameters(params);
        this.nearPlane = params.nearPlane ?? params.near ?? DEFAULT_NEAR_PLANE;
        this.farPlane = params.farPlane ?? params.far ?? DEFAULT_FAR_PLANE;
        this.orthoZoom = params.orthoZoom ?? DEFAULT_ORTHO_ZOOM;
        this.projectionMix = params.projectionMix ?? DEFAULT_PROJECTION_MIX;
        this.setProjection(params.projection ?? DEFAULT_PROJECTION);
        this.verticalFov = params.verticalFov ?? params.fov ?? DEFAULT_VERTICAL_FOV;
        this.aspectRatio = params.aspectRatio ?? params.aspect ?? DEFAULT_ASPECT_RATIO;
        this.upVector = params.upVector ?? DEFAULT_UP_VECTOR;
        this.left = params.left ?? DEFAULT_LEFT;
        this.right = params.right ?? DEFAULT_RIGHT;
        this.top = params.top ?? DEFAULT_TOP;
        this.bottom = params.bottom ?? DEFAULT_BOTTOM;
        this.dirty();
        //this._renderMode = 2;
    }
    computeCameraMatrix() {
        fromRotationTranslation$1(this.#cameraMatrix, this.getWorldQuaternion(tempQuat$c), this.getWorldPosition(tempVec3$u));
        invert$3(this.#cameraMatrix, this.#cameraMatrix);
    }
    #computeProjectionMatrix() {
        if (this.#projection == CameraProjection.Perspective) {
            perspective(this.#projectionMatrix, this.#verticalFov, this.#aspectRatio, this.#nearPlane, this.#farPlane);
        }
        else if (this.#projection == CameraProjection.Orthographic) {
            let ortho$1 = this.#orthoZoom;
            ortho(this.#projectionMatrix, this.#left / ortho$1, this.#right / ortho$1, this.#bottom / ortho$1, this.#top / ortho$1, this.#nearPlane, this.#farPlane);
        }
        else {
            // Mixed perspective / ortho
            let invOrtho = 1 / this.#orthoZoom;
            perspective(proj1, this.#verticalFov, this.#aspectRatio, this.#nearPlane, this.#farPlane);
            ortho(proj2, this.#left * invOrtho, this.#right * invOrtho, this.#bottom * invOrtho, this.#top * invOrtho, this.#nearPlane, this.#farPlane);
            multiplyScalar(this.#projectionMatrix, proj1, 1 - this.#projectionMix);
            multiplyScalarAndAdd(this.#projectionMatrix, this.#projectionMatrix, proj2, this.#projectionMix);
        }
    }
    reset() {
    }
    setProjection(projection) {
        const oldValue = this.#projection;
        this.#projection = projection;
        this.#dirtyProjectionMatrix = true;
        this.isPerspective = projection == CameraProjection.Perspective;
        this.isOrthographic = projection == CameraProjection.Orthographic;
        if (oldValue != projection) {
            EntityObserver.propertyChanged(this, 'projection', oldValue, this.#projection);
        }
    }
    get projection() {
        return this.#projection;
    }
    setProjectionMix(projectionMix) {
        this.projectionMix = (1 - Math.exp(-LAMBDA * projectionMix)) / LAMBDA_DIVIDOR;
    }
    set projectionMix(projectionMix) {
        const oldValue = this.#projectionMix;
        this.#projectionMix = projectionMix;
        if (projectionMix == 0) {
            this.setProjection(CameraProjection.Perspective);
        }
        else if (projectionMix == 1) {
            this.setProjection(CameraProjection.Orthographic);
        }
        else {
            this.setProjection(CameraProjection.Mixed);
        }
        if (oldValue != projectionMix) {
            EntityObserver.propertyChanged(this, 'projectionmix', oldValue, this.#projectionMix);
        }
    }
    get projectionMix() {
        return this.#projectionMix;
    }
    set nearPlane(nearPlane) {
        const oldValue = this.#nearPlane;
        this.#nearPlane = Number(nearPlane);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != nearPlane) {
            EntityObserver.propertyChanged(this, 'nearplane', oldValue, this.#nearPlane);
        }
    }
    get nearPlane() {
        return this.#nearPlane;
    }
    set farPlane(farPlane) {
        const oldValue = this.#farPlane;
        this.#farPlane = Number(farPlane);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != farPlane) {
            EntityObserver.propertyChanged(this, 'farplane', oldValue, this.#farPlane);
        }
    }
    get farPlane() {
        return this.#farPlane;
    }
    set orthoZoom(orthoZoom) {
        const oldValue = this.#orthoZoom;
        this.#orthoZoom = Number(orthoZoom);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != orthoZoom) {
            EntityObserver.propertyChanged(this, 'orthozoom', oldValue, this.#orthoZoom);
        }
    }
    get orthoZoom() {
        return this.#orthoZoom;
    }
    set verticalFov(verticalFov) {
        const oldValue = this.#verticalFov;
        this.#verticalFov = verticalFov * DEG_TO_RAD;
        this.#tanHalfVerticalFov = Math.tan(this.#verticalFov * 0.5);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#verticalFov) {
            EntityObserver.propertyChanged(this, 'verticalfov', oldValue, this.#verticalFov);
        }
    }
    get verticalFov() {
        return this.#verticalFov * RAD_TO_DEG;
    }
    getTanHalfVerticalFov() {
        return this.#tanHalfVerticalFov;
    }
    set aspectRatio(aspectRatio) {
        const oldValue = this.#aspectRatio;
        this.#aspectRatio = Number(aspectRatio);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#aspectRatio) {
            EntityObserver.propertyChanged(this, 'aspectratio', oldValue, this.#aspectRatio);
        }
    }
    get aspectRatio() {
        return this.#aspectRatio;
    }
    set upVector(upVector) {
        copy$4(this.#upVector, upVector);
    }
    get upVector() {
        return this.#upVector;
    }
    set left(left) {
        const oldValue = this.#left;
        this.#left = Number(left);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#left) {
            EntityObserver.propertyChanged(this, 'left', oldValue, this.#left);
        }
    }
    get left() {
        return this.#left;
    }
    set right(right) {
        const oldValue = this.#right;
        this.#right = Number(right);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#right) {
            EntityObserver.propertyChanged(this, 'right', oldValue, this.#right);
        }
    }
    get right() {
        return this.#right;
    }
    set top(top) {
        const oldValue = this.#top;
        this.#top = Number(top);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#top) {
            EntityObserver.propertyChanged(this, 'top', oldValue, this.#top);
        }
    }
    get top() {
        return this.#top;
    }
    set bottom(bottom) {
        const oldValue = this.#bottom;
        this.#bottom = Number(bottom);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#bottom) {
            EntityObserver.propertyChanged(this, 'bottom', oldValue, this.#bottom);
        }
    }
    get bottom() {
        return this.#bottom;
    }
    dirty() {
        this.#dirtyCameraMatrix = true;
        this.#dirtyProjectionMatrix = true;
    }
    get cameraMatrix() {
        if (this.#dirtyCameraMatrix) {
            this.computeCameraMatrix();
            this.#dirtyCameraMatrix = false;
        }
        return this.#cameraMatrix;
    }
    get projectionMatrix() {
        if (this.#dirtyProjectionMatrix) {
            this.#computeProjectionMatrix();
            invert$3(this.#projectionMatrixInverse, this.#projectionMatrix);
            this.#dirtyProjectionMatrix = false;
        }
        return this.#projectionMatrix;
    }
    get projectionMatrixInverse() {
        if (this.#dirtyProjectionMatrix) {
            this.#computeProjectionMatrix();
            invert$3(this.#projectionMatrixInverse, this.#projectionMatrix);
            this.#dirtyProjectionMatrix = false;
        }
        return this.#projectionMatrixInverse;
    }
    get worldMatrixInverse() {
        //TODO: optimize
        invert$3(this.#worldMatrixInverse, this.worldMatrix);
        return this.#worldMatrixInverse;
    }
    distanceFrom(point) {
        return distance$3(this._position, point);
    }
    set position(position) {
        super.position = position;
        this.#dirtyCameraMatrix = true;
    }
    get position() {
        return super.position;
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        this.#dirtyCameraMatrix = true;
    }
    get quaternion() {
        return super.quaternion;
    }
    /*set renderMode(mode) {
        throw 'set renderMode(mode) {';
        if ((mode === 0) || (mode === 1) || (mode === 2) || (mode === 3)) {
            this._renderMode = mode;
        }
    }
    get renderMode() {
        throw 'get renderMode(mode) {';
        return this._renderMode;
    }*/
    toString() {
        return 'Camera ' + super.toString();
    }
    setActiveCamera() {
        let scene = this.root;
        if (scene.is('Scene')) {
            scene.activeCamera = this;
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            camera1: null,
            cameraPerspective: { i18n: '#perspective_camera', selected: this.isPerspective, f: () => this.setProjection(CameraProjection.Perspective) },
            cameraOrthographic: { i18n: '#orthographic_camera', selected: this.isOrthographic, f: () => this.setProjection(CameraProjection.Orthographic) },
            cameraNearPlane: { i18n: '#near_plane', f: () => { let nearPlane = prompt('Near plane', String(this.nearPlane)); if (nearPlane !== null) {
                    this.nearPlane = Number(nearPlane);
                } } },
            cameraFarPlane: { i18n: '#far_plane', f: () => { let farPlane = prompt('Far plane', String(this.farPlane)); if (farPlane !== null) {
                    this.farPlane = Number(farPlane);
                } } },
            cameraOrthoZoom: { i18n: '#zoom', f: () => { let zoom = prompt('Zoom', String(this.orthoZoom)); if (zoom !== null) {
                    this.orthoZoom = Number(zoom);
                } } },
            cameraFov: { i18n: '#fov', f: () => { let fov = prompt('FOV', String(this.verticalFov)); if (fov !== null) {
                    this.verticalFov = Number(fov);
                } } },
            cameraSetActiveCamera: { i18n: '#set_active_camera', f: () => this.setActiveCamera() },
        });
    }
    invertProjection(v3) {
        transformMat4$2(v3, v3, this.projectionMatrixInverse);
    }
    getViewDirection(v = create$4()) {
        return transformQuat$1(v, FrontVector, this.getWorldQuaternion(tempQuat$c));
    }
    copy(source) {
        super.copy(source);
        this.nearPlane = source.nearPlane;
        this.farPlane = source.farPlane;
        this.orthoZoom = source.orthoZoom;
        this.setProjection(source.projection);
        this.projectionMix = source.projectionMix;
        this.verticalFov = source.verticalFov;
        this.aspectRatio = source.aspectRatio;
        this.upVector = source.upVector;
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.dirty();
    }
    toJSON() {
        let json = super.toJSON();
        if (this.nearPlane != DEFAULT_NEAR_PLANE) {
            json.nearplane = this.#nearPlane;
        }
        if (this.#farPlane != DEFAULT_FAR_PLANE) {
            json.farplane = this.#farPlane;
        }
        if (this.orthoZoom != DEFAULT_ORTHO_ZOOM) {
            json.orthoZoom = this.orthoZoom;
        }
        if (this.projection != DEFAULT_PROJECTION) {
            json.projection = this.projection;
        }
        if (this.#projectionMix != DEFAULT_PROJECTION_MIX) {
            json.projectionMix = this.#projectionMix;
        }
        if (this.verticalFov != DEFAULT_VERTICAL_FOV) {
            json.verticalFov = this.verticalFov;
        }
        if (this.aspectRatio != DEFAULT_ASPECT_RATIO) {
            json.aspectRatio = this.aspectRatio;
        }
        if (!equals$5(this.#upVector, DEFAULT_UP_VECTOR)) {
            json.upVector = this.upVector;
        }
        if (this.left != DEFAULT_LEFT) {
            json.left = this.left;
        }
        if (this.right != DEFAULT_RIGHT) {
            json.right = this.right;
        }
        if (this.top != DEFAULT_TOP) {
            json.top = this.top;
        }
        if (this.bottom != DEFAULT_BOTTOM) {
            json.bottom = this.bottom;
        }
        return json;
    }
    static async constructFromJSON(json) {
        return new Camera(json);
    }
    static getEntityName() {
        return 'Camera';
    }
    is(s) {
        if (s == 'Camera') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(Camera);

class Pass {
    camera;
    quad;
    scene;
    enabled = true;
    swapBuffers = true;
    renderToScreen = false;
    setSize(width, height) {
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        throw 'Can\'t render default pass';
    }
}

class ClearPass extends Pass {
    swapBuffers = false;
    #clearColor = create$3();
    #clearDepth = 0;
    #clearStencil = 0;
    constructor(clearColor, clearDepth, clearStencil) {
        super();
        this.clearColor = clearColor;
        this.clearDepth = clearDepth;
        this.clearStencil = clearStencil;
    }
    set clearColor(clearColor) {
        copy$3(this.#clearColor, clearColor);
    }
    set clearDepth(clearDepth) {
        this.#clearDepth = clearDepth ?? null;
    }
    set clearStencil(clearStencil) {
        this.#clearStencil = clearStencil ?? null;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        let clearColor = this.#clearColor != null;
        let clearDepth = this.#clearDepth != null;
        let clearStencil = this.#clearStencil != null;
        if (clearColor) {
            renderer.clearColor(this.#clearColor);
        }
        if (clearDepth) {
            renderer.clearDepth(this.#clearDepth);
        }
        if (clearStencil) {
            renderer.clearStencil(this.#clearStencil);
        }
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.clear(clearColor, clearDepth, clearStencil);
        renderer.popRenderTarget();
    }
}

class FullScreenQuadGeometry extends BufferGeometry {
    constructor() {
        super();
        let indices = [0, 2, 1, 2, 3, 1];
        let vertices = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
        let uvs = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0];
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(vertices, 3)); //TODOv3: fix this
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}
class FullScreenQuad extends Mesh {
    //constructor({ material = new MeshBasicMaterial() } = {}) {
    constructor(params = {}) {
        super(new FullScreenQuadGeometry(), params.material ?? new MeshBasicMaterial());
        this.setDefine('SKIP_PROJECTION');
        super.setParameters(arguments[0]);
    }
}

class CopyPass extends Pass {
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'copy', depthTest: false });
        material.addUser(this);
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class CrosshatchPass extends Pass {
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'crosshatch' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class GrainPass extends Pass {
    #intensity;
    //#density;
    //#size;
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'grain' });
        material.addUser(this);
        material.uniforms['uGrainParams'] = create$3();
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
        this.intensity = 0.2;
        //this.density = 0.2;
        //this.size = 1.0;
    }
    set intensity(intensity) {
        this.#intensity = intensity;
        this.quad.material.uniforms['uGrainIntensity'] = this.#intensity;
    }
    /*set density(density) {
        this.#density = density;
        this.quad.material.uniforms['uGrainParams'][1] = this.#density;
    }

    set size(size) {
        this.#size = size;
        this.quad.material.uniforms['uGrainParams'][2] = this.#size;
    }*/
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class OldMoviePass extends Pass {
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'oldmovie' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

const textures = new Set();
let context;
const TextureFactoryEventTarget = new EventTarget();
function setTextureFactoryContext(c) {
    context = c;
}
function createTexture() {
    const texture = context.createTexture();
    textures.add(texture);
    TextureFactoryEventTarget.dispatchEvent(new CustomEvent('textureCreated', { detail: { texture: texture, count: textures.size } }));
    return texture;
}
function deleteTexture(texture) {
    if (texture) {
        context.deleteTexture(texture);
        textures.delete(texture);
        TextureFactoryEventTarget.dispatchEvent(new CustomEvent('textureDeleted', { detail: { texture: texture, count: textures.size } }));
    }
}
function fillFlatTexture(texture, color = [255, 255, 255], needCubeMap) {
    let width = 64;
    let height = 64;
    if (texture) {
        let byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                //if ((i + j) % 2 == 0) {
                byteArray[pixelIndex] = color[0];
                byteArray[pixelIndex + 1] = color[1];
                byteArray[pixelIndex + 2] = color[2];
                //}
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_2D);
            context.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillCheckerTexture(texture, color = [255, 0, 255], width = 64, height = 64, needCubeMap) {
    if (texture) {
        let byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                if ((i + j) % 2 == 0) {
                    byteArray[pixelIndex] = color[0];
                    byteArray[pixelIndex + 1] = color[1];
                    byteArray[pixelIndex + 2] = color[2];
                }
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_2D);
            context.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillNoiseTexture(texture, width = 64, height = 64, needCubeMap = false) {
    if (texture) {
        let byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        let randomVec3 = create$4();
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                random$5(randomVec3, 255.0);
                byteArray[pixelIndex] = randomVec3[0];
                byteArray[pixelIndex + 1] = randomVec3[1];
                byteArray[pixelIndex + 2] = randomVec3[2];
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context.generateMipmap(GL_TEXTURE_2D);
            context.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillTextureWithImage(texture, image) {
    context.bindTexture(GL_TEXTURE_2D, texture.texture);
    context.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    context.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, texture.flipY);
    context.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, image);
    context.generateMipmap(GL_TEXTURE_2D);
    context.bindTexture(GL_TEXTURE_2D, null);
    texture.width = image.width;
    texture.height = image.height;
    context.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
}

class Texture {
    mapping = TextureMapping.UvMapping;
    #users = new Set();
    #alphaBits = 0;
    image;
    internalFormat;
    format;
    type;
    magFilter;
    minFilter;
    wrapS;
    wrapT;
    anisotropy;
    generateMipmaps = true;
    flipY = false;
    premultiplyAlpha = false;
    dirty = true;
    texture = null;
    width = 0;
    height = 0;
    isTexture = true;
    name = '';
    #colorSpace;
    isRenderTargetTexture = false;
    properties = new Map();
    constructor(textureParams = {}) {
        //this.target = GL_TEXTURE_2D;//TODOv3 target bound to texture ?
        this.image = textureParams.image;
        this.internalFormat = textureParams.internalFormat || GL_RGBA;
        this.magFilter = textureParams.magFilter || GL_LINEAR;
        this.minFilter = textureParams.minFilter || GL_NEAREST_MIPMAP_LINEAR;
        this.wrapS = textureParams.wrapS || GL_REPEAT;
        this.wrapT = textureParams.wrapT || GL_REPEAT;
        //this.width = textureParams.width || 0;TODOv3
        //this.height = textureParams.height || 0;
        this.anisotropy = 0;
        this.flipY = textureParams.flipY ?? false;
        this.premultiplyAlpha = textureParams.premultiplyAlpha ?? false;
        this.#colorSpace = textureParams.colorSpace ?? ColorSpace.None;
        this.dirty = true; //removeme ?
        //this.texture = TextureManager.createTexture();
        //this.setParameters();
        /*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, byteArray);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);*/
        /*gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);*/
    }
    setParameters(glContext, target) {
        glContext.bindTexture(target, this.texture);
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, this.flipY);
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
        glContext.texParameteri(target, GL_TEXTURE_MAG_FILTER, this.magFilter);
        glContext.texParameteri(target, GL_TEXTURE_MIN_FILTER, this.minFilter);
        glContext.texParameteri(target, GL_TEXTURE_WRAP_S, this.wrapS);
        glContext.texParameteri(target, GL_TEXTURE_WRAP_T, this.wrapT);
        glContext.bindTexture(target, null);
    }
    texImage2D(glContext, target, width, height, format, type, pixels = null, level = 0) {
        glContext.bindTexture(target, this.texture);
        glContext.texImage2D(target, level, this.internalFormat, width, height, 0, format, type, pixels);
        glContext.bindTexture(target, null);
        this.width = width;
        this.height = height;
    }
    generateMipmap(glContext, target) {
        glContext.bindTexture(target, this.texture);
        glContext.generateMipmap(target);
        glContext.bindTexture(target, null);
    }
    clone() {
        return new Texture().copy(this);
    }
    copy(other) {
        this.image = other.image;
        this.#alphaBits = other.#alphaBits;
        this.internalFormat = other.internalFormat;
        this.magFilter = other.magFilter;
        this.minFilter = other.minFilter;
        this.wrapS = other.wrapS;
        this.wrapT = other.wrapT;
        this.anisotropy = other.anisotropy;
        this.generateMipmaps = other.generateMipmaps;
        this.flipY = other.flipY;
        this.premultiplyAlpha = other.premultiplyAlpha;
        this.dirty = true; //removeme ?
    }
    setAlphaBits(bits) {
        this.#alphaBits = bits;
    }
    getAlphaBits() {
        return this.#alphaBits;
    }
    hasAlphaChannel() {
        return this.#alphaBits > 0;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    is(type) {
        return type === 'Texture';
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    hasOnlyUser(user) {
        return (this.#users.size == 1) && (this.#users.has(user));
    }
    dispose() {
        if (this.hasNoUser()) {
            deleteTexture(this.texture);
        }
    }
}

class TextureManager {
    static #texturesList = new Map();
    static setTexture(path, texture) {
        this.#texturesList.set(path, texture);
    }
    static createTexture(textureParams) {
        let texture = new Texture(textureParams);
        texture.texture = createTexture();
        //TODOv3: init texture parameters
        //texture.setParameters(Graphics.glContext, target);
        return texture;
    }
    static deleteTexture(texture) {
        deleteTexture(texture.texture);
    }
    static createFlatTexture(color = [255, 0, 255], needCubeMap = false) {
        let texture = this.createTexture();
        fillFlatTexture(texture, color, needCubeMap);
        return texture;
    }
    static createCheckerTexture(color = [255, 0, 255], width = 64, height = 64, needCubeMap = false) {
        let texture = this.createTexture();
        fillCheckerTexture(texture, color, width, height, needCubeMap);
        return texture;
    }
    static createNoiseTexture(width, height, needCubeMap = false) {
        let texture = this.createTexture();
        fillNoiseTexture(texture, width, height, needCubeMap);
        return texture;
    }
    static createTextureFromImage(image, textureParams) {
        let texture = this.createTexture(textureParams);
        fillTextureWithImage(texture, image);
        return texture;
    }
    static fillTextureWithImage(texture, image) {
        return fillTextureWithImage(texture, image);
    }
}

var GraphicsEvent;
(function (GraphicsEvent) {
    GraphicsEvent["MouseMove"] = "mousemove";
    GraphicsEvent["MouseDown"] = "mousedown";
    GraphicsEvent["MouseUp"] = "mouseup";
    GraphicsEvent["Wheel"] = "wheel";
    GraphicsEvent["Resize"] = "resize";
    GraphicsEvent["Tick"] = "tick";
    GraphicsEvent["KeyDown"] = "keydown";
    GraphicsEvent["KeyUp"] = "keyup";
    GraphicsEvent["TouchStart"] = "touchstart";
    GraphicsEvent["TouchMove"] = "touchmove";
    GraphicsEvent["TouchCancel"] = "touchcancel";
})(GraphicsEvent || (GraphicsEvent = {}));
const GraphicsEvents = new (function () {
    class GraphicsEvents extends EventTarget {
        static #instance;
        constructor() {
            if (GraphicsEvents.#instance) {
                return GraphicsEvents.#instance;
            }
            super();
            GraphicsEvents.#instance = this;
        }
        tick(delta, time, speed) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.Tick, { detail: { delta: delta, time: time, speed: speed } }));
        }
        resize(width, height) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.Resize, { detail: { width: width, height: height } }));
        }
        mouseMove(x, y, pickedEntity, mouseEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseMove, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
        }
        mouseDown(x, y, pickedEntity, mouseEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseDown, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
        }
        mouseUp(x, y, pickedEntity, mouseEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseUp, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
        }
        wheel(x, y, pickedEntity, wheelEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.Wheel, { detail: { x: x, y: y, entity: pickedEntity, wheelEvent: wheelEvent } }));
        }
        keyDown(keyboardEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.KeyDown, { detail: { keyboardEvent: keyboardEvent } }));
        }
        keyUp(keyboardEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.KeyUp, { detail: { keyboardEvent: keyboardEvent } }));
        }
        touchStart(pickedEntity, touchEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchStart, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
        }
        touchMove(pickedEntity, touchEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchMove, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
        }
        touchCancel(pickedEntity, touchEvent) {
            this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchCancel, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
        }
    }
    return GraphicsEvents;
}());

const RECORDER_MIME_TYPE = 'video/webm';
const RECORDER_DEFAULT_FILENAME = 'Harmony3D recording.webm';
// Note : you can provide your own url when calling ShaderEditor.initEditor.
const ACE_EDITOR_URI = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js';
const MAX_HARDWARE_BONES = 256;
const TEXTURE_CLEANUP_DELAY = 100000;
const SMD_HEADER = '// Created by harmony-3d';

class WebGLRenderingState {
    static #viewport = create$3();
    static #scissor = create$3();
    static #enabledCapabilities = [];
    // clear values
    static #clearColor = create$3();
    static #clearDepth = 1.0;
    static #clearStencil = 0;
    // Masking
    static #colorMask = create$3();
    static #depthMask = true;
    static #stencilMask;
    // Depth
    static #depthFunc = GL_LESS;
    // Blend
    static #sourceFactor = GL_ONE;
    static #destinationFactor = GL_ZERO;
    static #srcRGB = GL_ONE;
    static #dstRGB = GL_ZERO;
    static #srcAlpha = GL_ONE;
    static #dstAlpha = GL_ZERO;
    static #modeRGB = GL_FUNC_ADD;
    static #modeAlpha = GL_FUNC_ADD;
    // Cull
    static #cullFace = GL_BACK;
    static #frontFace = GL_CCW;
    //polygonOffset
    static #polygonOffsetFactor = 0;
    static #polygonOffsetUnits = 0;
    static #lineWidth = 1;
    static #program;
    static #graphics;
    static #glContext;
    static #enabledVertexAttribArray;
    static #usedVertexAttribArray;
    static #vertexAttribDivisor;
    static setGraphics(graphics) {
        this.#graphics = graphics;
        this.#glContext = graphics.glContext;
        const maxVertexAttribs = this.#glContext.getParameter(GL_MAX_VERTEX_ATTRIBS);
        this.#enabledVertexAttribArray = new Uint8Array(maxVertexAttribs);
        this.#usedVertexAttribArray = new Uint8Array(maxVertexAttribs);
        this.#vertexAttribDivisor = new Uint8Array(maxVertexAttribs);
    }
    static clearColor(clearColor) {
        if (!exactEquals$3(clearColor, this.#clearColor)) {
            this.#glContext.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            copy$3(this.#clearColor, clearColor);
        }
    }
    static getClearColor(out = create$3()) {
        return copy$3(out, this.#clearColor);
    }
    static clearDepth(clearDepth) {
        if (clearDepth !== this.#clearDepth) {
            this.#glContext.clearDepth(clearDepth);
            this.#clearDepth = clearDepth;
        }
    }
    static clearStencil(clearStencil) {
        if (clearStencil !== this.#clearStencil) {
            this.#glContext.clearStencil(clearStencil);
            this.#clearStencil = clearStencil;
        }
    }
    static clear(color, depth, stencil) {
        let bits = 0;
        if (color)
            bits |= GL_COLOR_BUFFER_BIT;
        if (depth)
            bits |= GL_DEPTH_BUFFER_BIT;
        if (stencil)
            bits |= GL_STENCIL_BUFFER_BIT;
        this.#glContext.clear(bits);
    }
    static colorMask(colorMask) {
        if (!exactEquals$3(colorMask, this.#colorMask)) {
            this.#glContext.colorMask(Boolean(colorMask[0]), Boolean(colorMask[1]), Boolean(colorMask[2]), Boolean(colorMask[3]));
            copy$3(this.#colorMask, colorMask);
        }
    }
    static depthMask(flag) {
        if (flag !== this.#depthMask) {
            this.#glContext.depthMask(flag);
            this.#depthMask = flag;
        }
    }
    static stencilMask(stencilMask) {
        if (stencilMask !== this.#stencilMask) {
            this.#glContext.stencilMask(stencilMask);
            this.#stencilMask = stencilMask;
        }
    }
    static lineWidth(width) {
        if (width !== this.#lineWidth) {
            this.#glContext.lineWidth(width);
            this.#lineWidth = width;
        }
    }
    static viewport(viewport) {
        if (!exactEquals$3(viewport, this.#viewport)) {
            this.#glContext.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
            copy$3(this.#viewport, viewport);
        }
    }
    static scissor(scissor) {
        if (!exactEquals$3(scissor, this.#scissor)) {
            this.#glContext.scissor(scissor[0], scissor[1], scissor[2], scissor[3]);
            copy$3(this.#scissor, scissor);
        }
    }
    static enable(cap) {
        if (this.#enabledCapabilities[cap] !== true) {
            this.#glContext.enable(cap);
            this.#enabledCapabilities[cap] = true;
        }
    }
    static disable(cap) {
        if (this.#enabledCapabilities[cap] !== false) {
            this.#glContext.disable(cap);
            this.#enabledCapabilities[cap] = false;
        }
    }
    static isEnabled(cap) {
        return this.#enabledCapabilities[cap] ?? this.#glContext.isEnabled(cap);
    }
    static useProgram(program) {
        if (this.#program !== program) {
            this.#glContext.useProgram(program);
            this.#program = program;
        }
    }
    static enableVertexAttribArray(index, divisor = 0) {
        if (this.#enabledVertexAttribArray[index] === 0) {
            this.#glContext.enableVertexAttribArray(index);
            this.#enabledVertexAttribArray[index] = 1;
        }
        this.#usedVertexAttribArray[index] = 1;
        if (this.#vertexAttribDivisor[index] !== divisor) {
            this.#vertexAttribDivisor[index] = divisor;
            if (this.#graphics.isWebGL2) {
                this.#glContext.vertexAttribDivisor(index, divisor);
            }
            else {
                this.#graphics.ANGLE_instanced_arrays?.vertexAttribDivisorANGLE(index, divisor);
            }
        }
    }
    static initUsedAttributes() {
        let usedAttributes = this.#usedVertexAttribArray;
        for (let i = 0, l = usedAttributes.length; i < l; i++) {
            usedAttributes[i] = 0;
        }
    }
    static disableUnusedAttributes() {
        let usedAttributes = this.#usedVertexAttribArray;
        let enabledAttributes = this.#enabledVertexAttribArray;
        for (let i = 0, l = usedAttributes.length; i < l; i++) {
            if (usedAttributes[i] !== enabledAttributes[i]) {
                this.#glContext.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
    }
    static depthFunc(func) {
        if (this.#depthFunc !== func) {
            this.#glContext.depthFunc(func);
            this.#depthFunc = func;
        }
    }
    static blendFunc(sourceFactor, destinationFactor) {
        if ((this.#sourceFactor !== sourceFactor) || (this.#destinationFactor !== destinationFactor)) {
            this.#glContext.blendFunc(sourceFactor, destinationFactor);
            this.#sourceFactor = sourceFactor;
            this.#destinationFactor = destinationFactor;
        }
    }
    static blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        if ((this.#srcRGB !== srcRGB) || (this.#dstRGB !== dstRGB) || (this.#srcAlpha !== srcAlpha) || (this.#dstAlpha !== dstAlpha)) {
            this.#glContext.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
            this.#srcRGB = srcRGB;
            this.#dstRGB = dstRGB;
            this.#srcAlpha = srcAlpha;
            this.#dstAlpha = dstAlpha;
        }
    }
    static blendEquationSeparate(modeRGB, modeAlpha) {
        if ((this.#modeRGB !== modeRGB) || (this.#modeAlpha !== modeAlpha)) {
            this.#glContext.blendEquationSeparate(modeRGB, modeAlpha);
            this.#modeRGB = modeRGB;
            this.#modeAlpha = modeAlpha;
        }
    }
    static cullFace(mode) {
        if (this.#cullFace !== mode) {
            this.#glContext.cullFace(mode);
            this.#cullFace = mode;
        }
    }
    static frontFace(mode) {
        if (this.#frontFace !== mode) {
            this.#glContext.frontFace(mode);
            this.#frontFace = mode;
        }
    }
    static polygonOffset(enable, factor, units) {
        if (enable) {
            this.enable(GL_POLYGON_OFFSET_FILL);
            if (this.#polygonOffsetFactor !== factor && this.#polygonOffsetUnits !== units) {
                this.#glContext.polygonOffset(factor, units);
                this.#polygonOffsetFactor = factor;
                this.#polygonOffsetUnits = units;
            }
        }
        else {
            this.disable(GL_POLYGON_OFFSET_FILL);
        }
    }
}

class WebGLStats {
    static #frames = 0;
    static #totalFrames = 0;
    static #fps = 0;
    static #drawElements = 0;
    static #renderTime = 0;
    static #renderTimeMean = 0;
    static #textures = 0;
    static #startTime = 0;
    static #endTime = 0;
    static #startRender = 0;
    static #primitivePerMode = new Map();
    static #htmlElement;
    static {
        this.#initHtml();
        this.#reset();
    }
    static start() {
        this.#startTime = performance.now();
    }
    static beginRender() {
        this.#startRender = performance.now();
    }
    static endRender() {
        this.#renderTime += performance.now() - this.#startRender;
    }
    static #reset() {
        this.#drawElements = 0;
        this.#primitivePerMode.set(GL_POINTS, 0);
        this.#primitivePerMode.set(GL_LINE_STRIP, 0);
        this.#primitivePerMode.set(GL_LINE_LOOP, 0);
        this.#primitivePerMode.set(GL_LINES, 0);
        this.#primitivePerMode.set(GL_TRIANGLE_STRIP, 0);
        this.#primitivePerMode.set(GL_TRIANGLE_FAN, 0);
        this.#primitivePerMode.set(GL_TRIANGLES, 0);
    }
    static tick() {
        this.#endTime = performance.now();
        ++this.#frames;
        let timeSinceReset = this.#endTime - this.#startTime;
        this.#updateHtml();
        if (timeSinceReset > 1000) {
            this.#fps = Math.round(this.#frames / timeSinceReset * 1000);
            this.#renderTimeMean = this.#renderTime / this.#frames;
            this.#frames = 0;
            this.#startTime = this.#endTime;
            this.#renderTime = 0;
        }
        this.#reset();
    }
    static drawElements(mode, count) {
        this.#primitivePerMode.set(mode, count + (this.#primitivePerMode.get(mode) ?? 0));
        ++this.#drawElements;
    }
    static #initHtml() {
        this.#htmlElement = createElement('div');
    }
    static #updateHtml() {
        this.#htmlElement.innerText = '';
        this.#htmlElement.append(String(this.#fps));
        this.#htmlElement.append(createElement('br'), `drawElements : ${this.#drawElements}`);
        this.#htmlElement.append(createElement('br'), `renderTime : ${this.#renderTimeMean.toPrecision(3)}`);
        this.#htmlElement.append(createElement('br'), `textures : ${this.#textures}`);
        for (const [mode, count] of this.#primitivePerMode) {
            //let count = this.primitivePerMode[mode];
            if (count > 0) {
                this.#htmlElement.append(createElement('br'), `${mode} : ${count}`);
            }
        }
    }
    static get htmlElement() {
        return this.#htmlElement;
    }
    static getFps() {
        return this.#fps;
    }
}

function flattenArray(array, arrayCount, arraySize) {
    let out = new Float32Array(arrayCount * arraySize); //TODO: cache this
    let offset = 0;
    for (let i = 0; i < arrayCount; i++) {
        for (let j = 0; j < arraySize; j++) {
            out[offset] = array[i][j];
            ++offset;
        }
    }
    return out;
}
const SAMPLERS = new Set([
    GL_SAMPLER_2D, GL_SAMPLER_3D, GL_SAMPLER_CUBE, GL_SAMPLER_2D_ARRAY,
    GL_SAMPLER_2D_SHADOW, GL_SAMPLER_CUBE_SHADOW, GL_SAMPLER_2D_ARRAY_SHADOW,
    GL_INT_SAMPLER_2D, GL_INT_SAMPLER_3D, GL_INT_SAMPLER_CUBE, GL_INT_SAMPLER_2D_ARRAY,
    GL_UNSIGNED_INT_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
]);
class Uniform {
    #activeInfo;
    #size;
    #uniformLocation;
    #isTextureSampler;
    #textureUnit;
    setValue;
    constructor(activeInfo, uniformLocation) {
        this.#activeInfo = activeInfo;
        this.#size = activeInfo.size;
        this.#uniformLocation = uniformLocation;
        this.setValue = this.#getSetter(activeInfo.type);
        this.#isTextureSampler = SAMPLERS.has(activeInfo.type);
    }
    #getSetter(type) {
        const name = this.#activeInfo.name;
        if (name.endsWith('[0]')) {
            // Array
            switch (type) {
                case GL_BOOL:
                case GL_INT:
                    return this.#uniform1iv;
                case GL_FLOAT:
                    return this.#uniform1fv;
                case GL_FLOAT_VEC2:
                    return this.#uniform2fv;
                case GL_FLOAT_VEC3:
                    return this.#uniform3fv;
                case GL_FLOAT_VEC4:
                    return this.#uniform4fv;
                case GL_SAMPLER_2D:
                    return this.#uniformSampler2DArray;
                case GL_FLOAT_MAT4:
                    return this.#uniformMatrix4fvArray;
                default:
                    throw 'Unknown uniform array type : ' + type;
            }
        }
        else {
            // Scalar value
            switch (type) {
                case GL_BOOL:
                case GL_INT:
                    return this.#uniform1i;
                case GL_FLOAT:
                    return this.#uniform1f;
                case GL_BOOL_VEC2:
                case GL_INT_VEC2:
                    return this.#uniform2iv;
                case GL_BOOL_VEC3:
                case GL_INT_VEC3:
                    return this.#uniform3iv;
                case GL_BOOL_VEC4:
                case GL_INT_VEC4:
                    return this.#uniform4iv;
                case GL_FLOAT_VEC2:
                    return this.#uniform2fv;
                case GL_FLOAT_VEC3:
                    return this.#uniform3fv;
                case GL_FLOAT_VEC4:
                    return this.#uniform4fv;
                case GL_FLOAT_MAT2:
                    return this.#uniformMatrix2fv;
                case GL_FLOAT_MAT3:
                    return this.#uniformMatrix3fv;
                case GL_FLOAT_MAT4:
                    return this.#uniformMatrix4fv;
                case GL_SAMPLER_2D:
                    return this.#uniformSampler2D;
                case GL_SAMPLER_CUBE:
                    return this.#uniformSamplerCube;
                default:
                    throw 'Unknown uniform type : ' + type;
            }
        }
    }
    setTextureUnit(textureUnit) {
        if (this.#activeInfo.name.endsWith('[0]')) {
            this.#textureUnit = [];
            for (let i = 0; i < this.#size; ++i) {
                this.#textureUnit.push(textureUnit + i);
            }
        }
        else {
            this.#textureUnit = textureUnit;
        }
    }
    isTextureSampler() {
        return this.#isTextureSampler;
    }
    getSize() {
        return this.#size;
    }
    #uniform1i(glContext, value) {
        glContext.uniform1i(this.#uniformLocation, value);
    }
    #uniform1iv(glContext, value) {
        glContext.uniform1iv(this.#uniformLocation, value);
    }
    #uniform2iv(glContext, value) {
        glContext.uniform2iv(this.#uniformLocation, value);
    }
    #uniform3iv(glContext, value) {
        glContext.uniform3iv(this.#uniformLocation, value);
    }
    #uniform4iv(glContext, value) {
        glContext.uniform4iv(this.#uniformLocation, value);
    }
    #uniform1f(glContext, value) {
        glContext.uniform1f(this.#uniformLocation, value);
    }
    #uniform1fv(glContext, value) {
        glContext.uniform1fv(this.#uniformLocation, value);
    }
    #uniform2fv(glContext, value) {
        glContext.uniform2fv(this.#uniformLocation, value);
    }
    #uniform3fv(glContext, value) {
        glContext.uniform3fv(this.#uniformLocation, value);
    }
    #uniform4fv(glContext, value) {
        glContext.uniform4fv(this.#uniformLocation, value);
    }
    #uniformMatrix2fv(glContext, value) {
        glContext.uniformMatrix2fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix3fv(glContext, value) {
        glContext.uniformMatrix3fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix4fv(glContext, value) {
        glContext.uniformMatrix4fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix4fvArray(glContext, value) {
        glContext.uniformMatrix4fv(this.#uniformLocation, false, flattenArray(value, this.#size, 16));
    }
    #uniformSampler2D(glContext, texture) {
        glContext.uniform1i(this.#uniformLocation, this.#textureUnit);
        glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit);
        if (texture) {
            glContext.bindTexture(GL_TEXTURE_2D, texture.texture);
        }
        else {
            glContext.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    #uniformSampler2DArray(glContext, textures) {
        glContext.uniform1iv(this.#uniformLocation, this.#textureUnit);
        for (let i = 0; i < this.#size; ++i) {
            let texture = textures[i];
            glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit[i]);
            if (texture) {
                glContext.bindTexture(GL_TEXTURE_2D, textures[i].texture);
            }
            else {
                glContext.bindTexture(GL_TEXTURE_2D, null);
            }
        }
    }
    #uniformSamplerCube(glContext, texture) {
        glContext.uniform1i(this.#uniformLocation, this.#textureUnit);
        glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit);
        if (texture) {
            glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
        }
        else {
            glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
    }
}

class Program {
    #glContext;
    #program;
    #vs;
    #fs;
    #vertexShaderName;
    #fragmentShaderName;
    #valid = false;
    attributes = new Map();
    uniforms = new Map();
    #linkError = '';
    constructor(glContext, vertexShaderName, fragmentShaderName) {
        this.#glContext = glContext;
        this.#program = glContext.createProgram();
        this.#vs = glContext.createShader(GL_VERTEX_SHADER);
        this.#fs = glContext.createShader(GL_FRAGMENT_SHADER);
        this.#vertexShaderName = vertexShaderName;
        this.#fragmentShaderName = fragmentShaderName;
        glContext.attachShader(this.#program, this.#vs);
        glContext.attachShader(this.#program, this.#fs);
    }
    get program() {
        throw 'error';
    }
    get vs() {
        throw 'error';
    }
    get fs() {
        throw 'error';
    }
    setUniformValue(name, value) {
        let uniform = this.uniforms.get(name);
        if (uniform !== undefined) {
            uniform.setValue(this.#glContext, value);
        }
    }
    validate(includeCode) {
        const vertexShaderScript = ShaderManager.getShaderSource(GL_VERTEX_SHADER, this.#vertexShaderName);
        const fragmentShaderScript = ShaderManager.getShaderSource(GL_FRAGMENT_SHADER, this.#fragmentShaderName);
        if (vertexShaderScript && fragmentShaderScript && vertexShaderScript.isValid() && fragmentShaderScript.isValid()) {
            const vsOk = this.#compileShader(this.#vs, this.#vertexShaderName, vertexShaderScript, includeCode);
            const fsOk = vsOk && this.#compileShader(this.#fs, this.#fragmentShaderName, fragmentShaderScript, includeCode);
            if (fsOk) {
                this.#glContext.linkProgram(this.#program);
                if (!this.#glContext.getProgramParameter(this.#program, this.#glContext.LINK_STATUS)) {
                    let linkError = this.#glContext.getProgramInfoLog(this.#program);
                    if (this.#linkError != linkError) {
                        console.error(`Failed linking program for ${this.#vertexShaderName} and ${this.#fragmentShaderName}`);
                        console.error('Reason : ' + linkError);
                        this.#linkError = linkError;
                    }
                    return false;
                }
                else {
                    this.#linkError = '';
                }
                this.#initProgram();
                this.#valid = true;
            }
        }
    }
    invalidate() {
        this.#valid = false;
    }
    isValid() {
        return this.#valid;
    }
    getProgram() {
        return this.#program;
    }
    #initProgram() {
        this.attributes.clear();
        this.uniforms.clear();
        const activeAttributes = this.#glContext.getProgramParameter(this.#program, this.#glContext.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < activeAttributes; i++) {
            let attribInfo = this.#glContext.getActiveAttrib(this.#program, i);
            if (attribInfo) {
                this.#setProgramAttribute(attribInfo.name);
            }
        }
        const activeUniforms = this.#glContext.getProgramParameter(this.#program, this.#glContext.ACTIVE_UNIFORMS);
        for (let i = 0; i < activeUniforms; i++) {
            let uniformInfo = this.#glContext.getActiveUniform(this.#program, i);
            if (uniformInfo) {
                this.#setProgramUniform(uniformInfo);
            }
        }
        let samplerId = 0;
        for (let [uniformName, uniform] of this.uniforms) {
            if (uniform.isTextureSampler()) {
                uniform.setTextureUnit(samplerId); //setValue(this.#glContext, samplerId);
                samplerId += uniform.getSize();
            }
        }
    }
    #setProgramAttribute(attributeName) {
        const attributeLocation = this.#glContext.getAttribLocation(this.#program, attributeName);
        this.attributes.set(attributeName, attributeLocation); //TODO: set in attributes ?
    }
    #setProgramUniform(uniformInfo) {
        const uniformLocation = this.#glContext.getUniformLocation(this.#program, uniformInfo.name);
        if (uniformLocation) {
            this.uniforms.set(uniformInfo.name, new Uniform(uniformInfo, uniformLocation));
        }
    }
    #compileShader(shader, shaderName, shaderSource, includeCode) {
        if (!shaderSource || !shaderSource.isValid()) {
            return null;
        }
        let compileSource = shaderSource.getCompileSource(includeCode);
        this.#glContext.shaderSource(shader, compileSource);
        this.#glContext.compileShader(shader);
        if (!this.#glContext.getShaderParameter(shader, this.#glContext.COMPILE_STATUS)) {
            let shaderInfoLog = this.#glContext.getShaderInfoLog(shader);
            let m = 'Compile error in ' + shaderName + '. Reason : ' + shaderInfoLog;
            console.warn(m, shaderSource.getCompileSourceLineNumber(includeCode), m);
            ShaderManager.setCompileError(shaderName, shaderInfoLog);
            shaderSource.setCompileError(this.#glContext.getShaderInfoLog(shader), includeCode);
            return false;
        }
        return true;
    }
}

const tempViewProjectionMatrix = create$5();
const lightDirection = create$4();
function getDefinesAsString(material) {
    let defines = [];
    for (let [name, value] of Object.entries(material.defines)) {
        if (value === false) {
            defines.push('#undef ' + name);
        }
        else {
            defines.push('#define ' + name + ' ' + value);
        }
    }
    return defines.join('\n') + '\n';
}
class Renderer {
    #toneMapping = ToneMapping.None;
    #toneMappingExposure = 1.;
    #graphics;
    #glContext;
    #materialsProgram = new Map();
    #globalIncludeCode = '';
    constructor(graphics) {
        this.#graphics = graphics;
        this.#glContext = graphics.glContext;
    }
    getProgram(mesh, material) {
        let program;
        let includeCode = this.#graphics.getIncludeCode();
        includeCode += this.#globalIncludeCode;
        includeCode += getDefinesAsString(mesh);
        includeCode += getDefinesAsString(material);
        includeCode += material.getShaderSource();
        if (this.#materialsProgram.has(includeCode)) {
            program = this.#materialsProgram.get(includeCode);
        }
        else {
            const shaderSource = material.getShaderSource();
            program = new Program(this.#glContext, shaderSource + '.vs', shaderSource + '.fs');
            this.#materialsProgram.set(includeCode, program);
        }
        if (!program.isValid()) {
            let includeCode = this.#graphics.getIncludeCode();
            includeCode += this.#globalIncludeCode;
            includeCode += getDefinesAsString(mesh);
            includeCode += getDefinesAsString(material);
            program.validate(includeCode);
            material._dirtyProgram = false;
        }
        return program;
    }
    #setupVertexAttributes(program, geometry, wireframe) {
        WebGLRenderingState.initUsedAttributes();
        let geometryAttributes = geometry.attributes;
        let programAttributes = program.attributes;
        for (let [attributeName, attribute] of geometryAttributes) {
            let attributeLocation = programAttributes.get(attributeName);
            if (attributeName == 'index') {
                if (wireframe == 1) {
                    attribute.updateWireframe(this.#glContext); //TODO: put somewhere else
                }
                else {
                    attribute.update(this.#glContext); //TODO: put somewhere else
                }
                this.#glContext.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, attribute._buffer);
            }
            else if (attributeLocation !== undefined) {
                attribute.update(this.#glContext); //TODO: put somewhere else
                WebGLRenderingState.enableVertexAttribArray(attributeLocation, attribute.divisor);
                this.#glContext.bindBuffer(GL_ARRAY_BUFFER, attribute._buffer);
                this.#glContext.vertexAttribPointer(attributeLocation, attribute.itemSize, attribute.type, false, 0, 0);
            }
        }
        WebGLRenderingState.disableUnusedAttributes();
    }
    #setupVertexUniforms(program, mesh) {
        for (let uniform in mesh.uniforms) {
            program.setUniformValue(uniform, mesh.uniforms[uniform]);
        }
    }
    applyMaterial(program, material) {
    }
    setupLights(renderList, camera, program, viewMatrix) {
        let lightPositionCameraSpace = create$4(); //TODO: do not create a vec3
        let lightPositionWorldSpace = create$4(); //TODO: do not create a vec3
        let colorIntensity = create$4(); //TODO: do not create a vec3
        let pointLights = renderList.pointLights; //scene.getChildList(PointLight);
        let spotLights = renderList.spotLights;
        let shadow;
        let pointLightId = 0;
        let pointShadowMap = [];
        let pointShadowMatrix = [];
        for (let pointLight of pointLights) {
            if (pointLight.isVisible()) {
                pointLight.getWorldPosition(lightPositionWorldSpace);
                transformMat4$2(lightPositionCameraSpace, lightPositionWorldSpace, viewMatrix);
                program.setUniformValue('uPointLights[' + pointLightId + '].position', lightPositionCameraSpace);
                program.setUniformValue('uPointLights[' + pointLightId + '].color', scale$5(colorIntensity, pointLight.color, pointLight.intensity));
                program.setUniformValue('uPointLights[' + pointLightId + '].range', pointLight.range);
                //program.setUniformValue('uPointLightsuPointLights[' + pointLightId + '].direction', pointLight.getDirection(tempVec3));
                //program.setUniformValue('uPointLights[' + pointLightId + '].direction', [0, 0, -1]);
                program.setUniformValue('uPbrLights[' + pointLightId + '].position', lightPositionWorldSpace);
                program.setUniformValue('uPbrLights[' + pointLightId + '].radiance', scale$5(colorIntensity, pointLight.color, pointLight.intensity));
                if (pointLight.castShadow) {
                    shadow = pointLight.shadow;
                    pointShadowMap.push(shadow.renderTarget.getTexture());
                    pointShadowMatrix.push(shadow.shadowMatrix);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].mapSize', shadow.textureSize);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].near', shadow.camera.nearPlane);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].far', shadow.camera.farPlane);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].enabled', true);
                }
                ++pointLightId;
            }
        }
        program.setUniformValue('uPointShadowMap[0]', pointShadowMap);
        program.setUniformValue('uPointShadowMatrix[0]', pointShadowMatrix);
        let spotLightId = 0;
        let spotShadowMap = [];
        let spotShadowMatrix = [];
        for (let spotLight of spotLights) {
            if (spotLight.visible) {
                spotLight.getWorldPosition(lightPositionCameraSpace);
                transformMat4$2(lightPositionCameraSpace, lightPositionCameraSpace, viewMatrix);
                program.setUniformValue('uSpotLights[' + spotLightId + '].position', lightPositionCameraSpace);
                program.setUniformValue('uSpotLights[' + spotLightId + '].color', scale$5(colorIntensity, spotLight.color, spotLight.intensity));
                program.setUniformValue('uSpotLights[' + spotLightId + '].range', spotLight.range);
                program.setUniformValue('uSpotLights[' + spotLightId + '].innerAngleCos', spotLight.innerAngleCos);
                program.setUniformValue('uSpotLights[' + spotLightId + '].outerAngleCos', spotLight.outerAngleCos);
                //program.setUniformValue('uSpotLights[' + spotLightId + '].direction', spotLight.getDirection(tempVec3));
                //program.setUniformValue('uSpotLights[' + spotLightId + '].direction', [0, 0, -1]);
                spotLight.getDirection(lightDirection);
                let m = viewMatrix;
                let x = lightDirection[0];
                let y = lightDirection[1];
                let z = lightDirection[2];
                lightDirection[0] = m[0] * x + m[4] * y + m[8] * z;
                lightDirection[1] = m[1] * x + m[5] * y + m[9] * z;
                lightDirection[2] = m[2] * x + m[6] * y + m[10] * z;
                program.setUniformValue('uSpotLights[' + spotLightId + '].direction', lightDirection);
                if (spotLight.castShadow) {
                    shadow = spotLight.shadow;
                    spotShadowMap.push(shadow.renderTarget.getTexture());
                    spotShadowMatrix.push(shadow.shadowMatrix);
                    program.setUniformValue('uSpotLightShadows[' + spotLightId + '].mapSize', shadow.textureSize);
                    program.setUniformValue('uSpotLightShadows[' + spotLightId + '].enabled', true);
                }
                ++spotLightId;
            }
        }
        program.setUniformValue('uSpotShadowMap[0]', spotShadowMap);
        program.setUniformValue('uSpotShadowMatrix[0]', spotShadowMatrix);
        let ambientLights = renderList.ambientLights; //scene.getChildList(AmbientLight);
        let ambientAccumulator = create$4(); //TODO: do not create a vec3
        for (let ambientLight of ambientLights) {
            if (ambientLight.isVisible()) {
                scaleAndAdd$2(ambientAccumulator, ambientAccumulator, ambientLight.color, ambientLight.intensity);
            }
        }
        program.setUniformValue('uAmbientLight', ambientAccumulator);
    }
    setLights(pointLights, spotLights, pointLightShadows, spotLightShadows) {
        this.#graphics.setIncludeCode('USE_SHADOW_MAPPING', '#define USE_SHADOW_MAPPING');
        this.#graphics.setIncludeCode('NUM_POINT_LIGHTS', '#define NUM_POINT_LIGHTS ' + pointLights);
        this.#graphics.setIncludeCode('NUM_PBR_LIGHTS', '#define NUM_PBR_LIGHTS ' + pointLights);
        this.#graphics.setIncludeCode('NUM_SPOT_LIGHTS', '#define NUM_SPOT_LIGHTS ' + spotLights);
        this.#graphics.setIncludeCode('NUM_POINT_LIGHT_SHADOWS', '#define NUM_POINT_LIGHT_SHADOWS ' + pointLightShadows);
        this.#graphics.setIncludeCode('NUM_SPOT_LIGHT_SHADOWS', '#define NUM_SPOT_LIGHT_SHADOWS ' + spotLightShadows);
        //TODO: other lights of disable lighting all together
    }
    unsetLights() {
        this.#graphics.setIncludeCode('USE_SHADOW_MAPPING', '#undef USE_SHADOW_MAPPING');
        this.#graphics.setIncludeCode('NUM_POINT_LIGHTS', '#define NUM_POINT_LIGHTS 0');
        this.#graphics.setIncludeCode('NUM_SPOT_LIGHTS', '#define NUM_SPOT_LIGHTS 0');
        this.#graphics.setIncludeCode('NUM_POINT_LIGHT_SHADOWS', '#define NUM_POINT_LIGHTS 0');
        this.#graphics.setIncludeCode('NUM_SPOT_LIGHT_SHADOWS', '#define NUM_SPOT_LIGHTS 0');
        //TODO: other lights of disable lighting all together
    }
    renderObject(renderList, object, camera, geometry, material, renderLights = true, lightPos) {
        if (!object.isRenderable) {
            return;
        }
        if (object.isVisible() === false) {
            return;
        }
        if (geometry.count === 0) {
            return;
        }
        if (!renderLights) {
            if (!object.castShadow) {
                return;
            }
        }
        renderLights &&= material.renderLights;
        material.updateMaterial(this.#graphics.getTime(), object); //TODO: frame delta
        let cameraMatrix = camera.cameraMatrix;
        let projectionMatrix = camera.projectionMatrix;
        mul$5(object._mvMatrix, cameraMatrix, object.worldMatrix);
        //object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        normalFromMat4(object._normalMatrix, cameraMatrix); //TODO: fixme
        //let viewProjectionMatrix = mat4.create();//TODOv3 don't recreate the matrix
        mul$5(tempViewProjectionMatrix, projectionMatrix, cameraMatrix); //TODO: compute this in camera
        if (renderLights) {
            this.setLights(renderList.pointLights.length, renderList.spotLights.length, renderList.pointLightShadows, renderList.spotLightShadows);
            if (!object.receiveShadow) {
                this.#graphics.setIncludeCode('USE_SHADOW_MAPPING', '#undef USE_SHADOW_MAPPING');
            }
        }
        else {
            this.unsetLights();
        }
        if (camera.projection == CameraProjection.Perspective) {
            this.#graphics.setIncludeCode('CAMERA_PROJECTION_TYPE', '#define IS_PERSPECTIVE_CAMERA');
        }
        else {
            this.#graphics.setIncludeCode('CAMERA_PROJECTION_TYPE', '#define IS_ORTHOGRAPHIC_CAMERA');
        }
        let program = this.getProgram(object, material);
        if (program.isValid()) {
            WebGLRenderingState.useProgram(program.getProgram());
            if (renderLights) {
                material.beforeRender(camera);
            }
            this.applyMaterial(program, material);
            program.setUniformValue('uModelMatrix', object.worldMatrix);
            program.setUniformValue('uModelViewMatrix', object._mvMatrix);
            program.setUniformValue('uViewMatrix', cameraMatrix);
            program.setUniformValue('uProjectionMatrix', projectionMatrix);
            program.setUniformValue('uProjectionLogDepth', 2.0 / (Math.log(camera.farPlane + 1.0) / Math.LN2)); //TODO: perf: compute that once we set camera farplane
            program.setUniformValue('uViewProjectionMatrix', tempViewProjectionMatrix);
            program.setUniformValue('uNormalMatrix', object._normalMatrix);
            program.setUniformValue('uCameraPosition', camera.position);
            let pickingColor = object.pickingColor;
            if (pickingColor) {
                program.setUniformValue('uPickingColor', pickingColor);
            }
            //TODO: set this on resolution change
            program.setUniformValue('uResolution', [this.#graphics.getWidth(), this.#graphics.getHeight(), camera.aspectRatio, 0]);
            //TODO: set this at start of the frame
            program.setUniformValue('uTime', [this.#graphics.getTime(), this.#graphics.currentTick, 0, 0]);
            if (renderLights) {
                this.setupLights(renderList, camera, program, cameraMatrix);
            }
            else {
                program.setUniformValue('uLightPosition', lightPos);
                program.setUniformValue('uLightNear', camera.nearPlane);
                program.setUniformValue('uLightFar', camera.farPlane);
            }
            const wireframe = object.wireframe;
            this.#setupVertexAttributes(program, geometry, wireframe);
            this.#setupVertexUniforms(program, object);
            if (geometry.instanceCount === undefined) {
                if (wireframe == 1) {
                    //TODO: case where original geometry is GL_LINES
                    this.#glContext.drawElements(GL_LINES, geometry.count * 2, GL_UNSIGNED_INT, 0);
                }
                else {
                    this.#glContext.drawElements(object.renderMode, geometry.count, geometry.elementArrayType, 0);
                }
            }
            else {
                if (this.#graphics.isWebGL2) {
                    this.#glContext.drawElementsInstanced(object.renderMode, geometry.count, geometry.elementArrayType, 0, geometry.instanceCount);
                }
                else {
                    this.#graphics.ANGLE_instanced_arrays?.drawElementsInstancedANGLE(object.renderMode, geometry.count, geometry.elementArrayType, 0, geometry.instanceCount);
                }
            }
        }
    }
    _prepareRenderList(renderList, scene, camera, delta, context) {
        renderList.reset();
        let currentObject = scene;
        let objectStack = [];
        //scene.pointLights = scene.getChildList(PointLight);
        //scene.ambientLights = scene.getChildList(AmbientLight);
        while (currentObject) {
            if (currentObject.getAttribute(EngineEntityAttributes.IsTool, false) && context.DisableToolRendering) {
                currentObject = objectStack.shift();
                continue;
            }
            //objectStack.push(currentObject);
            for (let child of currentObject.children) {
                {
                    objectStack.push(child);
                }
            }
            if (currentObject.isRenderable) {
                renderList.addObject(currentObject);
            }
            else {
                currentObject.update(scene, camera, delta);
            }
            currentObject = objectStack.shift();
        }
        renderList.finish();
    }
    _renderRenderList(renderList, camera, renderLights, context, lightPos) {
        for (let child of renderList.opaqueList) {
            this.renderObject(renderList, child, camera, child.geometry, child.material, renderLights, lightPos);
        }
        if (renderLights) {
            for (let child of renderList.transparentList) {
                this.renderObject(renderList, child, camera, child.geometry, child.material, renderLights, lightPos);
            }
        }
    }
    render(scene, camera, delta, context) {
    }
    clear(color, depth, stencil) {
        WebGLRenderingState.clear(color, depth, stencil);
    }
    /*
        get vpMatrix() {
            return mat4.mul(mat4.create(), this.currentCamera.projectionMatrix, this.viewMatrix);
        }
            */
    /**
     * Invalidate all shader (force recompile)
     */
    invalidateShaders() {
        for (let shader of this.#materialsProgram.values()) {
            shader.invalidate();
        }
    }
    clearColor(clearColor) {
        WebGLRenderingState.clearColor(clearColor);
    }
    clearDepth(clearDepth) {
        WebGLRenderingState.clearDepth(clearDepth);
    }
    clearStencil(clearStencil) {
        WebGLRenderingState.clearStencil(clearStencil);
    }
    setToneMapping(toneMapping) {
        this.#toneMapping = toneMapping;
        this.#graphics.setIncludeCode('TONE_MAPPING', `#define TONE_MAPPING ${toneMapping}`);
    }
    getToneMapping() {
        return this.#toneMapping;
    }
    setToneMappingExposure(exposure) {
        this.#toneMappingExposure = exposure;
        this.#graphics.setIncludeCode('TONE_MAPPING_EXPOSURE', `#define TONE_MAPPING_EXPOSURE ${exposure.toFixed(2)}`);
    }
    getToneMappingExposure() {
        return this.#toneMappingExposure;
    }
}

const CLEAR_COLOR$1 = fromValues$3(1, 0, 1, 1);
const a$a = create$3();
const mapSize = create();
const lightPos = create$4();
const viewPort = create$3();
class ShadowMap {
    #graphics;
    #glContext;
    constructor(graphics) {
        this.#graphics = graphics;
        this.#glContext = this.#graphics.glContext;
    }
    render(renderer, renderList, camera, context) {
        let lights = renderList.lights;
        let blendCapability = WebGLRenderingState.isEnabled(GL_BLEND);
        let scissorCapability = WebGLRenderingState.isEnabled(GL_SCISSOR_TEST);
        let depthCapability = WebGLRenderingState.isEnabled(GL_DEPTH_TEST);
        WebGLRenderingState.getClearColor(a$a);
        WebGLRenderingState.disable(GL_BLEND);
        WebGLRenderingState.disable(GL_SCISSOR_TEST);
        WebGLRenderingState.enable(GL_DEPTH_TEST);
        WebGLRenderingState.clearColor(CLEAR_COLOR$1);
        this.#graphics.setIncludeCode('WRITE_DEPTH_TO_COLOR', '#define WRITE_DEPTH_TO_COLOR');
        let renderTarget;
        let shadowViewport;
        for (let lightIndex = 0, l = lights.length; lightIndex < l; ++lightIndex) {
            const light = lights[lightIndex];
            if (light.castShadow) {
                const shadow = light.shadow;
                if (shadow) {
                    light.getWorldPosition(lightPos);
                    renderTarget = shadow.renderTarget;
                    copy(mapSize, shadow.textureSize);
                    this.#graphics.pushRenderTarget(renderTarget);
                    WebGLRenderingState.clear(true, true, true);
                    this.#graphics.setIncludeCode('IS_POINT_LIGHT', light.isPointLight ? '#define IS_POINT_LIGHT' : '');
                    for (let viewPortIndex = 0; viewPortIndex < shadow.viewPortsLength; ++viewPortIndex) {
                        shadowViewport = shadow.viewPorts[viewPortIndex];
                        set$4(viewPort, mapSize[0] * shadowViewport[0], mapSize[1] * shadowViewport[1], mapSize[0] * shadowViewport[2], mapSize[1] * shadowViewport[3]);
                        shadow.computeShadowMatrix(viewPortIndex);
                        this.#graphics.viewport = viewPort;
                        renderer._renderRenderList(renderList, shadow.camera, false, context, lightPos);
                    }
                    this.#graphics.popRenderTarget();
                }
            }
        }
        blendCapability ? WebGLRenderingState.enable(GL_BLEND) : WebGLRenderingState.disable(GL_BLEND);
        scissorCapability ? WebGLRenderingState.enable(GL_SCISSOR_TEST) : WebGLRenderingState.disable(GL_SCISSOR_TEST);
        depthCapability ? WebGLRenderingState.enable(GL_DEPTH_TEST) : WebGLRenderingState.disable(GL_DEPTH_TEST);
        WebGLRenderingState.clearColor(a$a);
        this.#graphics.setIncludeCode('WRITE_DEPTH_TO_COLOR', '');
    }
}

function sortLights(first, second) {
    if (first.castShadow) {
        return -1;
    }
    return 1;
}
class RenderList {
    lights = [];
    pointLights = [];
    spotLights = [];
    ambientLights = [];
    transparentList = [];
    opaqueList = [];
    pointLightShadows = 0;
    spotLightShadows = 0;
    reset() {
        this.lights = [];
        this.pointLights = [];
        this.spotLights = [];
        this.ambientLights = [];
        this.transparentList = [];
        this.opaqueList = [];
        this.pointLightShadows = 0;
        this.spotLightShadows = 0;
    }
    finish() {
        this.pointLights.sort(sortLights);
        this.spotLights.sort(sortLights);
    }
    addObject(entity) {
        if (entity.isVisible() !== false) {
            if (entity.isLight) {
                this.lights.push(entity);
                if (entity.isAmbientLight) {
                    this.ambientLights.push(entity);
                }
                else if (entity.isPointLight) {
                    this.pointLights.push(entity);
                    if (entity.castShadow) {
                        ++this.pointLightShadows;
                    }
                }
                else if (entity.isSpotLight) {
                    this.spotLights.push(entity);
                    if (entity.castShadow) {
                        ++this.spotLightShadows;
                    }
                }
            }
            else {
                const material = entity.material;
                if (material) {
                    if (material.blend) { //TODOv3 changeblend
                        this.transparentList.push(entity);
                    }
                    else {
                        this.opaqueList.push(entity);
                    }
                }
            }
        }
    }
}

class ForwardRenderer extends Renderer {
    #shadowMap;
    #frame = 0;
    constructor(graphics) {
        super(graphics);
        this.#shadowMap = new ShadowMap(graphics);
    }
    applyMaterial(program, material) {
        if (material.depthTest) {
            WebGLRenderingState.enable(GL_DEPTH_TEST);
            WebGLRenderingState.depthFunc(material.depthFunc);
        }
        else {
            WebGLRenderingState.disable(GL_DEPTH_TEST);
        }
        WebGLRenderingState.depthMask(material.depthMask);
        WebGLRenderingState.colorMask(material.colorMask);
        if (material.blend) {
            WebGLRenderingState.enable(GL_BLEND);
            WebGLRenderingState.blendFuncSeparate(material.srcRGB, material.dstRGB, material.srcAlpha, material.dstAlpha);
            WebGLRenderingState.blendEquationSeparate(material.modeRGB, material.modeAlpha);
        }
        else {
            WebGLRenderingState.disable(GL_BLEND);
        }
        /*
        if (material.disableCulling === true) {
            WebGLRenderingState.disable(GL_CULL_FACE);
        } else {
            WebGLRenderingState.enable(GL_CULL_FACE);
            WebGLRenderingState.cullFace(material.cullMode);
        }
            */
        const renderFace = material.getRenderFace();
        switch (renderFace) {
            case RenderFace.Front:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_BACK);
                break;
            case RenderFace.Back:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_FRONT);
                break;
            case RenderFace.Both:
                WebGLRenderingState.disable(GL_CULL_FACE);
                break;
            case RenderFace.None:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_FRONT_AND_BACK);
                break;
        }
        WebGLRenderingState.polygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        for (let uniform in material.uniforms) {
            program.setUniformValue(uniform, material.uniforms[uniform]);
        }
    }
    render(scene, camera, delta, context) {
        const renderList = new RenderList(); //TODO: optimize
        camera.dirty(); //Force matrices to recompute
        this._prepareRenderList(renderList, scene, camera, delta, context);
        this.#shadowMap.render(this, renderList, camera, context);
        if (scene.background) {
            scene.background.render(this, camera);
        }
        this._renderRenderList(renderList, camera, true, context);
        WebGLRenderingState.depthMask(true); //TODOv3 check why we have to do this
        ++this.#frame;
    }
    set scissorTest(scissorTest) {
        if (scissorTest) {
            WebGLRenderingState.enable(GL_SCISSOR_TEST);
        }
        else {
            WebGLRenderingState.disable(GL_SCISSOR_TEST);
        }
    }
}

const VEC4_ALL_1 = fromValues$3(1.0, 1.0, 1.0, 1.0);
var ShaderPrecision;
(function (ShaderPrecision) {
    ShaderPrecision[ShaderPrecision["Low"] = 0] = "Low";
    ShaderPrecision[ShaderPrecision["Medium"] = 1] = "Medium";
    ShaderPrecision[ShaderPrecision["High"] = 2] = "High";
})(ShaderPrecision || (ShaderPrecision = {}));
var ShaderQuality;
(function (ShaderQuality) {
    ShaderQuality[ShaderQuality["Low"] = 0] = "Low";
    ShaderQuality[ShaderQuality["Medium"] = 1] = "Medium";
    ShaderQuality[ShaderQuality["High"] = 2] = "High";
})(ShaderQuality || (ShaderQuality = {}));
var ShaderDebugMode;
(function (ShaderDebugMode) {
    ShaderDebugMode[ShaderDebugMode["None"] = 0] = "None";
})(ShaderDebugMode || (ShaderDebugMode = {}));
let graphics$1 = null;
function getGraphics() {
    if (!graphics$1) {
        graphics$1 = new Graphics();
    }
    return graphics$1;
}
class Graphics {
    static #instance;
    #pixelRatio = /*window.devicePixelRatio ?? */ 1.0;
    #viewport = create$3();
    #scissor = create$3();
    #extensions = new Map();
    #autoResize = false;
    isWebGL = false;
    isWebGL2 = false;
    autoClear = true;
    autoClearColor = false;
    autoClearDepth = true;
    autoClearStencil = true;
    #includeCode = new Map();
    #globalIncludeCode = '';
    speed = 1.0;
    #timeOrigin = performance.now();
    #time = 0;
    #running = false;
    #lastTick = performance.now();
    currentTick = 0;
    #renderBuffers = new Set();
    #renderTargetStack = [];
    #readyPromiseResolve;
    #readyPromise = new Promise((resolve) => this.#readyPromiseResolve = resolve);
    #canvas;
    #width = 0;
    #height = 0;
    #offscreenCanvas;
    #forwardRenderer;
    glContext;
    #bipmapContext;
    #pickedEntity = null;
    #animationFrame = 0;
    ANGLE_instanced_arrays;
    OES_texture_float_linear;
    #mediaRecorder;
    dragging = false;
    constructor() {
        if (Graphics.#instance) {
            return Graphics.#instance;
        }
        Graphics.#instance = this;
        this.setShaderPrecision(ShaderPrecision.Medium);
        this.setShaderQuality(ShaderQuality.Medium);
        this.setShaderDebugMode(ShaderDebugMode.None);
        this.setIncludeCode('MAX_HARDWARE_BONES', '#define MAX_HARDWARE_BONES ' + MAX_HARDWARE_BONES);
    }
    initCanvas(contextAttributes = {}) {
        this.#canvas = contextAttributes.canvas ?? createElement('canvas');
        if (!this.#canvas.hasAttribute('tabindex')) {
            this.#canvas.setAttribute('tabindex', "1");
        }
        ShortcutHandler.addContext('3dview', this.#canvas);
        this.#width = this.#canvas.width;
        this.#height = this.#canvas.height;
        this.#initContext(contextAttributes);
        this.#initObserver();
        WebGLRenderingState.setGraphics(this);
        // init state
        WebGLRenderingState.enable(GL_CULL_FACE);
        // init state end
        //this.clearColor = vec4.fromValues(0, 0, 0, 255);
        this.#forwardRenderer = new ForwardRenderer(this);
        let autoResize = contextAttributes.autoResize;
        if (autoResize !== undefined) {
            this.autoResize = autoResize;
        }
        this.#canvas.addEventListener('mousedown', (event) => this.#mouseDown(event));
        this.#canvas.addEventListener('mousemove', (event) => this.#mouseMove(event));
        this.#canvas.addEventListener('mouseup', (event) => this.#mouseUp(event));
        this.#canvas.addEventListener('keydown', (event) => GraphicsEvents.keyDown(event));
        this.#canvas.addEventListener('keyup', (event) => GraphicsEvents.keyUp(event));
        this.#canvas.addEventListener('wheel', (event) => this.#wheel(event));
        this.#canvas.addEventListener('touchstart', (event) => GraphicsEvents.touchStart(this.#pickedEntity, event));
        this.#canvas.addEventListener('touchmove', (event) => GraphicsEvents.touchMove(this.#pickedEntity, event));
        this.#canvas.addEventListener('touchcancel', (event) => GraphicsEvents.touchCancel(this.#pickedEntity, event));
        this.#readyPromiseResolve(true);
        return this;
    }
    pickEntity(x, y) {
        if (!this.#canvas) {
            return null;
        }
        this.setIncludeCode('pickingMode', '#define PICKING_MODE');
        GraphicsEvents.tick(0, performance.now(), 0);
        this.setIncludeCode('pickingMode', '#undef PICKING_MODE');
        this.glContext;
        let pixels = new Uint8Array(4);
        this.glContext?.readPixels(x, this.#canvas.height - y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
        let pickedEntityIndex = (pixels[0] << 16) + (pixels[1] << 8) + (pixels[2]);
        return pickList.get(pickedEntityIndex) ?? null;
    }
    #mouseDown(event) {
        this.#canvas.focus();
        let x = event.offsetX;
        let y = event.offsetY;
        this.#pickedEntity = this.pickEntity(x, y);
        GraphicsEvents.mouseDown(x, y, this.#pickedEntity, event);
    }
    #mouseMove(event) {
        let x = event.offsetX;
        let y = event.offsetY;
        GraphicsEvents.mouseMove(x, y, this.#pickedEntity, event);
    }
    #mouseUp(event) {
        let x = event.offsetX;
        let y = event.offsetY;
        GraphicsEvents.mouseUp(x, y, this.#pickedEntity, event);
        this.#pickedEntity = null;
    }
    #wheel(event) {
        let x = event.offsetX;
        let y = event.offsetY;
        GraphicsEvents.wheel(x, y, this.#pickedEntity, event);
        this.#pickedEntity = null;
    }
    getDefinesAsString(material) {
        let defines = [];
        for (let [name, value] of Object.entries(material.defines)) {
            if (value === false) {
                defines.push('#undef ' + name + ' ' + value);
            }
            else {
                defines.push('#define ' + name + ' ' + value);
            }
        }
        return defines.join('\n') + '\n';
    }
    render(scene, camera, delta, context) {
        this.renderBackground(); //TODOv3 put in rendering pipeline
        this.#forwardRenderer.render(scene, camera, delta, context);
    }
    renderBackground() {
        if (this.autoClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
    }
    clear(color, depth, stencil) {
        let bits = 0;
        if (color)
            bits |= GL_COLOR_BUFFER_BIT;
        if (depth)
            bits |= GL_DEPTH_BUFFER_BIT;
        if (stencil)
            bits |= GL_STENCIL_BUFFER_BIT;
        //TODO check if doing a complete state reinitilisation is better ?
        WebGLRenderingState.colorMask(VEC4_ALL_1);
        WebGLRenderingState.depthMask(true);
        WebGLRenderingState.stencilMask(Number.MAX_SAFE_INTEGER);
        this.glContext?.clear(bits);
    }
    _tick() {
        cancelAnimationFrame(this.#animationFrame);
        {
            this.#animationFrame = requestAnimationFrame(() => this._tick());
        }
        const tick = performance.now();
        this.#time = (tick - this.#timeOrigin) * 0.001;
        let delta = (tick - this.#lastTick) * this.speed * 0.001;
        if (this.#running) {
            ++this.currentTick;
            GraphicsEvents.tick(delta, tick, this.speed);
        }
        this.#lastTick = tick;
    }
    #initContext(contextAttributes) {
        const canvas = this.#canvas;
        if (!canvas) {
            return;
        }
        // we may want to cleanup the contextAttributes here
        try {
            try { // first try to create a webgl2 context
                if (DISABLE_WEBGL2) ;
                this.glContext = canvas.getContext('webgl2', contextAttributes);
                if (this.glContext instanceof WebGL2RenderingContext) {
                    this.isWebGL2 = true;
                    WebGLShaderSource.isWebGL2 = true;
                    this.setIncludeCode('WEBGL2', '#define WEBGL2');
                }
                else {
                    throw 'no webgl2';
                }
            }
            catch (e) {
                this.glContext = canvas.getContext('webgl', contextAttributes);
                if (this.glContext instanceof WebGLRenderingContext) {
                    this.isWebGL = true;
                    this.setIncludeCode('WEBGL1', '#define WEBGL1');
                    //TODO: put this in a separate function and alert the user in case of failure
                    //these extensions are important
                    // activate UNSIGNED_INT indices in drawElements
                    this.getExtension('OES_element_index_uint');
                    // activate floating point textures
                    this.getExtension('OES_texture_float');
                    // activate derivatives functions
                    this.getExtension('OES_standard_derivatives');
                    //activate writing in gl_FragDepth
                    this.getExtension('EXT_frag_depth');
                    // get access to drawElementsInstancedANGLE
                    this.ANGLE_instanced_arrays = this.getExtension('ANGLE_instanced_arrays');
                    // add MIN_EXT and MAX_EXT for blendEquation in webgl1 context. MIN_EXT and MAX_EXT have the same value as MIN and MAX
                    this.getExtension('EXT_blend_minmax');
                    //Depth texture https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
                    this.getExtension('WEBGL_depth_texture');
                    //https://developer.mozilla.org/en-US/docs/Web/API/EXT_sRGB
                    this.getExtension('EXT_sRGB');
                    //TODO: see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension
                }
            }
            // WEBGL1 / WEBGL2 extensions
            // https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float_linear
            this.OES_texture_float_linear = this.getExtension('OES_texture_float_linear');
        }
        catch (error) {
            console.error(error);
            throw error;
        }
        if (this.glContext) {
            setTextureFactoryContext(this.glContext);
        }
    }
    set shaderPrecision(shaderPrecision) {
        this.setShaderPrecision(shaderPrecision);
    }
    setShaderPrecision(shaderPrecision) {
        switch (shaderPrecision) {
            case ShaderPrecision.Low:
                this.setIncludeCode('SHADER_PRECISION', '#define LOW_PRECISION');
                break;
            case ShaderPrecision.Medium:
                this.setIncludeCode('SHADER_PRECISION', '#define MEDIUM_PRECISION');
                break;
            case ShaderPrecision.High:
                this.setIncludeCode('SHADER_PRECISION', '#define HIGH_PRECISION');
                break;
        }
    }
    setShaderQuality(shaderQuality) {
        this.setIncludeCode('SHADER_QUALITY', `#define SHADER_QUALITY ${shaderQuality}`);
    }
    setShaderDebugMode(shaderDebugMode) {
        this.setIncludeCode('SHADER_DEBUG_MODE', `#define SHADER_DEBUG_MODE ${shaderDebugMode}`);
    }
    setIncludeCode(key, code) {
        this.#includeCode.set(key, code);
        this.#refreshIncludeCode();
    }
    removeIncludeCode(key) {
        this.#includeCode.delete(key);
        this.#refreshIncludeCode();
    }
    #refreshIncludeCode() {
        this.#globalIncludeCode = '';
        for (let code of this.#includeCode.values()) {
            this.#globalIncludeCode += code + '\n';
        }
    }
    getIncludeCode() {
        return this.#globalIncludeCode;
    }
    /**
     * Invalidate all shader (force recompile)
     */
    invalidateShaders() {
        if (this.#forwardRenderer) {
            this.#forwardRenderer.invalidateShaders();
        }
        /*for (let shader of this._materialsProgram) {
            shader.invalidate();
        }*/
    }
    clearColor(clearColor) {
        WebGLRenderingState.clearColor(clearColor);
    }
    getClearColor(clearColor) {
        return WebGLRenderingState.getClearColor(clearColor);
    }
    clearDepth(clearDepth) {
        WebGLRenderingState.clearDepth(clearDepth);
    }
    clearStencil(clearStencil) {
        WebGLRenderingState.clearStencil(clearStencil);
    }
    setColorMask(mask) {
        WebGLRenderingState.colorMask(mask);
    }
    set autoResize(autoResize) {
        this.#autoResize = autoResize;
        if (autoResize) {
            this.checkCanvasSize();
        }
    }
    get autoResize() {
        return this.#autoResize;
    }
    getExtension(name) {
        if (this.glContext) {
            if (this.#extensions.has(name)) {
                return this.#extensions.get(name);
            }
            else {
                let extension = this.glContext.getExtension(name);
                this.#extensions.set(name, extension);
                return extension;
            }
        }
        return null;
    }
    set pixelRatio(pixelRatio) {
        this.#pixelRatio = pixelRatio;
        this.#updateSize();
    }
    get pixelRatio() {
        return this.#pixelRatio;
    }
    setSize(width, height) {
        width = Math.max(width, 1);
        height = Math.max(height, 1);
        let previousWidth = this.#width;
        let previousHeight = this.#height;
        if (isNumeric(width)) {
            this.#width = width;
        }
        if (isNumeric(height)) {
            this.#height = height;
        }
        this.#updateSize();
        GraphicsEvents.resize(width, height);
        return [previousWidth, previousHeight];
    }
    getSize(ret = create()) {
        ret[0] = this.#width;
        ret[1] = this.#height;
        return ret;
    }
    #updateSize() {
        if (!this.#canvas) {
            return;
        }
        this.#canvas.width = this.#width * this.#pixelRatio;
        this.#canvas.height = this.#height * this.#pixelRatio;
        this.viewport = fromValues$3(0, 0, this.#width, this.#height);
    }
    set viewport(viewport) {
        copy$3(this.#viewport, viewport);
        WebGLRenderingState.viewport(viewport);
    }
    get viewport() {
        return clone$3(this.#viewport);
    }
    set scissor(scissor) {
        copy$3(this.#scissor, scissor);
        WebGLRenderingState.scissor(scissor);
    }
    set scissorTest(scissorTest) {
        if (scissorTest) {
            WebGLRenderingState.enable(GL_SCISSOR_TEST);
        }
        else {
            WebGLRenderingState.disable(GL_SCISSOR_TEST);
        }
    }
    checkCanvasSize() {
        if (!this.#autoResize) {
            return;
        }
        const canvas = this.#canvas;
        if (!canvas?.parentElement) {
            return;
        }
        const width = canvas.parentElement.clientWidth;
        const height = canvas.parentElement.clientHeight;
        if (width !== this.#width
            || height !== this.#height) {
            this.setSize(width, height);
        }
    }
    #initObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.checkCanvasSize();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        if (this.#canvas?.parentElement) {
            resizeObserver.observe(this.#canvas.parentElement);
        }
    }
    play() {
        this.#running = true;
        this._tick();
    }
    pause() {
        this.#running = false;
    }
    isRunning() {
        return this.#running;
    }
    createFramebuffer() {
        let frameBuffer = this.glContext.createFramebuffer();
        //this.frameBuffers.add(frameBuffer);
        return frameBuffer;
    }
    deleteFramebuffer(frameBuffer) {
        this.glContext.deleteFramebuffer(frameBuffer);
    }
    createRenderbuffer() {
        let renderBuffer = this.glContext.createRenderbuffer();
        if (renderBuffer) {
            this.#renderBuffers.add(renderBuffer);
        }
        return renderBuffer;
    }
    deleteRenderbuffer(renderBuffer) {
        this.glContext.deleteRenderbuffer(renderBuffer);
    }
    /*
    setFramebuffer(framebuffer: WebGLFramebuffer) {
        framebuffer.bind();
        //this.glContext.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    }
    */
    pushRenderTarget(renderTarget) {
        this.#renderTargetStack.push(renderTarget);
        this.#setRenderTarget(renderTarget);
    }
    popRenderTarget() {
        this.#renderTargetStack.pop();
        const renderTarget = this.#renderTargetStack[this.#renderTargetStack.length - 1];
        this.#setRenderTarget(renderTarget);
        return renderTarget;
    }
    #setRenderTarget(renderTarget) {
        if (renderTarget == undefined) {
            this.glContext.bindFramebuffer(GL_FRAMEBUFFER, null);
            this.viewport = fromValues$3(0, 0, this.#width, this.#height);
        }
        else {
            renderTarget.bind();
        }
    }
    savePicture(scene, camera, filename, width, height) {
        let previousWidth = this.#width;
        let previousHeight = this.#height;
        let previousAutoResize = this.autoResize;
        try {
            this.autoResize = false;
            this.setSize(width, height);
            this.render(scene, camera, 0, { DisableToolRendering: true });
            this._savePicture(filename);
        }
        finally {
            this.autoResize = previousAutoResize;
            this.setSize(previousWidth, previousHeight);
        }
    }
    async savePictureAsFile(filename) {
        return new File([await this.toBlob() ?? new Blob()], filename);
    }
    async toBlob() {
        let promiseResolve;
        const promise = new Promise((resolve) => {
            promiseResolve = resolve;
        });
        const callback = function (blob) {
            promiseResolve(blob);
        };
        this.#canvas.toBlob(callback);
        return promise;
    }
    async _savePicture(filename) {
        /*
        const callback = function (blob) {
            //SaveFile(filename, blob);
        };
        this.#canvas.toBlob(callback);*/
        SaveFile(await this.savePictureAsFile(filename));
    }
    startRecording(frameRate = 60, bitsPerSecond) {
        const stream = this.#canvas.captureStream(frameRate);
        this.#mediaRecorder = new MediaRecorder(stream, { mimeType: RECORDER_MIME_TYPE, bitsPerSecond: bitsPerSecond });
        this.#mediaRecorder.start();
    }
    stopRecording(fileName = RECORDER_DEFAULT_FILENAME) {
        if (!this.#mediaRecorder) {
            return;
        }
        this.#mediaRecorder.ondataavailable = (event) => {
            const blob = new Blob([event.data], { 'type': RECORDER_MIME_TYPE });
            SaveFile(new File([blob], fileName));
        };
        this.#mediaRecorder.stop();
        //Stop the canvas stream
        this.#mediaRecorder.stream.getVideoTracks()[0].stop();
    }
    get ready() {
        return this.#readyPromise;
    }
    async isReady() {
        await this.#readyPromise;
    }
    getParameter(param) {
        return this.glContext?.getParameter(param);
    }
    cleanupGLError() {
        this.glContext?.getError(); //empty the error
    }
    getGLError(context) {
        let glError = this.glContext?.getError() ?? 0;
        if (glError) {
            console.error(`GL Error in ${context} : `, glError);
        }
    }
    useLogDepth(use) {
        this.setIncludeCode('LOG_DEPTH', use ? '#define USE_LOG_DEPTH' : '');
    }
    getTime() {
        return this.#time;
    }
    getWidth() {
        return this.#width;
    }
    getHeight() {
        return this.#height;
    }
    getCanvas() {
        return this.#canvas;
    }
    getForwardRenderer() {
        return this.#forwardRenderer;
    }
}

const ATTACHMENT_TYPE_RENDER_BUFFER = 0;
const ATTACHMENT_TYPE_TEXTURE2D = 1;
class Framebuffer {
    #target;
    #frameBuffer;
    #width = 1;
    #height = 1;
    #attachments = new Map();
    #dirty = true;
    constructor(target) {
        this.#target = target;
        this.#frameBuffer = new Graphics().createFramebuffer();
    }
    /*
    createRenderTarget(colorFormat, colorType, depth, stencil) {
        this.#frameBuffer.addTexture2D(GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this._createTexture());
        this.frameBufferTexture = TextureManager.createTexture();

        this.bind();
    }

    _createTexture(internalFormat, width, height, format, type) {
        let texture = TextureManager.createTexture();

        new Graphics().glContext.bindTexture(GL_TEXTURE_2D, texture);
        new Graphics().glContext.texImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, null);
        new Graphics().glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        new Graphics().glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        new Graphics().glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        return texture;
    }
*/
    addRenderbuffer(attachmentPoint, renderbuffer) {
        this.#attachments.set(attachmentPoint, { renderbuffer: renderbuffer, type: ATTACHMENT_TYPE_RENDER_BUFFER });
        this.#dirty = true;
    }
    addTexture2D(attachmentPoint, textureTarget, texture) {
        this.#attachments.set(attachmentPoint, { target: textureTarget, texture: texture, type: ATTACHMENT_TYPE_TEXTURE2D });
        this.#dirty = true;
    }
    #setupAttachments() {
        for (let [attachmentPoint, attachmentParams] of this.#attachments) {
            switch (attachmentParams.type) {
                case ATTACHMENT_TYPE_RENDER_BUFFER:
                    //new Graphics().glContext.bindRenderbuffer(GL_RENDERBUFFER, attachmentParams.renderbuffer);
                    //new Graphics().renderbufferStorage(GL_RENDERBUFFER, GL_RGBA4, 256, 256);
                    new Graphics().glContext.framebufferRenderbuffer(this.#target, attachmentPoint, GL_RENDERBUFFER, attachmentParams.renderbuffer.getRenderbuffer());
                    //new Graphics().bindRenderbuffer(GL_RENDERBUFFER, null);
                    break;
                case ATTACHMENT_TYPE_TEXTURE2D:
                    //console.error(new Graphics().getError());
                    let webGLTexture = attachmentParams.texture.texture;
                    new Graphics().glContext.bindTexture(attachmentParams.target, null);
                    new Graphics().glContext.framebufferTexture2D(this.#target, attachmentPoint, attachmentParams.target, webGLTexture, 0);
                    break;
            }
        }
        this.#dirty = false;
        //console.error(new Graphics().checkFramebufferStatus(this.#target));
        //TODO: checkFramebufferStatus
    }
    bind() {
        new Graphics().glContext.bindFramebuffer(this.#target, this.#frameBuffer);
        /*console.error(new Graphics().getError());
        this.#setupAttachments();//TODOv3
        console.error(new Graphics().getError());
        return;*/
        if (this.#dirty) {
            this.#setupAttachments();
        }
    }
    dispose() {
        new Graphics().deleteFramebuffer(this.#frameBuffer);
        for (let [attachmentPoint, attachment] of this.#attachments) {
            switch (attachment.type) {
                case ATTACHMENT_TYPE_RENDER_BUFFER:
                    attachment.renderbuffer.dispose();
                    break;
                case ATTACHMENT_TYPE_TEXTURE2D:
                    attachment.texture.removeUser(this);
                    break;
            }
        }
    }
}

const graphics = getGraphics();
function renderbufferStorage(renderbuffer, internalFormat, width, height, samples) {
    const glContext = graphics.glContext;
    glContext.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);
    if (graphics.isWebGL2 && samples > 0) {
        glContext.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, internalFormat, width, height);
    }
    else {
        glContext.renderbufferStorage(GL_RENDERBUFFER, internalFormat, width, height);
    }
    glContext.bindRenderbuffer(GL_RENDERBUFFER, null);
}
class Renderbuffer {
    #renderbuffer;
    #internalFormat;
    #samples;
    constructor(internalFormat, width, height, samples) {
        this.#renderbuffer = graphics.createRenderbuffer();
        this.#internalFormat = internalFormat;
        renderbufferStorage(this.#renderbuffer, this.#internalFormat, width, height, this.#samples ?? 0);
    }
    resize(width, height) {
        renderbufferStorage(this.#renderbuffer, this.#internalFormat, width, height, this.#samples ?? 0);
    }
    getRenderbuffer() {
        return this.#renderbuffer;
    }
    dispose() {
        graphics.deleteRenderbuffer(this.#renderbuffer);
    }
}

class RenderTarget {
    #width = 0;
    #height = 0;
    #target = GL_FRAMEBUFFER;
    #frameBuffer = new Framebuffer(this.#target);
    #depthRenderbuffer;
    #texture;
    #scissor = create$3();
    #viewport = create$3();
    #scissorTest = false;
    #depthBuffer;
    #stencilBuffer;
    #depthTexture;
    constructor(params = {} /*width, height, options = {}/*depth, stencil, texture*/) {
        const width = params.width ?? 1;
        const height = params.height ?? 1;
        if (params.texture) {
            this.#texture = params.texture;
        }
        else {
            this.#texture = TextureManager.createTexture({ internalFormat: params.internalFormat, format: params.format, type: params.type } /*{minFilter:GL_LINEAR, wrapS:GL_CLAMP_TO_EDGE, wrapT:GL_CLAMP_TO_EDGE}*/);
        }
        this.#texture.addUser(this);
        this.#texture.minFilter = GL_LINEAR;
        this.#texture.wrapS = GL_CLAMP_TO_EDGE;
        this.#texture.wrapT = GL_CLAMP_TO_EDGE;
        this.#texture.setParameters(new Graphics().glContext, GL_TEXTURE_2D); //TODOv3: remove
        this.setViewport(0, 0, width, height);
        this.#depthBuffer = params.depthBuffer ?? true;
        this.#stencilBuffer = params.stencilBuffer ?? false;
        this.#depthTexture = params.depthTexture ?? false;
        this.#create(width, height);
    }
    #create(width, height) {
        this.#frameBuffer.addTexture2D(GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this.#texture);
        this.#createDepthBuffer(width, height);
        if (this.#stencilBuffer) ;
        this.resize(width, height);
    }
    #createDepthBuffer(width, height) {
        if (this.#depthBuffer && !this.#depthRenderbuffer) { //TODOv3 DEPTH_STENCIL
            this.#depthRenderbuffer = new Renderbuffer(GL_DEPTH_COMPONENT16, width, height);
            this.#frameBuffer.addRenderbuffer(GL_DEPTH_ATTACHMENT, this.#depthRenderbuffer);
        }
    }
    setDepthBuffer(depthBuffer) {
        this.#depthBuffer = depthBuffer;
        this.#createDepthBuffer(this.#width, this.#height);
    }
    setScissorTest(scissorTest) {
        this.#scissorTest = scissorTest;
    }
    getWidth() {
        return this.#width;
    }
    getHeight() {
        return this.#height;
    }
    getTexture() {
        return this.#texture;
    }
    /**
     * @deprecated Please use `getTexture` instead.
     */
    get texture() {
        throw 'deprecated, use getTexture()';
    }
    bind() {
        this.#frameBuffer.bind();
        new Graphics().viewport = this.#viewport;
    }
    unbind() {
        new Graphics().glContext.bindFramebuffer(GL_FRAMEBUFFER, null);
    }
    resize(width, height) {
        this.#width = width;
        this.#height = height;
        this.#texture.texImage2D(new Graphics().glContext, GL_TEXTURE_2D, width, height, TextureFormat.Rgba, TextureType.UnsignedByte);
        //TODOv3: stencil / depth buffer
        if (this.#depthRenderbuffer) {
            this.#depthRenderbuffer.resize(width, height);
        }
        this.setViewport(0, 0, width, height);
    }
    setViewport(x, y, width, height) {
        set$4(this.#viewport, x, y, width, height);
        set$4(this.#scissor, x, y, width, height);
    }
    clone() {
        let dest = new RenderTarget({ width: this.#width, height: this.#height, depthBuffer: this.#depthBuffer, stencilBuffer: this.#stencilBuffer });
        //dest.texture = this.#texture.clone();
        return dest;
    }
    dispose() {
        this.#texture.removeUser(this);
        this.#frameBuffer.dispose();
    }
}

const CLEAR_COLOR = fromValues$3(0, 0, 0, 0);
let tempVec2$4 = create();
class OutlinePass extends Pass {
    #edgedetectionMaterial;
    #copyMaterial;
    outlineScene;
    #renderTargetDepthBuffer;
    #renderTargetMaskDownSampleBuffer;
    #renderTargetBlurBuffer1;
    #renderTargetBlurBuffer2;
    #renderTargetEdgeBuffer1;
    #renderTargetEdgeBuffer2;
    width = 1;
    height = 1;
    constructor(outlineScene, camera) {
        super();
        this.outlineScene = outlineScene;
        this.camera = camera;
        this.#initRenderTargets();
        this.#copyMaterial = new ShaderMaterial({ shaderSource: 'copy' });
        this.#copyMaterial.addUser(this);
        this.#copyMaterial.depthTest = false;
        this.#copyMaterial.setBlending(MATERIAL_BLENDING_ADDITIVE);
        this.#edgedetectionMaterial = new ShaderMaterial({ shaderSource: 'edgedetection' });
        this.#edgedetectionMaterial.addUser(this);
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ parent: this.scene });
        //this.quad.material = material;
        this.camera = camera;
    }
    #initRenderTargets() {
        this.#renderTargetDepthBuffer = new RenderTarget({ width: 1, height: 1, } /*, {internalFormat:GL_DEPTH_COMPONENT16, format:GL_DEPTH_COMPONENT, type:GL_UNSIGNED_INT}*/);
        this.#renderTargetMaskDownSampleBuffer = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetBlurBuffer1 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetBlurBuffer2 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetEdgeBuffer1 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetEdgeBuffer2 = new RenderTarget({ width: 1, height: 1, });
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        this.#renderTargetDepthBuffer.resize(width, height);
        this.#renderTargetMaskDownSampleBuffer.resize(width, height);
        this.#renderTargetBlurBuffer1.resize(width, height);
        this.#renderTargetBlurBuffer2.resize(width, height);
        this.#renderTargetEdgeBuffer1.resize(width, height);
        this.#renderTargetEdgeBuffer2.resize(width, height);
    }
    changeVisibilityOfSelectedObjects(visible) {
        this.outlineScene.forEach((entity) => {
            if (entity.properties.get('selected') && entity.isRenderable) {
                if (visible) {
                    entity.setVisible(entity.properties.get('oldVisible'));
                    entity.properties.delete('oldVisible');
                }
                else {
                    entity.properties.set('oldVisible', entity.isVisibleSelf());
                    entity.setVisible(visible);
                }
            }
        });
    }
    changeVisibilityOfNonSelectedObjects(visible) {
        this.outlineScene.forEach((entity) => {
            if (!entity.properties.get('selected') && entity.isRenderable) {
                if (visible) {
                    entity.setVisible(entity.properties.get('oldVisible'));
                    entity.properties.delete('oldVisible');
                }
                else {
                    entity.properties.set('oldVisible', entity.isVisibleSelf());
                    entity.setVisible(visible);
                }
            }
        });
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        renderer.getSize(tempVec2$4);
        tempVec2$4[0];
        tempVec2$4[1];
        renderer.clearColor(CLEAR_COLOR);
        renderer.pushRenderTarget(this.#renderTargetDepthBuffer);
        renderer.clear(true, true, false);
        //renderer.setIncludeCode('WRITE_DEPTH_TO_COLOR', '#define WRITE_DEPTH_TO_COLOR');
        this.changeVisibilityOfSelectedObjects(false);
        renderer.setColorMask([0, 0, 0, 0]);
        renderer.render(this.outlineScene, this.camera, 0, context);
        renderer.setColorMask([1, 1, 1, 1]);
        this.changeVisibilityOfSelectedObjects(true);
        //renderer.setIncludeCode('WRITE_DEPTH_TO_COLOR', '');
        this.changeVisibilityOfNonSelectedObjects(false);
        renderer.setIncludeCode('outline_pass_silhouette_mode', '#define SILHOUETTE_MODE');
        renderer.setIncludeCode('silhouetteColor', '#define SILHOUETTE_COLOR vec4(1.0)');
        renderer.render(this.outlineScene, this.camera, 0, context);
        renderer.setIncludeCode('outline_pass_silhouette_mode', '#undef SILHOUETTE_MODE');
        this.changeVisibilityOfNonSelectedObjects(true);
        renderer.popRenderTarget();
        /**************/
        this.#edgedetectionMaterial.uniforms['colorMap'] = this.#renderTargetDepthBuffer.getTexture(); //TODO: optiùmize this
        this.#edgedetectionMaterial.uniforms['uTexSize'] = [this.width, this.height];
        this.#edgedetectionMaterial.uniforms['uVisibleEdgeColor'] = [1, 1, 1];
        this.#edgedetectionMaterial.uniforms['uHiddenEdgeColor'] = [0, 1, 0];
        this.quad.setMaterial(this.#edgedetectionMaterial);
        renderer.pushRenderTarget(this.#renderTargetEdgeBuffer1);
        renderer.clear(true, true, false);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
        /**************/
        this.#copyMaterial.uniforms['colorMap'] = readBuffer.getTexture();
        this.quad.setMaterial(this.#copyMaterial);
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.clear(true, true, false);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
        /***************/
        this.#copyMaterial.uniforms['colorMap'] = this.#renderTargetEdgeBuffer1.getTexture();
        this.quad.setMaterial(this.#copyMaterial);
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class PalettePass extends Pass {
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'palette' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class PixelatePass extends Pass {
    #horizontalTiles;
    #pixelStyle;
    #material;
    constructor(camera) {
        super();
        this.#material = new ShaderMaterial({ shaderSource: 'pixelate' });
        this.#material.addUser(this);
        this.#material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: this.#material, parent: this.scene });
        this.camera = camera;
        this.horizontalTiles = 10;
    }
    set horizontalTiles(horizontalTiles) {
        this.#horizontalTiles = horizontalTiles;
        this.#material.uniforms['uHorizontalTiles'] = this.#horizontalTiles;
    }
    set pixelStyle(pixelStyle) {
        this.#pixelStyle = pixelStyle;
        this.#material.setDefine('PIXEL_STYLE', pixelStyle);
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.#material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class RenderPass extends Pass {
    constructor(scene, camera) {
        super();
        this.swapBuffers = false;
        this.scene = scene;
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, delta, context);
        renderer.popRenderTarget();
    }
}

class SaturatePass extends Pass {
    #saturation;
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'saturate' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
        this.saturation = 1.0;
    }
    set saturation(saturation) {
        this.#saturation = saturation;
        this.quad.material.uniforms['uSaturation'] = this.#saturation;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

class SketchPass extends Pass {
    constructor(camera) {
        super();
        let material = new ShaderMaterial({ shaderSource: 'sketch' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(renderer, readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.material.uniforms['colorMap'] = readBuffer.getTexture();
        renderer.pushRenderTarget(renderToScreen ? null : writeBuffer);
        renderer.render(this.scene, this.camera, 0, context);
        renderer.popRenderTarget();
    }
}

let tempVec2$3 = create();
class Composer {
    #width = 0;
    #height = 0;
    enabled = true;
    passes = [];
    renderTarget1;
    renderTarget2;
    readBuffer;
    writeBuffer;
    constructor(renderTarget) {
        if (!renderTarget) {
            let rendererSize = new Graphics().getSize();
            renderTarget = new RenderTarget({ width: rendererSize[0], height: rendererSize[1], depthBuffer: true, stencilBuffer: true });
        }
        this.#setRenderTarget(renderTarget);
    }
    render(delta, context) {
        let pass;
        let swapBuffer;
        new Graphics().getSize(tempVec2$3);
        this.setSize(tempVec2$3[0], tempVec2$3[1]);
        let lastPass = -1;
        for (let i = this.passes.length - 1; i > 0; --i) {
            if (this.passes[i].enabled) {
                lastPass = i;
                break;
            }
        }
        for (let i = 0, l = this.passes.length; i < l; ++i) {
            pass = this.passes[i];
            if (!pass.enabled) {
                continue;
            }
            if (pass.swapBuffers) {
                swapBuffer = this.readBuffer;
                this.readBuffer = this.writeBuffer;
                this.writeBuffer = swapBuffer;
            }
            pass.render(new Graphics(), this.readBuffer, this.writeBuffer, i == lastPass, delta, context);
        }
    }
    savePicture(filename, width, height) {
        this.setSize(width, height);
        this.render(0, { DisableToolRendering: true });
        new Graphics()._savePicture(filename);
    }
    addPass(pass) {
        this.passes.push(pass);
        new Graphics().getSize(tempVec2$3);
        pass.setSize(tempVec2$3[0], tempVec2$3[1]);
    }
    #setRenderTarget(renderTarget) {
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
    }
    setSize(width, height) {
        if (this.#width != width || this.#height != height) {
            this.#width = width;
            this.#height = height;
            this.renderTarget1.resize(width, height);
            this.renderTarget2.resize(width, height);
            for (let i = 0, l = this.passes.length; i < l; ++i) {
                this.passes[i].setSize(width, height);
            }
        }
    }
}

class CameraControl {
    #camera;
    #enabled = true;
    constructor(camera) {
        this.#camera = camera;
    }
    set enabled(enabled) {
        this.#enabled = enabled;
        this.handleEnabled();
    }
    get enabled() {
        return this.#enabled && !new Graphics().dragging;
    }
    set camera(camera) {
        this.#camera = camera;
        this.setupCamera();
    }
    get camera() {
        return this.#camera;
    }
    setupCamera() {
    }
    handleEnabled() {
    }
    update(delta) {
    }
}

let EPSILON = 0.000001;
class Spherical {
    theta;
    phi;
    radius;
    constructor(theta = 0, phi = 0, radius = 1.0) {
        this.set(theta, phi, radius);
    }
    set(theta = 0, phi = 0, radius = 1.0) {
        this.theta = theta;
        this.phi = phi;
        this.radius = radius;
    }
    clone() {
        return new Spherical().copy(this);
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
    }
    makeSafe() {
        this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
    setFromVector3(v) {
        this.setFromCartesianCoords(v[0], v[1], v[2]);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        }
        else {
            this.theta = Math.atan2(y, x);
            this.phi = Math.atan2(Math.sqrt(x * x + y * y), z);
        }
    }
    toCartesian(v) {
        let sinPhiRadius = Math.sin(this.phi) * this.radius;
        v[0] = sinPhiRadius * Math.cos(this.theta);
        v[1] = sinPhiRadius * Math.sin(this.theta);
        v[2] = Math.cos(this.phi) * this.radius;
    }
}

const xUnitVec3$1 = fromValues$4(1, 0, 0);
fromValues$4(0, 1, 0);
const zUnitVec3$2 = fromValues$4(0, 0, 1);
const minusZUnitVec3 = fromValues$4(0, 0, -1);
const tempVec3$t = create$4();
const spherical$1 = new Spherical();
class FirstPersonControl extends CameraControl {
    #enableDamping = false;
    #dampingFactor = 0.05;
    #sphericalDelta = new Spherical();
    #rotateDelta = create();
    movementSpeed = 1.0;
    lookSpeed = 0.005;
    #rotateSpeed = 0.3;
    lookVertical = true;
    autoForward = false;
    activeLook = true;
    heightSpeed = false;
    heightCoef = 1.0;
    heightMin = 0.0;
    heightMax = 1.0;
    constrainVertical = false;
    verticalMin = 0;
    verticalMax = Math.PI;
    #mouseDragOn = false;
    #autoSpeedFactor = 0.0;
    #mouseX = 0;
    #mouseY = 0;
    #moveForward = false;
    #moveBackward = false;
    #moveLeft = false;
    #moveRight = false;
    #moveUp = false;
    #moveDown = false;
    #viewHalfX = 0;
    #viewHalfY = 0;
    #lat = 0;
    #lon = 0;
    #startLat = 0;
    #startLon = 0;
    #click = false;
    #q = create$2();
    #quatInverse = create$2();
    #clickOffsetX;
    #clickOffsetY;
    constructor(camera) {
        super(camera);
        //private
        //var target = vec3.create();
        //todo: set in webglcanvas
        /*if (this.htmlElement !== document) {
            this.htmlElement.setAttribute('tabindex', - 1);
        }*/
        this.#setupEventsListeners();
        this.#handleResize();
        //this.update();
        invert$2(this.#quatInverse, this.#q);
        this.#setOrientation();
    }
    #handleResize() {
        return;
        /*
        if (this.htmlElement === document) {
            this.viewHalfX = window.innerWidth / 2;
            this.viewHalfY = window.innerHeight / 2;
        } else {
            this.viewHalfX = this.htmlElement.offsetWidth / 2;
            this.viewHalfY = this.htmlElement.offsetHeight / 2;
        }
            */
    }
    #onMouseDown(event) {
        if (!this.enabled) {
            return;
        }
        //if (this.htmlElement !== document) {
        //this.htmlElement.focus();
        //}
        //event.preventDefault();
        //event.stopPropagation();
        const mouseEvent = event.detail.mouseEvent;
        if (this.activeLook) {
            switch (mouseEvent.button) {
                case 0:
                    this.#click = true;
                    this.#clickOffsetX = mouseEvent.offsetX;
                    this.#clickOffsetY = mouseEvent.offsetY;
                    this.#startLat = this.#lat;
                    this.#startLon = this.#lon;
                    this.#mouseX = 0;
                    this.#mouseY = 0;
                    break;
                //case 0: this.#moveForward = true; break;
                //case 2: this.#moveBackward = true; break;
            }
        }
        event.target.requestPointerLock();
        this.#mouseDragOn = true;
    }
    #onMouseUp(event) {
        document.exitPointerLock();
        const mouseEvent = event.detail.mouseEvent;
        mouseEvent.preventDefault();
        //event.stopPropagation();
        if (this.activeLook) {
            switch (mouseEvent.button) {
                case 0:
                    this.#click = false;
                    this.#startLat = this.#lat;
                    this.#startLon = this.#lon;
                    break;
                case 0:
                    this.#moveForward = false;
                    break;
                case 2:
                    this.#moveBackward = false;
                    break;
            }
        }
        this.#mouseDragOn = false;
    }
    #onMouseMove(event) {
        const mouseEvent = event.detail.mouseEvent;
        if (this.#mouseDragOn) {
            {
                /*this.#mouseX = (event.offsetX - this.viewHalfX - this.#clickOffsetX);
                this.#mouseY = (event.offsetY - this.viewHalfY - this.#clickOffsetY);
                this.#mouseX = (event.offsetX - this.#clickOffsetX);
                this.#mouseY = (event.offsetY - this.#clickOffsetY);*/
                this.#mouseX += mouseEvent.movementX;
                this.#mouseY += mouseEvent.movementY;
                //console.error(event, this.#clickOffsetX, this.#clickOffsetY);
            }
            //console.error(this.#mouseX, this.#mouseY);
            this.#rotateDelta[0] = mouseEvent.movementX * this.#rotateSpeed;
            this.#rotateDelta[1] = mouseEvent.movementY * this.#rotateSpeed;
            //console.error(event.movementX, event.movementY, ...this.#rotateDelta);
            const element = mouseEvent.target;
            this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
            this.#rotateUp(-2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        }
    }
    #onKeyDown(event) {
        //event.preventDefault();
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#moveForward = true;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#moveLeft = true;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#moveBackward = true;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#moveRight = true;
                break;
            case 'Space':
                this.#moveUp = true;
                break;
            case 'KeyC':
                this.#moveDown = true;
                break;
        }
        //console.error(event.code);//removeme
    }
    #onKeyUp(event) {
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#moveForward = false;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#moveLeft = false;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#moveBackward = false;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#moveRight = false;
                break;
            case 'Space':
                this.#moveUp = false;
                break;
            case 'KeyC':
                this.#moveDown = false;
                break;
        }
    }
    update(delta = 0) {
        if (this.enabled === false) {
            return;
        }
        if (this.heightSpeed) {
            var y = clamp(this.camera.position[1], this.heightMin, this.heightMax); //TODO
            var heightDelta = y - this.heightMin;
            this.#autoSpeedFactor = delta * (heightDelta * this.heightCoef);
        }
        else {
            this.#autoSpeedFactor = 0.0;
        }
        var actualMoveSpeed = delta * this.movementSpeed;
        if (this.#moveForward || (this.autoForward && !this.#moveBackward)) {
            this.camera.translateZ(-(actualMoveSpeed + this.#autoSpeedFactor));
        }
        if (this.#moveBackward) {
            this.camera.translateZ(actualMoveSpeed);
        }
        if (this.#moveLeft) {
            this.camera.translateX(-actualMoveSpeed);
        }
        if (this.#moveRight) {
            this.camera.translateX(actualMoveSpeed);
        }
        if (this.#moveUp) {
            this.camera.translateY(actualMoveSpeed);
        }
        if (this.#moveDown) {
            this.camera.translateY(-actualMoveSpeed);
        }
        var actualLookSpeed = this.lookSpeed;
        if (!this.activeLook) {
            actualLookSpeed = 0;
        }
        if (!this.#click) {
            actualLookSpeed = 0;
        }
        var verticalLookRatio = 1;
        if (this.constrainVertical) {
            verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
        }
        //this.#lon -= this.#mouseX * actualLookSpeed;
        this.#lon = this.#startLon - this.#mouseX * actualLookSpeed;
        if (this.#click) ;
        if (this.lookVertical) {
            this.#lat = this.#startLat - this.#mouseY * actualLookSpeed * verticalLookRatio;
        }
        if (this.#click) ;
        if (this.#enableDamping) {
            spherical$1.theta += this.#sphericalDelta.theta * this.#dampingFactor;
            spherical$1.phi += this.#sphericalDelta.phi * this.#dampingFactor;
        }
        else {
            spherical$1.theta += this.#sphericalDelta.theta;
            spherical$1.phi += this.#sphericalDelta.phi;
        }
        //this.#lat = Math.max(- 85, Math.min(85, this.#lat));
        //this.#lat = 90;//removeme
        var phi = DEG_TO_RAD * (90 - this.#lat);
        DEG_TO_RAD * (this.#lon);
        if (this.#click) ;
        function mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        }
        if (this.constrainVertical) {
            phi = mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);
        }
        var position = this.camera.position;
        spherical$1.toCartesian(tempVec3$t);
        // rotate offset back to 'camera-up-vector-is-up' space
        //offset.applyQuaternion(quatInverse);
        //vec3.transformQuat(tempVec3, tempVec3, this.#quatInverse);
        //position.copy(this.target).add(offset);
        add$5(position, position, tempVec3$t);
        this.camera.lookAt(position); //TODO: optimize
        if (this.#enableDamping === true) {
            this.#sphericalDelta.theta *= (1 - this.#dampingFactor);
            this.#sphericalDelta.phi *= (1 - this.#dampingFactor);
            //this.panOffset.multiplyScalar(1 - this.#dampingFactor);
        }
        else {
            this.#sphericalDelta.set(0, 0, 0);
            //vec3.set(this.panOffset, 0, 0, 0);
        }
        return;
        /*

        def from_spherical_coords(theta_phi, phi=None):
        """Return the quaternion corresponding to these spherical coordinates

        Assumes the spherical coordinates correspond to the quaternion R via

            R = exp(phi*z/2) * exp(theta*y/2)

        The angles naturally must be in radians for this to make any sense.

        Note that this quaternion rotates `z` onto the point with the given
        spherical coordinates, but also rotates `x` and `y` onto the usual basis
        vectors (theta and phi, respectively) at that point.

        Parameters
        ----------
        theta_phi: float or array of floats
            This argument may either contain an array with last dimension of
            size 2, where those two elements describe the (theta, phi) values in
            radians for each point; or it may contain just the theta values in
            radians, in which case the next argument must also be given.
        phi: None, float, or array of floats
            If this array is given, it must be able to broadcast against the
            first argument.

        Returns
        -------
        R: quaternion array
            If the second argument is not given to this function, the shape
            will be the same as the input shape except for the last dimension,
            which will be removed.If the second argument is given, this
            output array will have the shape resulting from broadcasting the
            two input arrays against each other.

        """
        # Figure out the input angles from either type of input
        if phi is None:
            theta_phi = np.asarray(theta_phi, dtype=np.double)
            theta = theta_phi[..., 0]
            phi = theta_phi[..., 1]
        else:
            theta = np.asarray(theta_phi, dtype=np.double)
            phi = np.asarray(phi, dtype=np.double)

        # Set up the output array
        R = np.empty(np.broadcast(theta, phi).shape + (4,), dtype=np.double)

        # Compute the actual values of the quaternion components
        R[..., 0] = np.cos(phi/2)*np.cos(theta/2) # scalar quaternion components
        R[..., 1] = -np.sin(phi/2)*np.sin(theta/2) # x quaternion components
        R[..., 2] = np.cos(phi/2)*np.sin(theta/2) # y quaternion components
        R[..., 3] = np.sin(phi/2)*np.cos(theta/2) # z quaternion components

        return as_quat_array(R)
        */
    }
    contextmenu(event) {
        event.preventDefault();
    }
    #setOrientation() {
        /*

        var position = this.camera._position;

        //offset.copy(position).sub(this.target);
        vec3.sub(tempVec3, position, this._target);

        // rotate offset to 'y-axis-is-up' space
        //offset.applyQuaternion(q);
        vec3.transformQuat(tempVec3, tempVec3, this.#q);

        // angle from z-axis around y-axis
        spherical.setFromVector3(tempVec3);
        */
        copy$4(tempVec3$t, xUnitVec3$1 /*minusZUnitVec3*/);
        transformQuat$1(tempVec3$t, tempVec3$t, this.camera._quaternion);
        spherical$1.setFromVector3(tempVec3$t);
        this.#lat = -(90 - RAD_TO_DEG * (spherical$1.phi));
        this.#lon = -RAD_TO_DEG * (spherical$1.theta);
        this.#startLat = this.#lat;
        this.#startLon = this.#lon;
        this.update();
    }
    #onContextMenu(event) {
        if (this.enabled === false)
            return;
        event.preventDefault();
    }
    #setupEventsListeners() {
        //this.htmlElement.addEventListener('contextmenu', event => this.#onContextMenu(event));
        //this.htmlElement.addEventListener('mousemove', event => this.#onMouseMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => this.#onMouseMove(event));
        //this.htmlElement.addEventListener('mousedown', event => this.#onMouseDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => this.#onMouseDown(event));
        //this.htmlElement.addEventListener('mouseup', event => this.#onMouseUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => this.#onMouseUp(event));
        //this.htmlElement.addEventListener('keydown', event => this.#onKeyDown(event), false);
        GraphicsEvents.addEventListener(GraphicsEvent.KeyDown, (event) => this.#onKeyDown(event));
        //this.htmlElement.addEventListener('keyup', event => this.#onKeyUp(event), false);
        GraphicsEvents.addEventListener(GraphicsEvent.KeyUp, (event) => this.#onKeyUp(event));
    }
    setupCamera() {
        if (this.camera) {
            rotationTo(this.#q, this.camera.upVector, zUnitVec3$2);
            this.#quatInverse = invert$2(this.#quatInverse, this.#q);
            transformQuat$1(tempVec3$t, minusZUnitVec3, this.camera.quaternion);
            spherical$1.setFromVector3(tempVec3$t);
        }
    }
    handleEnabled() {
        if (this.enabled) {
            this.setupCamera();
        }
    }
    #rotateLeft(angle) {
        this.#sphericalDelta.theta -= angle;
    }
    #rotateUp(angle) {
        this.#sphericalDelta.phi -= angle;
    }
}

// It is just a basic entity
class Target extends Entity {
    static async constructFromJSON(json) {
        return new Target({ name: json.name });
    }
    static getEntityName() {
        return 'Target';
    }
}
registerEntity(Target);

// This set of controls performs orbiting, dollying(zooming), and panning.
// Unlike TrackballControls, it maintains the 'up' direction object.up(+Y by default).
//
// Orbit - left mouse / touch: one-finger move
// Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
// Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const zUnitVec3$1 = fromValues$4(0, 0, 1);
const tempVec3$s = create$4();
const tempVec3_2$9 = create$4();
const spherical = new Spherical();
// Mouse buttons
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2, NONE: -1 };
({ LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN });
// Touch fingers
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
const STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
};
class OrbitControl extends CameraControl {
    #upVector = fromValues$4(0, 0, 1);
    #keyRotateHorizontal = 0;
    #keyRotateVertical = 0;
    #autoRotate = false;
    #autoRotateSpeed = 1.0;
    #enableDamping = false;
    #target = new Target({ name: 'Orbit control target' });
    #minDistance = 0;
    #maxDistance = Infinity;
    #minZoom = 0.01;
    #maxZoom = Infinity;
    #minPolarAngle = 0;
    #maxPolarAngle = Math.PI;
    #minAzimuthAngle = -Infinity;
    #maxAzimuthAngle = Infinity;
    #dampingFactor = 0.05;
    #enableDolly = true;
    #dollySpeed = 1.0;
    #enableRotate = true;
    #rotateSpeed = 1.0;
    #enablePan = true;
    #panSpeed = 0.001;
    #screenSpacePanning = false; // if true, pan in screen-space
    #keyPanSpeed = 7.0; // pixels moved per arrow key push
    #enableKeys = true;
    #position0 = create$4();
    #mouseButtons = [MOUSE.ROTATE, MOUSE.DOLLY, MOUSE.PAN];
    #state = STATE.NONE;
    #scale = 1.0;
    #q = create$2();
    #quatInverse = create$2();
    #lastPosition = create$4();
    #lastQuaternion = create$2();
    #sphericalDelta = new Spherical();
    #panOffset = create$4();
    #zoomChanged = false;
    #rotateStart = create();
    #rotateEnd = create();
    #rotateDelta = create();
    #panStart = create();
    #panEnd = create();
    #panDelta = create();
    #dollyStart = create();
    #dollyEnd = create();
    #dollyDelta = create();
    constructor(camera) {
        super(camera);
        //TODO end
        if (camera) {
            copy$4(this.#position0, camera.position);
        }
        this.setupCamera();
        this.#setupEventsListeners();
        this.update();
    }
    set target(target) {
        this.#target = target;
        this.update();
    }
    get target() {
        return this.#target;
    }
    setTargetPosition(position) {
        this.#target.position = position;
        this.update();
    }
    set upVector(upVector) {
        copy$4(this.#upVector, upVector);
        this.update();
    }
    get upVector() {
        return this.#upVector;
    }
    set minPolarAngle(minPolarAngle) {
        this.#minPolarAngle = minPolarAngle;
    }
    get minPolarAngle() {
        return this.#minPolarAngle;
    }
    set maxPolarAngle(maxPolarAngle) {
        this.#maxPolarAngle = maxPolarAngle;
    }
    get maxPolarAngle() {
        return this.#maxPolarAngle;
    }
    set dampingFactor(dampingFactor) {
        this.#dampingFactor = dampingFactor;
    }
    get dampingFactor() {
        return this.#dampingFactor;
    }
    setupCamera() {
        if (this.camera) {
            rotationTo(this.#q, this.#upVector, zUnitVec3$1);
            this.#quatInverse = invert$2(this.#quatInverse, this.#q);
        }
    }
    update(delta = 1) {
        if (this.enabled === false) {
            return;
        }
        var position = this.camera._position;
        //offset.copy(position).sub(this.target);
        sub$2(tempVec3$s, position, this.#target.getWorldPosition()); //TODO: optimise
        // rotate offset to 'y-axis-is-up' space
        //offset.applyQuaternion(q);
        transformQuat$1(tempVec3$s, tempVec3$s, this.#q);
        // angle from z-axis around y-axis
        spherical.setFromVector3(tempVec3$s);
        if (this.#autoRotate && this.#state === STATE.NONE) {
            this.#rotateLeft(this.#autoRotateSpeed);
        }
        if (this.#keyRotateVertical) {
            this.#rotateUp(this.#keyRotateVertical * 2 * Math.PI * delta);
        }
        if (this.#keyRotateHorizontal) {
            this.#rotateLeft(this.#keyRotateHorizontal * 2 * Math.PI * delta);
        }
        if (this.#enableDamping) {
            spherical.theta += this.#sphericalDelta.theta * this.#dampingFactor;
            spherical.phi += this.#sphericalDelta.phi * this.#dampingFactor;
        }
        else {
            spherical.theta += this.#sphericalDelta.theta;
            spherical.phi += this.#sphericalDelta.phi;
        }
        // restrict theta to be between desired limits
        spherical.theta = Math.max(this.#minAzimuthAngle, Math.min(this.#maxAzimuthAngle, spherical.theta));
        // restrict phi to be between desired limits
        spherical.phi = Math.max(this.#minPolarAngle, Math.min(this.#maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= this.#scale;
        // restrict radius to be between desired limits
        spherical.radius = Math.max(this.#minDistance, Math.min(this.#maxDistance, spherical.radius));
        // move target to panned location
        if (this.#enableDamping === true) {
            scaleAndAdd$2(tempVec3_2$9, this.#target._position, this.#panOffset, this.#dampingFactor);
            this.#target.setPosition(tempVec3_2$9);
        }
        else {
            //this.target.add(this.#panOffset);
            add$5(tempVec3_2$9, this.#target._position, this.#panOffset);
            this.#target.setPosition(tempVec3_2$9);
        }
        spherical.toCartesian(tempVec3$s);
        // rotate offset back to 'camera-up-vector-is-up' space
        //offset.applyQuaternion(quatInverse);
        transformQuat$1(tempVec3$s, tempVec3$s, this.#quatInverse);
        //position.copy(this.target).add(offset);
        add$5(tempVec3$s, this.#target.getWorldPosition(), tempVec3$s);
        this.camera.setPosition(tempVec3$s);
        this.camera.lookAt(this.#target.getWorldPosition(), this.#upVector); //TODO: optimize
        if (this.#enableDamping === true) {
            this.#sphericalDelta.theta *= (1 - this.#dampingFactor);
            this.#sphericalDelta.phi *= (1 - this.#dampingFactor);
            scale$5(this.#panOffset, this.#panOffset, 1 - this.#dampingFactor);
        }
        else {
            this.#sphericalDelta.set(0, 0, 0);
            set$5(this.#panOffset, 0, 0, 0);
        }
        this.#scale = 1;
        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > Number.EPSILON
        // using small-angle approximation cos(x/2)= 1 - x^2 / 8
        if (this.#zoomChanged ||
            squaredDistance$2(this.#lastPosition, this.camera._position) > Number.EPSILON ||
            8 * (1 - dot$2(this.#lastQuaternion, this.camera._quaternion)) > Number.EPSILON) {
            //this.dispatchEvent(changeEvent);
            copy$4(this.#lastPosition, this.camera._position);
            copy$2(this.#lastQuaternion, this.camera._quaternion);
            this.#zoomChanged = false;
            //this.camera.dirtyCameraMatrix = true;
            return true;
        }
        return false;
    }
    set autoRotateSpeed(speed) {
        this.#autoRotateSpeed = 2 * Math.PI / 60 / 60 * speed;
    }
    get zoomScale() {
        return Math.pow(0.95, this.#dollySpeed);
    }
    #rotateLeft(angle) {
        this.#sphericalDelta.theta -= angle;
    }
    #rotateUp(angle) {
        this.#sphericalDelta.phi -= angle;
    }
    #panLeft(distance, rotation) {
        transformQuat$1(tempVec3$s, [1, 0, 0], rotation);
        scale$5(tempVec3$s, tempVec3$s, -distance);
        add$5(this.#panOffset, this.#panOffset, tempVec3$s);
    }
    #panUp(distance, rotation) {
        transformQuat$1(tempVec3$s, [0, 1, 0], rotation);
        scale$5(tempVec3$s, tempVec3$s, distance);
        add$5(this.#panOffset, this.#panOffset, tempVec3$s);
    }
    #pan(deltaX, deltaY, element) {
        if (this.camera.isPerspective) {
            // perspective
            var position = this.camera.position;
            //offset.copy(position).sub(this.target);
            sub$2(tempVec3$s, position, this.#target.getWorldPosition()); //todo // OPTIMIZE:
            var targetDistance = len$4(tempVec3$s);
            // half of the fov is center to top of screen
            targetDistance *= this.camera.getTanHalfVerticalFov(); //Math.tan((this.camera.fov / 2)* Math.PI / 180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            this.#panLeft(2 * deltaX * targetDistance / element.clientHeight, this.camera._quaternion);
            this.#panUp(2 * deltaY * targetDistance / element.clientHeight, this.camera._quaternion);
        }
        else if (this.camera.isOrthographic) {
            // orthographic
            this.#panLeft(deltaX * (this.camera.right - this.camera.left) / this.camera.orthoZoom / element.clientWidth, this.camera._quaternion);
            this.#panUp(deltaY * (this.camera.top - this.camera.bottom) / this.camera.orthoZoom / element.clientHeight, this.camera._quaternion);
        }
        else {
            this.#enablePan = false;
        }
    }
    #dollyIn(dollyScale) {
        if (this.camera.isPerspective) {
            this.#scale /= dollyScale;
        }
        else if (this.camera.isOrthographic) {
            this.camera.orthoZoom = Math.max(this.#minZoom, Math.min(this.#maxZoom, this.camera.orthoZoom * dollyScale));
            this.#zoomChanged = true;
        }
        else {
            this.#enableDolly = false;
        }
    }
    #dollyOut(dollyScale) {
        if (this.camera.isPerspective) {
            this.#scale *= dollyScale;
        }
        else if (this.camera.isOrthographic) {
            this.camera.orthoZoom = Math.max(this.#minZoom, Math.min(this.#maxZoom, this.camera.orthoZoom / dollyScale));
            this.#zoomChanged = true;
        }
        else {
            this.#enableDolly = false;
        }
    }
    #handleMouseDownRotate(event) {
        set$1(this.#rotateStart, event.clientX, event.clientY);
    }
    #handleMouseDownDolly(event) {
        set$1(this.#dollyStart, event.clientX, event.clientY);
    }
    #handleMouseDownPan(event) {
        set$1(this.#panStart, event.clientX, event.clientY);
    }
    #handleMouseMoveRotate(event) {
        const mouseEvent = event.detail.mouseEvent;
        set$1(this.#rotateEnd, mouseEvent.clientX, mouseEvent.clientY);
        this.#rotateDelta[0] = mouseEvent.movementX * this.#rotateSpeed;
        this.#rotateDelta[1] = mouseEvent.movementY * this.#rotateSpeed;
        //console.error(event.movementX, event.movementY, ...this.#rotateDelta);
        const element = mouseEvent.target;
        this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
        this.#rotateUp(2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        copy(this.#rotateStart, this.#rotateEnd);
        this.update();
    }
    #handleMouseMoveDolly(event) {
        //console.error(event.movementX, event.movementY, ...this.#dollyDelta);
        //dollyEnd.set(event.clientX, event.clientY);
        set$1(this.#dollyEnd, event.movementX, event.movementY);
        //dollyDelta.subVectors(dollyEnd, dollyStart);
        //vec2.sub(this.#dollyDelta, this.#dollyEnd, this.#dollyStart);
        sub(this.#dollyDelta, this.#dollyDelta, this.#dollyEnd);
        if (this.#dollyDelta[1] > 0) {
            this.#dollyIn(this.zoomScale);
        }
        else if (this.#dollyDelta[1] < 0) {
            this.#dollyOut(this.zoomScale);
        }
        //dollyStart.copy(dollyEnd);
        //vec2.copy(this.#dollyStart, this.#dollyEnd);
        this.update();
    }
    #handleMouseMovePan(event) {
        this.#panSpeed = 1.0;
        this.#panDelta[0] = event.detail.mouseEvent.movementX * this.#panSpeed;
        this.#panDelta[1] = event.detail.mouseEvent.movementY * this.#panSpeed;
        this.#pan(this.#panDelta[0], this.#panDelta[1], event.detail.mouseEvent.target);
        this.update();
    }
    #handleMouseWheel(event) {
        //console.error(event.deltaY, this.zoomScale);
        const wheelEvent = event.detail.wheelEvent;
        if (wheelEvent.deltaY < 0) {
            this.#dollyOut(this.zoomScale);
        }
        else if (wheelEvent.deltaY > 0) {
            this.#dollyIn(this.zoomScale);
        }
        this.update();
    }
    #handleKeyDown(event) {
        if (this.enabled === false || this.#enableKeys === false || this.#enablePan === false) {
            return;
        }
        const keyboardEvent = event.detail.keyboardEvent;
        var needsUpdate = false;
        if (keyboardEvent.ctrlKey || keyboardEvent.metaKey || keyboardEvent.altKey) {
            return;
        }
        if (keyboardEvent.shiftKey) {
            switch (keyboardEvent.code) {
                case 'ArrowUp':
                case 'KeyW':
                    this.#keyRotateVertical = 1;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    this.#keyRotateVertical = -1;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    this.#keyRotateHorizontal = 1;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    this.#keyRotateHorizontal = -1;
                    break;
            }
            return;
        }
        switch (keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#pan(0, this.#keyPanSpeed, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#pan(0, -this.#keyPanSpeed, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#pan(this.#keyPanSpeed, 0, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#pan(-this.#keyPanSpeed, 0, keyboardEvent.target);
                needsUpdate = true;
                break;
            /*


            case 'ArrowUp':
            case 'KeyW': /*W* / this.moveForward = true; break;

            case 'ArrowLeft': /*left* /
            case 'KeyA': /*A* / this.moveLeft = true; break;

            case 'ArrowDown': /*down* /
            case 'KeyS': /*S* / this.moveBackward = true; break;

            case 'ArrowRight': /*right* /
            case 'KeyD': /*D* / this.moveRight = true; break;

            case 'KeyR': /*R* / this.moveUp = true; break;
            case 'KeyF': /*F* / this.moveDown = true; break;
            */
        }
        if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            keyboardEvent.preventDefault();
            this.update();
        }
    }
    #handleKeyUp(event) {
        if (this.enabled === false || this.#enableKeys === false || this.#enablePan === false) {
            return;
        }
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
            case 'ArrowDown':
            case 'KeyS':
                this.#keyRotateVertical = 0;
                break;
            case 'ArrowLeft':
            case 'KeyA':
            case 'ArrowRight':
            case 'KeyD':
                this.#keyRotateHorizontal = 0;
                break;
        }
    }
    #handleTouchStartRotate(event) {
        if (event.touches.length == 1) {
            set$1(this.#rotateStart, event.touches[0].pageX, event.touches[0].pageY);
        }
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            set$1(this.#rotateStart, x, y);
        }
    }
    #handleTouchStartPan(event) {
        if (event.touches.length == 1) {
            set$1(this.#panStart, event.touches[0].pageX, event.touches[0].pageY);
        }
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            set$1(this.#panStart, x, y);
        }
    }
    #handleTouchStartDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        set$1(this.#dollyStart, 0, distance);
    }
    #handleTouchStartDollyPan(event) {
        if (this.#enableDolly)
            this.#handleTouchStartDolly(event);
        if (this.#enablePan)
            this.#handleTouchStartPan(event);
    }
    #handleTouchStartDollyRotate(event) {
        if (this.#enableDolly)
            this.#handleTouchStartDolly(event);
        if (this.#enableRotate)
            this.#handleTouchStartRotate(event);
    }
    #handleTouchMoveRotate(event) {
        if (event.touches.length == 1) {
            set$1(this.#rotateEnd, event.touches[0].pageX, event.touches[0].pageY);
        }
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            set$1(this.#rotateEnd, x, y);
        }
        sub(this.#rotateDelta, this.#rotateEnd, this.#rotateStart);
        scale$1(this.#rotateDelta, this.#rotateDelta, this.#rotateSpeed);
        const element = event.target;
        this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
        this.#rotateUp(2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        copy(this.#rotateStart, this.#rotateEnd);
    }
    #handleTouchMovePan(event) {
        if (event.touches.length == 1) {
            //panEnd.set(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
            set$1(this.#panEnd, event.touches[0].pageX, event.touches[0].pageY);
        }
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            //panEnd.set(x, y);
            set$1(this.#panEnd, x, y);
        }
        //panDelta.subVectors(panEnd, panStart).multiplyScalar(this.#panSpeed);
        scale$1(this.#panDelta, sub(this.#panDelta, this.#panEnd, this.#panStart), this.#panSpeed);
        this.#pan(this.#panDelta[0], this.#panDelta[1], event.target);
        copy(this.#panStart, this.#panEnd);
    }
    #handleTouchMoveDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        //dollyEnd.set(0, distance);
        set$1(this.#dollyEnd, 0, distance);
        set$1(this.#dollyDelta, 0, Math.pow(this.#dollyEnd[1] / this.#dollyStart[1], this.#dollySpeed));
        this.#dollyIn(this.#dollyDelta[1]);
        //dollyStart.copy(this.#dollyEnd);
        copy(this.#dollyStart, this.#dollyEnd);
    }
    #handleTouchMoveDollyPan(event) {
        if (this.#enableDolly)
            this.#handleTouchMoveDolly(event);
        if (this.#enablePan)
            this.#handleTouchMovePan(event);
    }
    #handleTouchMoveDollyRotate(event) {
        if (this.#enableDolly)
            this.#handleTouchMoveDolly(event);
        if (this.#enableRotate)
            this.#handleTouchMoveRotate(event);
    }
    #onMouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.detail.entity?.getLayer() > 0) {
            return;
        }
        // Prevent the browser from scrolling.
        event.preventDefault();
        const mouseEvent = event.detail.mouseEvent;
        // Manually set the focus since calling preventDefault above
        // prevents the browser from setting it automatically.
        //this.htmlElement.focus ? this.htmlElement.focus(): window.focus();
        let action = this.#mouseButtons[mouseEvent.button];
        const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2, NONE: -1 };
        switch (action) {
            case MOUSE.ROTATE:
                if (this.#enableRotate) {
                    this.#handleMouseDownRotate(event);
                    this.#state = STATE.ROTATE;
                    mouseEvent.target.requestPointerLock();
                }
                break;
            case MOUSE.DOLLY:
                if (this.#enableDolly) {
                    this.#handleMouseDownDolly(event);
                    this.#state = STATE.DOLLY;
                    mouseEvent.target.requestPointerLock();
                }
                break;
            case MOUSE.PAN:
                if (this.#enablePan) {
                    this.#handleMouseDownPan(event);
                    this.#state = STATE.PAN;
                    mouseEvent.target.requestPointerLock();
                }
                break;
        }
    }
    #onMouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        event.preventDefault();
        switch (this.#state) {
            case STATE.ROTATE:
                if (this.#enableRotate === false)
                    return;
                this.#handleMouseMoveRotate(event);
                break;
            case STATE.DOLLY:
                if (this.#enableDolly === false)
                    return;
                this.#handleMouseMoveDolly(event);
                break;
            case STATE.PAN:
                if (this.#enablePan === false)
                    return;
                this.#handleMouseMovePan(event);
                break;
        }
    }
    #onMouseUp(event) {
        document.exitPointerLock();
        if (this.enabled === false) {
            return;
        }
        this.#state = STATE.NONE;
    }
    #onMouseWheel(event) {
        if (this.enabled === false || this.#enableDolly === false || (this.#state !== STATE.NONE && this.#state !== STATE.ROTATE))
            return;
        event.preventDefault();
        event.stopPropagation();
        this.#handleMouseWheel(event);
    }
    #onTouchStart(event) {
        if (this.enabled === false) {
            return;
        }
        const touchEvent = event.detail.touchEvent;
        touchEvent.preventDefault();
        switch (touchEvent.touches.length) {
            case 1:
                switch (touches.ONE) {
                    case TOUCH.ROTATE:
                        if (this.#enableRotate === false)
                            return;
                        this.#handleTouchStartRotate(touchEvent);
                        this.#state = STATE.TOUCH_ROTATE;
                        break;
                    case TOUCH.PAN:
                        if (this.#enablePan === false)
                            return;
                        this.#handleTouchStartPan(touchEvent);
                        this.#state = STATE.TOUCH_PAN;
                        break;
                    default:
                        this.#state = STATE.NONE;
                }
                break;
            case 2:
                switch (touches.TWO) {
                    case TOUCH.DOLLY_PAN:
                        if (this.#enableDolly === false && this.#enablePan === false)
                            return;
                        this.#handleTouchStartDollyPan(touchEvent);
                        this.#state = STATE.TOUCH_DOLLY_PAN;
                        break;
                    case TOUCH.DOLLY_ROTATE:
                        if (this.#enableDolly === false && this.#enableRotate === false)
                            return;
                        this.#handleTouchStartDollyRotate(touchEvent);
                        this.#state = STATE.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        this.#state = STATE.NONE;
                }
                break;
            default:
                this.#state = STATE.NONE;
        }
        if (this.#state !== STATE.NONE) ;
    }
    #onTouchMove(event) {
        if (this.enabled === false)
            return;
        const touchEvent = event.detail.touchEvent;
        touchEvent.preventDefault();
        touchEvent.stopPropagation();
        switch (this.#state) {
            case STATE.TOUCH_ROTATE:
                if (this.#enableRotate === false)
                    return;
                this.#handleTouchMoveRotate(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_PAN:
                if (this.#enablePan === false)
                    return;
                this.#handleTouchMovePan(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_DOLLY_PAN:
                if (this.#enableDolly === false && this.#enablePan === false)
                    return;
                this.#handleTouchMoveDollyPan(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_DOLLY_ROTATE:
                if (this.#enableDolly === false && this.#enableRotate === false)
                    return;
                this.#handleTouchMoveDollyRotate(touchEvent);
                this.update();
                break;
            default:
                this.#state = STATE.NONE;
        }
    }
    #onTouchCancel(event) {
        if (this.enabled === false) {
            return;
        }
        this.#state = STATE.NONE;
    }
    #onContextMenu(event) {
        if (this.enabled === false)
            return;
        event.preventDefault();
    }
    #setupEventsListeners() {
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => this.#onMouseDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => this.#onMouseMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => this.#onMouseUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.Wheel, (event) => this.#onMouseWheel(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchStart, (event) => this.#onTouchStart(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchMove, (event) => this.#onTouchMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchCancel, (event) => this.#onTouchCancel(event));
        GraphicsEvents.addEventListener(GraphicsEvent.KeyDown, (event) => this.#handleKeyDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.KeyUp, (event) => this.#handleKeyUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.update(event.detail.delta));
        // make sure element can receive keys.
        /*if(this.htmlElement.tabIndex === - 1) {
            this.htmlElement.tabIndex = 0;
        }*/
    }
    handleEnabled() {
        if (this.enabled) {
            this.update();
        }
    }
}
/*OrbitControls.prototype = Object.create(EventTarget.prototype);
OrbitControls.prototype.constructor = OrbitControls;*/
// This set of controls performs orbiting, dollying(zooming), and panning.
// Unlike TrackballControls, it maintains the 'up' direction object.up(+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
// Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
// Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
// Pan - left mouse, or arrow keys / touch: one-finger move
/*var MapControls = function(object, htmlElement) {

    OrbitControls.call(this, object, htmlElement);

    this.#mouseButtons.LEFT = MOUSE.PAN;
    this.#mouseButtons.RIGHT = MOUSE.ROTATE;

    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;

};

MapControls.prototype = Object.create(EventTarget.prototype);
MapControls.prototype.constructor = MapControls;*/

const Z_VECTOR$1 = fromValues$4(0, 0, 1);
const tempQuat$b = create$2();
class RotationControl extends Entity {
    #rotationSpeed = 1;
    #axis = clone$4(Z_VECTOR$1);
    constructor(params) {
        super(params);
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.#update(event.detail.delta));
    }
    set rotationSpeed(rotationSpeed) {
        this.#rotationSpeed = rotationSpeed;
    }
    get rotationSpeed() {
        return this.#rotationSpeed;
    }
    set axis(axis) {
        copy$4(this.#axis, axis);
        identity$1(this._quaternion);
    }
    get axis() {
        return clone$4(this.#axis);
    }
    #update(delta) {
        setAxisAngle(tempQuat$b, this.#axis, this.#rotationSpeed * delta);
        let quaternion = this._quaternion;
        mul$2(quaternion, quaternion, tempQuat$b);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            RotationControl_1: null,
            rotation_axis: { i18n: '#rotation_axis', f: () => { let v = prompt('Rotation axis', this.axis.join(' ')); if (v !== null) {
                    this.axis = stringToVec3(v);
                } } },
            rotation_speed: { i18n: '#rotation_speed', f: () => { let s = prompt('Rotation speed', String(this.rotationSpeed * RAD_TO_DEG)); if (s !== null) {
                    this.rotationSpeed = Number(s) * DEG_TO_RAD;
                } } },
        });
    }
}

var TranslationMode;
(function (TranslationMode) {
    TranslationMode[TranslationMode["Bounce"] = 0] = "Bounce";
    TranslationMode[TranslationMode["Loop"] = 1] = "Loop";
    TranslationMode[TranslationMode["Continue"] = 2] = "Continue";
})(TranslationMode || (TranslationMode = {}));
class TranslationControl extends Entity {
    #speed = 1;
    #startPoint = create$4();
    #endPoint = fromValues$4(10, 0, 0);
    #mode = TranslationMode.Bounce;
    #percent = 0;
    #bounceDirection = 1;
    constructor(params) {
        super(params);
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.#update(event.detail.delta));
    }
    #update(delta) {
        switch (this.#mode) {
            case TranslationMode.Bounce:
                let distance = distance$3(this.#startPoint, this.#endPoint);
                let deltaL = distance ? this.#speed * delta / distance : 1;
                let percent = this.#percent + deltaL * this.#bounceDirection;
                if (percent >= 1) {
                    this.#bounceDirection = -1;
                    percent = 1;
                }
                if (percent <= 0) {
                    this.#bounceDirection = 1;
                    percent = 0;
                }
                this.#percent = percent;
                lerp$5(this._position, this.#startPoint, this.#endPoint, this.#percent);
                break;
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            TranslationControl_1: null,
            speed: { i18n: '#speed', f: () => { let s = prompt('Speed', String(this.#speed)); if (s !== null) {
                    this.#speed = Number(s);
                } } },
            start_position: { i18n: '#start_position', f: () => { let v = prompt('Position', this.#startPoint.join(' ')); if (v !== null) {
                    stringToVec3(v, this.#startPoint);
                } } },
            end_position: { i18n: '#end_position', f: () => { let v = prompt('Position', this.#endPoint.join(' ')); if (v !== null) {
                    stringToVec3(v, this.#endPoint);
                } } },
        });
    }
}

class LineMaterial extends Material {
    #lineWidth = 1;
    constructor(params = {}) {
        super(params);
        this.lineWidth = params?.lineWidth ?? 10;
        this.setValues(params);
    }
    getShaderSource() {
        return 'line';
    }
    set lineWidth(lineWidth) {
        this.#lineWidth = lineWidth;
        this.uniforms['linewidth'] = lineWidth;
    }
    toJSON() {
        let json = super.toJSON();
        json.linewidth = this.#lineWidth;
        return json;
    }
    static async constructFromJSON(json) {
        return new LineMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.lineWidth = json.linewidth;
    }
    static getEntityName() {
        return 'LineMaterial';
    }
}
Material.materialList['Line'] = LineMaterial;
registerEntity(LineMaterial);

class InstancedBufferGeometry extends BufferGeometry {
    instanceCount;
    constructor(count = 0) {
        super();
        this.instanceCount = count;
        return this;
    }
}

class LineSegmentsGeometry extends InstancedBufferGeometry {
    constructor() {
        super();
        this.#setupGeometry();
    }
    #setupGeometry() {
        var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
        var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
        var indices = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(positions, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    setSegments(positions, colors, lineStrip) {
        let start = [];
        let end = [];
        let instanceCount = 0;
        let increment = lineStrip ? 3 : 6;
        for (let i = 0, l = positions.length; i < l; i += increment) {
            start.push(positions[i + 0]);
            start.push(positions[i + 1]);
            start.push(positions[i + 2]);
            end.push(positions[i + 3]);
            end.push(positions[i + 4]);
            end.push(positions[i + 5]);
            ++instanceCount;
        }
        let startAttribute = new Float32BufferAttribute(start, 3);
        startAttribute.divisor = 1;
        let endAttribute = new Float32BufferAttribute(end, 3);
        endAttribute.divisor = 1;
        this.setAttribute('aSegmentStart', startAttribute);
        this.setAttribute('aSegmentEnd', endAttribute);
        this.instanceCount = instanceCount;
    }
    updateGeometry() {
        /*************************/
        let start = [];
        let end = [];
        let x = Math.random();
        let y = Math.random();
        let z = Math.random();
        for (let i = 0; i < 10 * 3; i += 3) {
            start[i + 0] = x;
            start[i + 1] = y;
            start[i + 2] = z;
            x = Math.random();
            y = Math.random();
            z = Math.random();
            end[i + 0] = x;
            end[i + 1] = y;
            end[i + 2] = z;
        }
        let startAttribute = new Float32BufferAttribute(start, 3);
        startAttribute.divisor = 1;
        let endAttribute = new Float32BufferAttribute(end, 3);
        endAttribute.divisor = 1;
        this.setAttribute('aSegmentStart', startAttribute);
        this.setAttribute('aSegmentEnd', endAttribute);
        /*************************/
    }
}

class LineSegments extends Mesh {
    #lineStrip;
    constructor(params = {}) {
        super(new LineSegmentsGeometry(), params.material ?? new LineMaterial());
        this.#lineStrip = params.lineStrip ?? true;
    }
    setSegments(positions, colors) {
        this.geometry.setSegments(positions, colors, this.#lineStrip);
    }
}

class Circle extends LineSegments {
    #radius;
    #segments;
    #startAngle;
    #endAngle;
    constructor(params = {}) {
        super(params);
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#segments = params.segments ?? 64;
        this.#startAngle = params.startAngle ?? 0;
        this.#endAngle = params.endAngle ?? TWO_PI;
        this.#update();
    }
    #update() {
        let startEnd = [];
        let a = (this.#endAngle - this.#startAngle) / this.#segments;
        for (let i = 0; i < this.#segments + 1; i++) {
            let theta = a * i + this.#startAngle;
            let x = this.#radius * Math.cos(theta);
            let y = this.#radius * Math.sin(theta);
            startEnd.push(x);
            startEnd.push(y);
            startEnd.push(0);
        }
        this.setSegments(startEnd);
    }
    toJSON() {
        let json = super.toJSON();
        json.radius = this.#radius;
        json.segments = this.#segments;
        json.startAngle = this.#startAngle;
        json.endAngle = this.#endAngle;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Circle({ radius: json.radius, segments: json.segments, material: material, startAngle: json.startAngle, endAngle: json.endAngle });
    }
    static getEntityName() {
        return 'Circle';
    }
}
registerEntity(Circle);

class ConeBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    updateGeometry(radius = 1, height = 1, segments = 24, hasCap = true) {
        segments = Math.max(Math.floor(segments), 3);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        this.#generateCone(radius, height, segments);
        if (hasCap) {
            this.#generateCap(radius, 0, segments);
            //this.generateCap(radius, +height / 2, segments);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    #generateCone(radius, height, segments) {
        var normal = create$4();
        var vertex = create$4();
        let thetaPerSegment = TWO_PI / segments;
        //let halfHeight = height / 2.0;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            let theta = thetaPerSegment * segmentId;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            vertex[0] = radius * cosTheta;
            vertex[1] = radius * sinTheta;
            let u = segmentId / segments;
            normal[0] = cosTheta;
            normal[1] = sinTheta;
            //TODO: compute proper normal
            // Bottom vertex
            vertex[2] = 0;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 0);
            // Top vertex
            this.#vertices.push(0, 0, height);
            this.#normals.push(...normal);
            this.#uvs.push(u, 1);
            let indexStart = segmentId * 2;
            this.#indices.push(indexStart, indexStart + 2, indexStart + 1);
            this.#indices.push(indexStart + 1, indexStart + 2, indexStart + 3);
        }
    }
    #generateCap(radius, z, segments) {
        let middlePointIndex = this.#vertices.length / 3;
        // Push middle vertex
        this.#vertices.push(0, 0, z);
        this.#normals.push(0, 0, Math.sign(z));
        this.#uvs.push(0.5, 0.5);
        // Note: we use vertices generated in generateCone for the caps.
        // This uses less memory but limits uv / normals usage
        let indexStart = z <= 0 ? 0 : 1;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            this.#indices.push(indexStart, middlePointIndex, indexStart + 2);
            indexStart += 2;
        }
    }
}

class Cone extends Mesh {
    #radius;
    #height;
    #segments;
    #hasCap;
    constructor(params = {}) {
        super(new ConeBufferGeometry(), params.material ?? new MeshBasicMaterial());
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#height = params.height ?? 1;
        this.#segments = params.segments ?? 24;
        this.#hasCap = params.hasCap ?? true;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#radius, this.#height, this.#segments, this.#hasCap);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Cone_1: null,
            radius: { i18n: '#radius', f: () => { let radius = prompt('Radius', String(this.#radius)); if (radius) {
                    this.#radius = Number(radius);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { let height = prompt('Height', String(this.#height)); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
        });
    }
    static getEntityName() {
        return 'Cone';
    }
}
registerEntity(Cone);

class CylinderBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    updateGeometry(radius, height, segments, hasCap) {
        segments = Math.max(Math.floor(segments), 3);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        this.generateCylinder(radius, height, segments);
        if (hasCap) {
            this.generateCap(radius, -height / 2, segments);
            this.generateCap(radius, +height / 2, segments);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    generateCylinder(radius, height, segments) {
        var normal = create$4();
        var vertex = create$4();
        let thetaPerSegment = TWO_PI / segments;
        let halfHeight = height / 2.0;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            let theta = thetaPerSegment * segmentId;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            vertex[0] = radius * cosTheta;
            vertex[1] = radius * sinTheta;
            let u = segmentId / segments;
            normal[0] = cosTheta;
            normal[1] = sinTheta;
            //No need to normalize the normal
            // Bottom vertex
            vertex[2] = -halfHeight;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 0);
            // Top vertex
            vertex[2] = halfHeight;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 1);
            let indexStart = segmentId * 2;
            this.#indices.push(indexStart, indexStart + 2, indexStart + 1);
            this.#indices.push(indexStart + 1, indexStart + 2, indexStart + 3);
        }
    }
    generateCap(radius, z, segments) {
        let middlePointIndex = this.#vertices.length / 3;
        let sign = Math.sign(z);
        // Push middle vertex
        this.#vertices.push(0, 0, z);
        this.#normals.push(0, 0, sign);
        this.#uvs.push(0.5, 0.5);
        // Note: we use vertices generated in generateCylinder for the caps.
        // This uses less memory but limits uv / normals usage
        let indexStart = z < 0 ? 0 : 1;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            if (sign < 0) {
                this.#indices.push(indexStart, middlePointIndex, indexStart + 2);
            }
            else {
                this.#indices.push(middlePointIndex, indexStart, indexStart + 2);
            }
            indexStart += 2;
        }
    }
}

class Cylinder extends Mesh {
    #radius;
    #height;
    #segments;
    #hasCap;
    constructor(params = {}) {
        super(new CylinderBufferGeometry(), params.material ?? new MeshBasicMaterial());
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#height = params.height ?? 1;
        this.#segments = params.segments ?? 24;
        this.#hasCap = params.hasCap ?? true;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#radius, this.#height, this.#segments, this.#hasCap);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Cylinder_1: null,
            radius: { i18n: '#radius', f: () => { let radius = prompt('Radius', String(this.#radius)); if (radius) {
                    this.#radius = Number(radius);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { let height = prompt('Height', String(this.#height)); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
            segments: { i18n: '#segments', f: () => { let segments = prompt('Segments', String(this.#segments)); if (segments) {
                    this.#segments = Number(segments);
                    this.#updateGeometry();
                } } },
            hasCap: { i18n: '#has_caps', f: () => { let hasCap = prompt('Has Caps', String(this.#hasCap)); if (hasCap) {
                    this.#hasCap = (Number(hasCap) == 1);
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        let json = super.toJSON();
        json.radius = this.#radius;
        json.height = this.#height;
        json.segments = this.#segments;
        json.hasCap = this.#hasCap;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Cylinder({ radius: json.radius, height: json.height, material: material, segments: json.segments, hasCap: json.hasCap });
    }
    static getEntityName() {
        return 'Cylinder';
    }
}
registerEntity(Cylinder);

class PlaneBufferGeometry extends BufferGeometry {
    constructor() {
        super();
    }
    updateGeometry(width, height, widthSegments, heightSegments) {
        ///width = width || 1;
        //height = height || 1;
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments);
        var gridY = Math.floor(heightSegments);
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var ix, iy;
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - (iy / gridY));
            }
        }
        // indices
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = (ix + 1) + gridX1 * (iy + 1);
                var d = (ix + 1) + gridX1 * iy;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

class Plane extends Mesh {
    #widthSegments;
    #heightSegments;
    #width;
    #height;
    //constructor({ width = 1, height, material = new MeshBasicMaterial(), widthSegments = 1, heightSegments = 1 } = {}) {
    constructor(params = {}) {
        super(new PlaneBufferGeometry(), params.material ?? new MeshBasicMaterial());
        super.setParameters(arguments[0]);
        this.#width = params.width ?? 1;
        this.#height = params.height ?? this.#width;
        this.#widthSegments = params.widthSegments ?? 1;
        this.#heightSegments = params.heightSegments ?? 1;
        this.#updateGeometry();
    }
    setWidth(width) {
        this.#width = width;
        this.#updateGeometry();
    }
    setHeight(height) {
        this.#height = height;
        this.#updateGeometry();
    }
    setSize(width, height) {
        this.#width = width;
        this.#height = height ?? width;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#width, this.#height, this.#widthSegments, this.#heightSegments);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Plane_1: null,
            width: { i18n: '#width', f: () => { let width = prompt(); if (width) {
                    this.#width = Number(width);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { let height = prompt(); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
            square: { i18n: '#square', f: () => { let size = Number(prompt('Square size')); if (size) {
                    this.#width = size;
                    this.#height = size;
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        let json = super.toJSON();
        json.width = this.#width;
        json.height = this.#height;
        json.widthSegments = this.#widthSegments;
        json.heightsegments = this.#heightSegments;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Plane({ width: json.width, height: json.height, material: material, widthSegments: json.widthSegments, heightSegments: json.heightSegments });
    }
    static getEntityName() {
        return 'Plane';
    }
}
JSONLoader.registerEntity(Plane);

class SphereBufferGeometry extends BufferGeometry {
    updateGeometry(radius, segments, rings, phiStart, phiLength, thetaStart, thetaLength) {
        segments = Math.max(3, Math.floor(segments));
        rings = Math.max(2, Math.floor(rings));
        //phiStart = phiStart !== undefined ? phiStart : 0;
        //phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        //thetaStart = thetaStart !== undefined ? thetaStart : 0;
        //thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        var ix, iy;
        var index = 0;
        var grid = [];
        var vertex = create$4();
        var normal = create$4();
        // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy <= rings; iy++) {
            var verticesRow = [];
            var v = iy / rings;
            // special case for the poles
            var uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
                uOffset = 0.5 / segments;
            }
            else if (iy == rings && thetaEnd == Math.PI) {
                uOffset = -0.5 / segments;
            }
            for (ix = 0; ix <= segments; ix++) {
                var u = ix / segments;
                // vertex
                vertex[0] = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex[2] = radius * Math.cos(thetaStart + v * thetaLength);
                vertex[1] = -radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(...vertex);
                // normal
                normalize$5(normal, vertex);
                normals.push(...normal);
                // uv
                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        // indices
        for (iy = 0; iy < rings; iy++) {
            for (ix = 0; ix < segments; ix++) {
                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0)
                    indices.push(a, b, d);
                if (iy !== rings - 1 || thetaEnd < Math.PI)
                    indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

let intersectionPoint1 = create$4();
let intersectionPoint2 = create$4();
let intersectionNormal$1 = create$4();
const tempVec3$r = create$4();
let v$f = create$4();
class Sphere extends Mesh {
    radius;
    segments;
    rings;
    phiStart;
    phiLength;
    thetaStart;
    thetaLength;
    isSphere = true;
    constructor(params = {}) {
        super(new SphereBufferGeometry(), params.material ?? new MeshBasicMaterial());
        this.radius = params.radius ?? 1;
        this.segments = params.segments ?? 8;
        this.rings = params.rings ?? 8;
        this.phiStart = params.phiStart ?? 0;
        this.phiLength = params.phiLength ?? TAU;
        this.thetaStart = params.thetaStart = 0;
        this.thetaLength = params.thetaLength ?? PI;
        this.updateGeometry();
        super.setParameters(arguments[0]);
    }
    setRadius(radius) {
        this.radius = radius;
        this.updateGeometry();
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.radius, this.segments, this.rings, this.phiStart, this.phiLength, this.thetaStart, this.thetaLength);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Sphere_1: null,
            radius: { i18n: '#radius', f: () => { let radius = prompt('Radius', String(this.radius)); if (radius) {
                    this.radius = Number(radius);
                    this.updateGeometry();
                } } },
            segments: { i18n: '#segments', f: () => { let segments = prompt('Segments', String(this.segments)); if (segments) {
                    this.segments = Number(segments);
                    this.updateGeometry();
                } } },
            rings: { i18n: '#rings', f: () => { let rings = prompt('Rings', String(this.rings)); if (rings) {
                    this.rings = Number(rings);
                    this.updateGeometry();
                } } }
        });
    }
    raycast(raycaster, intersections) {
        let ray = raycaster.ray;
        let worldPosition = this.getWorldPosition(v$f);
        let inverseRadius = 1 / this.radius;
        if (ray.intersectSphere(worldPosition, this.radius, this.getWorldScale(tempVec3$r), intersectionPoint1, intersectionPoint2)) {
            //return super.raycast(raycaster, intersections);//TODO: improve
            //TODO: case when the ray spawn from inside the sphere
            sub$2(intersectionNormal$1, intersectionPoint1, worldPosition);
            scale$5(intersectionNormal$1, intersectionNormal$1, inverseRadius);
            intersections.push(ray.createIntersection(intersectionPoint1, intersectionNormal$1, null, this, 0));
            sub$2(intersectionNormal$1, intersectionPoint2, worldPosition);
            scale$5(intersectionNormal$1, intersectionNormal$1, inverseRadius);
            intersections.push(ray.createIntersection(intersectionPoint2, intersectionNormal$1, null, this, 0));
        }
    }
    toJSON() {
        let json = super.toJSON();
        json.radius = this.radius;
        json.segments = this.segments;
        json.rings = this.rings;
        json.phistart = this.phiStart;
        json.philength = this.phiLength;
        json.thetastart = this.thetaStart;
        json.thetalength = this.thetaLength;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Sphere({ radius: json.radius, material: material, segments: json.segments, rings: json.rings, phiStart: json.phistart, phiLength: json.philength, thetaStart: json.thetastart, thetaLength: json.thetalength });
    }
    static getEntityName() {
        return 'Sphere';
    }
}
registerEntity(Sphere);

const ARROW_RADIUS = 0.1;
const ARROW_LENGTH = 5;
const PLANE_LENGTH = ARROW_LENGTH / 3;
const HALF_PLANE_LENGTH = PLANE_LENGTH / 2;
const TIP_LENGTH = 1;
const RADIUS = 5;
const X_COLOR = fromValues$3(1, 0, 0, 1);
const Y_COLOR = fromValues$3(0, 1, 0, 1);
const Z_COLOR = fromValues$3(0, 0, 1, 1);
const XY_COLOR = fromValues$3(1, 1, 0, 0.2);
const XZ_COLOR = fromValues$3(1, 0, 1, 0.2);
const YZ_COLOR = fromValues$3(0, 1, 1, 0.2);
const GREY_COLOR = fromValues$3(0.2, 0.2, 0.2, 1);
const SCREEN_COLOR = fromValues$3(1.0, 0.0, 1.0, 1);
const SELECTED_COLOR = fromValues$3(1, 1, 0, 1);
const ORIENTATION_WORLD = 0;
const xUnitVec3 = fromValues$4(1, 0, 0);
const yUnitVec3 = fromValues$4(0, 1, 0);
const zUnitVec3 = fromValues$4(0, 0, 1);
const xyUnitVec3 = fromValues$4(1, 1, 0);
const xzUnitVec3 = fromValues$4(1, 0, 1);
const yzUnitVec3 = fromValues$4(0, 1, 1);
const tempVec3$q = create$4();
const tempVec3_b = create$4();
const translationManipulatorTempQuat = create$2();
const tempQuat$a = create$2();
const MANIPULATOR_SHORTCUT_INCREASE = 'engine.shortcuts.manipulator.size.increase';
const MANIPULATOR_SHORTCUT_DECREASE = 'engine.shortcuts.manipulator.size.decrease';
const MANIPULATOR_SHORTCUT_TRANSLATION = 'engine.shortcuts.manipulator.mode.translation';
const MANIPULATOR_SHORTCUT_ROTATION = 'engine.shortcuts.manipulator.mode.rotation';
const MANIPULATOR_SHORTCUT_SCALE = 'engine.shortcuts.manipulator.mode.scale';
const MANIPULATOR_SHORTCUT_AXIS_ORIENTATION = 'engine.shortcuts.manipulator.axis.orientation';
const MANIPULATOR_SHORTCUT_TOGGLE_X = 'engine.shortcuts.manipulator.toggle.x';
const MANIPULATOR_SHORTCUT_TOGGLE_Y = 'engine.shortcuts.manipulator.toggle.y';
const MANIPULATOR_SHORTCUT_TOGGLE_Z = 'engine.shortcuts.manipulator.toggle.z';
var ManipulatorMode;
(function (ManipulatorMode) {
    ManipulatorMode[ManipulatorMode["Translation"] = 0] = "Translation";
    ManipulatorMode[ManipulatorMode["Rotation"] = 1] = "Rotation";
    ManipulatorMode[ManipulatorMode["Scale"] = 2] = "Scale";
})(ManipulatorMode || (ManipulatorMode = {}));
var ManipulatorAxis;
(function (ManipulatorAxis) {
    ManipulatorAxis[ManipulatorAxis["None"] = 0] = "None";
    ManipulatorAxis[ManipulatorAxis["X"] = 1] = "X";
    ManipulatorAxis[ManipulatorAxis["Y"] = 2] = "Y";
    ManipulatorAxis[ManipulatorAxis["Z"] = 3] = "Z";
    ManipulatorAxis[ManipulatorAxis["XY"] = 4] = "XY";
    ManipulatorAxis[ManipulatorAxis["XZ"] = 5] = "XZ";
    ManipulatorAxis[ManipulatorAxis["YZ"] = 6] = "YZ";
    ManipulatorAxis[ManipulatorAxis["XYZ"] = 7] = "XYZ";
    ManipulatorAxis[ManipulatorAxis["View"] = 8] = "View";
})(ManipulatorAxis || (ManipulatorAxis = {}));
class Manipulator extends Entity {
    #entityAxis = new Map();
    #xMaterial = new MeshBasicMaterial();
    #yMaterial = new MeshBasicMaterial();
    #zMaterial = new MeshBasicMaterial();
    #xyMaterial = new MeshBasicMaterial();
    #xzMaterial = new MeshBasicMaterial();
    #yzMaterial = new MeshBasicMaterial();
    #xyzMaterial = new MeshBasicMaterial();
    #xLineMaterial = new LineMaterial();
    #yLineMaterial = new LineMaterial();
    #zLineMaterial = new LineMaterial();
    #xyzLineMaterial = new LineMaterial();
    #viewLineMaterial = new LineMaterial();
    #xyzSphere = new Sphere({ radius: ARROW_RADIUS * 6.0, material: this.#xyzMaterial, segments: 32, rings: 32, name: 'Manipulator XYZ sphere' });
    #xArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#xMaterial, name: 'Manipulator X arrow' });
    #yArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#yMaterial, name: 'Manipulator Y arrow' });
    #zArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#zMaterial, name: 'Manipulator Z arrow' });
    #xyPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#xyMaterial, name: 'Manipulator XY' });
    #xzPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#xzMaterial, name: 'Manipulator XZ' });
    #yzPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#yzMaterial, name: 'Manipulator YZ' });
    #xCircle = new Circle({ radius: RADIUS, material: this.#xLineMaterial, segments: 32, startAngle: -HALF_PI, endAngle: HALF_PI, name: 'Manipulator rotate X' });
    #yCircle = new Circle({ radius: RADIUS, material: this.#yLineMaterial, segments: 32, startAngle: -PI, endAngle: 0, name: 'Manipulator rotate Y' });
    #zCircle = new Circle({ radius: RADIUS, material: this.#zLineMaterial, segments: 32, startAngle: -HALF_PI, endAngle: HALF_PI, name: 'Manipulator rotate Z' });
    #viewCircle = new Circle({ radius: RADIUS * 1.25, material: this.#xyzLineMaterial, name: 'Manipulator rotate XYZ' });
    #circle = new Circle({ radius: RADIUS, material: this.#viewLineMaterial, name: 'Manipulator rotate view' });
    #xScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#xMaterial });
    #yScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#yMaterial });
    #zScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#zMaterial });
    #cursorPos = create();
    #axisOrientation = ORIENTATION_WORLD;
    #near = create$4();
    #far = create$4();
    #startDragPosition = create$4();
    #startScalePosition = create$4();
    #parentStartScale = create$4();
    #mode = ManipulatorMode.Translation;
    enumerable = false;
    camera;
    size = 1;
    #axis = ManipulatorAxis.None;
    #startPosition = create$4();
    #startQuaternion = create$2();
    #startLocalQuaternion = create$2();
    #startDragVector = 0; //vec3 = vec3.create();
    #translationManipulator = new Entity({ name: 'Translation manipulator' });
    #rotationManipulator = new Entity({ name: 'Rotation manipulator' });
    #scaleManipulator = new Entity({ name: 'Scale manipulator' });
    #enableX = false;
    #enableY = false;
    #enableZ = false;
    constructor(params) {
        super(params);
        this.wireframe = 0;
        this.setLayer(LAYER_MAX);
        this.hideInExplorer = true;
        this.castShadow = false;
        this.serializable = false;
        this.#initMaterials();
        this.#initTranslationManipulator();
        this.#initRotationManipulator();
        this.#initScaleManipulator();
        this.setMode(ManipulatorMode.Translation);
        this.setAttribute(EngineEntityAttributes.IsTool, true);
        this.enableX = true;
        this.enableY = true;
        this.enableZ = true;
        this.forEach((entity) => entity.setupPickingId());
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => this.resize(this.root?.activeCamera));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => {
            const detail = event.detail;
            if (this.#entityAxis.has(detail.entity)) {
                this.#axis = this.#entityAxis.get(detail.entity);
                switch (this.#mode) {
                    case ManipulatorMode.Translation:
                        this.startTranslate(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Rotation:
                        this.startRotate(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Scale:
                        this.startScale(detail.x, detail.y);
                        break;
                }
                new Graphics().dragging = true;
                this.#setAxisSelected(true);
            }
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => {
            const detail = event.detail;
            if (!detail.entity?.isVisible()) {
                return;
            }
            if (this.#entityAxis.has(detail.entity)) {
                switch (this.#mode) {
                    case ManipulatorMode.Translation:
                        this.#translationMoveHandler(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Rotation:
                        this.#rotationMoveHandler(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Scale:
                        this.#scaleMoveHandler(detail.x, detail.y);
                        break;
                }
            }
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => {
            if (this.#entityAxis.has(event.detail.entity)) {
                new Graphics().dragging = false;
                this.#setAxisSelected(false);
            }
        });
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_INCREASE, () => this.size *= 1.1);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_DECREASE, () => this.size *= 0.9);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TRANSLATION, () => this.setMode(ManipulatorMode.Translation));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_ROTATION, () => this.setMode(ManipulatorMode.Rotation));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_SCALE, () => this.setMode(ManipulatorMode.Scale));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_AXIS_ORIENTATION, () => this.#axisOrientation = (++this.#axisOrientation) % 2);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_X, () => this.enableX = !this.enableX);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_Y, () => this.enableY = !this.enableY);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_Z, () => this.enableZ = !this.enableZ);
    }
    resize(camera) {
        if (!this.isVisible()) {
            return;
        }
        let scaleFactor = 1;
        if (camera) {
            this.camera = camera;
            if (camera.isPerspective) {
                this.getWorldPosition(tempVec3$q);
                camera.getWorldPosition(tempVec3_b);
                scaleFactor = distance$3(tempVec3$q, tempVec3_b) * Math.min(1.9 * Math.tan(camera.verticalFov * DEG_TO_RAD), 7);
                scaleFactor *= 0.02;
            }
            else if (camera.isOrthographic) {
                scaleFactor = (camera.top - camera.bottom) / camera.orthoZoom;
                scaleFactor *= 0.02;
            }
            scaleFactor *= this.size;
            this.scale = set$5(tempVec3$q, scaleFactor, scaleFactor, scaleFactor);
            this.#setupAxis();
        }
    }
    #setAxisSelected(selected) {
        switch (this.#axis % 10) {
            case 1:
                this.#xMaterial.setMeshColor(selected ? SELECTED_COLOR : X_COLOR);
                this.#xLineMaterial.setMeshColor(selected ? SELECTED_COLOR : X_COLOR);
                break;
            case 2:
                this.#yMaterial.setMeshColor(selected ? SELECTED_COLOR : Y_COLOR);
                this.#yLineMaterial.setMeshColor(selected ? SELECTED_COLOR : Y_COLOR);
                break;
            case 3:
                this.#zMaterial.setMeshColor(selected ? SELECTED_COLOR : Z_COLOR);
                this.#zLineMaterial.setMeshColor(selected ? SELECTED_COLOR : Z_COLOR);
                break;
            case 4:
                this.#xyMaterial.setMeshColor(selected ? SELECTED_COLOR : XY_COLOR);
                break;
            case 5:
                this.#xzMaterial.setMeshColor(selected ? SELECTED_COLOR : XZ_COLOR);
                break;
            case 6:
                this.#yzMaterial.setMeshColor(selected ? SELECTED_COLOR : YZ_COLOR);
                break;
            case 7:
                this.#xyzLineMaterial.setMeshColor(selected ? SELECTED_COLOR : SCREEN_COLOR);
                break;
        }
    }
    #initMaterials() {
        this.#xMaterial.setMeshColor(X_COLOR);
        this.#xMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yMaterial.setMeshColor(Y_COLOR);
        this.#yMaterial.setDefine('ALWAYS_ON_TOP');
        this.#zMaterial.setMeshColor(Z_COLOR);
        this.#zMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyMaterial.setMeshColor(XY_COLOR);
        this.#xyMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyMaterial.renderFace(RenderFace.Both);
        this.#xyMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#xzMaterial.setMeshColor(XZ_COLOR);
        this.#xzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xzMaterial.renderFace(RenderFace.Both);
        this.#xzMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#yzMaterial.setMeshColor(YZ_COLOR);
        this.#yzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yzMaterial.renderFace(RenderFace.Both);
        this.#yzMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#xyzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xLineMaterial.setMeshColor(X_COLOR);
        this.#xLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yLineMaterial.setMeshColor(Y_COLOR);
        this.#yLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#zLineMaterial.setMeshColor(Z_COLOR);
        this.#zLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyzLineMaterial.setMeshColor(SCREEN_COLOR);
        this.#xyzLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#viewLineMaterial.setMeshColor(GREY_COLOR);
        this.#viewLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#viewLineMaterial.lineWidth = 2;
    }
    #initTranslationManipulator() {
        this.addChild(this.#translationManipulator);
        this.#xArrow.rotateY(HALF_PI);
        this.#xArrow.translateZ(ARROW_LENGTH / 2);
        this.#yArrow.rotateX(-HALF_PI);
        this.#yArrow.translateZ(ARROW_LENGTH / 2);
        this.#zArrow.translateZ(ARROW_LENGTH / 2);
        let xTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#xMaterial, name: 'Manipulator X tip' });
        xTip.translateZ(ARROW_LENGTH / 2);
        let yTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#yMaterial, name: 'Manipulator Y tip' });
        yTip.translateZ(ARROW_LENGTH / 2);
        let zTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#zMaterial, name: 'Manipulator Z tip' });
        zTip.translateZ(ARROW_LENGTH / 2);
        this.#xyPlane.translateOnAxis([1, 1, 0], HALF_PLANE_LENGTH);
        this.#xzPlane.translateOnAxis([1, 0, 1], HALF_PLANE_LENGTH);
        this.#xzPlane.rotateX(HALF_PI);
        this.#yzPlane.translateOnAxis([0, 1, 1], HALF_PLANE_LENGTH);
        this.#yzPlane.rotateY(HALF_PI);
        this.#translationManipulator.addChild(this.#xyzSphere);
        this.#translationManipulator.addChild(this.#xArrow);
        this.#translationManipulator.addChild(this.#yArrow);
        this.#translationManipulator.addChild(this.#zArrow);
        this.#xArrow.addChild(xTip);
        this.#yArrow.addChild(yTip);
        this.#zArrow.addChild(zTip);
        this.#translationManipulator.addChild(this.#xyPlane);
        this.#translationManipulator.addChild(this.#xzPlane);
        this.#translationManipulator.addChild(this.#yzPlane);
        this.#entityAxis.set(this.#xyzSphere, ManipulatorAxis.XYZ);
        this.#entityAxis.set(this.#xArrow, ManipulatorAxis.X);
        this.#entityAxis.set(xTip, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yArrow, ManipulatorAxis.Y);
        this.#entityAxis.set(yTip, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zArrow, ManipulatorAxis.Z);
        this.#entityAxis.set(zTip, ManipulatorAxis.Z);
        this.#entityAxis.set(this.#xyPlane, ManipulatorAxis.XY);
        this.#entityAxis.set(this.#xzPlane, ManipulatorAxis.XZ);
        this.#entityAxis.set(this.#yzPlane, ManipulatorAxis.YZ);
    }
    #initRotationManipulator() {
        this.addChild(this.#rotationManipulator);
        this.#rotationManipulator.addChild(this.#xCircle);
        this.#rotationManipulator.addChild(this.#yCircle);
        this.#rotationManipulator.addChild(this.#zCircle);
        this.#rotationManipulator.addChild(this.#viewCircle);
        this.#rotationManipulator.addChild(this.#circle);
        this.#entityAxis.set(this.#xCircle, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yCircle, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zCircle, ManipulatorAxis.Z);
        this.#entityAxis.set(this.#viewCircle, ManipulatorAxis.View);
    }
    #initScaleManipulator() {
        this.addChild(this.#scaleManipulator);
        //let _xyzSphere = new Sphere(ARROW_RADIUS * 6.0, this.#xyzMaterial, 32, 32);
        this.#xScale.rotateY(HALF_PI);
        this.#xScale.translateZ(ARROW_LENGTH / 2);
        this.#yScale.rotateX(-HALF_PI);
        this.#yScale.translateZ(ARROW_LENGTH / 2);
        this.#zScale.translateZ(ARROW_LENGTH / 2);
        let xScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#xMaterial });
        xScaleTip.translateZ(ARROW_LENGTH / 2);
        let yScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#yMaterial });
        yScaleTip.translateZ(ARROW_LENGTH / 2);
        let zScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#zMaterial });
        zScaleTip.translateZ(ARROW_LENGTH / 2);
        /*this.#xyPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#xyMaterial);
        this.#xyPlane.translateOnAxis([1, 1, 0], HALF_PLANE_LENGTH);
        this.#xzPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#xzMaterial);
        this.#xzPlane.translateOnAxis([1, 0, 1], HALF_PLANE_LENGTH);
        this.#xzPlane.rotateX(HALF_PI);
        this.#yzPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#yzMaterial);
        this.#yzPlane.translateOnAxis([0, 1, 1], HALF_PLANE_LENGTH);
        this.#yzPlane.rotateY(HALF_PI);*/
        //scaleManipulator.addChild(_xyzSphere);
        this.#scaleManipulator.addChild(this.#xScale);
        this.#scaleManipulator.addChild(this.#yScale);
        this.#scaleManipulator.addChild(this.#zScale);
        this.#xScale.addChild(xScaleTip);
        this.#yScale.addChild(yScaleTip);
        this.#zScale.addChild(zScaleTip);
        /*this.addChild(this.#xyPlane);
        this.addChild(this.#xzPlane);
        this.addChild(this.#yzPlane);*/
        //this.#entityAxis.set(_xyzSphere, 20);
        this.#entityAxis.set(this.#xScale, ManipulatorAxis.X);
        this.#entityAxis.set(xScaleTip, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yScale, ManipulatorAxis.Y);
        this.#entityAxis.set(yScaleTip, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zScale, ManipulatorAxis.Z);
        this.#entityAxis.set(zScaleTip, ManipulatorAxis.Z);
    }
    startTranslate(x, y) {
        if (this._parent) {
            this._parent.getWorldPosition(this.#startPosition);
        }
        else {
            this.getWorldPosition(this.#startPosition);
        }
        this.#computeTranslationPosition(this.#startDragPosition, x, y);
    }
    startRotate(x, y) {
        if (this._parent) {
            this._parent.getWorldQuaternion(this.#startQuaternion);
            this._parent.getQuaternion(this.#startLocalQuaternion);
        }
        else {
            this.getWorldQuaternion(this.#startQuaternion);
            this.getQuaternion(this.#startLocalQuaternion);
        }
        this.#startDragVector = this.#computeQuaternion(x, y);
    }
    startScale(x, y) {
        let startScalePosition = this.#startScalePosition;
        if (this._parent) {
            this._parent.getWorldPosition(this.#startPosition);
        }
        else {
            this.getWorldPosition(this.#startPosition);
        }
        this.#computeTranslationPosition(this.#startScalePosition, x, y);
        div$2(startScalePosition, startScalePosition, this.scale);
        scale$5(startScalePosition, startScalePosition, 2 / ARROW_LENGTH);
        if (this._parent) {
            copy$4(this.#parentStartScale, this._parent._scale);
        }
    }
    #translationMoveHandler(x, y) {
        this.#computeTranslationPosition(tempVec3$q, x, y);
        sub$2(tempVec3$q, tempVec3$q, this.#startDragPosition);
        switch (this.#axis) {
            case ManipulatorAxis.None:
                break;
            case ManipulatorAxis.X:
                tempVec3$q[1] = 0;
                tempVec3$q[2] = 0;
                break;
            case ManipulatorAxis.Y:
                tempVec3$q[0] = 0;
                tempVec3$q[2] = 0;
                break;
            case ManipulatorAxis.Z:
                tempVec3$q[0] = 0;
                tempVec3$q[1] = 0;
                break;
            case ManipulatorAxis.XY:
                tempVec3$q[2] = 0;
                break;
            case ManipulatorAxis.XZ:
                tempVec3$q[1] = 0;
                break;
            case ManipulatorAxis.YZ:
                tempVec3$q[0] = 0;
                break;
            default:
                tempVec3$q[0] = 0;
                tempVec3$q[1] = 0;
                tempVec3$q[2] = 0;
        }
        transformQuat$1(tempVec3$q, tempVec3$q, this.getWorldQuaternion());
        add$5(tempVec3$q, this.#startPosition, tempVec3$q);
        if (this._parent) {
            this._parent.setWorldPosition(tempVec3$q);
            this._parent.locked = true;
        }
        else {
            this.setWorldPosition(tempVec3$q);
        }
    }
    #rotationMoveHandler(x, y) {
        const v3 = this.#computeQuaternion(x, y);
        rotationTo(translationManipulatorTempQuat, this.#startDragVector, v3);
        mul$2(translationManipulatorTempQuat, this.#startLocalQuaternion, translationManipulatorTempQuat);
        const viewDirection = this.camera.getViewDirection(create$4() /*TODO: optimize*/);
        let rotateAxis = xUnitVec3;
        switch (this.#axis) {
            case ManipulatorAxis.Y:
                rotateAxis = yUnitVec3;
                break;
            case ManipulatorAxis.Z:
                rotateAxis = zUnitVec3;
                break;
            case ManipulatorAxis.View:
                rotateAxis = viewDirection;
                break;
        }
        let invert = Math.sign(dot$4(rotateAxis, viewDirection));
        if (invert == 0) {
            invert = 1;
        }
        const angleDelta = this.#startDragVector - v3;
        setAxisAngle(translationManipulatorTempQuat, rotateAxis, angleDelta * invert);
        mul$2(translationManipulatorTempQuat, translationManipulatorTempQuat, this.#startLocalQuaternion);
        if (this._parent) {
            this._parent.quaternion = translationManipulatorTempQuat;
            this._parent.locked = true;
        }
        else {
            this.quaternion = translationManipulatorTempQuat;
        }
    }
    #scaleMoveHandler(x, y) {
        let v3 = this.#computeTranslationPosition(tempVec3$q, x, y);
        if (!v3) {
            return;
        }
        //vec3.sub(v3, v3, this.#startScalePosition);
        div$2(v3, v3, this.scale);
        div$2(v3, v3, this.#startScalePosition);
        scale$5(v3, v3, 2 / ARROW_LENGTH);
        switch (this.#axis) {
            case ManipulatorAxis.None:
                break;
            case ManipulatorAxis.X:
                v3[1] = 1;
                v3[2] = 1;
                break;
            case ManipulatorAxis.Y:
                v3[0] = 1;
                v3[2] = 1;
                break;
            case ManipulatorAxis.Z:
                v3[0] = 1;
                v3[1] = 1;
                break;
            default:
                v3[0] = 1;
                v3[1] = 1;
                v3[2] = 1;
        }
        if (this._parent) {
            this._parent.scale = mul$4(v3, v3, this.#parentStartScale);
            this._parent.locked = true;
        }
    }
    #computeTranslationPosition(out, x, y) {
        let camera = this.camera;
        if (camera) {
            let projectionMatrix = camera.projectionMatrix;
            let viewMatrix = camera.cameraMatrix;
            camera.nearPlane;
            camera.farPlane;
            camera.aspectRatio;
            let invProjectionMatrix = invert$3(create$5(), projectionMatrix);
            let invViewMatrix = invert$3(create$5(), viewMatrix);
            // transform the screen coordinates to normalized coordinates
            this.#cursorPos[0] = (x / new Graphics().getWidth()) * 2.0 - 1.0;
            this.#cursorPos[1] = 1.0 - (y / new Graphics().getHeight()) * 2.0;
            this.#near[0] = this.#far[0] = this.#cursorPos[0];
            this.#near[1] = this.#far[1] = this.#cursorPos[1];
            this.#near[2] = -1.0;
            this.#far[2] = 1.0;
            transformMat4$2(this.#near, this.#near, invProjectionMatrix);
            transformMat4$2(this.#far, this.#far, invProjectionMatrix);
            transformMat4$2(this.#near, this.#near, invViewMatrix);
            transformMat4$2(this.#far, this.#far, invViewMatrix);
            function lineIntersection(out, planePoint, planeNormal, linePoint, lineDirection) {
                if (dot$4(planeNormal, lineDirection) == 0) {
                    return create$4(); //TODO: optimize
                }
                let t = (dot$4(planeNormal, planePoint) - dot$4(planeNormal, linePoint)) / dot$4(planeNormal, lineDirection);
                return scaleAndAdd$2(out, linePoint, lineDirection, t);
            }
            let planeNormal = create$4();
            switch (this.#axis % 10) {
                case 1:
                    planeNormal = transformQuat$1(planeNormal, xUnitVec3, this.getWorldQuaternion());
                    break;
                case 2:
                    planeNormal = transformQuat$1(planeNormal, yUnitVec3, this.getWorldQuaternion());
                    break;
                case 3:
                    planeNormal = transformQuat$1(planeNormal, zUnitVec3, this.getWorldQuaternion());
                    break;
                case 4:
                    planeNormal = transformQuat$1(planeNormal, xyUnitVec3, this.getWorldQuaternion());
                    break;
                case 5:
                    planeNormal = transformQuat$1(planeNormal, xzUnitVec3, this.getWorldQuaternion());
                    break;
                case 6:
                    planeNormal = transformQuat$1(planeNormal, yzUnitVec3, this.getWorldQuaternion());
                    break;
                default:
                    planeNormal = sub$2(create$4(), this.#far, this.#near);
                    break;
            }
            /********************/
            let worldPos = this._parent ? this._parent.getWorldPosition() : this.getWorldPosition();
            let A = worldPos; //vec3.clone(this._parent.position) : vec3.clone(this.position);
            let B = add$5(create$4(), A, planeNormal);
            let P = camera.position;
            let AP = sub$2(create$4(), P, A); //P-A;
            let AB = sub$2(create$4(), B, A); //B-A;
            let projPoint = add$5(create$4(), A, scale$5(AB, AB, dot$4(AP, AB) / dot$4(AB, AB)));
            planeNormal = sub$2(create$4(), projPoint, camera.position);
            normalize$5(planeNormal, planeNormal);
            if (this.#axis == ManipulatorAxis.XYZ) {
                transformQuat$1(planeNormal, fromValues$4(0, 0, 1), camera.quaternion);
            }
            /********************/
            lineIntersection(out, worldPos, planeNormal, this.#near, sub$2(create$4(), this.#far, this.#near));
            invert$2(translationManipulatorTempQuat, this.getWorldQuaternion());
            transformQuat$1(out, out, translationManipulatorTempQuat);
            return out;
        }
    }
    #computeQuaternion(x, y) {
        const camera = this.camera;
        if (!camera) {
            return 0;
        }
        // transform the screen coordinates to normalized coordinates
        const normalizedX = (x / new Graphics().getWidth()) * 2.0 - 1.0;
        const normalizedY = 1.0 - (y / new Graphics().getHeight()) * 2.0;
        this.getWorldPosition(tempVec3$q);
        transformMat4$2(tempVec3$q, tempVec3$q, camera.cameraMatrix);
        transformMat4$2(tempVec3$q, tempVec3$q, camera.projectionMatrix);
        return Math.atan2(normalizedY - tempVec3$q[1], normalizedX - tempVec3$q[0]);
    }
    #computeQuaternion_removeme(x, y) {
        let camera = this.camera;
        if (camera) {
            let projectionMatrix = camera.projectionMatrix;
            let viewMatrix = camera.cameraMatrix;
            camera.nearPlane;
            camera.farPlane;
            camera.aspectRatio;
            let invProjectionMatrix = invert$3(create$5(), projectionMatrix);
            let invViewMatrix = invert$3(create$5(), viewMatrix);
            this.#cursorPos[0] = (x / new Graphics().getWidth()) * 2.0 - 1.0;
            this.#cursorPos[1] = 1.0 - (y / new Graphics().getHeight()) * 2.0;
            this.#near[0] = this.#far[0] = this.#cursorPos[0];
            this.#near[1] = this.#far[1] = this.#cursorPos[1];
            this.#near[2] = -1.0;
            this.#far[2] = 1.0;
            transformMat4$2(this.#near, this.#near, invProjectionMatrix);
            transformMat4$2(this.#far, this.#far, invProjectionMatrix);
            transformMat4$2(this.#near, this.#near, invViewMatrix);
            transformMat4$2(this.#far, this.#far, invViewMatrix);
            function lineIntersection(planePoint, planeNormal, linePoint, lineDirection) {
                if (dot$4(planeNormal, lineDirection) == 0) {
                    return create$4(); //TODO: optimize
                }
                let t = (dot$4(planeNormal, planePoint) - dot$4(planeNormal, linePoint)) / dot$4(planeNormal, lineDirection);
                return scaleAndAdd$2(create$4(), linePoint, lineDirection, t); //TODO: optimize pass vec3 as param
            }
            let v4;
            let planeNormal = create$4();
            if (this.#axisOrientation == ORIENTATION_WORLD) {
                switch (this.#axis) {
                    case ManipulatorAxis.X:
                        planeNormal = copy$4(planeNormal, xUnitVec3);
                        break;
                    case ManipulatorAxis.Y:
                        planeNormal = copy$4(planeNormal, yUnitVec3);
                        break;
                    case ManipulatorAxis.Z:
                        planeNormal = copy$4(planeNormal, zUnitVec3);
                        break;
                    default:
                        this.getPositionFrom(camera, planeNormal);
                        planeNormal = normalize$5(planeNormal, planeNormal);
                        break;
                }
            }
            else {
                switch (this.#axis) {
                    case ManipulatorAxis.X:
                        planeNormal = transformQuat$1(planeNormal, xUnitVec3, this.#startQuaternion);
                        break;
                    case ManipulatorAxis.Y:
                        planeNormal = transformQuat$1(planeNormal, yUnitVec3, this.#startQuaternion);
                        break;
                    case ManipulatorAxis.Z:
                        planeNormal = transformQuat$1(planeNormal, zUnitVec3, this.#startQuaternion);
                        break;
                    default:
                        planeNormal = sub$2(create$4() /*TODO: optimize*/, this.#far, this.#near);
                        break;
                }
            }
            let worldPos = this._parent ? this._parent.getWorldPosition() : this.getWorldPosition();
            v4 = lineIntersection(worldPos, planeNormal, this.#near, sub$2(create$4(), this.#far, this.#near));
            if (!v4) {
                return create$4(); //TODO: optimize
            }
            sub$2(v4, v4, worldPos);
            invert$2(translationManipulatorTempQuat, this.#startQuaternion);
            transformQuat$1(v4, v4, translationManipulatorTempQuat);
            normalize$5(v4, v4);
            return v4;
        }
    }
    setCamera(camera) {
        this.camera = camera;
    }
    /**
     * @deprecated Please use `setMode` instead.
     */
    set mode(mode) {
        console.warn('deprecated, use setMode()');
        this.setMode(mode);
    }
    setMode(mode) {
        this.#translationManipulator.setVisible(false);
        this.#rotationManipulator.setVisible(false);
        this.#scaleManipulator.setVisible(false);
        this.#setAxisSelected(false);
        new Graphics().dragging = false;
        this.#mode = mode;
        switch (mode) {
            case ManipulatorMode.Translation:
                this.#translationManipulator.setVisible(undefined);
                break;
            case ManipulatorMode.Rotation:
                this.#rotationManipulator.setVisible(undefined);
                break;
            case ManipulatorMode.Scale:
                this.#scaleManipulator.setVisible(undefined);
                break;
        }
        this.#setAxisSelected(false);
    }
    set axisOrientation(axisOrientation) {
        this.#axisOrientation = axisOrientation;
    }
    getWorldQuaternion(q = create$2()) {
        if (this.#mode < ManipulatorMode.Scale) {
            switch (this.#axisOrientation) {
                case ORIENTATION_WORLD:
                    identity$1(q);
                    break;
                default:
                    super.getWorldQuaternion(q);
            }
        }
        else {
            super.getWorldQuaternion(q);
        }
        /*if (this._parent !== null) {
            this._parent.getWorldQuaternion(q);
            quat.mul(q, q, this._quaternion);
        } else {
            quat.copy(q, this._quaternion);
        }*/
        return q;
    }
    getWorldScale(vec = create$4()) {
        return copy$4(vec, this._scale);
    }
    set enableX(enableX) {
        this.#enableX = enableX;
        let enable = enableX ? undefined : false;
        this.#xArrow.setVisible(enable);
        this.#xCircle.setVisible(enable);
        this.#xScale.setVisible(enable);
    }
    get enableX() {
        return this.#enableX;
    }
    set enableY(enableY) {
        this.#enableY = enableY;
        let enable = enableY ? undefined : false;
        this.#yArrow.setVisible(enable);
        this.#yCircle.setVisible(enable);
        this.#yScale.setVisible(enable);
    }
    get enableY() {
        return this.#enableY;
    }
    set enableZ(enableZ) {
        this.#enableZ = enableZ;
        let enable = enableZ ? undefined : false;
        this.#zArrow.setVisible(enable);
        this.#zCircle.setVisible(enable);
        this.#zScale.setVisible(enable);
    }
    get enableZ() {
        return this.#enableZ;
    }
    #setupAxis() {
        const camera = this.camera;
        if (!camera) {
            return;
        }
        this.getWorldQuaternion(translationManipulatorTempQuat);
        invert$2(translationManipulatorTempQuat, translationManipulatorTempQuat);
        this.getPositionFrom(camera, tempVec3$q);
        normalize$5(tempVec3$q, tempVec3$q);
        transformQuat$1(tempVec3$q, tempVec3$q, translationManipulatorTempQuat);
        this.#circle.quaternion = rotationTo(tempQuat$a, zUnitVec3, tempVec3$q);
        this.#viewCircle.quaternion = tempQuat$a;
        this.#xCircle.quaternion = setAxisAngle(tempQuat$a, xUnitVec3, Math.atan2(tempVec3$q[1], -tempVec3$q[2]));
        this.#yCircle.quaternion = setAxisAngle(tempQuat$a, yUnitVec3, Math.atan2(tempVec3$q[0], tempVec3$q[2]));
        this.#zCircle.quaternion = setAxisAngle(tempQuat$a, zUnitVec3, Math.atan2(tempVec3$q[1], tempVec3$q[0]));
        this.#xCircle.rotateY(HALF_PI);
        this.#yCircle.rotateX(-HALF_PI);
    }
}
//Set default shortcuts
ShortcutHandler.setShortcuts('3dview,scene-explorer', new Map([
    [MANIPULATOR_SHORTCUT_INCREASE, 'PLUS'],
    [MANIPULATOR_SHORTCUT_DECREASE, '-'],
    [MANIPULATOR_SHORTCUT_TRANSLATION, 'ALT+T'],
    [MANIPULATOR_SHORTCUT_ROTATION, 'ALT+R'],
    [MANIPULATOR_SHORTCUT_SCALE, 'ALT+S'],
    [MANIPULATOR_SHORTCUT_AXIS_ORIENTATION, 'ALT+O'],
    [MANIPULATOR_SHORTCUT_TOGGLE_X, 'ALT+X'],
    [MANIPULATOR_SHORTCUT_TOGGLE_Y, 'ALT+Y'],
    [MANIPULATOR_SHORTCUT_TOGGLE_Z, 'ALT+Z'],
]));

class KeepOnlyLastChild extends Entity {
    addChild(child) {
        if (!(child instanceof Manipulator)) {
            this.removeChildren();
        }
        return super.addChild(child);
    }
    static getEntityName() {
        return 'Keep only last child';
    }
}
registerEntity(KeepOnlyLastChild);

function quatToEuler(out, q) {
    const test = q[0] * q[3] - q[1] * q[2];
    if (test > 0.5 - EPSILON$2) { // singularity at north pole
        out[1] = 2 * Math.atan2(q[1], q[0]);
        out[0] = Math.PI / 2;
        out[3] = 0;
        return out;
    }
    if (test < -0.5 + EPSILON$2) { // singularity at south pole
        out[1] = -2 * Math.atan2(q[1], q[0]);
        out[0] = -Math.PI / 2;
        out[2] = 0;
        return out;
    }
    // roll (x-axis rotation)
    const sinr_cosp = 2 * (q[3] * q[0] + q[1] * q[2]);
    const cosr_cosp = 1 - 2 * (q[0] * q[0] + q[1] * q[1]);
    out[0] = Math.atan2(sinr_cosp, cosr_cosp);
    // pitch (y-axis rotation)
    const sinp = Math.sqrt(1 + 2 * (q[3] * q[1] - q[0] * q[2]));
    const cosp = Math.sqrt(1 - 2 * (q[3] * q[1] - q[0] * q[2]));
    out[1] = 2 * Math.atan2(sinp, cosp) - Math.PI / 2;
    // yaw (z-axis rotation)
    const siny_cosp = 2 * (q[3] * q[2] + q[0] * q[1]);
    const cosy_cosp = 1 - 2 * (q[1] * q[1] + q[2] * q[2]);
    out[2] = Math.atan2(siny_cosp, cosy_cosp);
    return out;
}
function quatToEulerDeg(out, q) {
    quatToEuler(out, q);
    out[0] = RAD_TO_DEG * out[0];
    out[1] = RAD_TO_DEG * out[1];
    out[2] = RAD_TO_DEG * out[2];
    return out;
}
function QuaternionIdentityBlend(p, t, qt) {
    let sclp;
    sclp = 1.0 - t;
    qt[0] = p[0] * sclp;
    qt[1] = p[1] * sclp;
    qt[2] = p[2] * sclp;
    if (qt[3] < 0.0) {
        qt[3] = p[3] * sclp - t;
    }
    else {
        qt[3] = p[3] * sclp + t;
    }
    normalize$3(qt, qt);
}

const ROTATE_Z = create$2();
rotateX$1(ROTATE_Z, ROTATE_Z, -HALF_PI);
const tempMat4$3 = create$5();
async function exportToBinaryFBX(entity) {
    const fbxManager = new FBXManager();
    let fbxFile = fbxSceneToFBXFile(await entityToFBXScene(fbxManager, entity));
    return new FBXExporter().exportBinary(fbxFile);
}
async function entityToFBXScene(fbxManager, entity) {
    const fbxScene = fbxManager.createObject('FBXScene', 'Scene');
    let playing = new Graphics().isRunning();
    new Graphics().pause();
    await createFBXSceneEntity(fbxScene, entity);
    if (playing) {
        new Graphics().play();
    }
    return fbxScene;
}
async function createFBXSceneEntity(fbxScene, entity, context = {}) {
    if (!context.exportedBones) {
        context.exportedBones = new Map();
    }
    if (!context.animStackPerEntity) {
        context.animStackPerEntity = new Map();
    }
    if (!context.animLayerPerEntity) {
        context.animLayerPerEntity = new Map();
    }
    switch (true) {
        case entity.isSource1ModelInstance:
            await createSource1ModelInstance(fbxScene, entity, context);
            break;
        case entity.is('Mesh'):
            await createFBXMesh(fbxScene, entity, context);
            break;
        case entity.is('Camera'):
            await createFBXCamera(fbxScene, entity);
            break;
    }
    await createChildEntities(fbxScene, entity, context);
}
async function createChildEntities(fbxScene, entity, context) {
    for (let childEntity of entity.children) {
        await createFBXSceneEntity(fbxScene, childEntity, context);
    }
}
async function createSource1ModelInstance(fbxScene, entity, context) {
    const fbxManager = fbxScene.manager;
    let animStack;
    let animLayer;
    animStack = context.animStackPerEntity.get(entity.parent);
    animLayer = context.animLayerPerEntity.get(entity.parent);
    if (!animStack) {
        animStack = fbxManager.createObject('FBXAnimStack', 'test FBXAnimStack');
        fbxScene.addObject(animStack);
        context.animStackPerEntity.set(entity, animStack);
        animLayer = fbxManager.createObject('FBXAnimLayer', 'test FBXAnimLayer');
        animStack.add(animLayer);
    }
    const exportedBones = context.exportedBones;
    if (entity.skeleton) {
        const bones = entity.skeleton.bones;
        for (let bone of bones) {
            exportedBones.get(bone);
        }
    }
}
async function createFBXMesh(fbxScene, mesh, context) {
    const fbxManager = fbxScene.manager;
    let meshPose = fbxManager.createObject('FBXPose', 'Pose ' + mesh.name);
    fbxScene.addObject(meshPose);
    if (!mesh.exportObj || !mesh.visible || !mesh.is('Mesh') || mesh.parent?.isParticleSystem) {
        return;
    }
    let fbxMeshNode = fbxManager.createObject('FBXNode', mesh.name);
    fbxMeshNode.localRotation.value = quatToEulerDeg([0, 0, 0], mul$2(create$2(), ROTATE_Z, mesh.getWorldQuaternion()));
    fbxMeshNode.localTranslation.value = transformQuat$1(create$4(), mesh.getWorldPosition(), ROTATE_Z);
    fbxMeshNode.localScaling.value = mesh.getWorldScale();
    let fbxMaterial = fbxManager.createObject('FBXSurfacePhong');
    fbxMaterial.name = 'mat_' + fbxMaterial.id + '.png';
    let fbxMesh = fbxManager.createObject('FBXMesh', 'Name me FBXMesh');
    fbxMeshNode.nodeAttribute = fbxMesh;
    fbxMeshNode.addMaterial(fbxMaterial);
    fbxScene.rootNode.addChild(fbxMeshNode);
    let meshMaterial = mesh.material;
    //console.log(meshMaterial);
    if (meshMaterial) {
        await configureMaterial(meshMaterial, fbxMaterial, mesh.materialsParams);
    }
    let meshDatas = mesh.exportObj();
    if (mesh.skeleton) {
        meshDatas = {
            f: mesh.geometry.getAttribute('index')?._array,
            v: mesh.geometry.getAttribute('aVertexPosition')?._array,
            vn: mesh.geometry.getAttribute('aVertexNormal')?._array,
            vt: mesh.geometry.getAttribute('aTextureCoord')?._array,
            bi: mesh.geometry.getAttribute('aBoneIndices')?._array,
            bw: mesh.geometry.getAttribute('aBoneWeight')?._array,
        };
        meshDatas.bi;
        meshDatas.bw;
    }
    let boneIndexes = new Map();
    let boneWeights = new Map();
    let polygons = [];
    let edges = [];
    let uvIndex = [];
    let vertexIndices = meshDatas.f;
    let vertexIndex1;
    let vertexIndex2;
    let vertexIndex3;
    let remappedIndex = new Map();
    let currentIndex = 0;
    let remappedVertices = [];
    let remappedNormals = [];
    let remappedUV = [];
    let remappedBoneIndices = [];
    let remappedBoneWeight = [];
    const bonesPerVertex = mesh.bonesPerVertex;
    function remapIndex(index) {
        if (remappedIndex.has(index)) {
            return remappedIndex.get(index);
        }
        let newIndex = currentIndex++;
        remappedIndex.set(index, newIndex);
        let vIndex = index * 3;
        let uvIndex = index * 2;
        if (meshDatas.v) {
            remappedVertices.push(meshDatas.v[vIndex], meshDatas.v[vIndex + 1], meshDatas.v[vIndex + 2]);
        }
        if (meshDatas.vn) {
            remappedNormals.push(meshDatas.vn[vIndex], meshDatas.vn[vIndex + 1], meshDatas.vn[vIndex + 2]);
        }
        if (meshDatas.vt) {
            remappedUV.push(meshDatas.vt[uvIndex], meshDatas.vt[uvIndex + 1]);
        }
        {
            const boneIndex = index * bonesPerVertex;
            if (meshDatas.bi) {
                for (let j = 0; j < bonesPerVertex; ++j) {
                    remappedBoneIndices.push(meshDatas.bi[boneIndex + j]);
                    remappedBoneWeight.push(meshDatas.bw[boneIndex + j]);
                }
            }
        }
        return newIndex;
    }
    for (let i = 0, j = 0, l = vertexIndices.length; i < l; i += 3, j += 2) {
        vertexIndex1 = remapIndex(vertexIndices[i]);
        vertexIndex2 = remapIndex(vertexIndices[i + 1]);
        vertexIndex3 = remapIndex(vertexIndices[i + 2]);
        polygons.push(vertexIndex1, vertexIndex2, ~vertexIndex3);
        uvIndex.push(vertexIndex1, vertexIndex2, vertexIndex3);
        edges.push(vertexIndex1, vertexIndex2, vertexIndex3);
    }
    {
        for (let vertexIndex = 0, l = remappedBoneIndices.length / bonesPerVertex; vertexIndex < l; ++vertexIndex) {
            for (let j = 0; j < bonesPerVertex; ++j) {
                let k = vertexIndex * bonesPerVertex + j;
                let boneIndex = remappedBoneIndices[k];
                let boneWeight = remappedBoneWeight[k];
                if (boneWeight != 0) {
                    if (!boneIndexes.has(boneIndex)) {
                        boneIndexes.set(boneIndex, []);
                        boneWeights.set(boneIndex, []);
                    }
                    boneIndexes.get(boneIndex).push(vertexIndex);
                    boneWeights.get(boneIndex).push(boneWeight);
                }
            }
        }
    }
    console.log(boneIndexes, boneWeights);
    fbxMesh.vertices = remappedVertices;
    fbxMesh.normals = remappedNormals;
    fbxMesh.polygons = polygons;
    fbxMesh.edges = edges;
    fbxMesh.uv = remappedUV;
    fbxMesh.uvIndex = uvIndex;
    //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};
    /*let fbxModel = new FBXModel(fbxMesh, fbxMaterial);
    fbxModel.name = mesh.name;*/
    //fbxFile.addModel(fbxModel);
    if (mesh.skeleton) {
        let boneDatas = { bi: boneIndexes, bw: boneWeights };
        //for (let i = 0; i < )
        {
            exportSkeleton(fbxScene, mesh.skeleton, context, fbxMesh, boneDatas, meshPose);
        }
    }
}
async function createFBXCamera(fbxScene, camera) {
    const fbxManager = fbxScene.manager;
    console.log(camera);
    let fbxCameraNode = fbxManager.createObject('FBXNode', camera.name);
    let fbxCamera = fbxManager.createObject('FBXCamera', camera.name);
    fbxCameraNode.nodeAttribute = fbxCamera;
    //fbxCamera.position.value = camera.position;
    fbxCameraNode.localTranslation.value = camera.position;
    quatToEulerDeg([0, 0, 0], camera.quaternion);
    //fbxCameraNode.localRotation.value = angles;
    fbxCameraNode.parent = fbxScene.rootNode; //TODO: set the actual parent
}
//NodeAttribute -> Model -> cluster (subdeformer) -> skin(deformer) -> geometry
//38772576 -> 39350848 -> 49570336 -> 49569504 -> 39673840 samba dancing
function exportSkeleton(fbxScene, skeleton, context, fbxMesh, boneDatas, meshPose) {
    const fbxManager = fbxScene.manager;
    let fbxSkin = fbxManager.createObject('FBXSkin', skeleton.name);
    const exportedClusters = new WeakMap();
    fbxSkin.geometry = fbxMesh;
    for (let bone of skeleton.bones) {
        exportBone(fbxScene, bone, context, exportedClusters, fbxSkin, boneDatas, meshPose);
    }
}
function exportBone(fbxScene, bone, context, exportedClusters, fbxSkin, boneDatas, meshPose) {
    const fbxManager = fbxScene.manager;
    let boneParent = bone.parent ?? bone.skeleton;
    const boneParentSkeletonBone = bone.parentSkeletonBone;
    if (boneParent) {
        if (boneParent.isBone) {
            // Ensure the parent is already exported
            exportBone(fbxScene, boneParent, context, exportedClusters, fbxSkin, boneDatas, meshPose);
        }
    }
    // Export this very bone
    let fbxBone;
    const exportedBones = context.exportedBones;
    if (exportedBones.has(bone)) {
        fbxBone = exportedBones.get(bone);
    }
    else if (exportedBones.has(boneParentSkeletonBone)) {
        fbxBone = exportedBones.get(boneParentSkeletonBone);
        exportedBones.set(bone, fbxBone);
    }
    else {
        fbxBone = fbxManager.createObject('FBXNode', bone.name); //TODO
        let angles = create$4();
        let transformedQuat = create$2();
        let transformedVec = create$4();
        if (boneParentSkeletonBone) {
            if (boneParent.isSkeleton) {
                fbxBone.localTranslation.value = transformQuat$1(transformedVec, boneParentSkeletonBone.worldPos, ROTATE_Z);
                mul$2(transformedQuat, ROTATE_Z, boneParentSkeletonBone.worldQuat);
                quatToEulerDeg(angles, transformedQuat);
            }
            else {
                fbxBone.localTranslation.value = boneParentSkeletonBone.position;
                quatToEulerDeg(angles, boneParentSkeletonBone.quaternion);
            }
        }
        else {
            if (boneParent.isSkeleton) {
                fbxBone.localTranslation.value = transformQuat$1(transformedVec, bone.worldPos, ROTATE_Z);
                mul$2(transformedQuat, ROTATE_Z, bone.worldQuat);
                quatToEulerDeg(angles, transformedQuat);
            }
            else {
                fbxBone.localTranslation.value = bone.position;
                quatToEulerDeg(angles, bone.quaternion);
            }
        }
        meshPose.add(fbxBone, bone.boneMat, true);
        fbxBone.localRotation.value = angles;
        let fbxLimb = fbxManager.createObject('FBXSkeleton', 'Name me FBXSkeleton', FBX_SKELETON_TYPE_LIMB);
        fbxBone.nodeAttribute = fbxLimb;
        fbxBone.parent = exportedBones.get(boneParent) ?? fbxScene.rootNode;
        exportedBones.set(bone, fbxBone);
    }
    if (!exportedClusters.has(bone)) {
        let fbxCluster = fbxManager.createObject('FBXCluster', bone.name);
        fbxCluster.transformMatrix = bone.poseToBone;
        fbxCluster.transformLinkMatrix = invert$3(tempMat4$3, bone.poseToBone);
        fbxCluster.link = fbxBone;
        if (boneDatas.bi.has(bone.boneId)) {
            for (let i = 0; i < boneDatas.bi.get(bone.boneId).length; ++i) {
                fbxCluster.addVertexIndex(boneDatas.bi.get(bone.boneId)[i], boneDatas.bw.get(bone.boneId)[i]);
            }
        }
        fbxSkin.addCluster(fbxCluster);
        exportedClusters.set(bone, fbxCluster);
    }
}
/*
export async function entitytoFBXFile(entity) {
    let playing = Graphics.isRunning();
    Graphics.pause();
    let fbxFile = createEmptyFile();
    fbxFile.version = 7400;

    let meshes = entity.getMeshList();

    for (let mesh of meshes) {
        if (!mesh.exportObj || !mesh.visible || !mesh.is('Mesh') || mesh.parent?.isParticleSystem) {
            continue;
        }

        let fbxMaterial = new FBXMaterial();
        fbxMaterial.name = 'mat_' + fbxMaterial.id + '.png';
        let fbxGeometry = new FBXGeometry();
        let meshMaterial = mesh.material;
        //console.log(meshMaterial);
        if (meshMaterial) {
            await configureMaterial(meshMaterial, fbxMaterial, mesh.materialsParams);
        }

        let meshDatas = mesh.exportObj();

        let polygons = [];
        let edges = [];
        let uvIndex = [];
        let uv = [];

        let vertexIndices = meshDatas.f;
        let vertexIndex1;
        let vertexIndex2;
        let vertexIndex3;
        let remappedIndex = new Map();
        let currentIndex = 0;
        let remappedVertices = [];
        let remappedNormals = [];
        let remappedUV = [];
        function remapIndex(index) {
            if (remappedIndex.has(index)) {
                return remappedIndex.get(index);
            }

            let newIndex = currentIndex++;
            remappedIndex.set(index, newIndex);

            let vIndex = index * 3;
            let uvIndex = index * 2;
            remappedVertices.push(meshDatas.v[vIndex], meshDatas.v[vIndex + 1], meshDatas.v[vIndex + 2]);
            remappedNormals.push(meshDatas.vn[vIndex], meshDatas.vn[vIndex + 1], meshDatas.vn[vIndex + 2]);
            remappedUV.push(meshDatas.vt[uvIndex], meshDatas.vt[uvIndex + 1]);

            return newIndex;
        }

        for (let i = 0, j = 0, l = vertexIndices.length; i < l; i += 3, j += 2) {
            vertexIndex1 = remapIndex(vertexIndices[i]);
            vertexIndex2 = remapIndex(vertexIndices[i + 1]);
            vertexIndex3 = remapIndex(vertexIndices[i + 2]);
            polygons.push(vertexIndex1, vertexIndex2, ~vertexIndex3);
            uvIndex.push(vertexIndex1, vertexIndex2, vertexIndex3);
            edges.push(vertexIndex1, vertexIndex2, vertexIndex3);
        }

        fbxGeometry.vertices = remappedVertices;
        fbxGeometry.normals = remappedNormals;
        fbxGeometry.polygons = polygons;
        fbxGeometry.edges = edges;
        fbxGeometry.uv = remappedUV;
        fbxGeometry.uvIndex = uvIndex;

        //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};

        let fbxModel = new FBXModel(fbxGeometry, fbxMaterial);
        fbxModel.name = mesh.name;
        fbxFile.addModel(fbxModel);
    }

    if (playing) {
        Graphics.play();
    }

    return fbxFile;
}
*/
async function configureMaterial(material, fbxMaterial, materialsParams) {
    const fbxManager = fbxMaterial.manager;
    if (material.uniforms['colorMap']) {
        let fbxTexture = fbxManager.createObject('FBXTexture');
        let fbxVideo = fbxManager.createObject('FBXVideo');
        fbxTexture.fbxMapping = 'DiffuseColor';
        fbxTexture.media = fbxVideo;
        fbxTexture.name = 'mat_' + fbxTexture.id + '.png';
        fbxVideo.name = 'mat_' + fbxVideo.id + '.png';
        fbxVideo.content = new Uint8Array(await renderMaterial(material, materialsParams));
        //fbxMaterial.addTexture(fbxTexture);
        fbxMaterial.diffuse.connectSrcObject(fbxTexture);
    }
}
let scene;
let camera;
let fullScreenQuadMesh;
async function renderMaterial(material, materialsParams) {
    if (!scene) {
        scene = new Scene();
        camera = new Camera();
        camera.position = [0, 0, 100];
        fullScreenQuadMesh = new FullScreenQuad();
        scene.addChild(fullScreenQuadMesh);
    }
    let [previousWidth, previousHeight] = new Graphics().setSize(1024, 1024); //TODOv3: constant
    let previousClearColor = new Graphics().getClearColor();
    new Graphics().clearColor(fromValues$3(0, 0, 0, 0));
    new Graphics().setIncludeCode('EXPORT_TEXTURES', '#define EXPORT_TEXTURES');
    new Graphics().setIncludeCode('SKIP_PROJECTION', '#define SKIP_PROJECTION');
    new Graphics().setIncludeCode('SKIP_LIGHTING', '#define SKIP_LIGHTING');
    fullScreenQuadMesh.material = material;
    fullScreenQuadMesh.materialsParams = materialsParams;
    new Graphics().render(scene, camera, 0, { DisableToolRendering: true });
    let imgContent = await new Graphics().toBlob();
    new Graphics().setIncludeCode('EXPORT_TEXTURES', '');
    new Graphics().setIncludeCode('SKIP_PROJECTION', '');
    new Graphics().setIncludeCode('SKIP_LIGHTING', '');
    new Graphics().setSize(previousWidth, previousHeight);
    new Graphics().clearColor(previousClearColor);
    return imgContent.arrayBuffer();
}

function resizeCamera(context, camera) {
    const w = context.getWidth() / 2.0;
    const h = context.getHeight() / 2.0;
    camera.left = -w;
    camera.right = w;
    camera.bottom = -h;
    camera.top = h;
    camera.aspectRatio = w / h;
}
class ContextObserverClass {
    #observed = new Map();
    #listeners = new Map();
    static #instance;
    constructor() {
        if (ContextObserverClass.#instance) {
            return ContextObserverClass.#instance;
        }
    }
    handleEvent(event) {
        const subject = event.target;
        const dependents = this.#observed.get(subject);
        if (dependents) {
            for (let dependent of dependents) {
                ContextObserverClass.#processEvent(subject, dependent, event);
            }
        }
    }
    static #processEvent(subject, dependent, event) {
        switch (true) {
            case dependent.is('Camera'):
                resizeCamera(new Graphics(), dependent);
                break;
            case dependent instanceof FirstPersonControl: //TODO do it for any CameraControl?
            case dependent instanceof OrbitControl:
                dependent.update();
                break;
            case dependent.isRenderTargetViewer:
                dependent.refreshPlane();
                break;
        }
    }
    #addObserver(subject, dependent) {
        if (!this.#observed.has(subject)) {
            this.#observed.set(subject, new Set());
        }
        this.#createListeners(subject, dependent);
        this.#observed.get(subject).add(dependent);
    }
    #removeObserver(subject, dependent) {
        if (this.#observed.has(subject)) {
            this.#observed.get(subject).delete(dependent);
            this.#removeListeners(subject, dependent);
        }
    }
    #createListeners(subject, dependent) {
        switch (true) {
            case dependent.is('Camera'):
            case dependent instanceof FirstPersonControl: //TODO do it for any CameraControl?
            case dependent instanceof OrbitControl:
            case dependent.isRenderTargetViewer:
                //subject.addEventListener('resize', this);
                this.#addListener(subject, 'resize');
                break;
        }
    }
    #removeListeners(subject, dependent) {
        const size = this.#observed.get(subject).size;
        if (size == 0) {
            const types = this.#listeners.get(subject);
            for (let type of types) {
                //console.log(listener);
                this.#removeListener(subject, type);
            }
        }
    }
    #addListener(target, type) {
        if (!this.#listeners.has(target)) {
            this.#listeners.set(target, new Set());
        }
        const targetSet = this.#listeners.get(target);
        if (!targetSet.has(type)) {
            targetSet.add(type);
            target.addEventListener(type, this);
        }
    }
    #removeListener(target, type) {
        const targetSet = this.#listeners.get(target);
        if (targetSet && targetSet.has(type)) {
            targetSet.delete(type);
            target.removeEventListener(type, this);
        }
    }
    observe(subject, dependent) {
        this.#addObserver(subject, dependent);
        switch (true) {
            case dependent.is('Camera'):
                resizeCamera(new Graphics(), dependent);
                break;
        }
    }
    unobserve(subject, dependent) {
        this.#removeObserver(subject, dependent);
    }
}
const ContextObserver = new ContextObserverClass();

let fetchFunction = null;
function setFetchFunction(func) {
    fetchFunction = func;
}
async function customFetch(resource, options) {
    try {
        if (fetchFunction) {
            return await fetchFunction(resource, options);
        }
        else {
            return await fetch(resource, options);
        }
    }
    catch (e) {
        console.error('Error during custom fetch: ', e);
        return new Response(null, { status: 400 });
    }
}

class RgbeImporter {
    #context;
    constructor(context) {
        this.#context = context;
    }
    async fetch(url) {
        const response = await customFetch(url);
        if (!response.ok) {
            return 'error while fetching resource';
        }
        return this.import(new BinaryReader(await response.arrayBuffer()));
    }
    import(reader) {
        let rgbe = decodeRGBE(reader.getDataView());
        console.info(rgbe);
        if (!rgbe) {
            return null;
        }
        const params = {
            internalFormat: TextureFormat.Rgb_32F,
            flipY: true,
        };
        if (new Graphics().OES_texture_float_linear) {
            params.magFilter = GL_LINEAR;
            params.minFilter = GL_LINEAR;
        }
        else {
            params.magFilter = GL_NEAREST;
            params.minFilter = GL_NEAREST;
        }
        const texture = TextureManager.createTexture(params);
        texture.setParameters(this.#context, TextureTarget.TEXTURE_2D);
        texture.texImage2D(this.#context, TextureTarget.TEXTURE_2D, rgbe.width, rgbe.height, TextureFormat.Rgb, TextureType.Float, rgbe.data);
        return texture;
    }
}

class ObjFace {
    v = [];
    n = [];
    t = [];
}
class Obj {
    #vertices = [];
    #normals = [];
    #uvs = [];
    #faces = [];
    addVertex(v) {
        this.#vertices.push(v);
    }
    addNormal(n) {
        this.#normals.push(n);
    }
    addUv(t) {
        this.#uvs.push(t);
    }
    addFace(f) {
        this.#faces.push(f);
    }
    toMesh() {
        //TODO: handle polygons and commons vertices
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const hasNormals = this.#normals.length > 0;
        const hasUv = this.#uvs.length > 0;
        let i = 0;
        for (const f of this.#faces) {
            indices.push(i, i + 1, i + 2);
            i += 3;
            vertices.push(...this.#vertices[f.v[0]]);
            vertices.push(...this.#vertices[f.v[1]]);
            vertices.push(...this.#vertices[f.v[2]]);
            if (hasNormals) {
                normals.push(...this.#normals[f.n[0]]);
                normals.push(...this.#normals[f.n[1]]);
                normals.push(...this.#normals[f.n[2]]);
            }
            if (hasUv) {
                uvs.push(...this.#uvs[f.t[0]]);
                uvs.push(...this.#uvs[f.t[1]]);
                uvs.push(...this.#uvs[f.t[2]]);
            }
        }
        return { i: indices, v: vertices, n: normals, t: uvs };
    }
}

function readVertex(line) {
    let arr = line.split(' ');
    return fromValues$4(arr[1] ?? 0.0, arr[2] ?? 0.0, arr[3] ?? 0.0 /*, arr[4] ?? 1.0*/);
}
function readVertexCoord(line) {
    let arr = line.split(' ');
    return fromValues(arr[1] ?? 0.0, arr[2] ?? 0);
}
function readVertexNormal(line) {
    let arr = line.split(' ');
    let v = fromValues$4(arr[1] ?? 1.0, arr[2] ?? 1, arr[3] ?? 1);
    return normalize$5(v, v);
}
function readFace(line) {
    let arr = line.split(' ');
    let face = new ObjFace();
    for (let i = 1; i < arr.length; i++) {
        let v = arr[i];
        ///let faceVertex = [];
        if (v) {
            let v2 = v.split('/');
            //faceVertex.push(v2[0] ?? 0, v2[1] ?? 0, v2[2] ?? 0);
            face.v.push((v2[0] ?? 1) - 1);
            face.t.push((v2[1] ?? 1) - 1);
            face.n.push((v2[2] ?? 1) - 1);
        }
        else {
            //			faceVertex.push(0, 0, 0);
            face.v.push(0);
            face.n.push(0);
            face.t.push(0);
        }
        //face.push(faceVertex);
    }
    return face;
}
function buildMesh(obj) {
    let geometry = new BufferGeometry();
    let material = new MeshBasicMaterial();
    const m = obj.toMesh();
    geometry.setIndex(new Uint32BufferAttribute(m.i, 1));
    geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(m.v, 3));
    geometry.setAttribute('aVertexNormal', new Float32BufferAttribute(m.n, 3));
    geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(m.t, 2));
    geometry.count = m.i.length;
    return new Mesh(geometry, material);
}
class OBJImporter {
    static load(txt) {
        let lines = txt.split('\n');
        const obj = new Obj();
        for (let line of lines) {
            line = line.trim();
            line = line.replace(/\s+/g, ' ');
            if (line.startsWith('v ')) {
                //vertices.push(readVertex(line));
                obj.addVertex(readVertex(line));
            }
            else if (line.startsWith('vt ')) {
                //verticesCoords.push(readVertexCoord(line));
                obj.addUv(readVertexCoord(line));
            }
            else if (line.startsWith('vn ')) {
                //verticesNormals.push(readVertexNormal(line));
                obj.addNormal(readVertexNormal(line));
            }
            else if (line.startsWith('f ')) {
                //faces.push(readFace(line));
                obj.addFace(readFace(line));
            }
        }
        return buildMesh(obj);
        //return buildMesh(vertices, verticesNormals, verticesCoords, faces);
    }
}

class LineBasicMaterial extends Material {
    lineWidth;
    constructor(params = {}) {
        super(params);
        this.color = fromValues$3(1.0, 1.0, 1.0, 1.0);
        this.lineWidth = 1;
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshbasic';
    }
}
Material.materialList['LineBasic'] = LineBasicMaterial;

const SPHERE_RADIUS = 1;
const RAYS_RADIUS = 3;
class PointLightHelper extends Mesh {
    constructor() {
        super(new BufferGeometry(), new LineBasicMaterial());
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.material.setColorMode(MaterialColorMode.PerMesh);
        this.material.setDefine('ALWAYS_ON_TOP');
        let sphere = new Sphere({ radius: SPHERE_RADIUS, segments: 12, rings: 12 });
        sphere.material.setDefine('ALWAYS_ON_TOP');
        this.addChild(sphere);
    }
    #createVertices() {
        const indices = [];
        const vertices = [];
        vertices.push(0, 0, 0);
        let iInc = PI / 4;
        let jInc = PI / 4;
        let k = 0;
        for (let i = 0; i < TWO_PI; i += iInc) {
            for (let j = 0; j < PI; j += jInc) {
                vertices.push(RAYS_RADIUS * Math.cos(i) * Math.sin(j), RAYS_RADIUS * Math.cos(j), RAYS_RADIUS * Math.sin(i) * Math.sin(j));
                indices.push(0, ++k);
            }
        }
        let geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.count = indices.length;
    }
}

const DEFAULT_LIGHT_COLOR = fromValues$4(1, 1, 1);
let defaultTextureSize = 1024;
class Light extends Entity {
    #intensity;
    #color;
    #range;
    shadow;
    #shadowTextureSize;
    isLight = true;
    constructor(parameters = {}) {
        super(parameters);
        this.#color = clone$4(parameters.color ?? DEFAULT_LIGHT_COLOR);
        this.#intensity = parameters.intensity ?? 1.0;
        this.castShadow = false;
        this.isRenderable = true;
        this.shadowTextureSize = defaultTextureSize;
    }
    set color(color) {
        copy$4(this.#color, color);
    }
    get color() {
        return this.#color;
    }
    set intensity(intensity) {
        this.#intensity = intensity;
    }
    get intensity() {
        return this.#intensity;
    }
    set range(range) {
        this.#range = range;
        if (this.shadow) {
            this.shadow.range = range;
        }
    }
    get range() {
        return this.#range;
    }
    set shadowTextureSize(shadowTextureSize) {
        this.#shadowTextureSize = shadowTextureSize;
        if (this.shadow) {
            this.shadow.textureSize = shadowTextureSize;
        }
    }
    get shadowTextureSize() {
        return this.#shadowTextureSize;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Light_1: null,
            color: { i18n: '#color', f: () => { let color = prompt('Color', this.color.join(' ')); if (color !== null) {
                    this.color = stringToVec3(color);
                } } },
            intensity: { i18n: '#intensity', f: () => { let intensity = prompt('Intensity', this.intensity); if (intensity !== null) {
                    this.intensity = intensity;
                } } },
        }, this.shadow ? {
            texture_size: { i18n: '#texture_size', f: () => { let textureSize = prompt('Texture size', String(this.shadow.textureSize[0])); if (textureSize !== null) {
                    this.shadowTextureSize = Number.parseFloat(textureSize);
                } } }
        } : null);
    }
    toJSON() {
        let json = super.toJSON();
        json.color = this.color;
        json.intensity = this.intensity;
        json.shadowtexturesize = this.shadowTextureSize;
        return json;
    }
    static async constructFromJSON(json) {
        return new Light(json);
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.color = json.color ?? DEFAULT_LIGHT_COLOR;
        this.intensity = json.intensity ?? 1;
        this.shadowTextureSize = json.shadowtexturesize ?? defaultTextureSize;
    }
    static set defaultTextureSize(textureSize) {
        defaultTextureSize = textureSize;
    }
    static getEntityName() {
        return 'Light';
    }
    is(s) {
        return s == 'Light';
    }
}
registerEntity(Light);

create$5();
class LightShadow {
    #textureSize = create();
    light;
    camera;
    shadowMatrix = create$5();
    viewPorts;
    viewPortsLength;
    renderTarget;
    constructor(light, camera) {
        camera.hideInExplorer = true;
        camera.serializable = false;
        light.addChild(camera);
        this.light = light;
        this.camera = camera;
        this.#textureSize = set$1(this.#textureSize, light.shadowTextureSize, light.shadowTextureSize);
        this.shadowMatrix = create$5();
        this.viewPorts = [fromValues$3(0, 0, 1, 1)];
        this.viewPortsLength = 1;
        this.renderTarget = new RenderTarget({ width: this.#textureSize[0], height: this.#textureSize[0], });
        this.renderTarget.resize(this.#textureSize[0], this.#textureSize[1]);
    }
    set range(range) {
    }
    set textureSize(textureSize) {
        set$1(this.#textureSize, textureSize, textureSize);
        this.renderTarget.resize(this.#textureSize[0], this.#textureSize[1]);
    }
    get textureSize() {
        return this.#textureSize;
    }
    computeShadowMatrix(mapIndex) {
        let shadowCamera = this.camera;
        let shadowMatrix = this.shadowMatrix;
        set$6(shadowMatrix, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
        shadowCamera.dirty();
        mul$5(shadowMatrix, shadowMatrix, shadowCamera.projectionMatrix);
        mul$5(shadowMatrix, shadowMatrix, shadowCamera.worldMatrixInverse);
    }
}

class SpotLightShadow extends LightShadow {
    constructor(light) {
        super(light, new Camera()); //TODO: adjust default variables
        const textureSize = this.textureSize;
        this.aspect = textureSize[0] / textureSize[1];
        this.angle = this.light.angle;
        this.range = this.light.range;
    }
    set angle(angle) {
        this.camera.verticalFov = RAD_TO_DEG * 2.0 * angle;
    }
    set range(range) {
        this.camera.farPlane = range || 1000.0;
    }
    set aspect(aspect) {
        this.camera.aspectRatio = aspect;
    }
}

const DEFAULT_ANGLE = Math.PI / 4.0;
const Z_VECTOR = fromValues$4(0, 0, 1);
const tempQuat$9 = create$2();
class SpotLight extends Light {
    isSpotLight = true;
    #innerAngle;
    innerAngleCos;
    #outerAngle;
    outerAngleCos;
    constructor(parameters = {}) {
        super(parameters);
        this.angle = DEFAULT_ANGLE;
        this.innerAngle = DEFAULT_ANGLE;
        this.range = 0;
    }
    set castShadow(castShadow) {
        super.castShadow = castShadow;
        if (this.castShadow) {
            this.shadow = new SpotLightShadow(this);
            this.shadow.range = this.range;
            this.shadow.angle = this.#outerAngle;
        }
    }
    get castShadow() {
        return super.castShadow;
    }
    set angle(angle) {
        this.#outerAngle = angle;
        this.outerAngleCos = Math.cos(angle);
        if (this.shadow) {
            this.shadow.angle = angle;
        }
    }
    get angle() {
        return this.#outerAngle;
    }
    set innerAngle(innerAngle) {
        this.#innerAngle = innerAngle;
        this.innerAngleCos = Math.cos(innerAngle);
    }
    get innerAngle() {
        return this.#innerAngle;
    }
    getDirection(out = create$4()) {
        return transformQuat$1(out, Z_VECTOR, this.getWorldQuaternion(tempQuat$9));
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            angle: { i18n: '#angle', f: () => { let angle = prompt('Angle', String(this.angle)); if (angle !== null) {
                    this.angle = Number(angle);
                } } },
            inner_angle: { i18n: '#inner_angle', f: () => { let innerAngle = prompt('Inner angle', String(this.#innerAngle)); if (innerAngle !== null) {
                    this.innerAngle = Number(innerAngle);
                } } },
            range: { i18n: '#range', f: () => { let range = prompt('Range', this.range); if (range !== null) {
                    this.range = range;
                } } },
        });
    }
    static getEntityName() {
        return 'SpotLight';
    }
}
registerEntity(SpotLight);

const DIVISIONS = 32;
const tempVec4$1 = create$3();
class SpotLightHelper extends Mesh {
    #color = create$4();
    #angle;
    #range;
    #spotLight;
    #vertexPositionAttribute;
    constructor() {
        super(new BufferGeometry(), new LineBasicMaterial());
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.material.setMeshColor();
        this.material.setDefine('ALWAYS_ON_TOP');
        this.castShadow = false;
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, event => this.update());
    }
    #createVertices() {
        const indices = [];
        const vertices = [];
        vertices.push(0, 0, 0);
        let k = 1;
        for (let i = 0; i < DIVISIONS; i += 1) {
            vertices.push(0, 0, 0);
            indices.push(0, k);
            if (k < DIVISIONS) {
                //segement til next point
                indices.push(k, ++k);
            }
        }
        //close loop
        indices.push(k, 1);
        let geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        this.#vertexPositionAttribute = new Float32BufferAttribute(vertices, 3);
        geometry.setAttribute('aVertexPosition', this.#vertexPositionAttribute);
        geometry.count = indices.length;
    }
    update() {
        let spotLight = this.#spotLight;
        if (spotLight && ((this.#range != spotLight.range) || (this.#angle != spotLight.angle) || (!exactEquals$4(spotLight.color, this.#color)))) {
            copy$4(this.#color, spotLight.color);
            set$4(tempVec4$1, this.#color[0], this.#color[1], this.#color[2], 1.);
            this.material.setMeshColor(tempVec4$1);
            let range = spotLight.range || 1000.0;
            let radius = Math.sin(spotLight.angle) * range;
            this.#range = spotLight.range;
            this.#angle = spotLight.angle;
            let verticesArray = this.#vertexPositionAttribute._array;
            for (let i = 0; i < DIVISIONS; i += 1) {
                let angle = i * TWO_PI / DIVISIONS;
                let index = (i + 1) * 3;
                verticesArray[index + 0] = Math.cos(angle) * radius;
                verticesArray[index + 1] = Math.sin(angle) * radius;
                verticesArray[index + 2] = -range;
                verticesArray.subarray(index, index + 2);
            }
            this.#vertexPositionAttribute.dirty = true;
        }
    }
    parentChanged(parent = null) {
        if (parent instanceof SpotLight) {
            this.#spotLight = parent;
        }
        else {
            this.#spotLight = null;
        }
        this.update();
    }
}

class AmbientLight extends Light {
    isAmbientLight = true;
    constructor(params = {}) {
        super(params);
    }
    static async constructFromJSON(json) {
        return new AmbientLight(json);
    }
    static getEntityName() {
        return 'AmbientLight';
    }
    is(s) {
        if (s == 'AmbientLight') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(AmbientLight);

const worldPos = create$4();
[
    fromValues$4(1, 0, 0), fromValues$4(-1, 0, 0), fromValues$4(0, 0, 1),
    fromValues$4(0, 0, -1), fromValues$4(0, 1, 0), fromValues$4(0, -1, 0)
];
[
    fromValues$4(0, 1, 0), fromValues$4(0, 1, 0), fromValues$4(0, 1, 0),
    fromValues$4(0, 1, 0), fromValues$4(0, 0, 1), fromValues$4(0, 0, -1)
];
const S2 = Math.SQRT1_2;
const DIRECTIONS = [
    fromValues$2(0, -S2, 0, S2), //+x
    fromValues$2(0, S2, 0, S2), //-x
    fromValues$2(0, 1, 0, 0), //+z
    fromValues$2(0, 0, 0, 1), //-z
    fromValues$2(S2, 0, 0, S2), //+y
    fromValues$2(-S2, 0, 0, S2), //-y
];
class PointLightShadow extends LightShadow {
    constructor(light) {
        super(light, new Camera({ nearPlane: 1, farPlane: 1000, verticalFov: 90 })); //TODO: adjust default variables
        this.range = this.light.range;
        this.viewPorts = [
            fromValues$3(0.5, 0.5, 0.25, 0.5),
            fromValues$3(0, 0.5, 0.25, 0.5),
            fromValues$3(0.75, 0.5, 0.25, 0.5),
            fromValues$3(0.25, 0.5, 0.25, 0.5),
            fromValues$3(0.75, 0, 0.25, 0.5),
            fromValues$3(0.25, 0, 0.25, 0.5),
            /*vec4.fromValues(2, 1, 1, 1),
            vec4.fromValues(0, 1, 1, 1),
            vec4.fromValues(3, 1, 1, 1),
            vec4.fromValues(1, 1, 1, 1),
            vec4.fromValues(3, 0, 1, 1),
            vec4.fromValues(1, 0, 1, 1),*/
        ];
        this.viewPortsLength = 6;
    }
    computeShadowMatrix(mapIndex) {
        let shadowCamera = this.camera;
        let shadowMatrix = this.shadowMatrix;
        shadowCamera.setWorldQuaternion(DIRECTIONS[mapIndex]);
        shadowCamera.dirty();
        shadowCamera.getWorldPosition(worldPos);
        scale$5(worldPos, worldPos, -1);
        fromTranslation$1(shadowMatrix, worldPos);
    }
}

class PointLight extends Light {
    isPointLight = true;
    constructor(params = {}) {
        super(params);
        this.range = params.range ?? 100.0;
    }
    set castShadow(castShadow) {
        super.castShadow = castShadow;
        if (this.castShadow) {
            this.shadow = new PointLightShadow(this);
            this.shadow.range = this.range;
        }
    }
    get castShadow() {
        return super.castShadow;
    }
    toJSON() {
        let json = super.toJSON();
        json.range = this.range;
        return json;
    }
    static async constructFromJSON(json) {
        return new PointLight(json);
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.range = json.range ?? this.range;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            range: { i18n: '#range', f: () => { let range = prompt('Range', this.range); if (range !== null) {
                    this.range = range;
                } } },
        });
    }
    static getEntityName() {
        return 'PointLight';
    }
    is(s) {
        if (s == 'PointLight') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(PointLight);

const DEFAULT_POINT = create$4();
class Curve {
    controlPoints = [];
    arcLength = 0;
    getPosition(t, out = create$4()) {
        return out;
    }
    getArcLength(divisions = 100) {
        create$4();
        let last = create$4();
        let current = create$4();
        let temp;
        this.getPosition(0, last);
        let length = 0;
        for (let i = 1; i <= divisions; i++) {
            this.getPosition(i / divisions, current);
            length += distance$3(last, current);
            temp = last;
            last = current;
            current = temp;
        }
        return length;
    }
    getPoints(divisions = 5) {
        let points = [];
        for (let i = 0; i <= divisions; i++) {
            points.push(this.getPosition(i / divisions));
        }
        return points;
    }
    getAppropriateDivision(division) {
        return division;
    }
}

class CubicBezierCurve extends Curve {
    p0 = create$4();
    p1 = create$4();
    p2 = create$4();
    p3 = create$4();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT, p2 = DEFAULT_POINT, p3 = DEFAULT_POINT) {
        super();
        copy$4(this.p0, p0);
        copy$4(this.p1, p1);
        copy$4(this.p2, p2);
        copy$4(this.p3, p3);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = create$4()) {
        //P = (1 - t)³ * P0 + 3 * (1 - t)² * t * P1 + 3 * (1 - t) * t² * P2 + t³ * P3
        let oneMinusT = 1 - t;
        let oneMinusTSqr = oneMinusT * oneMinusT;
        let tSqr = t * t;
        scale$5(out, this.p0, oneMinusTSqr * oneMinusT);
        scaleAndAdd$2(out, out, this.p1, 3 * oneMinusTSqr * t);
        scaleAndAdd$2(out, out, this.p2, 3 * oneMinusT * tSqr);
        scaleAndAdd$2(out, out, this.p3, tSqr * t);
        return out;
    }
}

class LinearBezierCurve extends Curve {
    p0 = create$4();
    p1 = create$4();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT) {
        super();
        copy$4(this.p0, p0);
        copy$4(this.p1, p1);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = create$4()) {
        if (t === 0) {
            copy$4(out, this.p0);
        }
        else if (t === 1) {
            copy$4(out, this.p1);
        }
        else {
            sub$2(out, this.p1, this.p0);
            scaleAndAdd$2(out, this.p0, out, t);
        }
        return out;
    }
    getArcLength() {
        return distance$3(this.p0, this.p1);
    }
    getAppropriateDivision() {
        return 1;
    }
}

class QuadraticBezierCurve extends Curve {
    p0 = create$4();
    p1 = create$4();
    p2 = create$4();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT, p2 = DEFAULT_POINT) {
        super();
        copy$4(this.p0, p0);
        copy$4(this.p1, p1);
        copy$4(this.p2, p2);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = create$4()) {
        //P = (1 - t)² * P0 + 2 * (1 - t) * t * P1 + t² * P2
        let oneMinusT = 1 - t;
        scale$5(out, this.p0, oneMinusT * oneMinusT);
        scaleAndAdd$2(out, out, this.p1, 2 * oneMinusT * t);
        scaleAndAdd$2(out, out, this.p2, t * t);
        return out;
    }
}

let p0 = create$4();
let p1 = create$4();
let p2 = create$4();
let p3 = create$4();
class Path extends Curve {
    looping;
    _curves = [];
    cursor = create$4();
    constructor(looping = false) {
        super();
        this.looping = looping;
    }
    set curves(curves) {
        this._curves.splice(undefined, undefined, ...curves);
        this.arcLength = this.getArcLength();
    }
    get curves() {
        return this._curves;
    }
    addCurve(curve) {
        this._curves.push(curve);
        this.arcLength = this.getArcLength();
    }
    getArcLength(divisions) {
        let length = 0;
        for (let curve of this._curves) {
            length += curve.getArcLength(divisions);
        }
        return length;
    }
    getPosition(t, out = create$4()) {
        let l = this.arcLength * t;
        let accumulate = 0;
        let accumulateTmp = 0;
        for (let curve of this._curves) {
            accumulateTmp += curve.arcLength;
            if (accumulateTmp > l) {
                let t2 = (l - accumulate) / curve.arcLength;
                return curve.getPosition(t2, out);
            }
            accumulate = accumulateTmp;
        }
        return out;
    }
    moveTo(p0) {
        copy$4(this.cursor, p0);
    }
    lineTo(p1) {
        this.addCurve(new LinearBezierCurve(this.cursor, p1));
        copy$4(this.cursor, p1);
    }
    quadraticCurveTo(p1, p2) {
        this.addCurve(new QuadraticBezierCurve(this.cursor, p1, p2));
        copy$4(this.cursor, p2);
    }
    cubicCurveTo(p1, p2, p3) {
        this.addCurve(new CubicBezierCurve(this.cursor, p1, p2, p3));
        copy$4(this.cursor, p3);
    }
    getPoints(divisions = 12) {
        let points = [];
        let last;
        for (let i = 0, curves = this.curves; i < curves.length; i++) {
            let curve = curves[i];
            let resolution = curve.getAppropriateDivision(divisions);
            let pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
                let point = pts[j];
                if (last && equals$5(last, point)) {
                    continue;
                }
                points.push(point);
                last = point;
            }
        }
        if (this.looping && points.length > 1 && !equals$5(points[0], points[points.length - 1])) {
            points.push(points[0]);
        }
        return points;
    }
    fromSvgPath(path) {
        path = path.split(' ');
        for (let i = 0, l = path.length; i < l;) {
            switch (path[i++]) {
                case 'm':
                    set$5(p0, path[i++], path[i++], 0);
                    this.moveTo(p0);
                    break;
                case 'l':
                    set$5(p1, path[i++], path[i++], 0);
                    this.lineTo(p1);
                    break;
                case 'q':
                    set$5(p2, path[i++], path[i++], 0);
                    set$5(p1, path[i++], path[i++], 0);
                    this.quadraticCurveTo(p1, p2);
                    break;
                case 'c':
                    set$5(p3, path[i++], path[i++], 0);
                    set$5(p1, path[i++], path[i++], 0);
                    set$5(p2, path[i++], path[i++], 0);
                    this.cubicCurveTo(p1, p2, p3);
                    break;
            }
        }
    }
}

class Shape extends Path {
    uuid = generateRandomUUID();
    type = 'Shape';
    holes = [];
    getPointsHoles(divisions) {
        const holesPts = [];
        for (let i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    }
}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */
const Earcut = {
    triangulate: function (data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
    }
    else {
        for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start)
        return start;
    if (!end)
        end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
                break;
            again = true;
        }
        else {
            p = p.next;
        }
    } while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
        return;
    // interlink polygon nodes in z-order
    if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0)
            return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0)
            return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0)
            return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
            list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y)
                        return p;
                    if (hy === p.next.y)
                        return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);
    if (!m)
        return null;
    if (hx === qx)
        return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    } while (p !== stop);
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q)
                    break;
            }
            qSize = inSize;
            while (pSize > 0 || (qSize > 0 && q)) {
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                }
                else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail)
                    tail.nextZ = e;
                else
                    list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    } while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;
    return x | (y << 1);
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
            leftmost = p;
        p = p.next;
    } while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign$1(area(p1, q1, p2));
    const o2 = sign$1(area(p1, q1, q2));
    const o3 = sign$1(area(p2, q2, p1));
    const o4 = sign$1(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
        return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1))
        return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1))
        return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2))
        return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2))
        return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
            intersects(p, p.next, a, b))
            return true;
        p = p.next;
    } while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a, inside = false;
    const px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = new Node$1(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    }
    else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
}
function Node$1(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

class ShapeUtils {
    // calculate area of the contour polygon
    static area(contour) {
        const n = contour.length;
        let a = 0.0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
        }
        return a * 0.5;
    }
    static isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
        const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i = 0; i < holes.length; i++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
        }
        //
        const triangles = Earcut.triangulate(vertices, holeIndices);
        //
        for (let i = 0; i < triangles.length; i += 3) {
            faces.push(triangles.slice(i, i + 3));
        }
        return faces;
    }
}
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && equals$1(points[l - 1], points[0])) {
        points.pop();
    }
}
function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
        vertices.push(contour[i][0]);
        vertices.push(contour[i][1]);
    }
}

class ShapePath {
    type = 'ShapePath';
    subPaths = [];
    currentPath = null;
    moveTo(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo([x, y, 0]);
        return this;
    }
    lineTo(x, y) {
        this.currentPath.lineTo([x, y, 0]);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo([aCPx, aCPy, 0], [aX, aY, 0]);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo([aCP1x, aCP1y, 0], [aCP2x, aCP2y, 0], [aX, aY, 0]);
        return this;
    }
    splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
    }
    toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for (let i = 0, l = inSubpaths.length; i < l; i++) {
                const tmpPath = inSubpaths[i];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt[0] - edgeLowPt[0];
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                        continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt[0] === edgeLowPt[0])
                            return true; // inPt is on contour ?
                        // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    }
                    else {
                        const perpEdge = edgeDy * (inPt[0] - edgeLowPt[0]) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0)
                            return true; // inPt is on contour ?
                        if (perpEdge < 0)
                            continue;
                        inside = !inside; // true intersection left of inPt
                    }
                }
                else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y)
                        continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (((edgeHighPt[0] <= inPt[0]) && (inPt[0] <= edgeLowPt[0])) ||
                        ((edgeLowPt[0] <= inPt[0]) && (inPt[0] <= edgeHighPt[0])))
                        return true; // inPt: Point on contour !
                    // continue;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0)
            return [];
        if (noHoles === true)
            return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for (let i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if ((!holesFirst) && (newShapes[mainIdx]))
                    mainIdx++;
                newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst)
                    mainIdx++;
                newShapeHoles[mainIdx] = [];
                //console.log('cw', i);
            }
            else {
                newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                //console.log('ccw', i);
            }
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0])
            return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                const sho = newShapeHoles[sIdx];
                for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (sIdx !== s2Idx)
                                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            }
                            else {
                                ambiguous = true;
                            }
                        }
                    }
                    if (hole_unassigned) {
                        betterShapeHoles[sIdx].push(ho);
                    }
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) {
                // console.log("to change: ", toChange);
                if (!ambiguous)
                    newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for (let i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
                tmpShape.holes.push(tmpHoles[j].h);
            }
        }
        //console.log("shape", shapes);
        return shapes;
    }
}

class Font {
    json;
    constructor(json) {
        this.json = json;
    }
    generateShapes(text, size = 100) {
        let shapes = [];
        let paths = this.createPaths(text, size);
        for (let path of paths) {
            shapes.push(...path.toShapes());
        }
        return shapes;
    }
    createPaths(text = '', size = 1) {
        let data = this.json;
        const chars = Array.from(text);
        const scale = size / data.resolution;
        const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        const paths = [];
        let offsetX = 0, offsetY = 0;
        for (let char of chars) {
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            }
            else {
                const ret = this.createPath(char, scale, offsetX, offsetY);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    createPath(char, scale, offsetX, offsetY) {
        let data = this.json;
        const glyph = data.glyphs[char] ?? data.glyphs['?'];
        const path = new ShapePath();
        let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            let outline = glyph.o.split(' ');
            for (let i = 0, l = outline.length; i < l;) {
                let action = outline[i++];
                switch (action) {
                    case 'm': // moveTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l': // lineTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q': // quadraticCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b': // bezierCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        cpx2 = outline[i++] * scale + offsetX;
                        cpy2 = outline[i++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return { offsetX: glyph.ha * scale, path: path };
    }
}

class FontManager {
    static #fontList = new Map();
    static #fontsPath;
    static #manifestPromise;
    static setFontsPath(url) {
        this.#fontsPath = url;
    }
    static async #getManifest() {
        if (this.#manifestPromise) {
            return this.#manifestPromise;
        }
        this.#manifestPromise = new Promise(async (resolve) => {
            if (!this.#fontsPath) {
                throw 'No manifest set';
            }
            let response = await customFetch(this.#fontsPath + 'manifest.json');
            resolve(await response.json());
        });
        return this.#manifestPromise;
    }
    static async #loadFont(name, style) {
        let manifest = await this.#getManifest();
        let fonts = manifest?.fonts;
        if (fonts) {
            let font = fonts[name];
            if (font && font.styles) {
                let s = font.styles[style];
                if (s) {
                    let response = await customFetch(this.#fontsPath + s);
                    let fontFile = await response.json();
                    let font = new Font(fontFile);
                    this.#fontList.get(name).set(style, font);
                    return font;
                }
            }
        }
    }
    static async getFont(name, style = 'normal') {
        name = name.toLowerCase();
        style = style.toLowerCase();
        let fontFamilly = this.#fontList.get(name);
        if (fontFamilly) {
            let font = fontFamilly.get(style);
            if (font) {
                return font;
            }
        }
        else {
            this.#fontList.set(name, new Map());
        }
        return await this.#loadFont(name, style);
    }
    static async getFontList() {
        let list = [];
        let manifest = await this.#getManifest();
        let fonts = manifest?.fonts;
        if (fonts) {
            for (let fontName in fonts) {
                let font = fonts[fontName];
                for (let styleName in font.styles) {
                    list.push([fontName, styleName]);
                }
            }
        }
        return list;
    }
}

class MeshBasicPbrMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.addParameter('color', MateriaParameterType.Color4, null, newValue => this.setColor4Uniform('uColor', newValue ?? DEFAULT_COLOR));
        this.addParameter('metalness', MateriaParameterType.NormalizedFloat, 0, newValue => { this.uniforms['uMetalness'] = newValue; });
        this.addParameter('roughness', MateriaParameterType.NormalizedFloat, 0, newValue => { this.uniforms['uRoughness'] = newValue; });
        this.addParameter('color_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uColorTexture', newValue, 'USE_COLOR_TEXTURE'));
        this.addParameter('normal_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uNormalTexture', newValue, 'USE_NORMAL_TEXTURE'));
        this.addParameter('metalness_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uMetalnessTexture', newValue, 'USE_METALNESS_TEXTURE'));
        this.addParameter('roughness_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uRoughnessTexture', newValue, 'USE_ROUGHNESS_TEXTURE'));
        this.setParameters(params);
    }
    setParameters(params = {}) {
        this.setColor(params.color);
        this.setMetalness(params.metalness);
        this.setRoughness(params.roughness);
        this.setColorTexture(params.colorTexture);
        this.setNormalTexture(params.normalTexture);
        this.setMetalnessTexture(params.metalnessTexture);
        this.setRoughnessTexture(params.roughnessTexture);
    }
    setColor(color) {
        if (color !== undefined) {
            this.setParameterValue('color', color);
        }
    }
    setMetalness(metalness) {
        if (metalness !== undefined) {
            this.setParameterValue('metalness', metalness);
        }
    }
    setRoughness(roughness) {
        if (roughness !== undefined) {
            this.setParameterValue('roughness', roughness);
        }
    }
    setColorTexture(colorTexture) {
        if (colorTexture !== undefined) {
            this.setParameterValue('color_texture', colorTexture);
        }
    }
    setNormalTexture(normalTexture) {
        if (normalTexture !== undefined) {
            this.setParameterValue('normal_texture', normalTexture);
        }
    }
    setMetalnessTexture(metalnessTexture) {
        if (metalnessTexture !== undefined) {
            this.setParameterValue('metalness_texture', metalnessTexture);
        }
    }
    setRoughnessTexture(roughnessTexture) {
        if (roughnessTexture !== undefined) {
            this.setParameterValue('roughness_texture', roughnessTexture);
        }
    }
    get shaderSource() {
        return 'meshbasicpbr';
    }
    toJSON() {
        let json = super.toJSON();
        return json;
    }
    static async constructFromJSON(json) {
        return new MeshBasicPbrMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
    }
    static getEntityName() {
        return 'MeshBasicPbrMaterial';
    }
}
Material.materialList['MeshBasicPbr'] = MeshBasicPbrMaterial;
registerEntity(MeshBasicPbrMaterial);

class GridMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.spacing = params.spacing ?? 1;
        this.setBlending(MATERIAL_BLENDING_NORMAL);
        this.renderFace(RenderFace.Both);
    }
    set spacing(spacing) {
        this.uniforms['uSpacing'] = spacing;
    }
    getShaderSource() {
        return 'grid';
    }
}
Material.materialList['Grid'] = GridMaterial;

class MeshFlatMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.setDefine('FLAT_SHADING');
    }
    getShaderSource() {
        return 'meshphong';
    }
}
Material.materialList['MeshFlat'] = MeshFlatMaterial;

class MeshPhongMaterial extends Material {
    map = null;
    lightMap = null;
    lightMapIntensity = 1.0;
    aoMap = null;
    aoMapIntensity = 1.0;
    specularMap = null;
    alphaMap = null;
    envMap = null;
    combine = 0 /*MultiplyOperation*/;
    reflectivity = 1;
    refractionRatio = 0.98;
    wireframe = false;
    wireframeLinewidth = 1;
    wireframeLinecap = 'round';
    wireframeLinejoin = 'round';
    skinning = false;
    morphTargets = false;
    constructor(params = {}) {
        super(params);
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshphong';
    }
}
Material.materialList['MeshPhong'] = MeshPhongMaterial;

class ShaderToyMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.setTexture('noiseMap', TextureManager.createNoiseTexture(256, 256));
    }
    getShaderSource() {
        return 'shadertoy';
    }
}
Material.materialList['ShaderToy'] = ShaderToyMaterial;

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

if (filepath && isNode) {
  
var fs = require("fs");
var path = require("path");

return new Promise((resolve, reject) => {
  fs.readFile(path.resolve(__dirname, filepath), (error, buffer) => {
    if (error != null) {
      reject(error);
    } else {
      resolve(_instantiateOrCompile(buffer, imports, false));
    }
  });
});

} else if (filepath) {
  
return _instantiateOrCompile(fetch(filepath), imports, true);

}

if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function loopSubdivision(imports){return _loadWasmModule(0, null, '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IAIgASgCBGsLIQAgA0EgaiQAIAALPgEBfyMAQRBrIgMkACAAKAI8IAEgAkH/AXEgA0EIahACIgAEQEGEMCAANgIACyADKQMIIQEgA0EQaiQAIAELCQAgACgCPBADC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBf2oiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQX9qIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQs0AQJ/QfgvKAIAIQBB8C8oAgAiAQRAIAEQBQsgAARAIAAQBQtB+C9CADcDAEHwL0IANwMACzQAIABQRQRAA0AgAUF/aiIBIACnQQ9xQfAQai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABC8UCAQN/IwBB0AFrIgIkACACIAE2AswBQQAhASACQaABakEAQSgQCCACIAIoAswBNgLIAQJAQQAgAkHIAWogAkHQAGogAkGgAWoQIUEASA0AIAAoAkxBAE4EQEEBIQELIAAoAgAhAyAALABKQQBMBEAgACADQV9xNgIACyADQSBxIQQCfyAAKAIwBEAgACACQcgBaiACQdAAaiACQaABahAhDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACACQcgBaiACQdAAaiACQaABahAhIANFDQAaIABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAM2AiwgAEEANgIcIABBADYCECAAKAIUGiAAQQA2AhRBAAsaIAAgBCAAKAIAcjYCACABRQ0ACyACQdABaiQAC4kCAAJAIAAEfyABQf8ATQ0BAkBBqC4oAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCyABQYCwA09BACABQYBAcUGAwANHG0UEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDwsgAUGAgHxqQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUES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', imports)}

class LoopSubdivision {
    static #instance;
    #webAssembly;
    #heap;
    #heapBuffer;
    constructor() {
        if (LoopSubdivision.#instance) {
            return LoopSubdivision.#instance;
        }
        LoopSubdivision.#instance = this;
    }
    async subdivide(indices, vertices, subdivideCount = 1, tolerance = 0.001) {
        await this.#initWebAssembly();
        const api = this.#webAssembly.instance.exports;
        //const meshPointer = api.create_mesh();
        //console.log(meshPointer);
        const indicesCount = indices.length;
        const verticesCount = vertices.length;
        const indicesPointer = api.create_buffer(indicesCount * 4);
        const verticesPointer = api.create_buffer(verticesCount * 4);
        const indicesView = new Uint32Array(this.#heapBuffer, indicesPointer, indicesCount);
        indicesView.set(indices);
        const verticesView = new Float32Array(this.#heapBuffer, verticesPointer, verticesCount);
        verticesView.set(vertices);
        //console.log(indices.join(', '));
        //console.log(vertices.join(', '));
        const subdivideResult = api.subdivide(indicesPointer, indicesCount, verticesPointer, verticesCount, subdivideCount, tolerance);
        api.delete_buffer(indicesPointer);
        api.delete_buffer(verticesPointer);
        const resultView = new Uint32Array(this.#heapBuffer, subdivideResult, 4);
        const newIndicesView = new Uint32Array(new Uint32Array(this.#heapBuffer, resultView[0], resultView[1]));
        const newVerticesView = new Float32Array(new Float32Array(this.#heapBuffer, resultView[2], resultView[3]));
        api.cleanup();
        return {
            indices: newIndicesView,
            vertices: newVerticesView,
        };
    }
    async #initWebAssembly() {
        if (this.#webAssembly) {
            return this.#webAssembly;
        }
        const env = {
            'abortStackOverflow': _ => { throw new Error('overflow'); },
            'emscripten_notify_memory_growth': _ => {
                this.#initHeap();
            },
            'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
            'tableBase': 0,
            'memoryBase': 1024,
            'STACKTOP': 0,
            console_log: (ptr, size) => {
                const stringContent = new Uint8Array(this.#heapBuffer, ptr, size);
                console.log(new TextDecoder().decode(stringContent));
            },
        };
        //this.#webAssembly = await loopSubdivision({ env });
        const imports = {
            env: env,
            wasi_snapshot_preview1: {
                fd_write: (fd, iovsPtr, iovsLength, bytesWrittenPtr) => {
                    const iovs = new Uint32Array(this.#heapBuffer, iovsPtr, iovsLength * 2);
                    if (fd === 1 || fd === 2) { //stdout
                        let text = '';
                        let totalBytesWritten = 0;
                        const decoder = new TextDecoder();
                        for (let i = 0; i < iovsLength * 2; i += 2) {
                            const offset = iovs[i];
                            const length = iovs[i + 1];
                            const textChunk = decoder.decode(new Int8Array(this.#heapBuffer, offset, length));
                            text += textChunk;
                            totalBytesWritten += length;
                        }
                        const dataView = new DataView(this.#heapBuffer);
                        dataView.setInt32(bytesWrittenPtr, totalBytesWritten, true);
                        console.log(text);
                    }
                    return 0;
                },
                fd_seek: (p1, p2, p3, p4) => {
                },
                fd_read: (p1, p2, p3, p4) => {
                },
                fd_close: (p1, p2, p3, p4) => {
                },
                proc_exit: (p1) => { console.log('Exit code:', p1); },
            },
        };
        //this.#webAssembly = await WebAssembly.instantiateStreaming(fetch('loop_subdivision.wasm'), imports);
        this.#webAssembly = await loopSubdivision(imports);
        this.#initHeap();
        return this.#webAssembly;
    }
    #initHeap() {
        //this.HEAPU8 = new Uint8Array(this.webAssembly.instance.exports.memory.buffer);
        this.#heap = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
        this.#heapBuffer = this.#heap.buffer;
    }
}

const IO_TYPE_FLOAT = 2;
const IO_TYPE_VEC2 = 3;
const IO_TYPE_COLOR = 7;
const IO_TYPE_TEXTURE_2D = 8;
const IO_TYPE_ARRAY_INT = 101;
const IO_TYPE_ARRAY_FLOAT = 102;
/*const ARRAY_START = 1000;
export const IO_TYPE_INT_ARRAY = ARRAY_START + 1;
export const IO_TYPE_FLOAT_ARRAY = ARRAY_START + 2;
export const IO_TYPE_VEC2_ARRAY = ARRAY_START + 3;
export const IO_TYPE_VEC3_ARRAY = ARRAY_START + 4;
export const IO_TYPE_VEC4_ARRAY = ARRAY_START + 5;
export const IO_TYPE_QUAT_ARRAY = ARRAY_START + 6;
export const IO_TYPE_COLOR_ARRAY = ARRAY_START + 7;
export const IO_TYPE_TEXTURE_2D_ARRAY = ARRAY_START + 8;*/
var InputOutputType;
(function (InputOutputType) {
    InputOutputType[InputOutputType["Unknown"] = 0] = "Unknown";
    InputOutputType[InputOutputType["Int"] = 1] = "Int";
    InputOutputType[InputOutputType["Float"] = 2] = "Float";
    InputOutputType[InputOutputType["Vec2"] = 3] = "Vec2";
    InputOutputType[InputOutputType["Vec3"] = 4] = "Vec3";
    InputOutputType[InputOutputType["Vec4"] = 5] = "Vec4";
    InputOutputType[InputOutputType["Quat"] = 6] = "Quat";
    InputOutputType[InputOutputType["Color"] = 7] = "Color";
    InputOutputType[InputOutputType["Texture2D"] = 8] = "Texture2D";
    InputOutputType[InputOutputType["IntArray"] = 1000] = "IntArray";
    InputOutputType[InputOutputType["FloatArray"] = 1001] = "FloatArray";
})(InputOutputType || (InputOutputType = {}));
class InputOutput {
    node;
    id;
    type;
    size;
    _value;
    constructor(node, id, type, size = 1) {
        this.node = node;
        this.id = id;
        this.type = type;
        this.size = size;
        if (size == 1) {
            this._value = undefined;
        }
        else {
            this._value = new Array(size);
        }
    }
}

//const isUndefined = (element) => element == undefined;
class Input extends InputOutput {
    #predecessor;
    constructor(node, id, type, size = 1) {
        super(node, id, type, size);
    }
    set value(value) {
        //TODO: check the value type
        this._value = value;
        this.node.invalidate();
    }
    /*
    setArrayValue(value, index) {
        if (index == undefined) {
            index = this._value.findIndex(isUndefined)
            if (index == -1) {
                return;
            }
        }

        //TODOv3 check type / index
        this._value[index] = value;
        this.node.invalidate();
    }*/
    get value() {
        if (this.#predecessor) {
            return this.#predecessor.value;
        }
        return Promise.resolve(this._value);
    }
    setPredecessor(predecessor) {
        if (predecessor) {
            predecessor.addSuccessor(this);
        }
        if (this.#predecessor && !predecessor) {
            this.#predecessor.removeSuccessor(this);
        }
        this.#predecessor = predecessor;
        this.node.invalidate();
    }
    getPredecessor() {
        return this.#predecessor;
    }
    /* TODO:remove
    draw(glContext) {
        if (this.#predecessor) {
            this.#predecessor.draw(glContext);
        }
    }

    getInputTexture(defaultWhite) {
        if (this.#predecessor) {
            return this.#predecessor.outputTexture;
        }
    }
    */
    hasPredecessor() {
        return this.#predecessor ? true : false;
    }
    getType() {
        if (this.#predecessor) {
            return this.#predecessor.getType();
        }
        return null;
    }
    getValue() {
        if (this.#predecessor) {
            return this.#predecessor.getValue();
        }
        return null;
    }
    isValid(startingPoint) {
        if (this.#predecessor) {
            return this.#predecessor.isValid(startingPoint);
        }
        return true; //TODO: check input mandatory
    }
    async toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + 'id : ' + this.id);
        if (this.#predecessor) {
            ret.push(await this.#predecessor.toString(tabs1));
        }
        else {
            console.error('no predecessor : ', this);
        }
        return ret.join('\n');
    }
}

class Output extends InputOutput {
    #successors = new Set();
    #pixelArray;
    get value() {
        return this.getValue();
    }
    getValue() {
        let valuePromise = new Promise(async (resolve, reject) => {
            await this.node.validate();
            if (this.type == IO_TYPE_TEXTURE_2D) {
                resolve(this._value);
            }
            else {
                resolve(this._value);
            }
        });
        return valuePromise;
    }
    get pixelArray() {
        return this.getPixelArray();
    }
    getPixelArray() {
        let valuePromise = new Promise(async (resolve, reject) => {
            await this.node.validate();
            if (this.type == InputOutputType.Texture2D) {
                resolve(this.#pixelArray ?? null);
            }
            else {
                //TODO: this should resolve to something else
                resolve(this.#pixelArray ?? null);
            }
        });
        return valuePromise;
    }
    addSuccessor(successor) {
        this.#successors.add(successor);
    }
    removeSuccessor(successor) {
        this.#successors.delete(successor);
    }
    hasSuccessor() {
        return this.#successors.size > 0;
    }
    successorsLength() {
        let max = 0;
        for (let successor of this.#successors) {
            let l = successor.node.successorsLength() + 1;
            if (l > max) {
                max = l;
            }
        }
        return max;
    }
    invalidate() {
        for (let successor of this.#successors) {
            successor.node.invalidate();
        }
    }
    /*
    draw(glContext) {
        if (this.node) {
            this.node.draw(glContext);
        }
    }
    */
    getType() {
        if (this.node) {
            return this.node.getType();
        }
        return null;
    }
    isValid(startingPoint) {
        if (this.node) {
            return this.node.isValid(startingPoint);
        }
        return false;
    }
    async toString(tabs = '') {
        return await this.node.toString(tabs);
    }
    dispose() {
        this.#pixelArray = undefined;
    }
}

function imageDataToImage(imagedata, image = new Image()) {
    var canvas = createElement('canvas', { width: imagedata.width, height: imagedata.height });
    var ctx = canvas.getContext('2d');
    canvas.width = imagedata.width;
    canvas.height = imagedata.height;
    ctx.putImageData(imagedata, 0, 0);
    image.src = canvas.toDataURL();
    return image;
}
function flipPixelArray(pixelArray, width, height) {
    let rowLength = width * 4;
    let tempRow = new Uint8ClampedArray(rowLength);
    let halfHeight = height * 0.5;
    for (let row = 0; row < halfHeight; ++row) {
        let topOffset = row * rowLength;
        let bottomOffset = (height - row - 1) * rowLength;
        tempRow.set(pixelArray.subarray(topOffset, topOffset + rowLength));
        pixelArray.copyWithin(topOffset, bottomOffset, bottomOffset + rowLength);
        pixelArray.set(tempRow, bottomOffset);
    }
}

const LOW_RES_IMAGE = 0x01;
const HIGH_RES_IMAGE = 0x30;
class VTFResource {
    #type;
    #flag;
    #data;
    #length = 0;
    constructor(type, flag = 0) {
        this.#type = type;
        this.#flag = flag;
        this.data = null;
    }
    set data(data) {
        this.#data = data;
        if (data) {
            this.#length = data.length;
        }
        else {
            this.#length = 0;
        }
    }
    get type() {
        return this.#type;
    }
    get length() {
        return this.#length;
    }
    get flag() {
        return this.#flag;
    }
}
class VTFFile {
    #flags = 0;
    #width;
    #height;
    #frames;
    #imageFormat;
    #faces;
    #slices;
    #hasThumbnail = false;
    #hasMipMaps = false;
    #mipMaps = [[[[]]]];
    #bumpmapScale = 1.0; //todo
    #highResImageFormat = 0; //todo
    #resources = [];
    #highResResource = new VTFResource(HIGH_RES_IMAGE);
    constructor(width = 512, height = 512, imageFormat = 0 /*TODO*/, frames = 1, faces = 1, slices = 1) {
        this.#width = width;
        this.#height = height;
        this.#imageFormat = imageFormat;
        this.#frames = frames;
        this.#faces = faces;
        this.#slices = slices;
        this.addResource(this.#highResResource);
    }
    addResource(resource) {
        this.#resources.push(resource);
    }
    get height() {
        return this.#height;
    }
    get width() {
        return this.#width;
    }
    setFlag(flag) {
        this.#flags |= flag;
    }
    unsetFlag(flag) {
        this.#flags &= ~flag;
    }
    get flags() {
        return this.#flags;
    }
    get frames() {
        return 1; //TODO
    }
    get bumpmapScale() {
        return this.#bumpmapScale;
    }
    get highResImageFormat() {
        return this.#highResImageFormat;
    }
    get mipmapCount() {
        return 1; //TODO
    }
    get lowResImageFormat() {
        return -1; //TODO
    }
    get lowResImageWidth() {
        return 0; //TODO
    }
    get lowResImageHeight() {
        return 0; //TODO
    }
    get depth() {
        return 1; //TODO
    }
    get numResources() {
        return this.#resources.length; //TODO
    }
    get resources() {
        return this.#resources;
    }
    getMipMaps() {
        return this.#mipMaps;
    }
    setImageData(imageData, frame = 0, face = 0, slice = 0, mipmap = 0) {
        this.#mipMaps[mipmap][frame][face][slice] = imageData; //TODO: check values;
        this.#highResResource.data = imageData;
    }
}
class VTFWriter {
    static writeAndSave(vtffile, filename) {
        let arrayBuffer = this.write(vtffile);
        var dataView = new DataView(arrayBuffer);
        //SaveFile(filename, new Blob([dataView]));
        SaveFile(new File([new Blob([dataView])], filename));
    }
    static write(vtffile) {
        //TODO: check vtffile
        let writer = new BinaryReader(new Uint8Array(this.#computeLength(vtffile)));
        this.#writeHeader(writer, vtffile);
        return writer.buffer;
    }
    static #computeLength(vtffile) {
        let result = 80 + vtffile.numResources * 8;
        let resArray = vtffile.resources;
        for (let i in resArray) {
            let resource = resArray[i];
            if (resource.flag != 2) {
                result += resource.length;
            }
        }
        return result;
    }
    static #writeHeader(writer, vtffile) {
        let fixedHeaderLength = 80;
        writer.seek(0);
        writer.setUint32(0x00465456); //VTF\0
        writer.setUint32(VTFWriter.majorVersion);
        writer.setUint32(VTFWriter.minorVersion);
        let headerLength = fixedHeaderLength + vtffile.numResources * 8;
        writer.setUint32(headerLength);
        writer.setUint16(vtffile.width);
        writer.setUint16(vtffile.height);
        writer.setUint32(vtffile.flags);
        writer.setUint16(vtffile.frames);
        writer.setUint16(0); //TODO ??? firstFrame
        writer.skip(4); //padding.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.skip(4); //padding.
        writer.setFloat32(vtffile.bumpmapScale); //TODO bumpmapScale
        //writer.writeInt32(vtffile.highResImageFormat);
        writer.setInt32(0);
        writer.setUint8(vtffile.mipmapCount);
        writer.setInt32(vtffile.lowResImageFormat);
        writer.setUint8(vtffile.lowResImageWidth);
        writer.setUint8(vtffile.lowResImageHeight);
        writer.setUint16(vtffile.depth);
        writer.skip(3);
        writer.setUint32(vtffile.numResources);
        writer.skip(8);
        let resArray = vtffile.resources;
        let dataOffset = headerLength;
        let resHeaderOffset = fixedHeaderLength;
        for (let i in resArray) {
            writer.seek(resHeaderOffset);
            let resource = resArray[i];
            writer.setUint32(resource.type);
            /*writer.skip(-1);
            writer.setUint8(resource.flag);*/
            if (resource.flag == 2) { // resource doesn't have data
                writer.skip(4);
                //todo writedata
            }
            else {
                writer.setUint32(dataOffset);
                this.#writeResource(writer, vtffile, resource, dataOffset);
                dataOffset += resource.length;
            }
            resHeaderOffset += 8;
        }
    }
    static #writeResource(writer, vtffile, resource, dataOffset) {
        switch (resource.type) {
            case LOW_RES_IMAGE:
                break;
            case HIGH_RES_IMAGE:
                this.#writeHighResImage(writer, vtffile, resource, dataOffset);
                break;
        }
    }
    static #writeHighResImage(writer, vtffile, resource, dataOffset) {
        writer.seek(dataOffset);
        writer.setBytes(vtffile.getMipMaps()[0][0][0][0]);
    }
    static get majorVersion() {
        return 7;
    }
    static get minorVersion() {
        return 5;
    }
}

const TEXTUREFLAGS_CLAMPS = 0x00000004;
const TEXTUREFLAGS_CLAMPT = 0x00000008;
const TEXTUREFLAGS_SRGB = 0x00000040;
const TEXTUREFLAGS_NOMIP = 0x00000100;
const TEXTUREFLAGS_ONEBITALPHA = 0x00001000;
const TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000;
const TEXTUREFLAGS_ENVMAP = 0x00004000;

var DrawState;
(function (DrawState) {
    DrawState[DrawState["Invalid"] = 0] = "Invalid";
    DrawState[DrawState["Valid"] = 1] = "Valid";
})(DrawState || (DrawState = {}));
const PREVIEW_PICTURE_SIZE = 256;
class Node extends EventTarget {
    #hasPreview = false;
    id = generateRandomUUID();
    editor;
    inputs = new Map();
    outputs = new Map();
    params = new Map();
    previewPic = new Image(PREVIEW_PICTURE_SIZE, PREVIEW_PICTURE_SIZE);
    previewSize = PREVIEW_PICTURE_SIZE;
    #previewRenderTarget;
    autoRedraw = false;
    #redrawState = DrawState.Invalid;
    #operation;
    material;
    #pixelArray;
    constructor(editor, params) {
        super();
        this.editor = editor;
        this.setParams(params);
    }
    addInput(inputId, inputType, size = 1) {
        let input = new Input(this, inputId, inputType, size);
        this.inputs.set(inputId, input);
        this.invalidate();
        return input;
    }
    addOutput(outputId, outputType) {
        let output = new Output(this, outputId, outputType);
        this.outputs.set(outputId, output);
        this.invalidate();
        return output;
    }
    getInput(inputId) {
        return this.inputs.get(inputId);
    }
    getOutput(outputId) {
        return this.outputs.get(outputId);
    }
    async operate(context = {}) {
        throw 'This function must be overriden';
    }
    addParam(param) {
        this.params.set(param.name, param);
        this.#dispatchEvent('paramadded', param);
    }
    getParam(paramName) {
        return this.params.get(paramName);
    }
    getValue(paramName) {
        let p = this.params.get(paramName);
        if (p) {
            return p.value;
        }
        return null;
    }
    setParams(params) {
        if (params) {
            for (let paramName in params) {
                let param = params[paramName];
                let p = this.params.get(paramName);
                if (p) {
                    p.value = param;
                }
            }
            this.invalidate();
        }
    }
    setParam(paramName, paramValue, paramIndex) {
        let p = this.params.get(paramName);
        if (p) {
            if (paramIndex != undefined) {
                p.value[paramIndex] = paramValue;
            }
            else {
                p.value = paramValue;
            }
            this.#dispatchEvent('paramchanged', p);
        }
    }
    setPredecessor(inputId, predecessor, predecessorOutputId) {
        let input = this.inputs.get(inputId);
        let output = predecessor.outputs.get(predecessorOutputId);
        if (input && output) {
            input.setPredecessor(output);
            this.invalidate();
        }
        else {
            console.error('Error : wrong predecessor', this, inputId, predecessor, predecessorOutputId);
        }
    }
    getParams() {
        return this.params;
    }
    invalidate() {
        // Invalidate only if valid to avoid recursion
        if (this.#redrawState != DrawState.Invalid) {
            this.#redrawState = DrawState.Invalid;
            for (let output of this.outputs.values()) {
                output.invalidate();
            }
        }
        if (this.autoRedraw) {
            this.redraw();
        }
    }
    async validate() {
        if (this.#redrawState == DrawState.Invalid) {
            await this.operate();
            this.#redrawState = DrawState.Valid;
        }
    }
    async revalidate() {
        this.invalidate();
        await this.validate();
    }
    async redraw(context = {}) {
        await this.operate(context);
        this.#redrawState = DrawState.Valid;
    }
    getInputCount() {
        return this.inputs.size;
    }
    getType() {
        throw 'This function must be overriden';
    }
    ready() {
        let node = this;
        let promiseFunction = function (resolve, reject) {
            let callback = function () {
                if (node.isValid()) {
                    resolve(true);
                }
                else {
                    setTimeout(callback, 100);
                }
            };
            callback();
        };
        return new Promise(promiseFunction);
    }
    isValid(startingPoint) {
        if (startingPoint == this) {
            return true; // handle cyclic operation
        }
        startingPoint = startingPoint || this;
        if (this.#redrawState == DrawState.Valid) {
            if (this.#operation && this.#operation.isValid) {
                return this.#operation.isValid(startingPoint);
            }
            else {
                let inputs = this.inputs;
                for (let i of inputs.values()) {
                    if (!i.isValid(startingPoint)) {
                        return false;
                    }
                }
            }
        }
        return this.#redrawState == DrawState.Valid;
    }
    hasSuccessor() {
        for (let output of this.outputs.values()) {
            if (output.hasSuccessor()) {
                return true;
            }
        }
        return false;
    }
    successorsLength() {
        let max = 0;
        for (let output of this.outputs.values()) {
            let l = output.successorsLength();
            if (l > max) {
                max = l;
            }
        }
        return max;
    }
    get title() {
        throw 'This function must be overriden';
    }
    #dispatchEvent(eventName, eventDetail) {
        this.dispatchEvent(new CustomEvent(eventName, { detail: { value: eventDetail } }));
        this.dispatchEvent(new CustomEvent('*', { detail: { eventName: eventName } }));
    }
    updatePreview(context = {}) {
        let previewSize = context.previewSize ?? this.previewSize;
        let renderTarget2 = this.#previewRenderTarget ?? new RenderTarget({ width: previewSize, height: previewSize, depthBuffer: false, stencilBuffer: false });
        if (this.#previewRenderTarget) {
            renderTarget2.resize(previewSize, previewSize);
        }
        this.#previewRenderTarget = renderTarget2;
        new Graphics().pushRenderTarget(renderTarget2);
        this.editor.render(this.material);
        let pixelArray = new Uint8ClampedArray(previewSize * previewSize * 4);
        new Graphics().glContext.readPixels(0, 0, previewSize, previewSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        this.#pixelArray = new Uint8ClampedArray(pixelArray);
        //set alpha to 1
        for (let i = 3; i < pixelArray.length; i += 4) {
            pixelArray[i] = 255;
        }
        let imageData = new ImageData(pixelArray, previewSize, previewSize);
        try {
            imageDataToImage(imageData, this.previewPic);
        }
        catch (e) { }
        this.previewPic.width = previewSize;
        this.previewPic.height = previewSize;
        new Graphics().popRenderTarget();
    }
    async savePicture() {
        await this.redraw({ previewSize: 2048 });
        let image = this.previewPic;
        const canvas = createElement('canvas', { width: image.width, height: image.height });
        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => SaveFile(new File([blob], 'texture.png'))); //toDataURL
        //		SaveFile(new File([blob], 'texture.png'));
        this.previewPic.width = PREVIEW_PICTURE_SIZE;
        this.previewPic.height = PREVIEW_PICTURE_SIZE;
    }
    async saveVTF() {
        if (!this.#pixelArray) {
            return;
        }
        let vtfFile = new VTFFile(2048, 2048);
        vtfFile.setFlag(TEXTUREFLAGS_EIGHTBITALPHA | TEXTUREFLAGS_NOMIP);
        await this.redraw({ previewSize: 2048 });
        vtfFile.setImageData(this.#pixelArray);
        VTFWriter.writeAndSave(vtfFile, 'texture.vtf');
        this.previewPic.width = PREVIEW_PICTURE_SIZE;
        this.previewPic.height = PREVIEW_PICTURE_SIZE;
    }
    async toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (let input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        return ret.join('\n');
    }
    dispose() {
        if (this.#previewRenderTarget) {
            this.#previewRenderTarget.dispose();
        }
        this.outputs.forEach((output) => output.dispose());
        this.outputs.clear();
    }
    set hasPreview(hasPreview) {
        this.#hasPreview = hasPreview;
    }
    get hasPreview() {
        return this.#hasPreview;
    }
}

class NodeImageEditorMaterial extends Material {
    shaderName = '';
    constructor(params) {
        super(params);
        this.shaderName = params?.shaderName;
    }
    getShaderSource() {
        return this.shaderName;
    }
}

const operations = new Map();
function registerOperation(name, ope) {
    operations.set(name, ope);
}
function getOperation(name, editor, params) {
    if (!operations.has(name)) {
        console.warn('Unknown operation : ' + name);
        return null;
    }
    return new (operations.get(name))(editor, params);
}

var NodeParamType;
(function (NodeParamType) {
    NodeParamType[NodeParamType["Unknown"] = 0] = "Unknown";
    NodeParamType[NodeParamType["Int"] = 1] = "Int";
    NodeParamType[NodeParamType["Bool"] = 2] = "Bool";
    NodeParamType[NodeParamType["Float"] = 3] = "Float";
    NodeParamType[NodeParamType["Radian"] = 4] = "Radian";
    NodeParamType[NodeParamType["Degree"] = 5] = "Degree";
    NodeParamType[NodeParamType["String"] = 6] = "String";
    NodeParamType[NodeParamType["Vec2"] = 7] = "Vec2";
    NodeParamType[NodeParamType["StickerAdjust"] = 8] = "StickerAdjust";
})(NodeParamType || (NodeParamType = {}));
class NodeParam {
    name;
    type;
    value;
    length;
    constructor(name, type, value, length) {
        this.name = name;
        this.type = type;
        this.value = value;
        this.length = length;
    }
}

create();
create$6();
class ApplySticker extends Node {
    #renderTarget;
    #textureSize;
    inputTexture;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input', IO_TYPE_TEXTURE_2D);
        this.addInput('sticker', IO_TYPE_TEXTURE_2D);
        this.addInput('specular', IO_TYPE_TEXTURE_2D);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'applysticker' });
        this.material.setDefine('TRANSFORM_TEX_COORD');
        this.material.setDefine('NEED_TWO_TEX_COORDS');
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('top left', NodeParamType.Vec2, create()));
        this.addParam(new NodeParam('top right', NodeParamType.Vec2, create()));
        this.addParam(new NodeParam('bottom left', NodeParamType.Vec2, create()));
        this.addParam(new NodeParam('path', NodeParamType.String, ''));
        this.addParam(new NodeParam('sticker', NodeParamType.StickerAdjust, create()));
    }
    async operate(context = {}) {
        this.params;
        this.material.setTexture('uSticker', this.inputTexture);
        this.material.setTexture('uStickerSpecular', await this.getInput('specular').value);
        this.material.setTexture('uInput', await this.getInput('input').value);
        this.material.uniforms['uAdjustLevels'] = fromValues$3(this.getValue('adjust black'), this.getValue('adjust white'), this.getValue('adjust gamma'), 0.0);
        let texTransform = create$6();
        ComputeTextureMatrixFromRectangle(texTransform, this.getValue('bottom left'), this.getValue('top left'), this.getValue('top right'));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;
        /*texTransform = mat3.identity(texTransform);
        mat3.rotate(texTransform, texTransform, this.params.rotation);
        mat3.translate(texTransform, texTransform, vec2.set(tempVec2, this.params.translateU, this.params.translateV));
        mat3.scale(texTransform, texTransform, vec2.set(tempVec2, this.params.scaleUV, this.params.scaleUV));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;*/
        /*let textureArray = [];
        let usedArray = [];
        for (let i = 0; i < 8; ++i) {
            //let inputName = 'uInput' + i;
            //this.material.uniforms['uInput' + i] = await this.getInput('input' + i).value;
            let texture = await this.getInput('input' + i).value;
            textureArray.push(texture);
            usedArray.push(texture != undefined);
        }

        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        this.material.uniforms['uInput[0]'] = textureArray;
        this.material.uniforms['uUsed[0]'] = usedArray;*/
        //this.material.uniforms['uInput'] = this.inputTexture;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false, texture: this.getOutput('output')._value });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        /*let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();*/
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        //this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'apply sticker';
    }
    async toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (let input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('apply_sticker', ApplySticker);
//void ComputeTextureMatrixFromRectangle( VMatrix* pOutMat, const Vector2D& bl, const Vector2D& tl, const Vector2D& tr )
function ComputeTextureMatrixFromRectangle(out, bl, tl, tr) {
    const tempVec2 = create();
    let leftEdge = sub(create(), bl, tl);
    let topEdge = sub(create(), tr, tl);
    let topEdgePerpLeft = fromValues(-topEdge[1], topEdge[0]);
    let magLeftEdge = length$1(leftEdge);
    let magTopEdge = length$1(topEdge);
    let xScalar = (dot(topEdgePerpLeft, leftEdge) > 0) ? 1 : -1;
    // Simplification of acos( ( A . L ) / ( mag( A ) * mag( L ) )
    // Because A is ( 0, 1), which means A . L is just L.y
    // and mag( A ) * mag( L ) is just mag( L )
    let rotationD = Math.acos(leftEdge[1] / magLeftEdge)
        * (leftEdge[0] < 0 ? 1 : -1);
    let texTransform = create$6();
    translate$2(texTransform, texTransform, tl);
    rotate$2(texTransform, texTransform, rotationD);
    scale$7(texTransform, texTransform, set$1(tempVec2, xScalar * magTopEdge, magLeftEdge));
    invert$4(out, texTransform);
}

const tempVec2$2 = create();
class TextureLookup extends Node {
    #renderTarget;
    #textureSize;
    inputTexture;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'texturelookup' });
        this.material.setDefine('TRANSFORM_TEX_COORD');
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        /*this.params.adjustBlack = 0;
        this.params.adjustWhite = 1.0;
        this.params.adjustGamma = 1.0;
        this.params.rotation = 0.0;
        this.params.translateU = 0.0;
        this.params.translateV = 0.0;
        this.params.scaleU = 1.0;
        this.params.scaleV = 1.0;*/
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('rotation', NodeParamType.Radian, 0.0));
        this.addParam(new NodeParam('translate u', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('translate v', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('scale u', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('scale v', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('path', NodeParamType.String, ''));
    }
    async operate(context = {}) {
        this.material.setTexture('uInput', this.inputTexture);
        this.material.uniforms['uAdjustLevels'] = fromValues$3(this.getValue('adjust black'), this.getValue('adjust white'), this.getValue('adjust gamma'), 0.0);
        let texTransform = create$6();
        rotate$2(texTransform, texTransform, this.getValue('rotation'));
        scale$7(texTransform, texTransform, set$1(tempVec2$2, this.getValue('scale u'), this.getValue('scale v')));
        translate$2(texTransform, texTransform, set$1(tempVec2$2, this.getValue('translate u'), this.getValue('translate v')));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;
        //console.error(this.params, this.testing);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'texture lookup';
    }
    async toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (let input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        ret.push(tabs1 + `black : ${this.getValue('adjust black')}, white : ${this.getValue('adjust white')}, gamma : ${this.getValue('adjust gamma')}`);
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
    }
}
registerOperation('texture lookup', TextureLookup);

const DELAY_BEFORE_REFRESH = 100;
const FLOAT_VALUE_DECIMALS = 3;
function dropFiles(evt, node) {
    let files = evt.target.files; // FileList object
    // Loop through the FileList and render image files as thumbnails.
    for (let i = 0, f; f = files[i]; i++) {
        // Only process image files.
        if (!f.type.match('image.*')) {
            continue;
        }
        let reader = new FileReader();
        // Closure to capture the file information.
        reader.onload = (function (theFile) {
            return function (e) {
                let texture = TextureManager.createTexture({ minFilter: GL_LINEAR });
                if (node instanceof ApplySticker) {
                    texture.wrapS = GL_CLAMP_TO_EDGE;
                    texture.wrapT = GL_CLAMP_TO_EDGE;
                }
                texture.setParameters(new Graphics().glContext, GL_TEXTURE_2D);
                const image = new Image();
                image.onload = () => {
                    TextureManager.fillTextureWithImage(texture, image);
                    node.inputTexture = texture;
                    node.invalidate();
                    node.validate();
                };
                image.src = e.target.result.toString();
            };
        })();
        // Read in the image file as a data URL.
        reader.readAsDataURL(f);
    }
}
function dropFilesSpecular(evt, node) {
    let files = evt.target.files; // FileList object
    // Loop through the FileList and render image files as thumbnails.
    for (let i = 0, f; f = files[i]; i++) {
        // Only process image files.
        if (!f.type.match('image.*')) {
            continue;
        }
        let reader = new FileReader();
        // Closure to capture the file information.
        reader.onload = (function (theFile) {
            return function (e) {
                let texture = TextureManager.createTexture({ minFilter: GL_LINEAR });
                if (node instanceof ApplySticker) {
                    texture.wrapS = GL_CLAMP_TO_EDGE;
                    texture.wrapT = GL_CLAMP_TO_EDGE;
                }
                texture.setParameters(new Graphics().glContext, GL_TEXTURE_2D);
                const image = new Image();
                image.onload = () => {
                    TextureManager.fillTextureWithImage(texture, image);
                    node.getInput('specular').value = texture;
                    //node.invalidate();
                    node.validate();
                };
                image.src = e.target.result.toString();
            };
        })();
        // Read in the image file as a data URL.
        reader.readAsDataURL(f);
    }
}
var FlipDirection;
(function (FlipDirection) {
    FlipDirection[FlipDirection["FlipUp"] = 0] = "FlipUp";
    FlipDirection[FlipDirection["FlipDown"] = 1] = "FlipDown";
    FlipDirection[FlipDirection["FlipLeft"] = 2] = "FlipLeft";
    FlipDirection[FlipDirection["FlipRight"] = 3] = "FlipRight";
    FlipDirection[FlipDirection["FlipX"] = 4] = "FlipX";
    FlipDirection[FlipDirection["FlipY"] = 5] = "FlipY";
})(FlipDirection || (FlipDirection = {}));
class NodeGui {
    #expanded = true;
    #html;
    #htmlPreview;
    #htmlRectSelector;
    #drag;
    #htmlParamsContainer;
    _ioGui = new Map();
    #refreshTimeout;
    #nodeChanged;
    #node;
    #nodeImageEditorGui;
    #dragStartClientX;
    #dragStartClientY;
    #htmlParams = new Map();
    #htmlParamsValue = new Map();
    constructor(nodeImageEditorGui, node) {
        this.#nodeChanged = () => {
            clearTimeout(this.#refreshTimeout);
            this.#refreshTimeout = setTimeout(() => this.#refreshHtml(), DELAY_BEFORE_REFRESH);
        };
        this.#nodeImageEditorGui = nodeImageEditorGui;
        this.#node = node;
        this.#initHtml();
        this.#node.addEventListener('*', this.#nodeChanged);
    }
    set expanded(expanded) {
        this.#expanded = expanded;
        this.#html.classList[!expanded ? 'add' : 'remove']('collapsed');
    }
    get expanded() {
        return this.#expanded;
    }
    get node() {
        return this.#node;
    }
    get html() {
        return this.#html;
    }
    set nodeImageEditorGui(nodeImageEditorGui) {
        this.#nodeImageEditorGui = nodeImageEditorGui;
    }
    #handlePreviewDragOver(event) {
        event.preventDefault();
        console.log(event);
        switch (this.#drag) {
            case 'move':
                this.#htmlRectSelector.style.top = event.offsetY - this.#dragStartClientY + 'px';
                this.#htmlRectSelector.style.left = event.offsetX - this.#dragStartClientX + 'px';
                break;
        }
    }
    #increasePreviewSize() {
        if (this.#node) {
            this.#node.previewSize *= 2;
            this.#node.updatePreview();
            this.#nodeImageEditorGui.refresh();
        }
    }
    #decreasePreviewSize() {
        if (this.#node) {
            this.#node.previewSize /= 2;
            this.#node.updatePreview();
            this.#nodeImageEditorGui.refresh();
        }
    }
    #initHtml() {
        let htmlInputs;
        let htmlOutputs;
        this.#html = createElement('div', {
            class: 'node-image-editor-node',
            childs: [
                createElement('div', {
                    class: 'node-image-editor-node-header',
                    childs: [
                        createElement('div', { class: 'node-image-editor-node-title', innerText: this.#node.title }),
                        createElement('div', {
                            class: 'node-image-editor-node-buttons',
                            childs: [
                                createElement('div', {
                                    innerHTML: zoomOutSVG,
                                    events: {
                                        click: () => this.#decreasePreviewSize(),
                                    }
                                }),
                                createElement('div', {
                                    innerHTML: zoomInSVG,
                                    events: {
                                        click: () => this.#increasePreviewSize(),
                                    }
                                }),
                            ]
                        }),
                    ],
                }),
                createElement('div', {
                    class: 'node-image-editor-node-content',
                    childs: [
                        htmlInputs = createElement('div', { class: 'node-image-editor-node-ios' }),
                        this.#htmlParamsContainer = createElement('div', { class: 'node-image-editor-node-params' }),
                        htmlOutputs = createElement('div', { class: 'node-image-editor-node-ios' }),
                    ],
                }),
            ]
        });
        this.#htmlPreview = createElement('div', {
            class: 'node-image-editor-node-preview',
            child: this.#node.previewPic,
            events: {
                dragover: event => this.#handlePreviewDragOver(event),
            }
        });
        if (this.#node.hasPreview) {
            this.#html.append(this.#htmlPreview);
        }
        for (let input of this.#node.inputs.values()) {
            htmlInputs.append(this.#createIo(input));
        }
        for (let output of this.#node.outputs.values()) {
            htmlOutputs.append(this.#createIo(output));
        }
        if (this.#node.hasPreview) {
            let htmlSavePicture = createElement('button', { i18n: '#save_picture' });
            htmlSavePicture.addEventListener('click', () => this.#node.savePicture());
            this.#html.append(htmlSavePicture);
            let htmlSaveVTF = createElement('button', { i18n: '#save_vtf' });
            htmlSaveVTF.addEventListener('click', () => this.#node.saveVTF());
            this.#html.append(htmlSaveVTF);
        }
        if ((this.#node instanceof TextureLookup) || this.#node instanceof ApplySticker) {
            let inputImage = createElement('input', { type: 'file', accept: 'image/*' });
            inputImage.addEventListener('input', (event) => dropFiles(event, this.#node));
            this.#htmlPreview.addEventListener('click', (event) => { if (event.target == this.#node.previewPic) {
                inputImage.click();
            } });
        }
        if (this.#node instanceof ApplySticker) {
            let htmlLoadStickerSpecular = createElement('button', { i18n: '#load_sticker_specular' });
            this.#html.append(htmlLoadStickerSpecular);
            let inputImage = createElement('input', { type: 'file', accept: 'image/*' });
            inputImage.addEventListener('input', (event) => dropFilesSpecular(event, this.#node));
            htmlLoadStickerSpecular.addEventListener('click', () => inputImage.click());
        }
        this.#refreshHtml();
        this.#initResizeObserver();
    }
    #initResizeObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.#updateManipulator();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        resizeObserver.observe(this.#htmlPreview);
    }
    #refreshHtml() {
        this.#htmlParamsContainer.innerText = '';
        for (let [_, param] of this.#node.params) {
            if (param.length && param.length > 1) {
                for (let i = 0; i < param.length; ++i) {
                    this.#htmlParamsContainer.append(this.#getParamHTML(param, i));
                }
            }
            else {
                this.#htmlParamsContainer.append(this.#getParamHTML(param));
            }
        }
    }
    #getParamHTML(param, index) {
        let paramHtml;
        if (index === undefined) {
            paramHtml = this.#htmlParams.get(param.name) ?? this.#createParamHTML(param, index);
        }
        else {
            paramHtml = this.#htmlParams.get(param.name)?.[index] ?? this.#createParamHTML(param, index);
        }
        if (Array.isArray(paramHtml)) {
            paramHtml = paramHtml[index];
        }
        let value;
        if (index != undefined) {
            value = param.value[index];
        }
        else {
            value = param.value;
        }
        const valueHtml = this.#htmlParamsValue.get(paramHtml);
        switch (param.type) {
            case NodeParamType.Float:
            case NodeParamType.Degree:
                value = Number(value).toFixed(FLOAT_VALUE_DECIMALS);
                break;
            case NodeParamType.Radian:
                value = Number(value * RAD_TO_DEG).toFixed(FLOAT_VALUE_DECIMALS);
                break;
            case NodeParamType.Vec2:
                value = `${Number(value[0]).toFixed(FLOAT_VALUE_DECIMALS)} ${Number(value[1]).toFixed(FLOAT_VALUE_DECIMALS)}`;
                break;
            case NodeParamType.StickerAdjust:
                this.#updateManipulator();
                break;
        }
        if (valueHtml) {
            valueHtml.value = value;
        }
        return paramHtml;
    }
    #createParamHTML(param, index) {
        let paramHtml = createElement('div', { class: 'node-image-editor-node-param' });
        let nameHtml = createElement('div', { parent: paramHtml, class: 'name' });
        let valueHtml;
        if (param.type != NodeParamType.StickerAdjust) {
            valueHtml = createElement('input', {
                parent: paramHtml,
                events: {
                    change: (event) => this.#setParamValue(param, event.target.value, index)
                }
            });
            createElement('span', {
                class: 'copy-button',
                parent: paramHtml,
                innerHTML: contentCopySVG,
                events: {
                    click: async () => {
                        await navigator.clipboard.writeText(valueHtml.value);
                        valueHtml.classList.add('flash');
                        await setTimeoutPromise(1500);
                        valueHtml.classList.remove('flash');
                    },
                }
            });
        }
        nameHtml.innerText = param.name;
        this.#htmlParamsValue.set(paramHtml, valueHtml);
        if (param.type == NodeParamType.StickerAdjust) {
            defineHarmony2dManipulator();
            defineHarmonyToggleButton();
            createElement('div', {
                parent: paramHtml,
                childs: [
                    createElement('div', {
                        childs: [
                            createElement('div', {
                                childs: [
                                    createElement('button', {
                                        i18n: '#flip_up',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipUp),
                                    }),
                                    createElement('button', {
                                        i18n: '#flip_down',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipDown),
                                    }),
                                ],
                            }),
                            createElement('div', {
                                childs: [
                                    createElement('button', {
                                        i18n: '#flip_left',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipLeft),
                                    }),
                                    createElement('button', {
                                        i18n: '#flip_right',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipRight),
                                    }),
                                ]
                            }),
                        ],
                    }),
                    createElement('div', {
                        childs: [
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: dragPanSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: dragPanSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({ translation: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None }),
                                }
                            }),
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: panZoomSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: panZoomSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({ resize: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None, scale: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None }),
                                }
                            }),
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: rotateSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: rotateSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({ rotation: event.target.state }),
                                }
                            }),
                        ],
                    }),
                ],
            });
            this.#htmlRectSelector = this.#htmlRectSelector ?? createElement('harmony-2d-manipulator', {
                class: 'node-image-editor-sticker-selector',
                parent: this.#htmlPreview,
                events: {
                    updateend: (event) => {
                        const parameters = { 'top left': 0, 'bottom left': 2, 'top right': 1 };
                        const manipulator = event.target;
                        for (let name in parameters) {
                            const param = this.#node.getParam(name);
                            if (param) {
                                const rect = this.#htmlPreview.getBoundingClientRect();
                                const corner = manipulator.getCorner(parameters[name]);
                                this.#setParamValue(param, `${corner.x / rect.width} ${corner.y / rect.width}`, undefined, false);
                            }
                        }
                    },
                },
                attributes: {
                    'min-width': "-Infinity",
                    'min-height': "-Infinity",
                }
            });
            this.#updateManipulator();
        }
        if (index === undefined) {
            this.#htmlParams.set(param.name, paramHtml);
        }
        else {
            if (!this.#htmlParams.has(param.name)) {
                this.#htmlParams.set(param.name, []);
            }
            this.#htmlParams.get(param.name)[index] = paramHtml;
        }
        return paramHtml;
    }
    #updateManipulator() {
        const rect = this.#htmlPreview.getBoundingClientRect();
        const A = this.#node.getValue('top left');
        const D = this.#node.getValue('bottom left');
        const C = this.#node.getValue('top right');
        if (!A || !D || !C) {
            return;
        }
        const AC = sub(create(), C, A);
        const AD = sub(create(), D, A);
        const B = add$1(create(), AC, D);
        const a1 = B[0] - A[0];
        const a2 = B[1] - A[1];
        const c1 = D[0] - C[0];
        const c2 = D[1] - C[1];
        const t = (a2 * C[0] - a2 * A[0] - a1 * C[1] + a1 * A[1]) / (-a2 * c1 + a1 * c2);
        const cross$1 = cross(create$4(), AD, AC);
        const flip = cross$1[2] > 0;
        const center = fromValues((C[0] + c1 * t) * rect.width, (C[1] + c2 * t) * rect.height);
        const width = len(AC) * rect.width * (flip ? -1 : 1);
        const height = len(AD) * rect.height;
        const angle = Math.atan2(AC[1], AC[0]) + (flip ? Math.PI : 0);
        this.#htmlRectSelector.set({
            rotation: angle,
            left: center[0],
            top: center[1],
            width: width,
            height: height
        });
    }
    #setParamValue(param, stringValue, index, updateManipulator = true) {
        let node = this.#node;
        let value;
        switch (param.type) {
            case NodeParamType.Float:
            case NodeParamType.Degree:
                value = Number(Number(stringValue).toFixed(FLOAT_VALUE_DECIMALS));
                break;
            case NodeParamType.Radian:
                value = Number(stringValue) * DEG_TO_RAD;
                break;
            case NodeParamType.Vec2:
                let arr = stringValue.split(' ');
                value = fromValues(Number(arr[0]), Number(arr[1]));
                break;
            default:
                value = Number(stringValue);
        }
        if (updateManipulator && (param.name == 'top left' || param.name == 'bottom left' || param.name == 'top right')) {
            this.#updateManipulator();
        }
        node.setParam(param.name, value, index);
        node.revalidate();
    }
    #createIo(io) {
        let html = createElement('div', { class: 'node-image-editor-node-io' });
        this._ioGui.set(io, html);
        return html;
    }
    #flipSticker(flip) {
        const topLeft = copy(create(), this.#node.getValue('top left'));
        const bottomLeft = copy(create(), this.#node.getValue('bottom left'));
        const topRight = copy(create(), this.#node.getValue('top right'));
        const newTopLeft = copy(create(), topLeft);
        const newBottomLeft = copy(create(), bottomLeft);
        const newTopRight = copy(create(), topRight);
        const top = sub(create(), topRight, topLeft);
        const left = sub(create(), bottomLeft, topLeft);
        const bottomRight = add$1(create(), top, bottomLeft);
        const topN = normalize$1(create(), top);
        const leftN = normalize$1(create(), left);
        switch (flip) {
            case FlipDirection.FlipUp:
                //delta = bottomLeft[1] - topLeft[1];
                //newBottomLeft[1] = topLeft[1] - delta;
                const DA = sub(create(), topLeft, bottomLeft);
                //const n1 = vec2.multiply(vec2.create(), vec2.dot(DA, topN));
                const v = scaleAndAdd(create(), DA, topN, -2 * dot(DA, topN));
                add$1(newBottomLeft, topLeft, v);
                //newBottomLeft[1] = topLeft[1] - delta;
                break;
            case FlipDirection.FlipDown:
                const AD = sub(create(), bottomLeft, topLeft);
                const v1 = scaleAndAdd(create(), AD, topN, -2 * dot(AD, topN));
                add$1(newTopLeft, bottomLeft, v1);
                add$1(newTopRight, bottomRight, v1);
                /*
                delta = bottomLeft[1] - topLeft[1];
                newTopLeft[1] = bottomLeft[1] + delta;
                newTopRight[1] = bottomLeft[1] + delta;
                */
                break;
            case FlipDirection.FlipLeft:
                const CA = sub(create(), topLeft, topRight);
                const v2 = scaleAndAdd(create(), CA, leftN, -2 * dot(CA, leftN));
                add$1(newTopRight, topLeft, v2);
                //vec2.add(newTopRight, bottomRight, v1);
                break;
            case FlipDirection.FlipRight:
                const AC = sub(create(), topRight, topLeft);
                const v3 = scaleAndAdd(create(), AC, leftN, -2 * dot(AC, leftN));
                add$1(newTopLeft, topRight, v3);
                add$1(newBottomLeft, bottomRight, v3);
                break;
        }
        /*

                newTopLeft[1] = bottomLeft[1];
                newBottomLeft[1] = topLeft[1];
                newTopRight[1] = bottomLeft[1];
                */
        //this.#setParamValue(param, `${corner.x / rect.width} ${corner.y / rect.width}`, undefined, false);
        const node = this.#node;
        node.setParam('top left', newTopLeft);
        node.setParam('bottom left', newBottomLeft);
        node.setParam('top right', newTopRight);
        this.#updateManipulator();
        node.revalidate();
        /*

        this.#htmlRectSelector.set({
            width: -0.06,
        });
        */
    }
}

var nodeImageEditorCSS = ":host {\n\tbackground-color: #000000FF;\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\tflex-direction: column;\n\tuser-select: none;\n}\n\n.node-image-editor-nodes {\n\toverflow: auto;\n\tposition: relative;\n\tdisplay: flex;\n\toverflow: auto;\n\tflex: 1;\n}\n\n.node-image-editor-nodes-column {\n\tdisplay: flex;\n\tflex-direction: column;\n\tmargin-left: 50px;\n\tmargin-right: 50px;\n}\n\n.node-image-editor-canvas {\n\tpointer-events: none;\n}\n\n.node-image-editor-node {\n\tbackground-color: var(--main-bg-color-bright);\n\tdisplay: flex;\n\tflex-direction: column;\n\tmargin-top: 50px;\n\tmargin-bottom: 50px;\n\tpadding: 5px;\n}\n\n.node-image-editor-node.collapsed {\n\twidth: auto;\n\tmargin-top: 1rem;\n\tmargin-bottom: 1rem;\n}\n\n.node-image-editor-node.collapsed .node-image-editor-node-content {\n\tdisplay: none;\n}\n\n.node-image-editor-node.collapsed .node-image-editor-node-preview {\n\tdisplay: none;\n}\n\n.node-image-editor-node.collapsed button {\n\tdisplay: none;\n}\n\n.node-image-editor-node-header {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-title {\n\tflex: 1;\n}\n\n.node-image-editor-node-buttons {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-buttons>div {\n\tcursor: pointer;\n}\n\n.node-image-editor-node-preview {\n\tposition: relative;\n\t/*height: 32px;\n\twidth: 32px;*/\n\tbackground-color: #000000FF;\n\tdisplay: inline-block;\n\twidth: min-content;\n\tdisplay: flex;\n}\n\n.node-image-editor-sticker-selector {\n\tposition: absolute;\n\tpointer-events: none;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\t--harmony-2d-manipulator-bg-color: rgba(0, 0, 0, 0);\n\t--harmony-2d-manipulator-border: 1px dashed white;\n}\n\n.node-image-editor-sticker-selector>div {\n\tposition: absolute;\n\twidth: 0.4rem;\n\theight: 0.4rem;\n\tbackground-color: black;\n\tpointer-events: all;\n}\n\n.node-image-editor-sticker-selector>.handle-move {\n\tcursor: move;\n\ttop: calc(50% - 0.2rem);\n\tleft: calc(50% - 0.2rem);\n}\n\n.node-image-editor-sticker-selector>.handle-resize {\n\tcursor: nesw-resize;\n\ttop: -0.2rem;\n\tright: 0.2rem;\n}\n\n.node-image-editor-sticker-selector>.handle-rotate {\n\tcursor: grab;\n\ttop: -0.2rem;\n\tleft: -0.2rem;\n}\n\n.node-image-editor-node-content {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-ios {\n\theight: 100%;\n\tflex: 0;\n}\n\n.node-image-editor-node-io {\n\twidth: 10px;\n\theight: 10px;\n\tbackground-color: green;\n}\n\n.node-image-editor-node-params {\n\tflex: 1;\n\toverflow: hidden;\n\tpadding: 5px;\n}\n\n.node-image-editor-node-param {\n\tdisplay: flex;\n\ttext-wrap: nowrap;\n}\n\n.node-image-editor-node-param>div {\n\tflex: 1;\n\t/*overflow: auto;*/\n}\n\n.node-image-editor-node-param>input {\n\theight: 1.5rem;\n\tbox-sizing: border-box;\n\tvertical-align: middle;\n}\n\n.node-image-editor-node-change-image {\n\topacity: 0%;\n\tposition: absolute;\n\ttop: 0px;\n\tleft: 0px;\n\theight: 100%;\n\twidth: 100%;\n\t/*background-image: url('./img/icons/image_search.svg');*/\n\toverflow: hidden;\n\tbackground-size: 100%;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n\tbackground-color: white;\n\tborder-radius: 4px;\n\tcursor: pointer;\n}\n\n.node-image-editor-node input[type=\"file\"] {\n\topacity: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.copy-button {\n\twidth: 2rem;\n\theight: 2rem;\n\tdisplay: inline-block;\n\tcursor: pointer;\n}\n\ninput {\n\t/*transition: background-color 1s;*/\n\tbackground-color: #FFF;\n\n\t/* only animation-duration here is required, rest are optional (also animation-name but it will be set on hover)*/\n\tanimation-duration: 1.5s;\n\t/* same as transition duration */\n\tanimation-timing-function: linear;\n\t/* kind of same as transition timing */\n\tanimation-delay: 0ms;\n\t/* same as transition delay */\n\tanimation-iteration-count: 1;\n\t/* set to 2 to make it run twice, or Infinite to run forever!*/\n\tanimation-direction: normal;\n\t/* can be set to \"alternate\" to run animation, then run it backwards.*/\n\tanimation-fill-mode: none;\n\t/* can be used to retain keyframe styling after animation, with \"forwards\" */\n\tanimation-play-state: running;\n\t/* can be set dynamically to pause mid animation*/\n\n}\n\n.flash {\n\tanimation-name: copyAnimation;\n}\n\n@keyframes copyAnimation {\n\t0% {\n\t\tbackground-color: #ffdf5d;\n\t}\n\n\t100% {\n\t\tbackground-color: #FFF;\n\t}\n}\n\nharmony-toggle-button.sticker {\n\tmargin: 0.5rem;\n\tpadding: 0.2rem;\n\tborder-radius: 0.5rem;\n}\n\nharmony-toggle-button.sticker.on {\n\tbackground-color: green;\n}\n\nharmony-toggle-button.sticker.off {\n\tbackground-color: red;\n}\n";

class NodeImageEditorGui {
    #filter = {};
    #shadowRoot;
    #imageEditorChanged;
    #refreshTimeout = 0;
    #nodesGui = new Map();
    #nodeImageEditor;
    #htmlNodeFilter;
    #htmlNodes;
    #canvas;
    #context;
    constructor(nodeImageEditor) {
        this.#imageEditorChanged = () => {
            clearTimeout(this.#refreshTimeout);
            this.#refreshTimeout = setTimeout(() => this.#refreshHtml(), DELAY_BEFORE_REFRESH);
        };
        this.setNodeImageEditor(nodeImageEditor);
        this.#shadowRoot = createShadowRoot('node-image-editor', {
            adoptStyle: nodeImageEditorCSS,
        });
        I18n.observeElement(this.#shadowRoot);
        createElement('div', {
            class: 'node-image-editor-header',
            parent: this.#shadowRoot,
            childs: [
                this.#htmlNodeFilter = createElement('input', {
                    class: 'node-image-editor-node-filter',
                    events: {
                        input: (event) => { this.#filter.node = event.target.value; this.#refreshFilter(); },
                    }
                }),
            ]
        });
        this.#htmlNodes = createElement('div', {
            class: 'node-image-editor-nodes',
            parent: this.#shadowRoot,
        });
        this.#canvas = createElement('canvas', {
            class: 'node-image-editor-canvas',
            style: 'z-index:1000;position:absolute;',
            parent: this.#htmlNodes,
        });
        this.#context = this.#canvas.getContext('2d');
        this.#initResizeObserver();
        this.#setCanvasSize();
    }
    /**
     * @deprecated Please use `setNodeImageEditor` instead.
     */
    set nodeImageEditor(nodeImageEditor) {
        console.warn('set nodeImageEditor is deprecated, use setNodeImageEditor instead');
        this.setNodeImageEditor(nodeImageEditor);
    }
    setNodeImageEditor(nodeImageEditor) {
        if (this.#nodeImageEditor == nodeImageEditor) {
            return;
        }
        if (this.#nodeImageEditor) {
            this.#nodeImageEditor.removeEventListener('*', this.#imageEditorChanged);
        }
        this.#nodeImageEditor = nodeImageEditor;
        this.#nodeImageEditor?.addEventListener('*', this.#imageEditorChanged);
    }
    get htmlElement() {
        return this.#shadowRoot.host;
    }
    #setCanvasSize() {
        this.#canvas.height = 0;
        this.#canvas.width = 0;
        this.#canvas.height = this.#htmlNodes.scrollHeight;
        this.#canvas.width = this.#htmlNodes.scrollWidth;
        this.#drawLinks();
    }
    #initResizeObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.#setCanvasSize();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        resizeObserver.observe(this.#htmlNodes);
    }
    #refreshHtml() {
        this.#htmlNodes.innerText = '';
        this.#htmlNodes.append(this.#canvas);
        if (this.#nodeImageEditor) {
            for (let node of this.#nodeImageEditor.getNodes()) {
                let nodeGui = this.#nodesGui.get(node);
                if (!nodeGui) {
                    nodeGui = new NodeGui(this, node);
                    this.#nodesGui.set(node, nodeGui);
                }
                this.#htmlNodes.append(nodeGui.html);
            }
        }
        //TODO: remove old nodes from this.#nodesGui
        this.#refreshFilter();
    }
    #organizeNodes() {
        this.#htmlNodes.innerText = '';
        this.#htmlNodes.append(this.#canvas);
        let nodes = new Map();
        if (this.#nodeImageEditor) {
            for (let node of this.#nodeImageEditor.getNodes()) {
                let nodeGui = this.#nodesGui.get(node);
                let l = node.successorsLength();
                //nodeGui.html.style.right = l * WIDTH + 'px';
                let s = nodes.get(l);
                if (!s) {
                    s = [];
                    nodes.set(l, s);
                }
                if (nodeGui) {
                    s.push(nodeGui);
                }
            }
        }
        nodes[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => {
                return a[0] < b[0] ? -1 : 1;
            });
        };
        for (let [s, n] of nodes) {
            let column = createElement('div', { class: 'node-image-editor-nodes-column' });
            this.#htmlNodes.prepend(column);
            for (let i = 0; i < n.length; ++i) {
                let nodeGui = n[i];
                //nodeGui.html.style.top = i * HEIGHT + 'px';
                nodeGui.html.getBoundingClientRect();
                //maxHeight = Math.max(maxHeight, rect.bottom);
                column.append(nodeGui.html);
            }
        }
        //this.#htmlNodes.style.height = maxHeight + 'px';;
    }
    #drawLink(p1, p2) {
        if (p1 && p2) {
            let context = this.#context;
            let p1BoundingRect = p1.getBoundingClientRect();
            let p2BoundingRect = p2.getBoundingClientRect();
            let p1Weight = 1;
            let p2Weight = 1;
            if (p1BoundingRect.height == 0 || p1BoundingRect.width == 0) {
                p1BoundingRect = p1?.parentNode?.parentNode?.parentNode?.getBoundingClientRect();
                p1Weight = 2;
            }
            if (p2BoundingRect.height == 0 || p2BoundingRect.width == 0) {
                p2BoundingRect = p2?.parentNode?.parentNode?.parentNode?.getBoundingClientRect();
                p2Weight = 0;
            }
            let panelBoundingRect = this.#canvas.getBoundingClientRect();
            let x1 = p1BoundingRect.left + p1BoundingRect.width / 2 * p1Weight - panelBoundingRect.left;
            let y1 = p1BoundingRect.top + p1BoundingRect.height / 2 - panelBoundingRect.top;
            let x2 = p2BoundingRect.left + p2BoundingRect.width / 2 * p2Weight - panelBoundingRect.left;
            let y2 = p2BoundingRect.top + p2BoundingRect.height / 2 - panelBoundingRect.top;
            context.beginPath();
            context.moveTo(x1, y1);
            //context.bezierCurveTo(Math.max(x2, x1 + max),y1,Math.min(x1, x2 - max),y2,x2,y2);
            let xa, xb;
            if (x2 > x1) {
                xa = (x1 + x2) / 2;
                xb = (x1 + x2) / 2;
            }
            else {
                xa = x1 + 100;
                xb = x2 - 100;
            }
            context.bezierCurveTo(xa, y1, xb, y2, x2, y2);
            context.lineWidth = 2;
            context.strokeStyle = '#EEEEEE';
            context.stroke();
        }
    }
    #drawLinks() {
        this.#context.clearRect(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        if (this.#nodeImageEditor) {
            for (let node of this.#nodeImageEditor.getNodes()) {
                let nodeGui = this.#nodesGui.get(node);
                let inputs = node.inputs;
                for (let input of inputs.values()) {
                    if (input.getPredecessor()) {
                        const predecessorNode = input.getPredecessor()?.node;
                        if (!predecessorNode) {
                            continue;
                        }
                        let nodeGui2 = this.#nodesGui.get(predecessorNode);
                        if (nodeGui && nodeGui2) {
                            let inputGui = nodeGui._ioGui.get(input);
                            let outputGui = nodeGui2._ioGui.get(input.getPredecessor());
                            this.#drawLink(outputGui, inputGui);
                        }
                    }
                }
            }
        }
    }
    #refreshFilter() {
        if (this.#nodeImageEditor) {
            for (let node of this.#nodeImageEditor.getNodes()) {
                let nodeGui = this.#nodesGui.get(node);
                if (nodeGui) {
                    this.#matchFilter(nodeGui);
                }
            }
        }
        this.refresh();
    }
    refresh() {
        this.#organizeNodes();
        this.#drawLinks();
    }
    #matchFilter(nodeGUI) {
        let expanded = true;
        if (this.#filter.node) {
            if (!nodeGUI.node.title.includes(this.#filter.node)) {
                expanded = false;
            }
        }
        nodeGUI.expanded = expanded;
    }
    setNodeFilter(nodeName) {
        this.#htmlNodeFilter.value = nodeName;
        this.#filter.node = nodeName;
        this.#refreshFilter();
    }
    getNodeFilter() {
        return this.#filter.node ?? '';
    }
}

var nodeimageeditor_declare_functions = `
#define SKIP_SRGB_ENC_DEC

float4 invlerp( float x, float y, float4 r )
{
	return ( r - x ) / ( y - x );
}


float4 ConvertLinearTosRGB( float4 lin )
{
	#ifdef SKIP_SRGB_ENC_DEC
		return lin;
	#else
		float3 col_lin = lin.xyz;
		float3 col_srgb;
		for (int i = 0; i < 3; ++i)
		{
			if ( col_lin[i] <= 0.0031308 )
				col_srgb[i] = 12.92 * col_lin[i];
			else
				col_srgb[i] = 1.055 * pow( col_lin[i], 1.0 / 2.4 ) - 0.055;
		}

		return float4( col_srgb.xyz, lin.a );
	#endif
}

float4 ConvertsRGBToLinear( float4 srgb )
{
	#ifdef SKIP_SRGB_ENC_DEC
		return srgb;
	#else
		float3 col_srgb = srgb.xyz;
		float3 col_lin;

		for (int i = 0; i < 3; ++i)
		{
			if ( col_srgb[i] <= 0.04045 )
				col_lin[i] = col_srgb[i] / 12.92;
			else
				col_lin[i] = pow( ( col_srgb[i] + 0.055 ) / 1.055, 2.4 );
		}

		return float4( col_lin.xyz, srgb.a );
	#endif
}

// Uses photoshop math to perform level adjustment.
// Note: Photoshop does this math in sRGB space, even though that is mathematically wrong.
// To match photoshop, we have to convert our textures from linear space (they're always linear in the shader)
// to sRGB, perform the calculations and then return to linear space for output from the shader.
// Yuck.
/*float AdjustLevels( float inSrc, float inBlackPoint, float inWhitePoint, float inGammaValue )
{
	if ( inBlackPoint == 0.0 && inWhitePoint == 1.0 && inGammaValue == 1.0 )
		return inSrc;
	else
	{
		inSrc = ConvertLinearTosRGB( inSrc );

		float pcg = saturate( invlerp( inBlackPoint, inWhitePoint, inSrc ) );
		float gammaAdjusted = pow( pcg, inGammaValue );

		gammaAdjusted = ConvertsRGBToLinear( gammaAdjusted );

		return saturate( gammaAdjusted );
	}
}*/

float4 AdjustLevels( float4 inSrc, float inBlackPoint, float inWhitePoint, float inGammaValue )
{
	if ( inBlackPoint == 0.0 && inWhitePoint == 1.0 && inGammaValue == 1.0 )
		return inSrc;
	else
	{
		inSrc = ConvertLinearTosRGB( inSrc );

		float4 pcg = saturate( invlerp( inBlackPoint, inWhitePoint, inSrc ) );
		float4 gammaAdjusted = pow( pcg, vec4(inGammaValue) );

		gammaAdjusted = ConvertsRGBToLinear( gammaAdjusted );

		return saturate( gammaAdjusted );
	}
}

`;

var nodeimageeditor_imageeditor_vs = `
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

#ifdef NEED_TWO_TEX_COORDS
varying vec4 vTextureCoord;
#else
varying vec2 vTextureCoord;
#endif

#ifdef TRANSFORM_TEX_COORD
	uniform mat3 uTransformTexCoord0;
#endif

/*imageeditor.vs*/
void main(void) {
	//gl_Position = vec4(aVertexPosition, 1.0);
	#include compute_vertex_projection
#ifdef TRANSFORM_TEX_COORD
	vTextureCoord.xy = vec3(uTransformTexCoord0 * vec3(aTextureCoord, 1.0)).xy;
	#ifdef NEED_TWO_TEX_COORDS
		vTextureCoord.zw = aTextureCoord.xy;
	#endif
#else
	vTextureCoord = aTextureCoord;
#endif

}
`;

Includes['nodeimageeditor_declare_functions'] = nodeimageeditor_declare_functions;
Includes['nodeimageeditor_imageeditor_vs'] = nodeimageeditor_imageeditor_vs;

class ParametersNode extends Node {
    isParametersNode = true;
}

class FloatArrayNode extends ParametersNode {
    #length;
    #array = [];
    constructor(editor, params) {
        super(editor, params);
        this.#length = params.length ?? 0;
        this.addOutput('output', IO_TYPE_ARRAY_FLOAT);
        for (let i = 0; i < this.#length; ++i) {
            this.#array.push(0);
        }
        this.addParam(new NodeParam('value', NodeParamType.Float, this.#array, this.#length));
    }
    async operate(context = {}) {
        this.getOutput('output')._value = this.#array;
    }
    get title() {
        return 'float array';
    }
    setValue(index, value) {
        if (index >= this.#length) {
            throw 'wrong index';
        }
        this.#array[index] = value;
        this.invalidate();
    }
}
registerOperation('float array', FloatArrayNode);

class IntArrayNode extends ParametersNode {
    #length;
    #array = [];
    constructor(editor, params) {
        super(editor, params);
        this.#length = params.length ?? 0;
        this.addOutput('output', IO_TYPE_ARRAY_INT);
        for (let i = 0; i < this.#length; ++i) {
            this.#array.push(0);
        }
        this.addParam(new NodeParam('value', NodeParamType.Int, this.#array, this.#length));
    }
    async operate(context = {}) {
        this.getOutput('output')._value = this.#array;
    }
    get title() {
        return 'int array';
    }
    setValue(index, value) {
        if (index >= this.#length) {
            throw 'wrong index';
        }
        this.#array[index] = value;
        this.invalidate();
    }
}
registerOperation('int array', IntArrayNode);

class DrawCircle extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('center', IO_TYPE_VEC2)._value = create();
        this.addInput('radius', IO_TYPE_FLOAT)._value = 10.0;
        this.addInput('border', IO_TYPE_FLOAT)._value = 1.0;
        this.addInput('bordercolor', IO_TYPE_COLOR)._value = fromValues$3(1.0, 1.0, 1.0, 1.0);
        this.addInput('fillcolor', IO_TYPE_COLOR)._value = fromValues$3(1.0, 1.0, 1.0, 1.0);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.addOutput('perimeter', IO_TYPE_FLOAT);
        this.addOutput('area', IO_TYPE_FLOAT);
        this.material = new NodeImageEditorMaterial({ shaderName: 'drawcircle' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        let center = await this.getInput('center').value;
        let radius = await this.getInput('radius').value;
        let borderColor = await this.getInput('bordercolor').value;
        let fillColor = await this.getInput('fillcolor').value;
        let border = await this.getInput('border').value;
        this.getOutput('perimeter')._value = Math.PI * radius * 2;
        this.getOutput('area')._value = Math.PI * radius ** 2;
        this.material.uniforms['uRadius'] = radius;
        this.material.uniforms['uCenter'] = center;
        this.material.uniforms['uBorderColor'] = borderColor;
        this.material.uniforms['uFillColor'] = fillColor;
        this.material.uniforms['uBorder'] = border;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'draw circle';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('draw_circle', DrawCircle);

class CombineAdd extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        for (let i = 0; i < 8; ++i) {
            this.addInput('input' + i, IO_TYPE_TEXTURE_2D);
        }
        //this.addInput('input', IO_TYPE_TEXTURE_2D, 8);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'combine_add' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        /*let input1 = this.getInput('input1').value;
        let input2 = this.getInput('input2').value;
        let input3 = this.getInput('input3').value;
        let input4 = this.getInput('input4').value;
        let input5 = this.getInput('input5').value;*/
        /*this.material.uniforms['uInput1'] = input1;
        this.material.uniforms['uInput2'] = input2;
        this.material.uniforms['uInput3'] = input3;
        this.material.uniforms['uInput4'] = input4;
        this.material.uniforms['uInput5'] = input5;*/
        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        let textureArray = [];
        for (let i = 0; i < 8; ++i) {
            textureArray.push(await this.getInput('input' + i).value);
        }
        this.material.setTextureArray('uInput[0]', textureArray);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'combine add';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('combine_add', CombineAdd);

class CombineLerp extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input0', IO_TYPE_TEXTURE_2D);
        this.addInput('input1', IO_TYPE_TEXTURE_2D);
        this.addInput('weight', IO_TYPE_TEXTURE_2D);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'combine_lerp' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
    }
    async operate(context = {}) {
        this.material.setTexture('uInput0', await this.getInput('input0').value);
        this.material.setTexture('uInput1', await this.getInput('input1').value);
        this.material.setTexture('uInputWeight', await this.getInput('weight').value);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'combine lerp';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('combine_lerp', CombineLerp);

class Multiply$1 extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        for (let i = 0; i < 8; ++i) {
            this.addInput('input' + i, IO_TYPE_TEXTURE_2D);
        }
        //this.addInput('input', IO_TYPE_TEXTURE_2D, 8);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'multiply' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        let textureArray = [];
        let usedArray = [];
        for (let i = 0; i < 8; ++i) {
            //let inputName = 'uInput' + i;
            //this.material.uniforms['uInput' + i] = await this.getInput('input' + i).value;
            let texture = await this.getInput('input' + i).value;
            textureArray.push(texture);
            usedArray.push(texture != undefined);
        }
        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        this.material.setTextureArray('uInput[0]', textureArray);
        this.material.uniforms['uUsed[0]'] = usedArray;
        //this.material.uniforms['uInput1'] = await this.getInput('input1').value;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false, texture: this.getOutput('output')._value });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        //let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        //new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
    }
    get title() {
        return 'multiply';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('multiply', Multiply$1);

const MAX_SELECTORS = 16;
class Select extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input', IO_TYPE_TEXTURE_2D);
        this.addInput('selectvalues', IO_TYPE_FLOAT, MAX_SELECTORS);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'select' });
        this.material.setDefine('MAX_SELECTORS', String(MAX_SELECTORS));
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        this.material.setTexture('uInputTexture', await this.getInput('input').value);
        this.material.uniforms['uSelect[0]'] = await this.getInput('selectvalues').value;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        new Graphics().pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        new Graphics().glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        new Graphics().popRenderTarget();
        this.updatePreview(context);
        this.getOutput('output')._value = this.#renderTarget.getTexture();
        this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'select';
    }
    async toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (let input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        let selectvalues = await this.getInput('selectvalues').value;
        let a = [];
        for (let v of selectvalues) {
            if (v) {
                a.push(v);
            }
        }
        ret.push(tabs1 + 'values : ' + a.join(' '));
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('select', Select);

var applysticker_fs = `
varying vec4 vTextureCoord;
uniform sampler2D uSticker;
uniform sampler2D uStickerSpecular;
uniform sampler2D uInput;

/*applysticker.fs*/
void main(void) {
	vec4 inputColor = texture2D(uInput, vTextureCoord.zw);
	vec4 stickerColor = texture2D(uSticker, vTextureCoord.xy);
	vec4 specularColor = texture2D(uStickerSpecular, vTextureCoord.xy);
	gl_FragColor = vec4((1.0 - stickerColor.a) * inputColor.xyz + stickerColor.a * stickerColor.xyz,
						(1.0 - stickerColor.a) * inputColor.a + stickerColor.a * specularColor.r);
}
`;

//TODO: sticker specular
/*
				float3 tmpColor = ( 1.0 - color1.a ) * color0.xyz
								+ ( color1.a )       * color1.xyz;

				float tmpSpecular = ( 1.0 - color1.a ) * color0.w
				                  + ( color1.a )       * srcSpecular;

				return float4( tmpColor.xyz, tmpSpecular );
				*/

var applysticker_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var combine_add_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput[8];
/*combine_add.fs*/
void main(void) {
	gl_FragColor = vec4(0.0);
	gl_FragColor += texture2D(uInput[0], vTextureCoord);
	gl_FragColor += texture2D(uInput[1], vTextureCoord);
	gl_FragColor += texture2D(uInput[2], vTextureCoord);
	gl_FragColor += texture2D(uInput[3], vTextureCoord);
	gl_FragColor += texture2D(uInput[4], vTextureCoord);
	gl_FragColor += texture2D(uInput[5], vTextureCoord);
	gl_FragColor += texture2D(uInput[6], vTextureCoord);
	gl_FragColor += texture2D(uInput[7], vTextureCoord);
}
`;

var combine_add_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var combine_lerp_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput0;
uniform sampler2D uInput1;
uniform sampler2D uInputWeight;

/*combine_lerp.fs*/
void main(void) {
	vec4 color1 = texture2D(uInput0, vTextureCoord);
	vec4 color2 = texture2D(uInput1, vTextureCoord);
	vec4 color3 = texture2D(uInputWeight, vTextureCoord);
	gl_FragColor = mix(color1, color2, color3.rrrr);
}
`;

var combine_lerp_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var drawcircle_fs = `
varying vec2 vTextureCoord;

uniform float uBorder;
uniform float uRadius;
uniform vec4 uBorderColor;
uniform vec4 uFillColor;
uniform vec2 uCenter;

uniform sampler2D backGround;
uniform sampler2D uMaskTexture;

/* hack to avoid smoothstep undefined behavior when uBorder = 0*/
const float epsilon = 0.000001;

/*drawcircle.fs*/
void main(void) {
	vec4 maskColor = texture2D(uMaskTexture, vTextureCoord);
	vec4 fillColor = vec4(1.0, 0.0, 0.0, 0.0);
	vec2 uv = gl_FragCoord.xy - uCenter;
	float dist = sqrt(dot(uv, uv));
	float t = smoothstep(uRadius-uBorder, uRadius, dist)
			- smoothstep(uRadius, uRadius+uBorder, dist);
	//float t2 = smoothstep(uRadius+uBorder, uRadius-uBorder-epsilon, dist);
	float t2 = 1.0 - smoothstep(uRadius - uBorder, uRadius + uBorder + epsilon, dist);
	//gl_FragColor = (uBorderColor * t + uFillColor * t2) * maskColor;
	gl_FragColor.rgb = (uBorderColor.rgb * t + uFillColor.rgb * t2);
	gl_FragColor.a = 1.0;
	/*gl_FragColor = vec4(1.0, 0.5, 0.25, 0.0);*/
	/*gl_FragColor = vec4(length(gl_FragCoord.xy/8.0));*/
	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(abs(uv) / 100.0, 0.0, 1.0);
	//gl_FragColor = vec4(uv, 0.0, 1.0);
	//gl_FragColor = vec4(dist / 100.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(t2, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(1.0, 0.5, 0.25, 1.0);
	//gl_FragColor.r += 0.5;
	//gl_FragColor = vec4(dist / 1000.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(t2);
}
`;

var drawcircle_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var multiply_fs = `
#define INPUT_COUNT 8

varying vec2 vTextureCoord;

uniform sampler2D uInput[INPUT_COUNT];
uniform bool uUsed[INPUT_COUNT];
/*multiply.fs*/
void main(void) {
	gl_FragColor = vec4(1.0);
	if (uUsed[0]) {
		gl_FragColor *= texture2D(uInput[0], vTextureCoord);
	}
	if (uUsed[1]) {
		gl_FragColor *= texture2D(uInput[1], vTextureCoord);
	}
	if (uUsed[2]) {
		gl_FragColor *= texture2D(uInput[2], vTextureCoord);
	}
	if (uUsed[3]) {
		gl_FragColor *= texture2D(uInput[3], vTextureCoord);
	}
	if (uUsed[4]) {
		gl_FragColor *= texture2D(uInput[4], vTextureCoord);
	}
	if (uUsed[5]) {
		gl_FragColor *= texture2D(uInput[5], vTextureCoord);
	}
	if (uUsed[6]) {
		gl_FragColor *= texture2D(uInput[6], vTextureCoord);
	}
	if (uUsed[7]) {
		gl_FragColor *= texture2D(uInput[7], vTextureCoord);
	}
}
`;

var multiply_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var select_fs = `
varying vec2 vTextureCoord;

uniform sampler2D 	uInputTexture;
uniform float		uSelect[MAX_SELECTORS];

/*select.fs*/
void main(void) {
	vec4 color = texture2D(uInputTexture, vTextureCoord);

	gl_FragColor = vec4(0.0);
	for (int i=0; i < MAX_SELECTORS; i++) {
		if (uSelect[i] > 0.0) {
			if (abs(color.r * 255.0 - uSelect[i]) < 8.0) {
				gl_FragColor = vec4(1.0);
			}
		}
	}
}
`;

var select_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var texturelookup_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput;
uniform float uRotateAngle;
uniform vec2 uUVTranslate;
uniform vec2 uUVScale;


uniform vec4 uAdjustLevels;
#define g_AdjustInBlack(n)		uAdjustLevels.x
#define g_AdjustInWhite(n)		uAdjustLevels.y
#define g_AdjustGamma(n)		uAdjustLevels.z

#include nodeimageeditor_declare_functions

/*texturelookup.fs*/
void main(void) {
	vec4 color0 = texture2D(uInput, vTextureCoord);
	gl_FragColor = AdjustLevels(color0, g_AdjustInBlack(0), g_AdjustInWhite(0), g_AdjustGamma(0));
	//gl_FragColor = vec4(g_AdjustInWhite(0));
}
`;

var texturelookup_vs = `
#include nodeimageeditor_imageeditor_vs
`;

Shaders['applysticker.fs'] = applysticker_fs;
Shaders['applysticker.vs'] = applysticker_vs;
Shaders['combine_add.fs'] = combine_add_fs;
Shaders['combine_add.vs'] = combine_add_vs;
Shaders['combine_lerp.fs'] = combine_lerp_fs;
Shaders['combine_lerp.vs'] = combine_lerp_vs;
Shaders['drawcircle.fs'] = drawcircle_fs;
Shaders['drawcircle.vs'] = drawcircle_vs;
Shaders['multiply.fs'] = multiply_fs;
Shaders['multiply.vs'] = multiply_vs;
Shaders['select.fs'] = select_fs;
Shaders['select.vs'] = select_vs;
Shaders['texturelookup.fs'] = texturelookup_fs;
Shaders['texturelookup.vs'] = texturelookup_vs;

var imageeditor_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uFinalTexture;

/*imageeditor.fs*/
void main(void) {
	gl_FragColor = texture2D(uFinalTexture, vTextureCoord);
}
`;

var imageeditor_vs = `
#include nodeimageeditor_imageeditor_vs
`;

Shaders['imageeditor.fs'] = imageeditor_fs;
Shaders['imageeditor.vs'] = imageeditor_vs;

const DEFAULT_TEXTURE_SIZE = 512;
class NodeImageEditor extends EventTarget {
    #variables = new Map();
    #scene = new Scene();
    #nodes = new Set();
    #camera = new Camera({ position: fromValues$4(0, 0, 100) });
    #fullScreenQuadMesh = new FullScreenQuad();
    textureSize = DEFAULT_TEXTURE_SIZE;
    constructor() {
        super();
        this.#scene.addChild(this.#fullScreenQuadMesh);
    }
    render(material) {
        this.#fullScreenQuadMesh.setMaterial(material);
        new Graphics().render(this.#scene, this.#camera, 0, { DisableToolRendering: true });
    }
    addNode(operationName, params = {}) {
        params.textureSize = params.textureSize ?? this.textureSize;
        if (!operationName) {
            return null;
        }
        let node = getOperation(operationName, this, params);
        if (node) {
            this.textureSize = params.textureSize;
        }
        this.#nodes.add(node);
        this.#dispatchEvent('nodeadded', node);
        return node;
    }
    /*addNewNode(operationName, params = Object.create(null)) {
        let node = this._createNode(operationName, params);
        this.addNode(node);
        return node;
    }*/
    #dispatchEvent(eventName, eventDetail) {
        this.dispatchEvent(new CustomEvent(eventName, { detail: { value: eventDetail } }));
        this.dispatchEvent(new CustomEvent('*', { detail: { eventName: eventName } }));
    }
    /*addNode(node) {
        if (node instanceof Node && node.editor == this) {
            this.#nodes.add(node);
            this.#dispatchEvent('nodeadded', node);
        }
    }*/
    removeNode(node) {
        if (node instanceof Node && node.editor == this) {
            this.#nodes.delete(node);
            //TODO :remove all inputs / output
            this.#dispatchEvent('noderemoved', node);
        }
    }
    removeAllNodes() {
        this.#nodes.forEach((node) => node.dispose());
        this.#nodes.clear();
        this.#dispatchEvent('allnodesremoved', this);
        //TODO :remove all inputs / output
    }
    getVariable(name) {
        return this.#variables.get(name);
    }
    setVariable(name, value) {
        return this.#variables.set(name, value);
    }
    deleteVariable(name) {
        return this.#variables.delete(name);
    }
    clearVariables() {
        return this.#variables.clear();
    }
    getNodes() {
        return new Set(this.#nodes);
    }
}

const tempVec3$p = create$4();
class BoundingBoxHelper extends Box {
    boundingBox = new BoundingBox();
    constructor(params = {}) {
        super(params);
        this.wireframe = 0;
    }
    update() {
        if (this._parent) {
            this._parent.getBoundingBox(this.boundingBox);
            this.boundingBox.getCenter(this._position);
            this.boundingBox.getSize(tempVec3$p);
            this.setSize(tempVec3$p[0], tempVec3$p[1], tempVec3$p[2]);
        }
    }
    getWorldPosition(vec = create$4()) {
        return copy$4(vec, this._position);
    }
    getWorldQuaternion(q = create$2()) {
        return identity$1(q);
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
}

const BASE_COLOR = [1, 1, 1, 1];
const FRUSTRUM_COLOR = [1, 0, 0, 1];
const AXIS_COLOR = [1, 1, 0, 1];
const tempVec3$o = create$4();
const Points = [
    //Base Points
    { p: fromValues$4(0, 0, 0), c: BASE_COLOR },
    { p: fromValues$4(0, 0, 0), c: AXIS_COLOR },
    // Base pyramid
    { p: fromValues$4(-1, -1, -1), c: BASE_COLOR },
    { p: fromValues$4(-1, +1, -1), c: BASE_COLOR },
    { p: fromValues$4(+1, -1, -1), c: BASE_COLOR },
    { p: fromValues$4(+1, +1, -1), c: BASE_COLOR },
    // near plane
    { p: fromValues$4(-1, -1, -1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(-1, +1, -1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(+1, -1, -1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(+1, +1, -1), c: FRUSTRUM_COLOR },
    // far plane
    { p: fromValues$4(-1, -1, 1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(-1, +1, 1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(+1, -1, 1), c: FRUSTRUM_COLOR },
    { p: fromValues$4(+1, +1, 1), c: FRUSTRUM_COLOR },
    //Axis line
    { p: fromValues$4(0, 0, 1), c: AXIS_COLOR },
    //Near plane axis
    { p: fromValues$4(-1, 0, -1), c: AXIS_COLOR },
    { p: fromValues$4(+1, 0, -1), c: AXIS_COLOR },
    { p: fromValues$4(0, -1, -1), c: AXIS_COLOR },
    { p: fromValues$4(0, +1, -1), c: AXIS_COLOR },
    //Far plane axis
    { p: fromValues$4(-1, 0, 1), c: AXIS_COLOR },
    { p: fromValues$4(+1, 0, 1), c: AXIS_COLOR },
    { p: fromValues$4(0, -1, 1), c: AXIS_COLOR },
    { p: fromValues$4(0, +1, 1), c: AXIS_COLOR },
];
const Lines = [
    0, 2,
    0, 3,
    0, 4,
    0, 5,
    // near plane
    6, 7,
    6, 8,
    7, 9,
    8, 9,
    6, 10,
    7, 11,
    8, 12,
    9, 13,
    // far plane
    10, 11,
    10, 12,
    11, 13,
    12, 13,
    //center axis
    1, 14,
    //near plane axis
    15, 16,
    17, 18,
    //far plane axis
    19, 20,
    21, 22,
    //near / far plane junction
    /*15, 19,
    16, 20,
    17, 21,
    18, 22,*/
];
class CameraFrustum extends Mesh {
    #camera;
    #vertexPositionAttribute;
    constructor() {
        super(new BufferGeometry(), new LineBasicMaterial());
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.material.setColorMode(MaterialColorMode.PerVertex);
        this.castShadow = false;
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => this.update());
    }
    #createVertices() {
        const indices = Lines;
        const vertices = [];
        const colors = [];
        for (let point of Points) {
            vertices.push(...point.p);
            colors.push(...point.c);
        }
        let geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        this.#vertexPositionAttribute = new Float32BufferAttribute(vertices, 3);
        geometry.setAttribute('aVertexPosition', this.#vertexPositionAttribute);
        geometry.setAttribute('aVertexColor', new Uint8BufferAttribute(colors, 4));
        geometry.count = indices.length;
    }
    update() {
        if (this.#camera) {
            let index = 0;
            let verticesArray = this.#vertexPositionAttribute._array;
            for (let point of Points) {
                if (index > 3) { //Skip the base point
                    copy$4(tempVec3$o, point.p);
                    this.#camera.invertProjection(tempVec3$o);
                    verticesArray.set(tempVec3$o, index);
                }
                index += 3;
            }
            this.#vertexPositionAttribute.dirty = true;
        }
    }
    parentChanged(parent) {
        if (parent?.is('Camera')) {
            this.#camera = parent;
        }
        else {
            this.#camera = null;
        }
        this.update();
    }
}

class Grid extends Mesh {
    #size;
    #spacing;
    #normal;
    constructor(params = {}) {
        const spacing = params.spacing ?? 10;
        super(new PlaneBufferGeometry(), new GridMaterial({ spacing: spacing }));
        this.#size = params.size ?? 100;
        this.#spacing = spacing;
        this.#normal = params.normal ?? 2;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#size, this.#size, 1, 1);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Grid_1: null,
            size: { i18n: '#size', f: () => { let size = prompt('Size', String(this.#size)); if (size) {
                    this.#size = Number(size);
                    this.#updateGeometry();
                } } },
            spacing: { i18n: '#spacing', f: () => { let spacing = prompt('Spacing', String(this.#spacing)); if (spacing) {
                    this.#spacing = this.material.spacing = Number(spacing);
                } } }
        });
    }
}

function getHelper(type) {
    switch (type.constructor.name) {
        case 'PointLight':
            return new PointLightHelper();
        case 'SpotLight':
            return new SpotLightHelper();
        case 'Scene':
            return new Grid();
    }
    if (type instanceof Camera) {
        return new CameraFrustum();
    }
}

const tempVec3$n = create$4();
let boxMaterial;
class HitboxHelper extends Entity {
    #hitboxes = [];
    constructor() {
        super();
        if (!boxMaterial) {
            boxMaterial = new MeshBasicMaterial();
            boxMaterial.setMeshColor([0.5, 0.5, 0.5, 0.1]);
            boxMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        }
    }
    parentChanged(parent) {
        this.removeBoxes();
        if (parent && parent.getHitboxes) {
            let hitboxes = parent.getHitboxes();
            for (let hitbox of hitboxes) {
                sub$2(tempVec3$n, hitbox.boundingBoxMax, hitbox.boundingBoxMin);
                let box = new Box({ width: tempVec3$n[0], height: tempVec3$n[1], depth: tempVec3$n[2], material: boxMaterial });
                box.serializable = false;
                lerp$5(tempVec3$n, hitbox.boundingBoxMin, hitbox.boundingBoxMax, 0.5);
                box.position = tempVec3$n;
                if (hitbox.parent) {
                    hitbox.parent.addChild(box);
                }
                else {
                    this.addChild(box);
                }
                this.#hitboxes.push(box);
            }
        }
    }
    removeBoxes() {
        this.#hitboxes.forEach(hitbox => hitbox.dispose());
        this.#hitboxes = [];
    }
    static async constructFromJSON() {
        return new HitboxHelper();
    }
    static getEntityName() {
        return 'HitboxHelper';
    }
}
registerEntity(HitboxHelper);

create$4();
class Line extends Mesh {
    isLine = true;
    #start = create$4();
    #end = create$4();
    constructor(params = {}) {
        super(new LineSegmentsGeometry(), params.material ?? new LineMaterial());
        if (params.start) {
            copy$4(this.#start, params.start);
        }
        if (params.end) {
            copy$4(this.#end, params.end);
        }
        this.#updateGeometry();
    }
    set start(start) {
        copy$4(this.#start, start);
        this.#updateGeometry();
    }
    getStart(start = create$4()) {
        return copy$4(start, this.#start);
    }
    set end(end) {
        copy$4(this.#end, end);
        this.#updateGeometry();
    }
    getEnd(end = create$4()) {
        return copy$4(end, this.#end);
    }
    #updateGeometry() {
        this.geometry.setSegments([...this.#start, ...this.#end], [], false);
    }
    raycast(raycaster, intersections) {
        const interSegment = create$4();
        const interRay = create$4();
        const ray = raycaster.ray;
        const sqrDist = ray.distanceSqToSegment(this.#start, this.#end, interRay, interSegment);
        if (sqrDist < 10) { //TODO: variable
            intersections.push(ray.createIntersection(interRay, null, null, this, sqrDist));
        }
    }
    toJSON() {
        let json = super.toJSON();
        json.start = clone$4(this.start);
        json.end = clone$4(this.end);
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Line({ start: json.start, end: json.end, material: material });
    }
    static getEntityName() {
        return 'Line';
    }
}
registerEntity(Line);

const a$9 = create$4();
const b$3 = create$4();
const c = create$4();
class Raycaster {
    near;
    far;
    ray = new Ray();
    constructor(near = 0, far = Infinity) {
        this.near = near;
        this.far = far;
    }
    castRay(origin, direction, entities, recursive) {
        this.ray.set(origin, direction);
        let intersections = [];
        for (let entity of entities) {
            this.intersectEntity(entity, intersections, recursive);
        }
        return intersections;
    }
    castCameraRay(camera, normalizedX, normalizedY, entities, recursive) {
        let projectionMatrixInverse = camera.projectionMatrixInverse;
        let nearP = set$5(a$9, normalizedX, normalizedY, -1);
        let farP = set$5(b$3, normalizedX, normalizedY, 1);
        transformMat4$2(nearP, nearP, projectionMatrixInverse);
        transformMat4$2(farP, farP, projectionMatrixInverse);
        transformQuat$1(nearP, nearP, camera.quaternion);
        transformQuat$1(farP, farP, camera.quaternion);
        let rayDirection = sub$2(c, farP, nearP);
        normalize$5(rayDirection, rayDirection);
        return this.castRay(camera.position, rayDirection, entities, recursive);
    }
    intersectEntity(entity, intersections, recursive) {
        if (!entity.visible) {
            return;
        }
        entity.raycast(this, intersections);
        if (recursive) {
            for (let child of entity.children) {
                this.intersectEntity(child, intersections, recursive);
            }
        }
    }
}

const SceneExplorerEvents = new EventTarget();

const tempVec3$m = create$4();
class SkeletonHelper extends Entity {
    #skeleton;
    #lines = new Map();
    #lineMaterial;
    #highlitLineMaterial;
    #boneTipMaterial;
    #raycaster;
    #highlitLine;
    #boneStart;
    #boneEnd;
    enumerable = false;
    #displayJoints = true;
    constructor(parameters) {
        super(parameters);
        this.#lineMaterial = new LineMaterial();
        this.#lineMaterial.addUser(this);
        this.#lineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#lineMaterial.lineWidth = 3;
        this.#highlitLineMaterial = new LineMaterial();
        this.#highlitLineMaterial.addUser(this);
        this.#highlitLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#highlitLineMaterial.lineWidth = 3;
        this.#highlitLineMaterial.setMeshColor([1, 0, 0, 1]);
        this.#boneTipMaterial = new MeshBasicMaterial();
        this.#boneTipMaterial.addUser(this);
        this.#boneTipMaterial.setDefine('ALWAYS_ON_TOP');
        this.#boneTipMaterial.setMeshColor([1, 0, 1, 1]);
        this.hideInExplorer = true;
        this.#skeleton = parameters?.skeleton;
        this.#raycaster = new Raycaster();
        this.#boneStart = new Sphere({ radius: 1, material: this.#boneTipMaterial });
        this.#boneEnd = new Sphere({ radius: 1, material: this.#boneTipMaterial });
        this.addChilds(this.#boneStart, this.#boneEnd);
        this.#initListeners();
    }
    parentChanged(parent) {
        if (!parent) {
            return;
        }
        this.#clearSkeleton();
        if (parent.isSkeleton) {
            this.#skeleton = parent;
        }
        else if (parent.skeleton) {
            this.#skeleton = parent.skeleton;
        }
        else {
            this.#skeleton = null;
        }
    }
    #clearSkeleton() {
        this.#lines.forEach(value => value.dispose());
        this.#lines.clear();
        this.#boneStart.setVisible(false);
        this.#boneEnd.setVisible(false);
    }
    /*
        set skeleton(skeleton) {
            this.#skeleton = skeleton;
        }

        get skeleton() {
            return this.#skeleton;
        }*/
    getWorldPosition(vec = create$4()) {
        return copy$4(vec, this._position);
    }
    getWorldQuaternion(q = create$2()) {
        return identity$1(q);
    }
    #update() {
        if (!this.#skeleton) {
            return;
        }
        for (let bone of this.#skeleton.bones) {
            let boneLine = this.#lines.get(bone);
            if (!boneLine) {
                boneLine = new Line({ material: this.#lineMaterial, parent: this });
                boneLine.properties.set('bone', bone);
                this.#lines.set(bone, boneLine);
                this.addChild(boneLine);
            }
            //boneLine.position = bone.worldPos;
            boneLine.start = bone.worldPos;
            boneLine.end = bone.worldPos;
            const boneParent = bone.parent;
            if (boneParent?.isBone) {
                boneLine.start = boneParent.getWorldPosition( /*TODO: optimize*/);
                boneLine.properties.set('boneParent', boneParent);
            }
        }
    }
    get wireframe() {
        return 0;
    }
    #initListeners() {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => {
            if (!this.isVisible()) {
                return;
            }
            this.#update();
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => {
            this.#mouseMoved(event);
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => {
            this.#mouseUp(event);
        });
    }
    #mouseMoved(event) {
        this.#highlit(this.#pickBone(event));
    }
    #mouseUp(event) {
        const closest = this.#pickBone(event);
        this.#highlit(closest);
        if (closest) {
            let bone = closest.properties.get('bone');
            if (closest.isLine) {
                bone = bone?.parent /*TODO case where parent is not Bone*/ ?? bone;
            }
            SceneExplorerEvents.dispatchEvent(new CustomEvent('bonepicked', { detail: { bone: bone } }));
        }
    }
    displayBoneJoints(display) {
        this.#boneStart.setVisible(this.#highlitLine && display);
        this.#boneEnd.setVisible(this.#highlitLine && display);
        this.#displayJoints = display;
    }
    setJointsRadius(radius) {
        this.#boneStart.setRadius(radius);
        this.#boneEnd.setRadius(radius);
    }
    #pickBone(event) {
        if (!this.isVisible()) {
            return;
        }
        let normalizedX = (event.detail.x / new Graphics().getWidth()) * 2 - 1;
        let normalizedY = 1 - (event.detail.y / new Graphics().getHeight()) * 2;
        const scene = this.root;
        if (!scene.is('Scene')) {
            return;
        }
        let intersections = this.#raycaster.castCameraRay(scene.activeCamera, normalizedX, normalizedY, [this], true);
        if (intersections.length) {
            let closest = null;
            let closestDist = Infinity;
            for (let intersection of intersections) {
                const entity = intersection.entity;
                if (entity.isLine) {
                    if (intersection.distanceFromRay < closestDist) {
                        closest = entity;
                        closestDist = intersection.distanceFromRay;
                    }
                }
                else if (entity.isSphere) {
                    if (intersection.distanceFromRay < closestDist) {
                        if (entity == this.#boneStart || entity == this.#boneEnd) {
                            closest = entity;
                            closestDist = intersection.distanceFromRay;
                        }
                    }
                }
            }
            return closest;
        }
    }
    #highlit(line) {
        if (!line?.isLine) {
            return;
        }
        if (this.#highlitLine) {
            this.#highlitLine.material = this.#lineMaterial;
        }
        if (line) {
            line.material = this.#highlitLineMaterial;
            this.#boneStart.position = line.getStart(tempVec3$m);
            this.#boneEnd.position = line.getEnd(tempVec3$m);
            this.#boneStart.setVisible(this.#displayJoints);
            this.#boneEnd.setVisible(this.#displayJoints);
            this.#boneStart.properties.set('bone', line.properties.get('boneParent'));
            this.#boneEnd.properties.set('bone', line.properties.get('bone'));
        }
        this.#highlitLine = line;
    }
    dispose() {
        this.#clearSkeleton();
        this.#lineMaterial.removeUser(this);
        this.#highlitLineMaterial.removeUser(this);
    }
}

const tempWorldMat = create$5();
const tempWorldQuat = create$2();
const tempWorldVec3 = create$4();
const tempWorldScale = create$4();
const tempPosition = create$4();
const tempQuat1 = create$2();
const tempVec1 = create$4();
class Bone extends Entity {
    isBone = true;
    isLockable = true;
    #boneId;
    #poseToBone = create$5();
    #boneMat = create$5();
    #worldPos = create$4();
    #worldQuat = create$2();
    #worldScale = fromValues$4(1, 1, 1);
    #parentSkeletonBone;
    #skeleton;
    #refPosition = create$4();
    #refQuaternion = create$2();
    dirty = true;
    lastComputed = 0;
    tempPosition = create$4();
    tempQuaternion = create$2();
    constructor(params /*TODO: improve type*/) {
        super(params);
        this.#boneId = params.boneId ?? -1;
        this.#skeleton = params.skeleton;
    }
    set position(position) {
        super.position = position;
        this.dirty = true;
    }
    get position() {
        return clone$4(this._position);
    }
    setWorldPosition(position) {
        super.setWorldPosition(position);
        this.dirty = true;
    }
    set refPosition(refPosition) {
        copy$4(this.#refPosition, refPosition);
    }
    get refPosition() {
        return clone$4(this.#refPosition);
    }
    getTotalRefPosition(position = create$4()) {
        let parent = this._parent;
        if (parent && parent.isBone) {
            parent.getTotalRefPosition(position);
            parent.getTotalRefQuaternion(tempQuat1);
            transformQuat$1(tempVec1, this.#refPosition, tempQuat1);
            add$5(position, position, tempVec1);
        }
        else {
            copy$4(position, this.#refPosition);
        }
        return position;
    }
    getTotalRefQuaternion(quaternion = create$2()) {
        let parent = this._parent;
        if (parent && parent.isBone) {
            parent.getTotalRefQuaternion(tempQuat1);
            multiply$3(quaternion, tempQuat1, this.#refQuaternion);
        }
        else {
            copy$2(quaternion, this.#refQuaternion);
        }
        return quaternion;
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        this.dirty = true;
    }
    get quaternion() {
        return clone$2(this._quaternion);
    }
    set refQuaternion(refQuaternion) {
        copy$2(this.#refQuaternion, refQuaternion);
    }
    get refQuaternion() {
        return clone$2(this.#refQuaternion);
    }
    set scale(scale) {
        copy$4(this._scale, scale);
        this.dirty = true;
    }
    get scale() {
        return clone$4(this._scale);
    }
    set parent(parent) {
        this._parent = parent;
        this.dirty = true;
    }
    get parent() {
        return this._parent;
    }
    set skeleton(skeleton) {
        this.#skeleton = skeleton;
        this.dirty = true;
    }
    get skeleton() {
        return this.#skeleton;
    }
    set parentSkeletonBone(parentSkeletonBone) {
        if (parentSkeletonBone == this) {
            // TODO: check ancestry as well ?
            return;
        }
        if (this.#parentSkeletonBone != parentSkeletonBone) {
            this.#parentSkeletonBone = parentSkeletonBone;
            this.dirty = true;
        }
    }
    get parentSkeletonBone() {
        return this.#parentSkeletonBone;
    }
    get boneMat() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#boneMat;
    }
    get worldPos() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldPos;
    }
    get worldQuat() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldQuat;
    }
    get worldScale() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldScale;
    }
    getWorldPosition(vec = create$4()) {
        return copy$4(vec, this.worldPos);
    }
    getWorldQuaternion(q = create$2()) {
        return copy$2(q, this.worldQuat);
    }
    getWorldScale(vec = create$4()) {
        return copy$4(vec, this.worldScale);
    }
    getWorldPosOffset(offset, out = create$4()) {
        transformQuat$1(out, offset, this.worldQuat);
        add$5(out, this.worldPos, out);
        return out;
    }
    set poseToBone(poseToBone) {
        copy$5(this.#poseToBone, poseToBone);
    }
    get poseToBone() {
        return clone$5(this.#poseToBone);
    }
    #compute() {
        let parent = this._parent;
        this.#parentSkeletonBone;
        if (!this.#parentSkeletonBone) {
            if (parent) {
                let parentWorldQuaternion = parent.getWorldQuaternion(tempWorldQuat);
                mul$4(this.#worldScale, parent.getWorldScale(tempWorldScale), this._scale);
                mul$4(tempPosition, this._position, tempWorldScale);
                transformQuat$1(this.#worldPos, tempPosition, parentWorldQuaternion);
                add$5(this.#worldPos, this.#worldPos, parent.getWorldPosition(tempWorldVec3));
                multiply$3(this.#worldQuat, parentWorldQuaternion, this._quaternion);
            }
            else {
                if (this.#skeleton) {
                    this.#skeleton.getWorldPosition(tempWorldVec3);
                    this.#skeleton.getWorldQuaternion(tempWorldQuat);
                    transformQuat$1(this.#worldPos, this._position, tempWorldQuat);
                    add$5(this.#worldPos, this.#worldPos, tempWorldVec3);
                    multiply$3(this.#worldQuat, tempWorldQuat, this._quaternion);
                    mul$4(this.#worldScale, this.#skeleton.getWorldScale(tempWorldScale), this._scale);
                }
                else {
                    copy$4(this.#worldPos, this._position);
                    copy$2(this.#worldQuat, this._quaternion);
                    copy$4(this.#worldScale, this._scale);
                }
            }
        }
        else {
            copy$2(this.#worldQuat, this.#parentSkeletonBone.worldQuat);
            copy$4(this.#worldPos, this.#parentSkeletonBone.worldPos);
            copy$4(this.#worldScale, this.#parentSkeletonBone.worldScale);
            /*vec3.transformQuat(this.#worldPos, this._position, this.#parentSkeletonBone.worldQuat);
            vec3.add(this.#worldPos, this.#worldPos, this.#parentSkeletonBone.worldPos);

            quat.multiply(this.#worldQuat, this.#parentSkeletonBone.worldQuat, this._quaternion);*/
        }
        fromRotationTranslationScale(tempWorldMat, this.#worldQuat, this.#worldPos, this.#worldScale);
        multiply$6(this.#boneMat, tempWorldMat, this.#poseToBone);
        if (this.isProcedural()) {
            if (this._parent) {
                copy$5(this.#boneMat, this._parent.#boneMat);
            }
            else {
                identity$2(this.#boneMat);
            }
        }
        this.dirty = false;
        this.lastComputed = new Graphics().currentTick;
    }
    set boneId(boneId) {
        this.#boneId = boneId;
    }
    get boneId() {
        return this.#boneId;
    }
    isProcedural() {
        return false;
        //return (this.flags & BONE_ALWAYS_PROCEDURAL) == BONE_ALWAYS_PROCEDURAL;
    }
    setLocked(locked) {
        this.lockPosition = locked;
        this.lockRotation = locked;
        this.lockScale = locked;
    }
    isLocked() {
        return this.lockPosition && this.lockRotation && this.lockScale;
    }
    reset() {
        zero$4(this._position);
        identity$1(this._quaternion);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), this.locked ? {
            Bone_1: null,
            unlock: { i18n: '#unlock', f: (entity) => entity.locked = false },
        } : null);
    }
    toJSON() {
        let json = super.toJSON();
        json.posetobone = clone$5(this.#poseToBone);
        json.refposition = clone$4(this.#refPosition);
        json.refquaternion = clone$2(this.#refQuaternion);
        json.boneid = this.boneId;
        return json;
    }
    static async constructFromJSON(json) {
        return new Bone({ name: json.name });
    }
    fromJSON(json) {
        super.fromJSON(json);
        copy$5(this.#poseToBone, json.posetobone ?? create$5());
        copy$4(this.#refPosition, json.refposition ?? create$4());
        copy$2(this.#refQuaternion, json.refquaternion ?? create$2());
        this.boneId = json.boneid;
    }
    static getEntityName() {
        return 'Bone';
    }
}
registerEntity(Bone);

const DEFAULT_SIZE$1 = fromValues$4(1, 1, 1);
class Decal extends Mesh {
    #size = create$4();
    //constructor(size = DEFAULT_SIZE, material = new MeshBasicMaterial({polygonOffset:true})) {
    constructor(params = {}) {
        super(new DecalGeometry(), params.material ?? new MeshBasicMaterial({ polygonOffset: true }));
        this.setSize(params.size ?? DEFAULT_SIZE$1);
    }
    set position(position) {
        super.position = position;
        this.refreshGeometry();
    }
    get position() {
        return super.position;
    }
    parentChanged(parent) {
        this.refreshGeometry();
    }
    setSize(size) {
        copy$4(this.#size, size);
        this.refreshGeometry();
    }
    get size() {
        return this.#size;
    }
    refreshGeometry() {
        if (this.parent) {
            this.geometry.applyTo(this.parent, this.worldMatrix, this.#size);
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            StaticDecal_1: null,
            size: { i18n: '#size', f: () => { let v = prompt('Size', this.size.join(' ')); if (v !== null) {
                    this.setSize(stringToVec3(v));
                } } },
            refresh: { i18n: '#refresh', f: () => this.refreshGeometry() },
        });
    }
    static async constructFromJSON(json) {
        return new Decal(json.name);
    }
    static getEntityName() {
        return 'Decal';
    }
}
registerEntity(Decal);
class DecalGeometry extends BufferGeometry {
    applyTo(mesh, projectorMatrix, size) {
        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];
        this.#generate(mesh, projectorMatrix, size, indices, vertices, normals, uvs);
        //console.log(uvs);
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    #generate(mesh, projectorMatrix, size, indices, vertices, normals, uvs) {
        let decalVertices = [];
        const projectorMatrixInverse = invert$3(create$5(), projectorMatrix);
        let vertex = create$4();
        let normal = create$4();
        const geometry = mesh.geometry;
        if (!geometry) {
            return;
        }
        const indexAttribute = geometry.attributes.get('index');
        const indexArray = indexAttribute._array;
        let posArray;
        let normalArray;
        if (!mesh.isSkeletalMesh) {
            posArray = geometry.attributes.get('aVertexPosition')._array;
            normalArray = geometry.attributes.get('aVertexNormal')._array;
        }
        else {
            mesh.prepareRayCasting();
            posArray = mesh.skinnedVertexPosition;
            normalArray = mesh.skinnedVertexNormal;
        }
        for (let i = 0, l = indexAttribute.count; i < l; ++i) {
            let index = indexArray[i];
            vertex[0] = posArray[index * 3];
            vertex[1] = posArray[index * 3 + 1];
            vertex[2] = posArray[index * 3 + 2];
            normal[0] = normalArray[index * 3];
            normal[1] = normalArray[index * 3 + 1];
            normal[2] = normalArray[index * 3 + 2];
            transformMat4$2(vertex, vertex, mesh.worldMatrix);
            transformMat4$2(vertex, vertex, projectorMatrixInverse);
            decalVertices.push([clone$4(vertex), clone$4(normal)]);
        }
        decalVertices = this.#clipGeometry(decalVertices, size, [1, 0, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [-1, 0, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 1, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, -1, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 0, 1]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 0, -1]);
        for (let i = 0; i < decalVertices.length; i++) {
            const decalVertex = decalVertices[i];
            // create texture coordinates (we are still in projector space)
            uvs.push(0.5 + (decalVertex[0][0] / size[0]), 0.5 + (decalVertex[0][1] / size[1]));
            // transform the vertex back to world space
            decalVertex[0];
            //vec3.transformMat4(v, v, projectorMatrix);
            vertices.push(...decalVertex[0]);
            normals.push(...decalVertex[1]);
            indices.push(i);
        }
    }
    #clipGeometry(inVertices, size, plane) {
        const outVertices = [];
        const s = 0.5 * Math.abs(dot$4(size, plane));
        // a single iteration clips one face,
        // which consists of three consecutive 'DecalVertex' objects
        for (let i = 0; i < inVertices.length; i += 3) {
            let total = 0;
            let nV1;
            let nV2;
            let nV3;
            let nV4;
            const d1 = dot$4(inVertices[i + 0][0], plane) - s;
            const d2 = dot$4(inVertices[i + 1][0], plane) - s;
            const d3 = dot$4(inVertices[i + 2][0], plane) - s;
            const v1Out = d1 > 0;
            const v2Out = d2 > 0;
            const v3Out = d3 > 0;
            // calculate, how many vertices of the face lie outside of the clipping plane
            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
            switch (total) {
                case 0: {
                    // the entire face lies inside of the plane, no clipping needed
                    outVertices.push(inVertices[i]);
                    outVertices.push(inVertices[i + 1]);
                    outVertices.push(inVertices[i + 2]);
                    break;
                }
                case 1: {
                    // one vertex lies outside of the plane, perform clipping
                    if (v1Out) {
                        nV1 = inVertices[i + 1];
                        nV2 = inVertices[i + 2];
                        nV3 = this.#clip(inVertices[i], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i], nV2, plane, s);
                    }
                    if (v2Out) {
                        nV1 = inVertices[i];
                        nV2 = inVertices[i + 2];
                        nV3 = this.#clip(inVertices[i + 1], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i + 1], nV2, plane, s);
                        outVertices.push(nV3);
                        outVertices.push([clone$4(nV2[0]), clone$4(nV2[1])]); //outVertices.push( nV2.clone() );
                        outVertices.push([clone$4(nV1[0]), clone$4(nV1[1])]); //outVertices.push( nV1.clone() );
                        outVertices.push([clone$4(nV2[0]), clone$4(nV2[1])]); //outVertices.push( nV2.clone() );
                        outVertices.push([clone$4(nV3[0]), clone$4(nV3[1])]); //outVertices.push( nV3.clone() );
                        outVertices.push(nV4);
                        break;
                    }
                    if (v3Out) {
                        nV1 = inVertices[i];
                        nV2 = inVertices[i + 1];
                        nV3 = this.#clip(inVertices[i + 2], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i + 2], nV2, plane, s);
                    }
                    outVertices.push([clone$4(nV1[0]), clone$4(nV1[1])]); //outVertices.push( nV1.clone() );
                    outVertices.push([clone$4(nV2[0]), clone$4(nV2[1])]); //outVertices.push( nV2.clone() );
                    outVertices.push(nV3);
                    outVertices.push(nV4);
                    outVertices.push([clone$4(nV3[0]), clone$4(nV3[1])]); //outVertices.push( nV3.clone() );
                    outVertices.push([clone$4(nV2[0]), clone$4(nV2[1])]); //outVertices.push( nV2.clone() );
                    break;
                }
                case 2: {
                    // two vertices lies outside of the plane, perform clipping
                    if (!v1Out) {
                        nV1 = [clone$4(inVertices[i][0]), clone$4(inVertices[i][1])]; //inVertices[ i ].clone();
                        nV2 = this.#clip(nV1, inVertices[i + 1], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i + 2], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    if (!v2Out) {
                        nV1 = [clone$4(inVertices[i + 1][0]), clone$4(inVertices[i + 1][1])]; //inVertices[ i + 1 ].clone();
                        nV2 = this.#clip(nV1, inVertices[i + 2], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    if (!v3Out) {
                        nV1 = [clone$4(inVertices[i + 2][0]), clone$4(inVertices[i + 2][1])]; //inVertices[ i + 2 ].clone();
                        nV2 = this.#clip(nV1, inVertices[i], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i + 1], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    break;
                }
            }
        }
        return outVertices;
    }
    #clip(v0, v1, p, s) {
        const v0Pos = v0[0];
        const v1Pos = v1[0];
        const v0Norm = v0[1];
        const v1Norm = v1[1];
        const d0 = dot$4(v0Pos, p) - s;
        const d1 = dot$4(v1Pos, p) - s;
        const s0 = d0 / (d0 - d1);
        // need to clip more values (texture coordinates)? do it this way:
        // intersectpoint.value = a.value + s * ( b.value - a.value );
        return [
            [
                v0Pos[0] + s0 * (v1Pos[0] - v0Pos[0]),
                v0Pos[1] + s0 * (v1Pos[1] - v0Pos[1]),
                v0Pos[2] + s0 * (v1Pos[2] - v0Pos[2])
            ],
            [
                v0Norm[0] + s0 * (v1Norm[0] - v0Norm[0]),
                v0Norm[1] + s0 * (v1Norm[1] - v0Norm[1]),
                v0Norm[2] + s0 * (v1Norm[2] - v0Norm[2])
            ]
        ];
    }
}

// It is just a basic entity
class Group extends Entity {
    static async constructFromJSON(json) {
        return new Group({ name: json.name });
    }
    static getEntityName() {
        return 'Group';
    }
}
registerEntity(Group);

const IDENTITY_MAT4$4 = create$5();
let v1$1 = create$4();
let v2 = create$4();
let v3 = create$4();
let n1 = create$4();
let n2 = create$4();
let n3 = create$4();
let uv1 = create();
let uv2 = create();
let uv3 = create();
let intersectionPoint = create$4();
let intersectionNormal = create$4();
let ray = new Ray();
let uv = create();
class SkeletalMesh extends Mesh {
    isSkeletalMesh = true;
    #bonesPerVertex = 3;
    skeleton;
    skinnedVertexPosition;
    skinnedVertexNormal;
    constructor(geometry, material, skeleton) {
        super(geometry, material);
        this.skeleton = skeleton;
        this.setUniform('uBoneMatrix', this.skeleton.getTexture());
        this.setDefine('HARDWARE_SKINNING'); //TODOv3 proper defines
        this.setDefine('SKELETAL_MESH');
    }
    set bonesPerVertex(bonesPerVertex) {
        this.#bonesPerVertex = bonesPerVertex;
    }
    get bonesPerVertex() {
        return this.#bonesPerVertex;
    }
    exportObj() {
        let ret = {};
        let skeletonBones = this.skeleton._bones;
        let attributes = { f: 'index', v: 'aVertexPosition', vn: 'aVertexNormal', vt: 'aTextureCoord' };
        let geometry = this.geometry;
        let vertexCount = geometry.getAttribute('aVertexPosition').count;
        let skinnedVertexPosition = new Float32Array(vertexCount * 3);
        let skinnedVertexNormal = new Float32Array(vertexCount * 3);
        let vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        let vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        let vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        let vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        let boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        let tempVertex = create$4();
        let tempVertexNormal = create$4();
        let accumulateMat = create$5();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                let vertexArrayIndex = vertexIndex * 3;
                let boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                tempVertexNormal[0] = vertexNormal[vertexArrayIndex + 0];
                tempVertexNormal[1] = vertexNormal[vertexArrayIndex + 1];
                tempVertexNormal[2] = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    let boneArrayIndex2 = boneArrayIndex + boneIndex;
                    let bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    let boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    let boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                transformMat4$2(tempVertex, tempVertex, accumulateMat);
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                transformMat4$2(tempVertexNormal, tempVertexNormal, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        for (let objAttribute in attributes) {
            let geometryAttribute = attributes[objAttribute];
            if (geometry.getAttribute(geometryAttribute)) {
                if (geometryAttribute == 'aVertexPosition') {
                    ret[objAttribute] = skinnedVertexPosition;
                }
                else if (geometryAttribute == 'aVertexNormal') {
                    ret[objAttribute] = skinnedVertexNormal;
                }
                else {
                    let webglAttrib = geometry.getAttribute(geometryAttribute);
                    if (webglAttrib) {
                        ret[objAttribute] = webglAttrib._array;
                    }
                }
            }
            else {
                ret[objAttribute] = [];
            }
        }
        return ret;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        let ret = {};
        let skeletonBones = this.skeleton._bones;
        //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};
        let geometry = this.geometry;
        let vertexCount = geometry.getAttribute('aVertexPosition').count;
        let vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        let vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        let vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        let boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        create$4();
        let accumulateMat = create$5();
        function RandomInt(max) {
            return Math.floor(Math.random() * max);
        }
        let vertexIndex = RandomInt(vertexCount);
        vec[0] = 0;
        vec[1] = 0;
        vec[2] = 0;
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            //for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex)
            {
                let vertexArrayIndex = vertexIndex * 3;
                let boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                vec[0] = vertexPosition[vertexArrayIndex + 0];
                vec[1] = vertexPosition[vertexArrayIndex + 1];
                vec[2] = vertexPosition[vertexArrayIndex + 2];
                copy$4(initialVec, vec);
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    let boneArrayIndex2 = boneArrayIndex + boneIndex;
                    let bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    let boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    let boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (bones) {
                        bones.push([bone, boneWeight]);
                    }
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                transformMat4$2(vec, vec, accumulateMat);
            }
        }
        return ret;
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        let skeletonBones = this.skeleton._bones;
        let geometry = this.geometry;
        let vertexCount = geometry.getAttribute('aVertexPosition').count;
        let skinnedVertexPosition = new Float32Array(vertexCount * 3);
        let vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        geometry.getAttribute('aVertexNormal')._array;
        let vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        let vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        let boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        let tempVertex = create$4();
        let accumulateMat = create$5();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                let vertexArrayIndex = vertexIndex * 3;
                let boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    let boneArrayIndex2 = boneArrayIndex + boneIndex;
                    let bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    let boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    let boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                transformMat4$2(tempVertex, tempVertex, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
            }
        }
        boundingBox.setPoints(skinnedVertexPosition);
        return boundingBox;
    }
    toString() {
        return 'SkeletalMesh ' + super.toString();
    }
    prepareRayCasting() {
        let skeletonBones = this.skeleton._bones;
        let geometry = this.geometry;
        let vertexCount = geometry.getAttribute('aVertexPosition').count;
        let skinnedVertexPosition = new Float32Array(vertexCount * 3);
        let skinnedVertexNormal = new Float32Array(vertexCount * 3);
        let vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        let vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        let vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        let vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        let boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        let tempVertex = create$4();
        let tempVertexNormal = create$4();
        let accumulateMat = create$5();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                let vertexArrayIndex = vertexIndex * 3;
                let boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                let tempVertexNormalX = vertexNormal[vertexArrayIndex + 0];
                let tempVertexNormalY = vertexNormal[vertexArrayIndex + 1];
                let tempVertexNormalZ = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    let boneArrayIndex2 = boneArrayIndex + boneIndex;
                    let bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    let boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    let boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                transformMat4$2(tempVertex, tempVertex, accumulateMat);
                tempVertexNormal[0] = accumulateMat[0] * tempVertexNormalX + accumulateMat[4] * tempVertexNormalY + accumulateMat[8] * tempVertexNormalZ;
                tempVertexNormal[1] = accumulateMat[1] * tempVertexNormalX + accumulateMat[5] * tempVertexNormalY + accumulateMat[9] * tempVertexNormalZ;
                tempVertexNormal[2] = accumulateMat[2] * tempVertexNormalX + accumulateMat[6] * tempVertexNormalY + accumulateMat[10] * tempVertexNormalZ;
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        this.skinnedVertexPosition = skinnedVertexPosition;
        this.skinnedVertexNormal = skinnedVertexNormal;
    }
    raycast(raycaster, intersections) {
        //TODO: case when normals are not provided
        let skeletonBones = this.skeleton._bones;
        let geometry = this.geometry;
        let indices = geometry.getAttribute('index')._array;
        //let normals = geometry.getAttribute('aVertexNormal')._array;
        let vertexCount = geometry.getAttribute('aVertexPosition').count;
        let skinnedVertexPosition = new Float32Array(vertexCount * 3);
        let skinnedVertexNormal = new Float32Array(vertexCount * 3);
        let textureCoords = geometry.getAttribute('aTextureCoord')._array;
        let worldMatrix = this.worldMatrix;
        ray.copyTransform(raycaster.ray, worldMatrix);
        let vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        let vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        let vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        let vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        let boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        let tempVertex = create$4();
        let tempVertexNormal = create$4();
        let accumulateMat = create$5();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                let vertexArrayIndex = vertexIndex * 3;
                let boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                tempVertexNormal[0] = vertexNormal[vertexArrayIndex + 0];
                tempVertexNormal[1] = vertexNormal[vertexArrayIndex + 1];
                tempVertexNormal[2] = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    let boneArrayIndex2 = boneArrayIndex + boneIndex;
                    let bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    let boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    let boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                transformMat4$2(tempVertex, tempVertex, accumulateMat);
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                transformMat4$2(tempVertexNormal, tempVertexNormal, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        for (let i = 0, l = indices.length; i < l; i += 3) {
            let i1 = 3 * indices[i];
            let i2 = 3 * indices[i + 1];
            let i3 = 3 * indices[i + 2];
            set$5(v1$1, skinnedVertexPosition[i1], skinnedVertexPosition[i1 + 1], skinnedVertexPosition[i1 + 2]);
            set$5(v2, skinnedVertexPosition[i2], skinnedVertexPosition[i2 + 1], skinnedVertexPosition[i2 + 2]);
            set$5(v3, skinnedVertexPosition[i3], skinnedVertexPosition[i3 + 1], skinnedVertexPosition[i3 + 2]);
            if (ray.intersectTriangle(v1$1, v2, v3, intersectionPoint)) {
                set$5(n1, skinnedVertexNormal[i1], skinnedVertexNormal[i1 + 1], skinnedVertexNormal[i1 + 2]);
                set$5(n2, skinnedVertexNormal[i2], skinnedVertexNormal[i2 + 1], skinnedVertexNormal[i2 + 2]);
                set$5(n3, skinnedVertexNormal[i3], skinnedVertexNormal[i3 + 1], skinnedVertexNormal[i3 + 2]);
                i1 = 2 * indices[i];
                i2 = 2 * indices[i + 1];
                i3 = 2 * indices[i + 2];
                set$1(uv1, textureCoords[i1], textureCoords[i1 + 1]);
                set$1(uv2, textureCoords[i2], textureCoords[i2 + 1]);
                set$1(uv3, textureCoords[i3], textureCoords[i3 + 1]);
                getUV(uv, intersectionPoint, v1$1, v2, v3, uv1, uv2, uv3);
                getNormal(intersectionNormal, intersectionPoint, v1$1, v2, v3, n1, n2, n3);
                let x = intersectionNormal[0];
                let y = intersectionNormal[1];
                let z = intersectionNormal[2];
                //Tranform the normal with the world matrix
                intersectionNormal[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                intersectionNormal[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                intersectionNormal[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                transformMat4$2(intersectionPoint, intersectionPoint, worldMatrix);
                intersections.push(ray.createIntersection(intersectionPoint, intersectionNormal, uv, this, 0));
            }
        }
    }
    static getEntityName() {
        return 'Skeletal mesh';
    }
}

create$5();
class Skeleton extends Entity {
    isSkeleton = true;
    #bonesByName = new Map();
    #rootBone = new Bone({ name: 'root', boneId: 0, skeleton: this });
    _bones = []; //TODOv3: rename set private
    _dirty = true;
    #imgData;
    #texture;
    lastComputed = 0;
    constructor(params /*TODO: improve type*/) {
        super(params);
        //this.bones = Object.create(null);//TODOv3: rename
        this.#createBoneMatrixArray();
        this.#createBoneMatrixTexture();
        this.dirty();
    }
    dirty() {
        this._dirty = true;
        for (let bone of this._bones) {
            bone.dirty = true;
        }
        /*if (this._bones[0]) {
            this._bones[0].dirty = true;
        }*/
    }
    getTexture() {
        return this.#texture;
    }
    #createBoneMatrixArray() {
        this.#imgData = new Float32Array(MAX_HARDWARE_BONES * 4 * 4);
        identity$2(this.#imgData);
        for (let i = 1; i < MAX_HARDWARE_BONES; ++i) {
            this.#imgData.copyWithin(i * 16, 0, 16);
        }
    }
    #createBoneMatrixTexture() {
        this.#texture = TextureManager.createTexture();
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture); //TODOv3: pass param to texture and remove this
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #updateBoneMatrixTexture() {
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, 4, MAX_HARDWARE_BONES, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, MAX_HARDWARE_BONES, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setBonesMatrix() {
        let index = 0;
        let bones = this._bones;
        let imgData = this.#imgData;
        let pose;
        if (bones.length == 0) {
            pose = this.#rootBone.boneMat;
            for (let k = 0; k < 16; ++k) {
                imgData[index++] = pose[k];
            }
        }
        for (let bone of bones) {
            pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                imgData[index++] = pose[k];
            }
        }
        this.#updateBoneMatrixTexture();
    }
    set position(position) {
        super.position = position;
    }
    get position() {
        if (this._parent) {
            return clone$4(this._parent._position);
        }
        else {
            return clone$4(this._position);
        }
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
    }
    get quaternion() {
        if (this._parent) {
            return clone$2(this._parent._quaternion);
        }
        else {
            return clone$2(this._quaternion);
        }
    }
    addBone(boneId, boneName) {
        let boneNameLowerCase = boneName.toLowerCase();
        if (!this.#bonesByName.has(boneNameLowerCase)) {
            let bone = new Bone({ name: boneName, boneId: boneId });
            bone.skeleton = this;
            //this.addChild(bone);
            this._bones[boneId] = bone;
            this.#bonesByName.set(boneNameLowerCase, bone);
            return bone;
        }
        else {
            let bone = this.#bonesByName.get(boneNameLowerCase);
            this._bones[boneId] = bone;
            return bone;
        }
    }
    async setParentSkeleton(skeleton) {
        await this.loadedPromise;
        if (skeleton) {
            await skeleton.loadedPromise;
        }
        let bones = this.#bonesByName;
        for (let [boneName, bone] of bones) {
            bone.parentSkeletonBone = skeleton?.getBoneByName(boneName) ?? null;
        }
    }
    getBoneByName(boneName) {
        return this.#bonesByName.get(boneName.toLowerCase());
    }
    getBoneById(boneId) {
        return this._bones[boneId];
    }
    toString() {
        return 'Skeleton ' + super.toString();
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
    get bones() {
        return this._bones;
    }
    reset() {
        for (const bone of this._bones) {
            bone.reset();
        }
    }
    toJSON() {
        let json = super.toJSON();
        let jBones = [];
        let bones = this._bones;
        for (let i = 0; i < bones.length; ++i) {
            jBones.push(bones[i].id);
        }
        json.bones = jBones;
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let entity = new Skeleton({ name: json.name });
        let loadedPromiseResolve;
        entity.loadedPromise = new Promise((resolve) => loadedPromiseResolve = resolve);
        loadedPromise.then(() => {
            let jBones = json.bones;
            if (jBones) {
                for (let i = 0; i < jBones.length; ++i) {
                    let boneEntity = entities.get(jBones[i]);
                    if (boneEntity) {
                        entity._bones[i] = boneEntity;
                        entity.#bonesByName.set(boneEntity.name.toLowerCase(), boneEntity);
                    }
                }
            }
            loadedPromiseResolve(true);
        });
        return entity;
    }
    dispose() {
        super.dispose();
        this.#texture.dispose();
    }
    static getEntityName() {
        return 'Skeleton';
    }
}
registerEntity(Skeleton);

class ExtrudeGeometry extends BufferGeometry {
    parameters;
    createGeometry(shapes, options) {
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        const scope = this;
        const indicesArray = [];
        const verticesArray = [];
        const uvArray = [];
        for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            addShape(shape);
        }
        // build geometry
        this.setIndex(new Uint32BufferAttribute(indicesArray, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvArray, 2));
        this.count = indicesArray.length;
        this.computeVertexNormals();
        // functions
        function addShape(shape) {
            const placeholder = [];
            verticesArray.length / 3;
            // options
            const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            const steps = options.steps !== undefined ? options.steps : 1;
            let depth = options.depth !== undefined ? options.depth : 100;
            let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
            // deprecated options
            if (options.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth = options.amount;
            }
            //
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = create$4();
                normal = create$4();
                position2 = create$4();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            /* Vertices */
            const contour = vertices; // vertices has all points but contour has only points of circumference
            for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec)
                    console.error('THREE.ExtrudeGeometry: vec does not exist');
                //return vec.clone().multiplyScalar( size ).add( pt );;
                return scaleAndAdd(create(), pt, vec, size);
            }
            const vlen = vertices.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt[0] - inPrev[0], v_prev_y = inPt[1] - inPrev[1];
                const v_next_x = inNext[0] - inPt[0], v_next_y = inNext[1] - inPt[1];
                const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                // check for collinear edges
                const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = (inPrev[0] - v_prev_y / v_prev_len);
                    const ptPrevShift_y = (inPrev[1] + v_prev_x / v_prev_len);
                    const ptNextShift_x = (inNext[0] - v_next_y / v_next_len);
                    const ptNextShift_y = (inNext[1] + v_next_x / v_next_len);
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                        (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                        (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt[0]);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt[1]);
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {
                        return fromValues(v_trans_x, v_trans_y);
                    }
                    else {
                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                    }
                }
                else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    }
                    else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        }
                        else {
                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    }
                    else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return fromValues(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = [];
                for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for (let b = 0; b < bevelSegments; b++) {
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t = b / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (let i = 0, il = contour.length; i < il; i++) {
                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert[0], vert[1], -z);
                }
                // expand holes
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        v(vert[0], vert[1], -z);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for (let i = 0; i < vlen; i++) {
                const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert[0], vert[1], 0);
                }
                else {
                    // v( vert[0], vert[1] + extrudePts[ 0 ][1], extrudePts[ 0 ][2] );
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert[0]);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert[1]);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2[0], position2[1], position2[2]);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for (let s = 1; s <= steps; s++) {
                for (let i = 0; i < vlen; i++) {
                    const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert[0], vert[1], depth / steps * s);
                    }
                    else {
                        // v( vert[0], vert[1] + extrudePts[ s - 1 ][1], extrudePts[ s - 1 ][2] );
                        normal.copy(splineTube.normals[s]).multiplyScalar(vert[0]);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert[1]);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2[0], position2[1], position2[2]);
                    }
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for (let b = bevelSegments - 1; b >= 0; b--) {
                const t = b / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (let i = 0, il = contour.length; i < il; i++) {
                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert[0], vert[1], depth + z);
                }
                // expand holes
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        if (!extrudeByPath) {
                            v(vert[0], vert[1], depth + z);
                        }
                        else {
                            v(vert[0], vert[1] + extrudePts[steps - 1][1], extrudePts[steps - 1][2] + z);
                        }
                    }
                }
            }
            /* Faces */
            // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset = vlen * layer;
                    // Bottom faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                }
                else {
                    // Bottom faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                //scope.addGroup( start, verticesArray.length / 3 - start, 0 );
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                //scope.addGroup( start, verticesArray.length / 3 - start, 1 );
            }
            function sidewalls(contour, layeroffset) {
                let i = contour.length;
                while (--i >= 0) {
                    const j = i;
                    let k = i - 1;
                    if (k < 0)
                        k = contour.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
                        const slen1 = vlen * s;
                        const slen2 = vlen * (s + 1);
                        const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addIndex();
                addIndex();
                addIndex();
                addVertex(a);
                addVertex(b);
                addVertex(c);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addIndex(index) {
                indicesArray.push(indicesArray.length);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2[0]);
                uvArray.push(vector2[1]);
            }
        }
    }
}
const WorldUVGenerator = {
    generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            fromValues(a_x, a_y),
            fromValues(b_x, b_y),
            fromValues(c_x, c_y)
        ];
    },
    generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [
                fromValues(a_x, 1 - a_z),
                fromValues(b_x, 1 - b_z),
                fromValues(c_x, 1 - c_z),
                fromValues(d_x, 1 - d_z)
            ];
        }
        else {
            return [
                fromValues(a_y, 1 - a_z),
                fromValues(b_y, 1 - b_z),
                fromValues(c_y, 1 - c_z),
                fromValues(d_y, 1 - d_z)
            ];
        }
    }
};

class Text3D extends Mesh {
    isText3D = true;
    static defaultFont = 'arial';
    static defaultStyle = 'normal';
    #text;
    #size;
    #depth;
    #font;
    #style;
    constructor(params = {}) {
        super(new ExtrudeGeometry(), params.material ?? new MeshBasicMaterial());
        this.#text = params.text;
        this.#size = params.size ?? 100;
        this.#depth = params.depth ?? 10;
        this.#font = params.font ?? Text3D.defaultFont;
        this.#style = params.style ?? Text3D.defaultStyle;
        this.#updateGeometry();
        this.rotateX(90 * DEG_TO_RAD);
        this.setParameters(params);
    }
    set text(text) {
        this.#text = text;
        this.#updateGeometry();
    }
    set size(size) {
        this.#size = size;
        this.#updateGeometry();
    }
    set depth(depth) {
        this.#depth = depth;
        this.#updateGeometry();
    }
    set font(font) {
        this.#font = font;
        this.#updateGeometry();
    }
    set style(style) {
        this.#style = style;
        this.#updateGeometry();
    }
    async #updateGeometry() {
        let font = await FontManager.getFont(this.#font);
        if (font) {
            let shapes = font.generateShapes(this.#text, this.#size);
            this.geometry.createGeometry(shapes, { depth: this.#depth, bevelThickness: 2, bevelSize: 0.5 });
        }
    }
    toJSON() {
        let json = super.toJSON();
        json.text = this.#text;
        json.size = this.#size;
        json.depth = this.#depth;
        json.font = this.#font;
        json.style = this.#style;
        return json;
    }
    static async constructFromJSON(json) {
        return new Text3D(json.name);
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.#text = json.text;
        this.#size = json.size;
        this.#depth = json.depth;
        this.#font = json.font ?? Text3D.defaultFont;
        this.#style = json.style ?? Text3D.defaultStyle;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Text3D_1: null,
            text: { i18n: '#text', f: () => { let text = prompt('Text', this.#text); this.text = text; } },
            font: {
                i18n: '#font', f: async () => {
                    let fontList = await FontManager.getFontList();
                    let fontList2 = new Map();
                    for (let font of fontList) {
                        if (font[1] == 'normal') {
                            fontList2.set(font[0], font);
                        }
                        else {
                            fontList2.set(font.join(' '), font);
                        }
                    }
                    let font = await new Interaction().getString(0, 0, fontList2);
                    if (font) {
                        this.#font = font[0];
                        this.#style = font[1];
                        this.#updateGeometry();
                    }
                }
            },
            font_size: { i18n: '#font_size', f: () => { let size = prompt('Size', String(this.#size)); this.size = Number(size); } },
            font_depth: { i18n: '#font_depth', f: () => { let depth = prompt('Depth', String(this.#depth)); this.depth = Number(depth); } }
        });
    }
    static getEntityName() {
        return 'Text3D';
    }
}
registerEntity(Text3D);

class Wireframe extends Entity {
    #material = new LineMaterial({ polygonOffset: true, lineWidth: 3 });
    #color = fromValues$3(0, 0, 0, 1);
    enumerable = false;
    #meshes = new Set();
    constructor(params) {
        super(params);
        //const material = new LineMaterial({ polygonOffset: true, lineWidth: 3 });
        //this.#material = material;
        this.#material.setColorMode(MaterialColorMode.PerMesh);
        this.#material.color = fromValues$3(0.0, 0.0, 0.0, 1.0);
        this.#material.addUser(this);
        //this.setParameters(params);
    }
    setColor(color) {
        copy$3(this.#color, color);
        this.#material.setMeshColor(color);
    }
    parentChanged(parent) {
        if (parent) {
            this.#updateGeometry(parent);
        }
    }
    #updateGeometry(parent) {
        this.#disposeMeshes();
        const meshes = parent.getChildList('Mesh');
        for (const mesh of meshes) {
            if (mesh == this || !mesh.isVisible()) {
                continue;
            }
            let segments = [];
            const line = new LineSegmentsGeometry();
            line.addUser(this);
            const me = new Mesh(line, this.#material);
            this.#meshes.add(me);
            this.addChild(me);
            const m = mesh.exportObj();
            const vertexIndices = m.f;
            const vertexPos = m.v;
            for (let i = 0, l = vertexIndices.length; i < l; i += 3) {
                let vertexIndex1 = vertexIndices[i + 0] * 3;
                let vertexIndex2 = vertexIndices[i + 1] * 3;
                let vertexIndex3 = vertexIndices[i + 2] * 3;
                segments.push(vertexPos[vertexIndex1], vertexPos[vertexIndex1 + 1], vertexPos[vertexIndex1 + 2]);
                segments.push(vertexPos[vertexIndex2], vertexPos[vertexIndex2 + 1], vertexPos[vertexIndex2 + 2]);
                segments.push(vertexPos[vertexIndex2], vertexPos[vertexIndex2 + 1], vertexPos[vertexIndex2 + 2]);
                segments.push(vertexPos[vertexIndex3], vertexPos[vertexIndex3 + 1], vertexPos[vertexIndex3 + 2]);
                segments.push(vertexPos[vertexIndex3], vertexPos[vertexIndex3 + 1], vertexPos[vertexIndex3 + 2]);
                segments.push(vertexPos[vertexIndex1], vertexPos[vertexIndex1 + 1], vertexPos[vertexIndex1 + 2]);
            }
            line.setSegments(segments);
        }
    }
    #disposeMeshes() {
        for (const mesh of this.#meshes) {
            mesh.dispose();
        }
        this.#meshes.clear();
    }
    dispose() {
        super.dispose();
        this.#material.removeUser(this);
        this.#disposeMeshes();
    }
    is(s) {
        return s == 'Wireframe';
    }
    static getEntityName() {
        return 'Wireframe';
    }
}

class World extends Entity {
    parentChanged(parent) {
        const iterator = this.getParentIterator();
        for (let p of iterator) {
            if (p.is('Scene')) {
                p.setWorld(this);
                iterator.return(null);
            }
        }
    }
    static getEntityName() {
        return 'World';
    }
    is(s) {
        if (s == 'World') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(World);

const DEFAULT_SEGMENT_COLOR = fromValues$3(1.0, 1.0, 1.0, 1.0);
const tempVec3$l = create$4();
const tempQuat$8 = create$2();
const tempQuat2 = create$2();
const UNIT_VEC3_X$1 = fromValues$4(1, 0, 0);
const UNIT_VEC3_MINUS_Y = fromValues$4(0, -1, 0);
class BeamSegment {
    pos = create$4();
    normal = create$4();
    color = create$3();
    texCoordY;
    width;
    constructor(pos, color = DEFAULT_SEGMENT_COLOR, texCoordY = 0.0, width = 1.0) {
        copy$4(this.pos, pos);
        copy$4(this.normal, UNIT_VEC3_MINUS_Y);
        copy$3(this.color, color);
        this.texCoordY = texCoordY;
        this.width = width;
    }
    distanceTo(other) {
        return distance$3(this.pos, other.pos);
    }
}
class BeamBufferGeometry extends BufferGeometry {
    constructor(segments) {
        super();
        if (segments) {
            this.segments = segments;
        }
    }
    set segments(segments) {
        let previousSegment = null;
        let indiceBase = 0;
        let indices = [];
        let vertices = [];
        let uvs = [];
        let colors = [];
        for (let segment of segments) {
            if (previousSegment) {
                indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
                sub$2(tempVec3$l, segment.pos, previousSegment.pos);
                normalize$5(tempVec3$l, tempVec3$l);
                rotationTo(tempQuat$8, UNIT_VEC3_X$1, tempVec3$l);
                rotationTo(tempQuat2, UNIT_VEC3_MINUS_Y, previousSegment.normal);
                set$5(tempVec3$l, 0, 0, -previousSegment.width / 2.0);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat$8);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat2);
                add$5(tempVec3$l, tempVec3$l, previousSegment.pos);
                vertices.push(...tempVec3$l);
                set$5(tempVec3$l, 0, 0, previousSegment.width / 2.0);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat$8);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat2);
                add$5(tempVec3$l, tempVec3$l, previousSegment.pos);
                vertices.push(...tempVec3$l);
                rotationTo(tempQuat2, UNIT_VEC3_MINUS_Y, segment.normal);
                set$5(tempVec3$l, 0, 0, -segment.width / 2.0);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat$8);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat2);
                add$5(tempVec3$l, tempVec3$l, segment.pos);
                vertices.push(...tempVec3$l);
                set$5(tempVec3$l, 0, 0, segment.width / 2.0);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat$8);
                transformQuat$1(tempVec3$l, tempVec3$l, tempQuat2);
                add$5(tempVec3$l, tempVec3$l, segment.pos);
                vertices.push(...tempVec3$l);
                uvs.push(0, previousSegment.texCoordY, 1, previousSegment.texCoordY, 0, segment.texCoordY, 1, segment.texCoordY);
                colors.push(...previousSegment.color, ...previousSegment.color, ...segment.color, ...segment.color);
                indiceBase += 4;
            }
            previousSegment = segment;
        }
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.setAttribute('aVertexColor', new Float32BufferAttribute(colors, 4));
        //this.setAttribute('aVertexWidth', new Float32BufferAttribute(this.widths, 1));
        this.count = indices.length;
    }
}

class Metaball extends Entity {
    currentWorldPosition = create$4();
    radius;
    radius2;
    constructor(radius = 1) {
        super();
        this.setRadius(radius);
    }
    setRadius(radius) {
        this.radius = radius;
        this.radius2 = radius * radius;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Metaball_1: null,
            radius: { i18n: '#radius', f: () => { let radius = prompt('Radius', String(this.radius)); if (radius) {
                    this.setRadius(Number(radius));
                } } }
        });
    }
}

let a$8 = create$4();
let b$2 = create$4();
const THRESHOLD = 0.99;
class MetaballsBufferGeometry extends BufferGeometry {
    constructor(balls) {
        super();
        this.updateGeometry(balls);
    }
    updateGeometry(balls = [], cubeWidth = 1) {
        // build geometry
        let triangles = this.TestMarchingCubes(balls, cubeWidth);
        var indices = [];
        var vertices = [];
        var normals = [];
        let vertexIndex;
        let normal = create$4();
        for (let triangleIndex = 0; triangleIndex < triangles.length; ++triangleIndex) {
            vertexIndex = triangleIndex * 3;
            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            vertices.push(...triangles[triangleIndex][0]);
            vertices.push(...triangles[triangleIndex][1]);
            vertices.push(...triangles[triangleIndex][2]);
            sub$2(a$8, triangles[triangleIndex][1], triangles[triangleIndex][0]);
            sub$2(b$2, triangles[triangleIndex][2], triangles[triangleIndex][0]);
            cross$2(normal, a$8, b$2);
            normalize$5(normal, normal);
            normals.push(...normal);
            normals.push(...normal);
            normals.push(...normal);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        //this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    static getBoundingBox(balls) {
        let min = fromValues$4(+Infinity, +Infinity, +Infinity);
        let max = fromValues$4(-Infinity, -Infinity, -Infinity);
        for (let ball of balls) {
            set$5(b$2, ball.radius, ball.radius, ball.radius);
            min$3(min, min, sub$2(a$8, ball.currentWorldPosition, b$2));
            max$3(max, max, add$5(a$8, ball.currentWorldPosition, b$2));
        }
        return [min, max];
    }
    static computeValue(balls, position) {
        let value = 0;
        for (let ball of balls) {
            let a = 1 / squaredDistance$2(ball.currentWorldPosition, position);
            value += ball.radius2 * a;
        }
        if (value < THRESHOLD) {
            for (let ball of balls) {
                for (let ball2 of balls) {
                    let a = 1 / (squaredDistance$2(ball.currentWorldPosition, position) + squaredDistance$2(ball2.currentWorldPosition, position));
                    value += 20 * a;
                }
            }
        }
        return value;
    }
    TestMarchingCubes(balls, cubeWidth) {
        let [min, max] = MetaballsBufferGeometry.getBoundingBox(balls);
        for (let ball of balls) {
            ball.getWorldPosition(ball.currentWorldPosition);
        }
        floor$3(min, min);
        ceil$3(max, max);
        let grid = new GRIDCELL();
        let isolevel = THRESHOLD; //1 / (radius * radius - 0.01);
        let triangles = [];
        fromValues$4(3, 3, 3);
        fromValues$4(7, 7, 7);
        for (let i = min[0] - 1; i <= max[0]; i += cubeWidth) {
            for (let j = min[1] - 1; j <= max[1]; j += cubeWidth) {
                for (let k = min[2] - 1; k <= max[2]; k += cubeWidth) {
                    let tris = [];
                    grid.p[0][0] = i;
                    grid.p[0][1] = j;
                    grid.p[0][2] = k;
                    grid.val[0] = MetaballsBufferGeometry.computeValue(balls, grid.p[0]); //1 / vec3.squaredDistance(center, grid.p[0]) + 1 / vec3.squaredDistance(center2, grid.p[0]) * doSphere2;
                    grid.p[1][0] = i + cubeWidth;
                    grid.p[1][1] = j;
                    grid.p[1][2] = k;
                    grid.val[1] = MetaballsBufferGeometry.computeValue(balls, grid.p[1]); //1 / vec3.squaredDistance(center, grid.p[1]) + 1 / vec3.squaredDistance(center2, grid.p[1]) * doSphere2;
                    grid.p[2][0] = i + cubeWidth;
                    grid.p[2][1] = j + cubeWidth;
                    grid.p[2][2] = k;
                    grid.val[2] = MetaballsBufferGeometry.computeValue(balls, grid.p[2]); //1 / vec3.squaredDistance(center, grid.p[2]) + 1 / vec3.squaredDistance(center2, grid.p[2]) * doSphere2;
                    grid.p[3][0] = i;
                    grid.p[3][1] = j + cubeWidth;
                    grid.p[3][2] = k;
                    grid.val[3] = MetaballsBufferGeometry.computeValue(balls, grid.p[3]); //1 / vec3.squaredDistance(center, grid.p[3]) + 1 / vec3.squaredDistance(center2, grid.p[3]) * doSphere2;
                    grid.p[4][0] = i;
                    grid.p[4][1] = j;
                    grid.p[4][2] = k + cubeWidth;
                    grid.val[4] = MetaballsBufferGeometry.computeValue(balls, grid.p[4]); //1 / vec3.squaredDistance(center, grid.p[4]) + 1 / vec3.squaredDistance(center2, grid.p[4]) * doSphere2;
                    grid.p[5][0] = i + cubeWidth;
                    grid.p[5][1] = j;
                    grid.p[5][2] = k + cubeWidth;
                    grid.val[5] = MetaballsBufferGeometry.computeValue(balls, grid.p[5]); //1 / vec3.squaredDistance(center, grid.p[5]) + 1 / vec3.squaredDistance(center2, grid.p[5]) * doSphere2;
                    grid.p[6][0] = i + cubeWidth;
                    grid.p[6][1] = j + cubeWidth;
                    grid.p[6][2] = k + cubeWidth;
                    grid.val[6] = MetaballsBufferGeometry.computeValue(balls, grid.p[6]); //1 / vec3.squaredDistance(center, grid.p[6]) + 1 / vec3.squaredDistance(center2, grid.p[6]) * doSphere2;
                    grid.p[7][0] = i;
                    grid.p[7][1] = j + cubeWidth;
                    grid.p[7][2] = k + cubeWidth;
                    grid.val[7] = MetaballsBufferGeometry.computeValue(balls, grid.p[7]); //1 / vec3.squaredDistance(center, grid.p[7]) + 1 / vec3.squaredDistance(center2, grid.p[7]) * doSphere2;
                    Polygonise(grid, isolevel, tris);
                    triangles.push(...tris);
                }
            }
        }
        let tris = [];
        for (let i = 0; i < triangles.length; ++i) {
            let triangle = [];
            if (triangles[i].p[0] && triangles[i].p[1] && triangles[i].p[2]) {
                triangle.push(triangles[i].p[0]);
                triangle.push(triangles[i].p[1]);
                triangle.push(triangles[i].p[2]);
                tris.push(triangle);
            }
            else {
                console.error('error');
            }
        }
        return tris;
    }
}

class Metaballs extends Mesh {
    cubeWidth;
    #balls = [];
    constructor(material = new MeshBasicMaterial(), cubeWidth = 1) {
        super(new MetaballsBufferGeometry(), material);
        /*this.setGeometry(new MetaballsBufferGeometry());
        this.setMaterial(material);*/
        this.cubeWidth = cubeWidth;
    }
    addBall(ball = new Metaball()) {
        this.#balls.push(ball);
        this.addChild(ball);
        this.updateGeometry();
        return ball;
    }
    setBalls(balls) {
        this.#balls = balls;
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.#balls, this.cubeWidth);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Metaballs_1: null,
            add_ball: { i18n: '#add_ball', f: () => { this.addBall(); } },
            cube_width: { i18n: '#cube_width', f: () => { let cubeWidth = prompt('Cube width', String(this.cubeWidth)); if (cubeWidth) {
                    this.cubeWidth = Number(cubeWidth);
                } } }
        });
    }
}

let a$7 = create$4();
let b$1 = create$4();
class TrianglesBufferGeometry extends BufferGeometry {
    constructor(triangles) {
        super();
        this.updateGeometry(triangles);
    }
    updateGeometry(triangles = []) {
        var indices = [];
        var vertices = [];
        var normals = [];
        let vertexIndex;
        let normal = create$4();
        for (let triangleIndex = 0; triangleIndex < triangles.length; ++triangleIndex) {
            vertexIndex = triangleIndex * 3;
            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            vertices.push(...triangles[triangleIndex][0]);
            vertices.push(...triangles[triangleIndex][1]);
            vertices.push(...triangles[triangleIndex][2]);
            sub$2(a$7, triangles[triangleIndex][1], triangles[triangleIndex][0]);
            sub$2(b$1, triangles[triangleIndex][2], triangles[triangleIndex][0]);
            cross$2(normal, a$7, b$1);
            normalize$5(normal, normal);
            normals.push(...normal);
            normals.push(...normal);
            normals.push(...normal);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        //this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

class Triangles extends Mesh {
    #triangles;
    //constructor(triangles, material = ) {
    constructor(params = {}) {
        super(params);
        this.#triangles = params.triangles;
        this.setMaterial(params.material ?? new MeshBasicMaterial());
        this.setGeometry(new TrianglesBufferGeometry(params.triangles));
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.#triangles);
    }
}

class OverrideRepository {
    #base;
    #overrides = new Map();
    constructor(base) {
        this.#base = base;
    }
    get name() {
        return this.#base.name;
    }
    /*
        async #getFile(filename: string): Promise<File | undefined> {
            if (this.#overrides.has(filename)) {
                return this.#overrides.get(filename);
            }
            return this.#zipEntries.get(filename);
        }
            */
    async getFile(filename) {
        if (this.#overrides.has(filename)) {
            return { buffer: await this.#overrides.get(filename).arrayBuffer() };
        }
        return this.#base.getFile(filename);
    }
    async getFileAsText(filename) {
        if (this.#overrides.has(filename)) {
            return { text: await this.#overrides.get(filename).text() };
        }
        return this.#base.getFileAsText(filename);
    }
    async getFileAsBlob(filename) {
        if (this.#overrides.has(filename)) {
            return { blob: await this.#overrides.get(filename) };
        }
        return this.#base.getFileAsText(filename);
    }
    async getFileAsJson(filename) {
        if (this.#overrides.has(filename)) {
            return { json: JSON.parse(await this.#overrides.get(filename).text()) };
        }
        return this.#base.getFileAsJson(filename);
    }
    async getFileList(filter) {
        //TODO: added overriden files ?
        return this.#base.getFileList(filter);
    }
    async overrideFile(filename, file) {
        this.#overrides.set(filename, file);
        return null;
    }
}

class ManifestRepository {
    #base;
    constructor(base) {
        this.#base = new OverrideRepository(base);
    }
    get name() {
        return this.#base.name;
    }
    async getFile(filename) {
        return this.#base.getFile(filename);
    }
    async getFileAsText(filename) {
        return this.#base.getFileAsText(filename);
    }
    async getFileAsBlob(filename) {
        return this.#base.getFileAsBlob(filename);
    }
    async getFileAsJson(filename) {
        return this.#base.getFileAsJson(filename);
    }
    async getFileList(filter) {
        return this.#base.getFileList(filter);
    }
    async generateModelManifest(name = 'models_manifest.json', filter) {
        const response = await this.#base.getFileList(filter);
        if (response.error) {
            return response.error;
        }
        const json = response.root.toJSON();
        this.#base.overrideFile(name, new File([JSON.stringify(json)], name));
        return null;
    }
}

var _a$3;
var RepositoryError;
(function (RepositoryError) {
    RepositoryError[RepositoryError["FileNotFound"] = 1] = "FileNotFound";
    RepositoryError[RepositoryError["UnknownError"] = 2] = "UnknownError";
    RepositoryError[RepositoryError["NotSupported"] = 3] = "NotSupported";
})(RepositoryError || (RepositoryError = {}));
class RepositoryEntry {
    #repository;
    #name;
    #childs = new Map;
    #isDirectory;
    #parent;
    constructor(repository, name, isDirectory) {
        this.#repository = repository;
        this.#name = name;
        this.#isDirectory = isDirectory;
    }
    addEntry(filename) {
        const splittedPath = filename.split(/[\/\\]+/);
        let current = this;
        let len = splittedPath.length - 1;
        for (const [i, p] of splittedPath.entries()) {
            if (!current.#childs.has(p)) {
                current = current.#addFile(p, i != len);
            }
            else {
                current = current.#childs.get(p);
            }
        }
    }
    #addFile(name, isDirectory) {
        const e = new _a$3(this.#repository, name, isDirectory);
        e.#parent = this;
        this.#childs.set(name, e);
        return e;
    }
    getName() {
        return this.#name;
    }
    getFullName() {
        let name = '';
        if (this.#parent) {
            name = this.#parent.getFullName();
        }
        name += this.#name;
        if (this.#isDirectory && this.#parent) {
            name += '/';
        }
        return name;
    }
    getParent() {
        return this.#parent;
    }
    getRepository() {
        return this.#repository;
    }
    getChild(name) {
        return this.#childs.get(name);
    }
    getChilds() {
        return new Set(this.#childs.values());
    }
    getAllChilds(filter) {
        const childs = new Set();
        let current;
        const stack = [this];
        do {
            current = stack.pop();
            if (current && !childs.has(current)) {
                if ((filter === undefined) || current.#matchFilter(filter)) {
                    childs.add(current);
                }
                for (const [_, child] of current.#childs) {
                    stack.push(child);
                }
            }
        } while (current);
        return childs;
    }
    #matchFilter(filter) {
        if (filter.directories !== undefined && filter.directories != this.#isDirectory) {
            return false;
        }
        if (filter.files !== undefined && filter.files == this.#isDirectory) {
            return false;
        }
        const { name, extension } = splitFilename(this.#name);
        if (filter.extension && !this.#isDirectory && !match(extension, filter.extension)) {
            return false;
        }
        if (filter.name && !match(name, filter.name)) {
            return false;
        }
        return true;
    }
    isDirectory() {
        return this.#isDirectory;
    }
    toJSON() {
        const json /*TODO:improve type*/ = { name: this.#name };
        if (this.#isDirectory) {
            const files = [];
            for (const [_, child] of this.#childs) {
                files.push(child.toJSON());
            }
            json.files = files;
        }
        return json;
    }
    merge(other) {
        if (this.#isDirectory != other.#isDirectory || this.#name != other.#name) {
            return;
        }
        for (const [name, entry] of other.#childs) {
            if (this.#childs.has(name)) {
                this.#childs.get(name)?.merge(entry);
            }
            else {
                this.#childs.set(name, entry);
            }
        }
    }
}
_a$3 = RepositoryEntry;
function splitFilename(filename) {
    const pos = filename.lastIndexOf('.');
    if (pos < 1) {
        // No dot found or dot in first position
        return { name: filename, extension: '' };
    }
    return { name: filename.substring(0, pos), extension: filename.substring(pos + 1) };
}
function match(name, filter) {
    if (typeof filter == 'string') {
        return filter == name;
    }
    else {
        //regex
        return filter.exec(name) != null;
    }
}

class MergeRepository {
    #name;
    #repositories = [];
    constructor(name, ...repositories) {
        this.#name = name;
        for (const repo of repositories) {
            if (repo) {
                this.#repositories.push(repo);
            }
        }
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        for (const repository of this.#repositories) {
            const response = await repository.getFile(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsText(filename) {
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsText(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsBlob(filename) {
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsBlob(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsJson(filename) {
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsJson(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileList(filter) {
        const root = new RepositoryEntry(this, '', true);
        for (const repository of this.#repositories) {
            const response = await repository.getFileList(filter);
            if (!response.error) {
                root.merge(response.root);
            }
        }
        return { root: root };
    }
    async pushRepository(repo) {
        this.#repositories.push(repo);
    }
    async unshiftRepository(repo) {
        this.#repositories.unshift(repo);
    }
}

class Repositories {
    static #instance;
    #repositories = {};
    constructor() {
        if (Repositories.#instance) {
            return Repositories.#instance;
        }
        Repositories.#instance = this;
    }
    addRepository(repo) {
        this.#repositories[repo.name] = repo;
    }
    getRepository(name) {
        return this.#repositories[name];
    }
    getRepositoryList() {
        return Object.keys(this.#repositories);
    }
    async getFile(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return null;
        }
        return repo?.getFile(filepath);
    }
    async getFileAsText(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return null;
        }
        return repo?.getFileAsText(filepath);
    }
    async getFileAsBlob(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return null;
        }
        return repo?.getFileAsBlob(filepath);
    }
    async getFileAsJson(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return null;
        }
        return repo?.getFileAsJson(filepath);
    }
}

class VpkRepository {
    #name;
    #vpk;
    #initPromiseResolve;
    #initPromise = new Promise(resolve => this.#initPromiseResolve = resolve);
    constructor(name, files) {
        this.#name = name;
        this.#vpk = new Vpk();
        (async () => {
            const error = await this.#vpk.setFiles(files);
            if (error) {
                this.#initPromiseResolve?.(false);
            }
            else {
                this.#initPromiseResolve?.(true);
            }
        })();
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { buffer: await response.file.arrayBuffer() };
    }
    async getFileAsText(filename) {
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { text: await response.file.text() };
    }
    async getFileAsBlob(filename) {
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { blob: response.file };
    }
    async getFileAsJson(filename) {
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { json: JSON.parse(await response.file.text()) };
    }
    async getFileList(filter) {
        await this.#initPromise;
        const root = new RepositoryEntry(this, '', true);
        for (const filename of await this.#vpk.getFileList()) {
            root.addEntry(filename);
        }
        return { root: root };
    }
}
function cleanupFilename$1(filename) {
    filename = filename.toLowerCase().replaceAll('\\', '/');
    const arr = filename.split('/');
    return arr.filter((path) => path != '').join('/');
}

class WebRepository {
    #name;
    #base;
    constructor(name, base) {
        this.#name = name;
        this.#base = base;
    }
    get name() {
        return this.#name;
    }
    get base() {
        return this.#base;
    }
    async getFile(fileName) {
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { buffer: await response.arrayBuffer() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsText(fileName) {
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { text: await response.text() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsBlob(fileName) {
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { blob: new Blob([new Uint8Array(await response.arrayBuffer())]) };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsJson(fileName) {
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { json: await response.json() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileList(filter) {
        return { error: RepositoryError.NotSupported };
    }
}

class ZipRepository {
    #name;
    #zip;
    #reader;
    #zipEntries = new Map();
    #initPromiseResolve;
    #initPromise = new Promise(resolve => this.#initPromiseResolve = resolve);
    constructor(name, zip) {
        this.#name = name;
        this.#zip = zip;
        this.#reader = new ZipReader(new BlobReader(zip));
        this.#initEntries();
    }
    async #initEntries() {
        const entries = await this.#reader.getEntries();
        for (const entry of entries) {
            if (!entry.getData || entry.directory) {
                continue;
            }
            const blob = await entry.getData(new BlobWriter());
            const filename = cleanupFilename(entry.filename);
            this.#zipEntries.set(filename, new File([blob], filename));
        }
        this.#initPromiseResolve?.(true);
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        await this.#initPromise;
        const file = this.#zipEntries.get(cleanupFilename(filename));
        if (!file) {
            return { error: RepositoryError.FileNotFound };
        }
        return { buffer: await file.arrayBuffer() };
    }
    async getFileAsText(filename) {
        await this.#initPromise;
        const file = this.#zipEntries.get(cleanupFilename(filename));
        if (!file) {
            return { error: RepositoryError.FileNotFound };
        }
        return { text: await file.text() };
    }
    async getFileAsBlob(filename) {
        await this.#initPromise;
        cleanupFilename(filename);
        throw 'code me';
    }
    async getFileAsJson(filename) {
        await this.#initPromise;
        const file = this.#zipEntries.get(cleanupFilename(filename));
        if (!file) {
            return { error: RepositoryError.FileNotFound };
        }
        return { json: JSON.parse(await file.text()) };
    }
    async getFileList(filter) {
        await this.#initPromise;
        const root = new RepositoryEntry(this, '', true);
        for (const [filename, _] of this.#zipEntries) {
            root.addEntry(filename);
        }
        return { root: root };
    }
}
function cleanupFilename(filename) {
    filename = filename.toLowerCase().replaceAll('\\', '/');
    const arr = filename.split('/');
    return arr.filter((path) => path != '').join('/');
}

class Environment {
    constructor() {
    }
}

class CubeEnvironment extends Environment {
    texture;
    constructor() {
        super();
    }
}

var _a$2;
const MAX_ANIMATIONS = 2;
let id = 0;
function getDataListId() {
    return `animations-datalist${++id}`;
}
class SceneExplorerEntity extends HTMLElement {
    #doOnce;
    #entity;
    #htmlHeader;
    #htmlContent;
    #htmlAnimations;
    #htmlInputDataList;
    #htmlChilds;
    #htmlTitle;
    #htmlVisible;
    #htmlPlaying;
    #htmlAnimationsButton;
    #htmlLoopedButton;
    #htmlLockedButton;
    #htmlReset;
    static #entitiesHTML = new Map();
    static #selectedEntity;
    static #explorer;
    static #draggedEntity;
    static {
        EntityObserver.addEventListener(CHILD_ADDED, (event) => _a$2.#expandEntityChilds(event.detail.parent));
        EntityObserver.addEventListener(CHILD_REMOVED, (event) => _a$2.#expandEntityChilds(event.detail.parent));
        EntityObserver.addEventListener(PROPERTY_CHANGED$1, (event) => _a$2.#handlePropertyChanged(event.detail));
        EntityObserver.addEventListener(ENTITY_DELETED, (event) => _a$2.#handleEntityDeleted(event.detail));
    }
    constructor() {
        super();
        this.#doOnce = true;
        defineHarmonyToggleButton();
        this.#htmlHeader = createElement('div', {
            class: 'scene-explorer-entity-header',
            childs: [
                this.#htmlTitle = createElement('div', {
                    class: 'scene-explorer-entity-title',
                    events: {
                        click: () => this.#titleClick(),
                    }
                }),
                createElement('div', {
                    class: 'scene-explorer-entity-buttons',
                    childs: [
                        this.#htmlVisible = createElement('div', {
                            class: 'scene-explorer-entity-button-visible',
                            events: {
                                click: () => {
                                    this.#entity?.toggleVisibility();
                                },
                            }
                        }),
                        this.#htmlPlaying = createElement('div', {
                            hidden: true,
                            class: 'scene-explorer-entity-button-play',
                            events: {
                                click: () => {
                                    this.#entity?.togglePlaying();
                                },
                            }
                        }),
                        this.#htmlAnimationsButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: runSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: walkSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#displayAnimations(event.target.state),
                            }
                        }),
                        this.#htmlLoopedButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: repeatSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: repeatOnSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#entity?.setLooping(event.target.state),
                            }
                        }),
                        this.#htmlLockedButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: lockOpenRightSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: lockSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#entity?.setLocked(event.target.state),
                            }
                        }),
                        this.#htmlReset = createElement('div', {
                            hidden: true,
                            class: 'scene-explorer-entity-button-reset',
                            innerHTML: restartSVG,
                            events: {
                                click: () => {
                                    this.#entity?.do('reset');
                                },
                            }
                        }),
                    ]
                }),
            ]
        });
        this.#htmlContent = createElement('div', {
            class: 'scene-explorer-entity-content',
            hidden: true,
        });
        this.#htmlChilds = createElement('div', {
            class: 'scene-explorer-entity-childs',
            hidden: true,
        });
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.#doOnce = false;
            this.#htmlHeader.draggable = true;
            this.append(this.#htmlHeader, this.#htmlContent, this.#htmlChilds);
            this.addEventListener('contextmenu', event => this.#contextMenuHandler(event));
            this.addEventListener('dragstart', event => {
                if (event.dataTransfer) {
                    event.dataTransfer.effectAllowed = 'link';
                }
                _a$2.#draggedEntity = this.#entity;
                event.stopPropagation();
            });
            this.addEventListener('dragenter', event => {
                this.classList.add('dragged-over');
            });
            this.addEventListener('dragleave', event => {
                this.classList.remove('dragged-over');
            });
            this.addEventListener('dragover', event => {
                event.preventDefault();
                event.stopPropagation();
            });
            this.addEventListener('drop', event => {
                const draggedEntity = _a$2.#draggedEntity;
                if (draggedEntity) {
                    this.classList.remove('dragged-over');
                    this.#entity?.addChild(draggedEntity);
                    event.stopPropagation();
                }
            });
            this.addEventListener('dragend', () => {
                _a$2.#draggedEntity = undefined;
            });
        }
    }
    /**
     * @deprecated Please use `setEntity` instead.
     */
    set entity(entity) {
        //TODO: deprecate
        console.warn('deprecated, use setEntity instaed');
        this.setEntity(entity);
    }
    setEntity(entity) {
        this.#entity = entity;
        this.#update();
        this.#updateVisibility();
        this.#updatePlaying();
        display(this.#htmlPlaying, entity?.animable);
        display(this.#htmlAnimationsButton, entity?.hasAnimations);
        display(this.#htmlReset, entity?.resetable);
        display(this.#htmlLoopedButton, entity?.isLoopable);
        display(this.#htmlLockedButton, entity?.isLockable);
    }
    static setExplorer(explorer) {
        _a$2.#explorer = explorer;
    }
    /*
    static get selectedEntity() {
        return SceneExplorerEntity.#selectedEntity.#entity;
    }
    */
    select() {
        this.classList.add('selected');
        const selectedEntity = _a$2.#selectedEntity;
        if (selectedEntity != this) {
            selectedEntity?.unselect();
        }
        _a$2.#selectedEntity = this;
    }
    display() {
        this.#display();
        this.scrollIntoView();
    }
    #display() {
        const parentEntity = this.#entity.parent;
        if (parentEntity) {
            const htmlParent = _a$2.getEntityElement(parentEntity);
            if (htmlParent) {
                htmlParent.#display();
                htmlParent.expand();
            }
        }
    }
    unselect() {
        this.classList.remove('selected');
    }
    static getEntityElement(entity) {
        if (entity.hideInExplorer) {
            return null;
        }
        let entityElement = _a$2.#entitiesHTML.get(entity);
        if (!entityElement) {
            entityElement = createElement('scene-explorer-entity');
            entityElement.setEntity(entity);
            _a$2.#entitiesHTML.set(entity, entityElement);
        }
        return entityElement;
    }
    static #handlePropertyChanged(detail) {
        const entity = detail.entity;
        _a$2.#updateEntity(entity);
        switch (detail.name) {
            case 'visible':
                this.#updateEntityVisibility(entity);
                for (let child of entity.children) {
                    this.#updateEntityVisibility(child);
                }
                break;
            case 'playing':
                this.#updateEntityPlaying(entity);
                break;
        }
    }
    static #handleEntityDeleted(detail) {
        _a$2.#entitiesHTML.delete(detail.entity);
        //console.log('deleted entity', detail.entity);
    }
    static #updateEntity(entity) {
        let entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#update();
        }
    }
    static #expandEntityChilds(entity) {
        let entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#expandChilds();
        }
    }
    #update() {
        const entity = this.#entity;
        if (entity) {
            const className = entity.constructor.getEntityName();
            this.#htmlTitle.innerText = entity.name ? `${entity.name} (${className})` : className;
        }
    }
    static #updateEntityVisibility(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#updateVisibility();
        }
    }
    #updateVisibility() {
        if (this.#entity?.isVisible()) {
            this.#htmlVisible.innerHTML = visibilityOnSVG;
        }
        else {
            this.#htmlVisible.innerHTML = visibilityOffSVG;
        }
    }
    static #updateEntityPlaying(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#updatePlaying();
        }
    }
    #updatePlaying() {
        if (this.#entity?.isPlaying()) {
            this.#htmlPlaying.innerHTML = playSVG;
        }
        else {
            this.#htmlPlaying.innerHTML = pauseSVG;
        }
    }
    expand() {
        show(this.#htmlChilds);
        this.#expandChilds();
        //this.select();
    }
    #expandChilds() {
        this.#htmlChilds.innerText = '';
        const entity = this.#entity;
        if (!entity) {
            return;
        }
        for (let child of entity.children) {
            const childHtml = _a$2.getEntityElement(child);
            if (childHtml) {
                this.#htmlChilds.append(childHtml);
            }
        }
    }
    #titleClick() {
        if (this == _a$2.#selectedEntity) {
            toggle(this.#htmlChilds);
        }
        else {
            show(this.#htmlChilds);
        }
        this.#expandChilds();
        _a$2.#explorer?.selectEntity(this.#entity);
    }
    #contextMenuHandler(event) {
        if (!event.shiftKey && this.#entity) {
            _a$2.#explorer?.showContextMenu(this.#entity.buildContextMenu(), event.clientX, event.clientY, this.#entity);
            event.preventDefault();
            event.stopPropagation();
        }
    }
    async #displayAnimations(display) {
        if (!this.#entity) {
            return;
        }
        if (this.#htmlAnimations && !display) {
            hide(this.#htmlAnimations);
            return;
        }
        this.#initAnimations();
        //SceneExplorerEntity.#explorer?.showAnimations(this.#entity);
        const animList = await this.#entity.getAnimations?.();
        if (!animList) {
            return;
        }
        this.#htmlInputDataList.innerText = '';
        for (let value of animList) {
            createElement('option', {
                innerText: value,
                parent: this.#htmlInputDataList,
            });
        }
        show(this.#htmlAnimations);
        show(this.#htmlContent);
    }
    #initAnimations() {
        if (this.#htmlAnimations) {
            return;
        }
        this.#htmlAnimations = createElement('div', {
            class: 'animations',
            parent: this.#htmlContent,
        });
        const dataListId = getDataListId();
        for (let i = 0; i < MAX_ANIMATIONS; i++) {
            createElement('div', {
                class: 'animation',
                parent: this.#htmlAnimations,
                childs: [
                    createElement('input', {
                        list: dataListId,
                        events: {
                            change: (event) => this.#setAnimName(i, event.target.value)
                        }
                    }),
                ],
            });
        }
        this.#htmlInputDataList = createElement('datalist', {
            id: dataListId,
            parent: this.#htmlAnimations,
        });
    }
    #setAnimName(id, name) {
        if (!this.#entity) {
            return;
        }
        this.#entity.playAnimation(name);
        this.#entity.setAnimation(id, name, 1); //TODO: weight
    }
}
_a$2 = SceneExplorerEntity;
if (window.customElements) {
    customElements.define('scene-explorer-entity', SceneExplorerEntity);
}

function getUniformsHtml(uniforms /*TODO: create a proper type for uniforms*/) {
    let htmlUniforms = createElement('div');
    for (let uniformName in uniforms) {
        let uniform = uniforms[uniformName];
        htmlUniforms.append(addHtmlParameter(uniformName, uniform));
    }
    return htmlUniforms;
}
function addHtmlParameter(name, value) {
    let htmlParameter = createElement('div');
    let htmlParameterName = createElement('span');
    htmlParameterName.innerHTML = name;
    let htmlParameterValue = createElement('span');
    htmlParameterValue.innerHTML = value;
    htmlParameter.append(htmlParameterName, htmlParameterValue);
    return htmlParameter;
}
let materialEditor = null;
function getMaterialEditor() {
    if (!materialEditor) {
        materialEditor = new MaterialEditor();
    }
    return materialEditor;
}
class MaterialEditor {
    static #instance;
    #shadowRoot;
    #htmlHeader;
    #htmlShader;
    #htmlBlending;
    #htmlHasBlending;
    #htmlBlendFactors = new Array(4);
    #htmlBlendSelects = new Array(6);
    #htmlParams;
    #material;
    constructor() {
        if (MaterialEditor.#instance) {
            return MaterialEditor.#instance;
        }
        MaterialEditor.#instance = this;
        this.#shadowRoot = createShadowRoot('div', {
            childs: [
                this.#htmlHeader = createElement('div', {
                    childs: [
                        this.#htmlShader = createElement('div', {}),
                        this.#htmlBlending = createElement('div', {
                            childs: [
                                createElement('label', {
                                    childs: [
                                        createElement('span', {
                                            i18n: '#enable_blending',
                                        }),
                                        this.#htmlHasBlending = createElement('input', {
                                            type: 'checkbox',
                                            events: {
                                                change: (event) => this.#setBlending(event.target.checked),
                                            }
                                        }),
                                    ]
                                }),
                            ]
                        }),
                        this.#htmlParams = createElement('div', {}),
                    ]
                }),
            ],
        });
        const i18n = ['#source_color', '#source_alpha', '#destination_color', '#destination_alpha', '#mode_color', '#mode_alpha'];
        for (let i = 0; i < 6; i++) {
            this.#htmlBlendFactors[i] = createElement('div', {
                hidden: 1,
                parent: this.#htmlBlending,
                childs: [
                    createElement('span', {
                        i18n: i18n[i],
                    }),
                    this.#htmlBlendSelects[i] = createElement('select', {
                        list: 'factors',
                        events: {
                            change: (event) => this.#changeBlendingFactor(i, event.target.value),
                        },
                    }),
                ],
            });
            if (i < 4) {
                for (let suite in BlendingFactor) {
                    const value = BlendingFactor[suite];
                    if (typeof value === 'string') {
                        createElement('option', {
                            parent: this.#htmlBlendSelects[i],
                            innerText: value,
                            value: value,
                        });
                    }
                }
            }
            else {
                for (let suite in BlendingEquation) {
                    const value = BlendingEquation[suite];
                    if (typeof value === 'string') {
                        createElement('option', {
                            parent: this.#htmlBlendSelects[i],
                            innerText: value,
                            value: value,
                        });
                    }
                }
            }
        }
    }
    editEntity(entity) {
        //this.#entity = entity;
        this.#material = entity.material;
        this.#refreshHtml();
    }
    editMaterial(material) {
        //this.#entity = null;
        this.#material = material;
        this.#refreshHtml();
    }
    #refreshHtml() {
        this.#htmlParams.innerText = '';
        this.#htmlShader.innerText = '';
        let material = this.#material;
        if (!material) {
            return;
        }
        let fileName = material.name;
        if (fileName) {
            this.#htmlParams.append(addHtmlParameter('filename', fileName));
        }
        this.#htmlShader.append(addHtmlParameter('shader', material.getShaderSource()));
        this.#htmlBlendSelects[0].value = BlendingFactor[this.#material.srcRGB];
        this.#htmlBlendSelects[1].value = BlendingFactor[this.#material.srcAlpha];
        this.#htmlBlendSelects[2].value = BlendingFactor[this.#material.dstRGB];
        this.#htmlBlendSelects[3].value = BlendingFactor[this.#material.dstAlpha];
        this.#htmlHasBlending.checked = this.#material.blend;
        if (material.blend) {
            show(this.#htmlBlendFactors);
        }
        else {
            hide(this.#htmlBlendFactors);
        }
        //this.#htmlElement.innerHTML += this.material.name;
        this.#htmlParams.append(getUniformsHtml(material.uniforms));
    }
    getHTML() {
        return this.#shadowRoot.host;
    }
    #setBlending(blending) {
        if (!this.#material) {
            return;
        }
        this.#material.blend = blending;
        this.#refreshHtml();
    }
    #changeBlendingFactor(i, blending) {
        if (!this.#material) {
            return;
        }
        let value;
        if (i < 4) {
            value = BlendingFactor[blending];
        }
        else {
            value = BlendingEquation[blending];
        }
        switch (i) {
            case 0: // src color
                this.#material.srcRGB = value;
                break;
            case 1: // src alpha
                this.#material.srcAlpha = value;
                break;
            case 2: // dst color
                this.#material.dstRGB = value;
                break;
            case 3: // dst alpha
                this.#material.dstAlpha = value;
                break;
            case 4: // color mode
                this.#material.modeRGB = value;
                break;
            case 5: // alpha mode
                this.#material.modeAlpha = value;
                break;
        }
    }
}

class WireframeHelper extends Entity {
    #meshToWireframe = new Map();
    #wireframeToMesh = new Map();
    constructor() {
        super();
    }
    parentChanged(parent) {
        if (parent instanceof Entity) {
            let meshes = parent.getChildList('Mesh');
            for (let mesh of meshes) {
                if (mesh.renderMode !== GL_LINES) { //TODO: improve wireframe detection
                    let wireframeGeometry = mesh.geometry.clone();
                    let wireframeMesh = new Mesh(wireframeGeometry, mesh.material);
                    wireframeMesh.renderMode = GL_LINES;
                    this.#meshToWireframe.set(mesh, wireframeMesh);
                    this.#wireframeToMesh.set(wireframeMesh, mesh);
                    WireframeHelper.updateWireframeIndex(wireframeGeometry);
                    mesh.addChild(wireframeMesh);
                }
            }
        }
    }
    setVisible(visible) {
        super.setVisible(visible);
        for (const [w, m] of this.#wireframeToMesh) {
            w.setVisible(visible);
        }
    }
    static updateWireframeIndex(geometry) {
        let attribute = geometry.attributes.get('index');
        if (attribute) {
            let indexArray = attribute._array;
            let wireframeArray;
            let arraySize = indexArray.length * 2;
            let wireframeAttribute = (geometry.elementArrayType == GL_UNSIGNED_INT) ? new Uint32BufferAttribute(new Array(arraySize), 1) : new Uint16BufferAttribute(new Array(arraySize), 1);
            wireframeAttribute.target = GL_ELEMENT_ARRAY_BUFFER;
            geometry.setAttribute('index', wireframeAttribute);
            geometry.count = arraySize;
            wireframeArray = wireframeAttribute._array;
            for (let i = 0, j = 0, l = indexArray.length; i < l; i += 3, j += 6) {
                let i1 = indexArray[i];
                let i2 = indexArray[i + 1];
                let i3 = indexArray[i + 2];
                wireframeArray[j + 0] = i1;
                wireframeArray[j + 1] = i2;
                wireframeArray[j + 2] = i2;
                wireframeArray[j + 3] = i3;
                wireframeArray[j + 4] = i3;
                wireframeArray[j + 5] = i1;
            }
            wireframeAttribute.dirty = true;
        }
    }
    static getEntityName() {
        return 'Wireframe helper';
    }
}

let loaders = new Map();
function registerLoader(name, loader) {
    loaders.set(name, loader);
}
function getLoader(name) {
    return loaders.get(name);
}

class Source1ModelManager {
    static #modelListPerRepository = new Map();
    static #modelsPerRepository = new Map();
    static async #createModel(repositoryName, fileName) {
        let model = this.#getModel(repositoryName, fileName);
        if (model) {
            return model;
        }
        const modelLoader = getLoader('ModelLoader');
        model = await new modelLoader().load(repositoryName, fileName);
        if (model) {
            this.#modelsPerRepository.get(repositoryName)?.set(fileName, model);
        }
        return model;
    }
    static #getModel(repositoryName, fileName) {
        if (!this.#modelsPerRepository.has(repositoryName)) {
            this.#modelsPerRepository.set(repositoryName, new Map());
        }
        return this.#modelsPerRepository.get(repositoryName)?.get(fileName);
    }
    static async createInstance(repository, fileName, dynamic, preventInit = false) {
        if (!repository) {
            //try to get repository from filename
            for (const [repo] of this.#modelListPerRepository) {
                if (fileName.startsWith(repo)) {
                    repository = repo;
                    fileName = fileName.replace(repo, '');
                    break;
                }
            }
        }
        let model = await this.#createModel(repository, fileName);
        if (model) {
            let instance = model.createInstance(dynamic, preventInit);
            return instance;
        }
        return null;
    }
    static loadManifest(repositoryName) {
        if (!this.#modelListPerRepository.has(repositoryName)) {
            this.#modelListPerRepository.set(repositoryName, null);
        }
    }
    static async getModelList() {
        const repoList = [];
        for (const [repositoryName, repo] of this.#modelListPerRepository) {
            if (repo === null) {
                const response = await new Repositories().getFileAsJson(repositoryName, 'models_manifest.json');
                if (!response.error) {
                    this.#modelListPerRepository.set(repositoryName, response.json);
                    repoList.push({ name: repositoryName, files: [response.json] });
                }
            }
            else {
                repoList.push({ name: repositoryName, files: [repo] });
            }
        }
        return { name: '', path: '', files: repoList };
    }
}

class SourceBinaryLoader {
    repository;
    async load(repositoryName, fileName) {
        this.repository = repositoryName;
        let promise = new Promise(resolve => {
            const p = new Repositories().getFile(repositoryName, fileName);
            p.then((response) => {
                if (!response.error) {
                    resolve(this.parse(repositoryName, fileName, response.buffer));
                }
                else {
                    resolve(null);
                }
            });
        });
        return promise;
    }
    parse(repository, fileName, arrayBuffer) {
        throw 'override me';
    }
}

const VTEX_FLAG_CUBE_TEXTURE = 0x10;
const VTEX_FORMAT_DXT1 = 0x01; // 1
const VTEX_FORMAT_DXT5 = 0x02; // 2
const VTEX_FORMAT_R8 = 0x03; // 3
const VTEX_FORMAT_R8G8B8A8_UINT = 0x04; // 4
const VTEX_FORMAT_PNG_R8G8B8A8_UINT = 0x10; // 16
const VTEX_FORMAT_BC7 = 0x14; // 20
const VTEX_FORMAT_BC5 = 0x15; // 21
const VTEX_FORMAT_BC4 = 0x1B; // 27
const VTEX_FORMAT_BGRA8888 = 0x1C; // 28

const TEXTURE_FORMAT_UNKNOWN = 0;
const TEXTURE_FORMAT_UNCOMPRESSED = 1 << 10;
const TEXTURE_FORMAT_COMPRESSED_S3TC = 1 << 11;
const TEXTURE_FORMAT_COMPRESSED_RGTC = 1 << 12;
const TEXTURE_FORMAT_COMPRESSED_BPTC = 1 << 13;
const TEXTURE_FORMAT_UNCOMPRESSED_RGB = TEXTURE_FORMAT_UNCOMPRESSED | 1;
const TEXTURE_FORMAT_UNCOMPRESSED_RGBA = TEXTURE_FORMAT_UNCOMPRESSED | 2;
const TEXTURE_FORMAT_UNCOMPRESSED_R8 = TEXTURE_FORMAT_UNCOMPRESSED | 3;
const TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888 = TEXTURE_FORMAT_UNCOMPRESSED | 4;
const TEXTURE_FORMAT_COMPRESSED_RGB_DXT1 = TEXTURE_FORMAT_COMPRESSED_S3TC | 1;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1 = TEXTURE_FORMAT_COMPRESSED_S3TC | 2;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3 = TEXTURE_FORMAT_COMPRESSED_S3TC | 3;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5 = TEXTURE_FORMAT_COMPRESSED_S3TC | 4;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC4 = TEXTURE_FORMAT_COMPRESSED_RGTC | 1;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC5 = TEXTURE_FORMAT_COMPRESSED_RGTC | 2;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC7 = TEXTURE_FORMAT_COMPRESSED_BPTC | 1;

const VTEX_TO_INTERNAL_IMAGE_FORMAT = {};
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_DXT1] = TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_DXT5] = TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_R8] = TEXTURE_FORMAT_UNCOMPRESSED_R8;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC4] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC4;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC5] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC5;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC7] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC7;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_R8G8B8A8_UINT] = TEXTURE_FORMAT_UNCOMPRESSED_RGBA;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BGRA8888] = TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888;
/*VTEX_FORMAT_DXT1 : TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1,
VTEX_FORMAT_DXT5 : TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5,
VTEX_FORMAT_BC7 : TEXTURE_FORMAT_COMPRESSED_RGBA_BC7,
}*/
//TODOv3: improve
/*export const TEXTURE_FORMAT_UNKNOWN = 0;
export const TEXTURE_FORMAT_UNCOMPRESSED_RGB = 1;
export const TEXTURE_FORMAT_UNCOMPRESSED_RGBA = 2;
export const TEXTURE_FORMAT_COMPRESSED_RGB_DXT1 = 1000;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1 = 1001;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3 = 1002;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5 = 1003;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_BC7 = 1004;


export const VTEX_FORMAT_DXT1 = 0x01;
export const VTEX_FORMAT_DXT5 = 0x02;
export const VTEX_FORMAT_R8G8B8A8_UINT = 0x04;
export const VTEX_FORMAT_PNG_R8G8B8A8_UINT = 0x10;
export const VTEX_FORMAT_BC7 = 0x14;//not sure*/
/**
 * Source2 common file
 */
class Source2File {
    repository;
    fileName;
    // blocks stores the first occurence of a block type
    // some blocks (MBUF, MDAT) may have multiple occurences that can be accessed via blocksArray
    blocks = {};
    blocksArray = [];
    fileLength = 0;
    versionMaj = 0;
    versionMin = 0;
    maxBlockOffset = 0;
    constructor(repository, fileName) {
        this.repository = repository;
        this.fileName = fileName;
    }
    addBlock(block) {
        this.blocksArray.push(block);
        if (this.blocks[block.type] === undefined) {
            this.blocks[block.type] = block;
        }
    }
    getBlockByType(type) {
        return this.blocks[type];
    }
    getBlockById(id) {
        return this.blocksArray[id];
    }
    getVertexCount(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return 0;
        }
        return block.indices[bufferId].indices.length;
    }
    getIndices(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let indexBuffer = block.indices[bufferId];
        return indexBuffer ? indexBuffer.indices : [];
    }
    getVertices(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let vertexBuffer = block.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.vertices : [];
    }
    getNormals(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let vertexBuffer = block.vertices[bufferId];
        let normals = vertexBuffer.normals;
        var ret = [];
        const normalVec4 = create$3();
        let normalVec3;
        for (var i = 0, l = normals.length; i < l; i += 4) {
            normalVec4[0] = normals[i + 0];
            normalVec4[1] = normals[i + 1];
            normalVec4[2] = normals[i + 2];
            normalVec4[3] = normals[i + 3];
            normalVec3 = DecompressNormal(normalVec4);
            ret.push(normalVec3[0]);
            ret.push(normalVec3[1]);
            ret.push(normalVec3[2]);
        }
        return ret; //vertexBuffer ? vertexBuffer.normals : [];
    }
    getCoords(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let vertexBuffer = block.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.coords : [];
    }
    getBoneIndices(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let vertexBuffer = block.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.boneIndices : [];
    }
    getBoneWeight(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        let vertexBuffer = block.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.boneWeight : [];
    }
    getPositionArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var vertices = vertexBuffer ? vertexBuffer.vertices : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 3;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
        }
        return ret;
    }
    getNormalArray(bufferId) {
        /*function DecompressNormal(float2 inputTangent, out float4 outputTangent) {//_DecompressShort2Tangent
            const ztSigns		= sign(inputTangent);				// sign bits for z and tangent (+1 or -1)
            float2 xyAbs		= abs(inputTangent);				// 1..32767
            outputTangent.xy	= (xyAbs - 16384.0) / 16384.0;	// x and y
            outputTangent.z		= ztSigns.x * sqrt(saturate(1.0 - dot(outputTangent.xy, outputTangent.xy)));
            //outputTangent.w		= ztSigns.y;
        }*/
        function DecompressNormal(inputNormal) {
            let outputNormal = create$4();
            //float2 ztSigns		= (inputNormal.xy - 128.0) < 0;				// sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
            const ztSigns = fromValues(Number((inputNormal[0] - 128.0) < 0), Number((inputNormal[1] - 128.0) < 0)); // sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
            //float2 xyAbs		= abs(inputNormal.xy - 128.0) - ztSigns;		// 0..127
            const xyAbs = fromValues(Math.abs(inputNormal[0] - 128.0) - ztSigns[0], Math.abs(inputNormal[1] - 128.0) - ztSigns[1]); // 0..127
            //float2 xySigns		= (xyAbs - 64.0) < 0;						// sign bits for xs and ys (1 or 0)
            const xySigns = fromValues(Number((xyAbs[0] - 64.0) < 0), Number((xyAbs[1] - 64.0) < 0)); // sign bits for xs and ys (1 or 0)
            //outputNormal.xy		= (abs(xyAbs - 64.0) - xySigns) / 63.0;	// abs({nX, nY})
            outputNormal[0] = (Math.abs(xyAbs[0] - 64.0) - xySigns[0]) / 63.0; // abs({nX, nY})
            outputNormal[1] = (Math.abs(xyAbs[1] - 64.0) - xySigns[1]) / 63.0; // abs({nX, nY})
            //outputNormal.z		= 1.0 - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1
            outputNormal[2] = 1.0 - outputNormal[0] - outputNormal[1]; // Project onto x+y+z=1
            //outputNormal.xyz	= normalize(outputNormal.xyz);				// Normalize onto unit sphere
            normalize$5(outputNormal, outputNormal);
            //outputNormal.xy	 *= lerp(fOne.xx, -fOne.xx, xySigns);			// Restore x and y signs
            //outputNormal.z	 *= lerp(fOne.x, -fOne.x, ztSigns.x);			// Restore z sign
            outputNormal[0] *= (1 - xySigns[0]) - xySigns[0];
            outputNormal[1] *= (1 - xySigns[1]) - xySigns[1];
            return normalize$5(outputNormal, outputNormal);
        }
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var normals = vertexBuffer ? vertexBuffer.normals : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        var ret = [];
        var indicesLength = indices.length;
        const normalVec4 = create$3();
        let normalVec3;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 4;
            normalVec4[0] = normals[vertexId + 0];
            normalVec4[1] = normals[vertexId + 1];
            normalVec4[2] = normals[vertexId + 2];
            normalVec4[3] = normals[vertexId + 3];
            normalVec3 = DecompressNormal(normalVec4);
            ret.push(normalVec3[0]);
            ret.push(normalVec3[1]);
            ret.push(normalVec3[2]);
            //ret.push(0);
            //ret.push(normals[vertexId + 0] / 255.0);
            //ret.push(normals[vertexId + 1] / 255.0);
            //ret.push(normals[vertexId + 2] / 255.0);
            //ret.push(normals[vertexId + 3] / 255.0);
        }
        return ret;
    }
    getCoordArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var coords = vertexBuffer ? vertexBuffer.coords : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        //var coords = block.vertices[bufferId].coords;
        //var indices = block.indices[bufferId].indices;
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 2;
            ret.push(coords[vertexId + 0]);
            ret.push(coords[vertexId + 1]);
        }
        return ret;
    }
    getBoneIndiceArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }
    getBoneWeightArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var vertices = vertexBuffer ? vertexBuffer.boneWeight : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneWeight;
        //var indices = block.indices[bufferId].indices;
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0] / 255); //TODO: optimise
            ret.push(vertices[vertexId + 1] / 255);
            ret.push(vertices[vertexId + 2] / 255);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }
    getTangentArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }
    getBinormalArray(bufferId) {
        var block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        var vertexBuffer = block.vertices[bufferId];
        var indexBuffer = block.indices[bufferId];
        var vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        var indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;
        var ret = [];
        var indicesLength = indices.length;
        for (var i = 0; i < indicesLength; i++) {
            var vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }
    getWidth() {
        var block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        return block.width;
    }
    getHeight() {
        var block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        return block.height;
    }
    getDxtLevel() {
        var block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        switch (block.imageFormat) {
            case 1: //TODO DXT1
                return 1;
            case 2: //TODO DXT5
                return 5;
        }
        return 0;
    }
    isCompressed() {
        var block = this.blocks.DATA;
        if (!block) {
            return false;
        }
        return block.imageFormat <= 2; //DXT1 or DXT5
    }
    isCubeTexture() {
        var block = this.blocks.DATA;
        if (!block) {
            return false;
        }
        return (block.flags & VTEX_FLAG_CUBE_TEXTURE) == VTEX_FLAG_CUBE_TEXTURE;
    }
    getBlockStruct(path) {
        var arr = path.split('.');
        var data = this.blocks;
        if (!data) {
            return null;
        }
        var sub;
        for (var i = 0; i < arr.length; i++) {
            sub = data[arr[i]];
            if (!sub) {
                return null;
            }
            data = sub;
        }
        return data;
    }
    getPermModelData(path) {
        return this.getBlockStruct('DATA.structs.PermModelData_t.' + path) || this.getBlockStruct('DATA.keyValue.root.' + path);
    }
    getMaterialResourceData(path) {
        return this.getBlockStruct('DATA.structs.MaterialResourceData_t.' + path) || this.getBlockStruct('DATA.keyValue.root.' + path);
    }
    getExternalFiles() {
        var externalFiles = this.getBlockStruct('RERL.externalFiles2');
        return externalFiles;
    }
    getExternalFile(fileIndex) {
        var externalFiles = this.getBlockStruct('RERL.externalFiles2');
        if (externalFiles) {
            return externalFiles[fileIndex];
        }
        return null;
    }
    getKeyValue(path) {
        var dataBlock = this.blocks['DATA'];
        if (dataBlock) {
            var keyValue = dataBlock.keyValue;
            if (keyValue) {
                return keyValue.getValue(path);
            }
        }
        return null;
    }
    get imageFormat() {
        var block = this.blocks.DATA;
        if (!block) {
            return TEXTURE_FORMAT_UNKNOWN;
        }
        let imageFormat = block.imageFormat;
        {
            return VTEX_TO_INTERNAL_IMAGE_FORMAT[imageFormat];
        }
    }
    get displayName() {
        let fileName = this.fileName;
        if (fileName) {
            let result = /(\w+)\.\w+$/.exec(fileName);
            if (result && result.length == 2) {
                return result[1];
            }
        }
    }
    getRemappingTable(meshIndex) {
        const remappingTableStarts = this.getPermModelData('m_remappingTableStarts');
        if (!remappingTableStarts || meshIndex > remappingTableStarts.length) {
            return;
        }
        const remappingTable = this.getPermModelData('m_remappingTable');
        if (!remappingTable) {
            return;
        }
        const starts = remappingTableStarts[meshIndex];
        if (starts > remappingTable.length) {
            return;
        }
        let end = remappingTableStarts[meshIndex + 1];
        if (end !== undefined) {
            end = Number(end); // Converts bigint
        }
        return remappingTable.slice(Number(starts), end);
    }
    remapBuffer(buffer, remappingTable) {
        const inArr = new Float32Array(buffer);
        const outArr = new Float32Array(new ArrayBuffer(buffer.byteLength));
        if (remappingTable) {
            inArr.forEach((element, index) => {
                outArr[index] = Number(remappingTable[element] ?? element);
            });
        }
        return outArr;
    }
}
function DecompressNormal(inputNormal) {
    let outputNormal = create$4();
    //float2 ztSigns		= (inputNormal.xy - 128.0) < 0;				// sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
    const ztSigns = fromValues(Number((inputNormal[0] - 128.0) < 0), Number((inputNormal[1] - 128.0) < 0)); // sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
    //float2 xyAbs		= abs(inputNormal.xy - 128.0) - ztSigns;		// 0..127
    const xyAbs = fromValues(Math.abs(inputNormal[0] - 128.0) - ztSigns[0], Math.abs(inputNormal[1] - 128.0) - ztSigns[1]); // 0..127
    //float2 xySigns		= (xyAbs - 64.0) < 0;						// sign bits for xs and ys (1 or 0)
    const xySigns = fromValues(Number((xyAbs[0] - 64.0) < 0), Number((xyAbs[1] - 64.0) < 0)); // sign bits for xs and ys (1 or 0)
    //outputNormal.xy		= (abs(xyAbs - 64.0) - xySigns) / 63.0;	// abs({nX, nY})
    outputNormal[0] = (Math.abs(xyAbs[0] - 64.0) - xySigns[0]) / 63.0; // abs({nX, nY})
    outputNormal[1] = (Math.abs(xyAbs[1] - 64.0) - xySigns[1]) / 63.0; // abs({nX, nY})
    //outputNormal.z		= 1.0 - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1
    outputNormal[2] = 1.0 - outputNormal[0] - outputNormal[1]; // Project onto x+y+z=1
    //outputNormal.xyz	= normalize(outputNormal.xyz);				// Normalize onto unit sphere
    normalize$5(outputNormal, outputNormal);
    //outputNormal.xy	 *= lerp(fOne.xx, -fOne.xx, xySigns);			// Restore x and y signs
    //outputNormal.z	 *= lerp(fOne.x, -fOne.x, ztSigns.x);			// Restore z sign
    outputNormal[0] *= (1 - xySigns[0]) - xySigns[0];
    outputNormal[1] *= (1 - xySigns[1]) - xySigns[1];
    return normalize$5(outputNormal, outputNormal);
}

/**
 * Source2 common file block
 */
class Source2FileBlock {
    file;
    type;
    offset;
    length;
    indices;
    vertices;
    keyValue;
    constructor(file, type, offset, length) {
        this.file = file;
        this.type = type;
        this.offset = offset;
        this.length = length;
    }
    getKeyValue(path) {
        let keyValue = this.keyValue;
        if (keyValue) {
            return keyValue.getValue(path);
        }
        return null;
    }
    getIndices(bufferId) {
        let indexBuffer = this.indices[bufferId];
        return indexBuffer ? indexBuffer.indices : [];
    }
    getVertices(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.vertices : [];
    }
    getNormalsTangents(bufferId) {
        function DecompressNormal(inputNormal, outputNormal) {
            //let outputNormal = vec3.create();
            //float2 ztSigns		= ( inputNormal.xy - 128.0 ) < 0;				// sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction
            const ztSigns = fromValues(Number((inputNormal[0] - 128.0) < 0), Number((inputNormal[1] - 128.0) < 0)); // sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction
            //float2 xyAbs		= abs( inputNormal.xy - 128.0 ) - ztSigns;		// 0..127
            const xyAbs = fromValues(Math.abs(inputNormal[0] - 128.0) - ztSigns[0], Math.abs(inputNormal[1] - 128.0) - ztSigns[1]); // 0..127
            //float2 xySigns		= ( xyAbs -  64.0 ) < 0;						// sign bits for xs and ys (1 or 0)
            const xySigns = fromValues(Number((xyAbs[0] - 64.0) < 0), Number((xyAbs[1] - 64.0) < 0)); // sign bits for xs and ys (1 or 0)
            //outputNormal.xy		= ( abs( xyAbs - 64.0 ) - xySigns ) / 63.0;	// abs({nX, nY})
            outputNormal[0] = (Math.abs(xyAbs[0] - 64.0) - xySigns[0]) / 63.0; // abs({nX, nY})
            outputNormal[1] = (Math.abs(xyAbs[1] - 64.0) - xySigns[1]) / 63.0; // abs({nX, nY})
            //outputNormal.z		= 1.0 - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1
            outputNormal[2] = 1.0 - outputNormal[0] - outputNormal[1]; // Project onto x+y+z=1
            //outputNormal.xyz	= normalize( outputNormal.xyz );				// Normalize onto unit sphere
            normalize$5(outputNormal, outputNormal);
            //outputNormal.xy	   *= lerp( fOne.xx, -fOne.xx, xySigns   );			// Restore x and y signs
            //outputNormal.z	   *= lerp( fOne.x,  -fOne.x,  ztSigns.x );			// Restore z sign
            outputNormal[0] *= (1 - xySigns[0]) - xySigns[0];
            outputNormal[1] *= (1 - xySigns[1]) - xySigns[1];
            return normalize$5(outputNormal, outputNormal);
        }
        function DecompressTangent(compressedTangent, outputTangent) {
            DecompressNormal(compressedTangent, outputTangent);
            var tSign = compressedTangent[1] - 128.0 < 0 ? -1.0 : 1.0;
            outputTangent[3] = tSign;
        }
        function DecompressNormal2(inputNormal) {
            let normals;
            let tangents;
            const SignBit = inputNormal & 1; // LSB bit
            const Tbits = (inputNormal >> 1) & 0x7ff; // 11 bits
            const Xbits = (inputNormal >> 12) & 0x3ff; // 10 bits
            const Ybits = (inputNormal >> 22) & 0x3ff; // 10 bits
            // Unpack from 0..1 to -1..1
            const nPackedFrameX = (Xbits / 1023.0) * 2.0 - 1.0;
            const nPackedFrameY = (Ybits / 1023.0) * 2.0 - 1.0;
            // Z is never given a sign, meaning negative values are caused by abs(packedframexy) adding up to over 1.0
            const derivedNormalZ = 1.0 - Math.abs(nPackedFrameX) - Math.abs(nPackedFrameY); // Project onto x+y+z=1
            const unpackedNormal = fromValues$4(nPackedFrameX, nPackedFrameY, derivedNormalZ);
            // If Z is negative, X and Y has had extra amounts (TODO: find the logic behind this value) added into them so they would add up to over 1.0
            // Thus, we take the negative components of Z and add them back into XY to get the correct original values.
            const negativeZCompensation = clamp(-derivedNormalZ, 0.0, 1.0); // Isolate the negative 0..1 range of derived Z
            const unpackedNormalXPositive = unpackedNormal[0] >= 0.0 ? 1.0 : 0.0;
            const unpackedNormalYPositive = unpackedNormal[1] >= 0.0 ? 1.0 : 0.0;
            unpackedNormal[0] += negativeZCompensation * (1 - unpackedNormalXPositive) + -negativeZCompensation * unpackedNormalXPositive; // mix() - x×(1−a)+y×a
            unpackedNormal[1] += negativeZCompensation * (1 - unpackedNormalYPositive) + -negativeZCompensation * unpackedNormalYPositive;
            let normal = normalize$5(unpackedNormal, unpackedNormal); // Get final normal by normalizing it onto the unit sphere
            normals = normal;
            // Invert tangent when normal Z is negative
            let tangentSign = (normal[2] >= 0.0) ? 1.0 : -1.0;
            // equal to tangentSign * (1.0 + abs(normal.z))
            let rcpTangentZ = 1.0 / (tangentSign + normal[2]);
            // Be careful of rearranging ops here, could lead to differences in float precision, especially when dealing with compressed data.
            const unalignedTangent = create$4();
            // Unoptimized (but clean) form:
            // tangent.X = -(normal.x * normal.x) / (tangentSign + normal.z) + 1.0
            // tangent.Y = -(normal.x * normal.y) / (tangentSign + normal.z)
            // tangent.Z = -(normal.x)
            unalignedTangent[0] = -tangentSign * (normal[0] * normal[0]) * rcpTangentZ + 1.0;
            unalignedTangent[1] = -tangentSign * ((normal[0] * normal[1]) * rcpTangentZ);
            unalignedTangent[2] = -tangentSign * normal[0];
            // This establishes a single direction on the tangent plane that derived from only the normal (has no texcoord info).
            // But it doesn't line up with the texcoords. For that, it uses nPackedFrameT, which is the rotation.
            // Angle to use to rotate tangent
            var nPackedFrameT = Tbits / 2047.0 * TWO_PI;
            // Rotate tangent to the correct angle that aligns with texcoords.
            //let tangent = unalignedTangent * Math.cos(nPackedFrameT) + Vector3.Cross(normal, unalignedTangent) * Math.sin(nPackedFrameT);
            let tangent = scale$5(create$4(), unalignedTangent, Math.cos(nPackedFrameT));
            const c = cross$2(create$4(), normal, unalignedTangent);
            scale$5(c, c, Math.sin(nPackedFrameT));
            add$5(tangent, tangent, c);
            tangents = fromValues$3(tangent[0], tangent[1], tangent[2], (SignBit == 0) ? -1.0 : 1.0); // Bitangent sign bit... inverted (0 = negative
            return [normals, tangents];
        }
        let vertexBuffer = this.vertices[bufferId];
        let normals = new Float32Array(vertexBuffer.normals);
        var normalArray = [];
        var tangentArray = [];
        const compressedNormal = create();
        const compressedTangent = create();
        let normalTemp = create$4();
        let tangentTemp = create$4();
        for (var i = 0, l = normals.length; i < l; i += 4) {
            if (!vertexBuffer.decompressTangentV2) {
                compressedNormal[0] = normals[i + 0] * 255.0;
                compressedNormal[1] = normals[i + 1] * 255.0;
                compressedTangent[0] = normals[i + 2] * 255.0;
                compressedTangent[1] = normals[i + 3] * 255.0;
                DecompressNormal(compressedNormal, normalTemp);
                DecompressTangent(compressedTangent, tangentTemp);
            }
            else {
                [normalTemp, tangentTemp] = DecompressNormal2(normals[i]);
            }
            normalArray.push(normalTemp[0]);
            normalArray.push(normalTemp[1]);
            normalArray.push(normalTemp[2]);
            tangentArray.push(tangentTemp[0]);
            tangentArray.push(tangentTemp[1]);
            tangentArray.push(tangentTemp[2]);
            tangentArray.push(1.0);
        }
        return [normalArray, tangentArray];
    }
    getCoords(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.coords : [];
    }
    getNormal(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.normals : [];
    }
    getTangent(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.tangents : [];
    }
    getBoneIndices(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.boneIndices : [];
    }
    getBoneWeight(bufferId) {
        let vertexBuffer = this.vertices[bufferId];
        return vertexBuffer ? vertexBuffer.boneWeight : [];
    }
}

function decodeLz4(reader, decompressBlobArray, compressedSize, uncompressedSize, outputIndex = 0) {
    reader.tell() + compressedSize;
    //let outputIndex = 0;
    let decodedeBytes = 0;
    let decodeMask = reader.getUint8();
    let readBytes = (decodeMask & 0xF0) >> 4;
    if (readBytes == 0xF) {
        let a = 0;
        do {
            a = reader.getUint8();
            readBytes += a;
        } while (a == 0xFF);
    }
    let decodeLen = decodeMask & 0xF;
    //let buffer = new Uint8Array(reader.buffer);
    decodeLoop: while (true) {
        //console.error(readBytes);
        let offset = reader.tell();
        while (readBytes--) {
            decompressBlobArray[outputIndex++] = reader.getUint8(offset++); //buffer[offset++];offset++
            ++decodedeBytes;
        }
        if (decodedeBytes >= uncompressedSize) {
            break decodeLoop;
        }
        let decodeOffset = reader.getUint16(offset);
        if (decodeLen == 0xF) {
            let a = 0;
            do {
                a = reader.getUint8();
                decodeLen += a;
            } while (a == 0xFF);
        }
        let decodeMask = reader.getUint8();
        let nextLen = decodeMask & 0xF;
        readBytes = (decodeMask & 0xF0) >> 4;
        if (readBytes == 0xF) {
            let a = 0;
            do {
                a = reader.getUint8();
                readBytes += a;
            } while (a == 0xFF);
        }
        for (let k = 0; k < decodeLen + 4; k++) {
            decompressBlobArray[outputIndex] = decompressBlobArray[outputIndex - decodeOffset];
            ++decodedeBytes;
            if (decodedeBytes >= uncompressedSize) {
                break decodeLoop;
            }
            ++outputIndex;
        }
        decodeLen = nextLen;
    }
    return decodedeBytes;
}

/**
 * Kv3Value
 */
class Kv3Value {
    t;
    v;
    constructor(type, value) {
        this.t = type;
        this.v = value;
    }
    exportAsText = function (linePrefix) {
        linePrefix = linePrefix ?? '';
        switch (this.t) {
            case 6:
                return linePrefix + '"' + this.v + '"';
            case 134:
                return linePrefix + 'resource:"' + this.v + '"';
        }
        return linePrefix + this.v;
    };
}

/**
 * Kv3Element
 */
class Kv3Element {
    setProperty(property, value) {
        this[property] = value;
    }
    exportAsText(linePrefix) {
        var out = [];
        var keys = Object.keys(this);
        var linePrefix2 = linePrefix + '\t';
        out.push(linePrefix);
        out.push('{\r\n');
        for (var i = 0; i < keys.length; i++) {
            var val = this[keys[i]];
            //console.log(keys[i]);
            // use val
            out.push(linePrefix2);
            out.push(keys[i]);
            out.push(' = ');
            // TODO: do this better
            if (val instanceof Kv3Value) {
                out.push(val.exportAsText());
            }
            else {
                out.push(val.exportAsText(linePrefix2));
            }
            out.push('\r\n');
        }
        out.push(linePrefix);
        out.push('}');
        return out.join('');
    }
}
class SourceKv3String {
    id;
    constructor(id) {
        this.id = id;
    }
}
class SourceKv3Value {
    value;
    type;
    constructor(type) {
        this.type = type;
    }
}

/**
 * Kv3Array
 */
class Kv3Array {
    properties = [];
    push(value) {
        this.properties.push(value);
    }
    exportAsText(linePrefix) {
        var out = [];
        var keys = this.properties;
        var linePrefix2 = linePrefix + '\t';
        out.push('\r\n');
        out.push(linePrefix);
        out.push('[\r\n');
        for (var i = 0; i < keys.length; i++) {
            var val = keys[i];
            out.push(val.exportAsText(linePrefix2));
            out.push(',\r\n');
        }
        out.push(linePrefix);
        out.push(']');
        return out.join('');
    }
}

/**
 * Kv3File
 */
class Kv3File {
    root = null;
    setRoot(root) {
        this.root = root;
    }
    exportAsText() {
        if (this.root) {
            return this.root.exportAsText('');
        }
        return null;
    }
    getValue(path) {
        var arr = path.split('.');
        var data = this.root;
        if (!data) {
            return null;
        }
        var sub;
        for (var i = 0; i < arr.length; i++) {
            sub = data[arr[i]];
            if (!sub) {
                return null;
            }
            if (sub instanceof Kv3Array) {
                data = sub.properties;
            }
            else {
                data = sub;
            }
        }
        if (data instanceof Kv3Value) {
            return data.v;
        }
        else {
            return data;
        }
    }
}

const DATA_TYPE_NULL = 0x01;
const DATA_TYPE_BOOL = 0x02;
const DATA_TYPE_INT64$1 = 0x03;
const DATA_TYPE_UINT64$1 = 0x04;
const DATA_TYPE_DOUBLE = 0x05;
const DATA_TYPE_STRING = 0x06;
const DATA_TYPE_BLOB = 0x07;
const DATA_TYPE_ARRAY = 0x08;
const DATA_TYPE_OBJECT = 0x09;
const DATA_TYPE_TYPED_ARRAY = 0x0A;
const DATA_TYPE_INT32 = 0x0B;
const DATA_TYPE_UINT32 = 0x0C;
const DATA_TYPE_TRUE = 0x0D;
const DATA_TYPE_FALSE = 0x0E;
const DATA_TYPE_INT_ZERO = 0x0F;
const DATA_TYPE_INT_ONE = 0x10;
const DATA_TYPE_DOUBLE_ZERO = 0x11;
const DATA_TYPE_DOUBLE_ONE = 0x12;
const DATA_TYPE_FLOAT$1 = 0x13;
const DATA_TYPE_BYTE$1 = 0x17;
const DATA_TYPE_TYPED_ARRAY2 = 0x18;
const DATA_TYPE_TYPED_ARRAY3 = 0x19;
const DATA_TYPE_RESOURCE = 0x86;
const BinaryKv3Loader = new (function () {
    class BinaryKv3Loader {
        getBinaryVkv3(binaryString) {
            let reader = new BinaryReader(binaryString);
            let binaryKv3 = new Kv3File();
            let stringDictionary = [];
            readStringDictionary(reader, stringDictionary);
            binaryKv3.setRoot(readElement(reader, stringDictionary));
            return binaryKv3;
        }
        getBinaryKv3(version, binaryString, singleByteCount, doubleByteCount, quadByteCount, eightByteCount, dictionaryTypeLength, blobCount, totalUncompressedBlobSize, compressedBlobReader, uncompressedBlobReader, compressionFrameSize, bufferId, stringDictionary, objectCount, arrayCount, buffer0) {
            let reader = new BinaryReader(binaryString);
            if (!stringDictionary) {
                stringDictionary = [];
            }
            //let offset = reader.byteLength - 4;//TODO: check last 4 bytes (0x00 0xDD 0xEE 0xFF)
            let offset;
            let byteCursor = 0;
            if (version >= 5 && bufferId == 1) {
                byteCursor = objectCount * 4;
            }
            let doubleCursor = Math.ceil((byteCursor + singleByteCount[bufferId]) / 2) * 2; //Math.ceil(byteCursor + singleByteCount[bufferId] / 2) * 2;
            let quadCursor = Math.ceil((doubleCursor + doubleByteCount[bufferId] * 2) / 4) * 4; //Math.ceil(singleByteCount / 4) * 4;
            let eightCursor = Math.ceil((quadCursor + quadByteCount[bufferId] * 4) / 8) * 8;
            if (version >= 5 && eightByteCount[bufferId] == 0) {
                // In this case, don't align cursor
                eightCursor = quadCursor + quadByteCount[bufferId] * 4;
            }
            //console.info(byteCursor, doubleCursor, quadCursor, eightCursor);
            let dictionaryOffset = eightCursor + eightByteCount[bufferId] * 8;
            if (version >= 5 && bufferId == 0) {
                dictionaryOffset = 0;
            }
            let uncompressedBlobSizeReader, compressedBlobSizeReader;
            const blobOffset = dictionaryOffset + dictionaryTypeLength;
            if (version >= 2 && blobCount != 0) {
                if (compressedBlobReader) {
                    let uncompressedLength = blobCount * 4;
                    uncompressedBlobSizeReader = new BinaryReader(reader, blobOffset, uncompressedLength);
                    compressedBlobSizeReader = new BinaryReader(reader, blobOffset + 4 + uncompressedLength);
                }
                else {
                    if (uncompressedBlobReader) {
                        uncompressedBlobSizeReader = new BinaryReader(reader, reader.byteLength - blobCount * 4 - 4, blobCount * 4);
                    }
                }
            }
            if (version == 1) { //v1
                offset = reader.byteLength - 4;
            }
            else if (version < 5) { //v2-v4
                offset = blobOffset;
            }
            let typeArray = [];
            let valueArray = [];
            if (version < 5) {
                do {
                    --offset;
                    let type = reader.getUint8(offset);
                    //typeArray.unshift(type);
                    if (type) {
                        typeArray.unshift(type);
                    }
                    else {
                        break;
                    }
                } while (offset >= 0);
            }
            else {
                if (bufferId == 1) {
                    reader.seek(dictionaryOffset);
                    for (let i = 0; i < dictionaryTypeLength; i++) {
                        let type = reader.getUint8();
                        if (type) {
                            typeArray.push(type);
                        }
                    }
                }
            }
            let byteReader = new BinaryReader(reader);
            let doubleReader = new BinaryReader(reader);
            let quadReader = new BinaryReader(reader);
            let eightReader = new BinaryReader(reader);
            let byteReaderBuf0;
            let doubleReaderBuf0;
            let quadReaderBuf0;
            let eightReaderBuf0;
            byteReader.seek(byteCursor);
            doubleReader.seek(doubleCursor);
            quadReader.seek(quadCursor);
            eightReader.seek(eightCursor);
            reader.seek(); // skip blob data
            const readers = {};
            let objectsSizeReader = quadReader;
            if (bufferId == 0) {
                // In v5, strings are in buffer 0
                let stringCount = quadReader.getUint32();
                reader.seek(dictionaryOffset);
                readStringDictionary(reader, stringDictionary, stringCount);
                if (version >= 5) {
                    return stringDictionary;
                }
            }
            else {
                objectsSizeReader = new BinaryReader(reader);
                let reader0 = new BinaryReader(buffer0);
                let byteCursorBuf0 = 0;
                let doubleCursorBuf0 = Math.ceil(singleByteCount[0] / 2) * 2;
                let quadCursorBuf0 = Math.ceil((doubleCursorBuf0 + doubleByteCount[0] * 2) / 4) * 4;
                let eightCursorBuf0 = Math.ceil((quadCursorBuf0 + quadByteCount[0] * 4) / 8) * 8;
                //console.info('cursor buff 0', byteCursorBuf0, doubleCursorBuf0, quadCursorBuf0, eightCursorBuf0)
                byteReaderBuf0 = new BinaryReader(reader0);
                doubleReaderBuf0 = new BinaryReader(reader0);
                quadReaderBuf0 = new BinaryReader(reader0);
                eightReaderBuf0 = new BinaryReader(reader0);
                byteReaderBuf0.seek(byteCursorBuf0);
                doubleReaderBuf0.seek(doubleCursorBuf0);
                quadReaderBuf0.seek(quadCursorBuf0 + 4); // Eat a quad (string dictionnary length)
                eightReaderBuf0.seek(eightCursorBuf0);
                readers.reader1 = byteReaderBuf0;
                readers.reader2 = doubleReaderBuf0;
                readers.reader4 = quadReaderBuf0;
                readers.reader8 = eightReaderBuf0;
            }
            let decompressBlobBuffer;
            let decompressBlobArray;
            if (compressedBlobReader) { //if a compressed reader is provided, we have to uncompress the blobs
                decompressBlobBuffer = new ArrayBuffer(totalUncompressedBlobSize);
                decompressBlobArray = new Uint8Array(decompressBlobBuffer);
                decompressBlobArray.decompressOffset = 0;
            }
            let rootElement = readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, false, compressionFrameSize, readers);
            // return it in a suitable format
            let binaryKv3 = new Kv3File();
            binaryKv3.setRoot(binaryKv32KV3(rootElement, stringDictionary));
            return binaryKv3;
        }
    }
    return BinaryKv3Loader;
}());
function readStringDictionary(reader, stringDictionary, stringCount) {
    stringCount = stringCount ?? reader.getUint32();
    for (var i = 0; i < stringCount; i++) {
        stringDictionary.push(reader.getNullString());
    }
}
function readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, elementType, isArray, compressionFrameSize, readers0) {
    function shiftArray() {
        let elementType = typeArray.shift();
        if (elementType == DATA_TYPE_RESOURCE) {
            typeArray.shift();
        }
        return elementType;
    }
    elementType = elementType || shiftArray() /*typeArray.shift()*/;
    if (elementType == undefined) {
        return;
    }
    let count;
    let elements;
    switch (elementType) {
        case DATA_TYPE_NULL:
            return null;
        case DATA_TYPE_BOOL:
            if (isArray) {
                return byteReader.getUint8() ? true : false;
            }
            else {
                let value = new SourceKv3Value(elementType);
                valueArray.push(value);
                value.value = byteReader.getUint8() ? true : false;
                return value;
            }
        case DATA_TYPE_INT64$1:
            if (isArray) {
                return eightReader.getBigInt64();
            }
            else {
                let value = new SourceKv3Value(elementType);
                value.value = eightReader.getBigInt64();
                valueArray.push(value);
                return value;
            }
        case DATA_TYPE_UINT64$1:
            if (isArray) {
                return eightReader.getBigUint64();
            }
            else {
                let value = new SourceKv3Value(elementType);
                value.value = eightReader.getBigUint64();
                valueArray.push(value);
                return value;
            }
        case DATA_TYPE_DOUBLE:
            if (isArray) {
                return eightReader.getFloat64();
            }
            else {
                let value = new SourceKv3Value(elementType);
                value.value = eightReader.getFloat64();
                valueArray.push(value);
                return value;
            }
        case DATA_TYPE_BYTE$1:
            if (isArray) {
                return byteReader.getInt8();
            }
            else {
                let value = new SourceKv3Value(elementType);
                value.value = byteReader.getInt8();
                valueArray.push(value);
                return value;
            }
        case DATA_TYPE_STRING:
            return new SourceKv3String(quadReader.getInt32());
        case DATA_TYPE_BLOB:
            if (blobCount == 0) {
                count = quadReader.getUint32();
                elements = [];
                for (let i = 0; i < count; i++) {
                    elements.push(byteReader.getUint8());
                }
                return elements;
            }
            else {
                if (compressedBlobReader) { //if we have a decompress buffer, that means we have to decompress the blobs
                    let uncompressedBlobSize = uncompressedBlobSizeReader.getUint32();
                    //let decompressBuffer = new ArrayBuffer(uncompressedBlobSize);
                    var decompressArray = new Uint8Array(decompressBlobBuffer, decompressBlobArray.decompressOffset, uncompressedBlobSize);
                    /*
                    TODO: test blobs version 5 compression method 1 (lz4)
                    let compressedBlobSize: number;
                    if (version < 5) {
                        compressedBlobSize = compressedBlobSizeReader.getUint16();
                    } else {
                        compressedBlobSize = quadReader.getUint32();
                    }*/
                    while (true) {
                        let compressedBlobSize = compressedBlobSizeReader.getUint16();
                        if (uncompressedBlobSize > compressionFrameSize) {
                            const uncompressedFrameSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, compressionFrameSize, decompressBlobArray.decompressOffset);
                            decompressBlobArray.decompressOffset += uncompressedFrameSize;
                            uncompressedBlobSize -= uncompressedFrameSize;
                        }
                        else {
                            uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize, decompressBlobArray.decompressOffset);
                            decompressBlobArray.decompressOffset += uncompressedBlobSize;
                            break;
                        }
                    }
                    /*if (uncompressedBlobSize > compressionFrameSize) {
                        let uncompressedBlobSize2;
                        uncompressedBlobSize2 = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, compressionFrameSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize2;
                        uncompressedBlobSize2 = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize - compressionFrameSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize2;
                        //uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize, decompressBlobArray.decompressOffset);
                    } else {
                        uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize;
                    }*/
                    return decompressArray;
                }
                else {
                    if (uncompressedBlobReader) { //blobs have already been uncompressed
                        let uncompressedBlobSize = uncompressedBlobSizeReader.getUint32();
                        return uncompressedBlobReader.getBytes(uncompressedBlobSize);
                    }
                    else {
                        //should not happend
                        throw 'Missing reader';
                    }
                }
            }
        case DATA_TYPE_ARRAY:
            count = quadReader.getUint32();
            elements = [];
            for (let i = 0; i < count; i++) {
                elements.push(readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, true, compressionFrameSize, readers0));
            }
            return elements;
        case DATA_TYPE_OBJECT:
            count = objectsSizeReader.getUint32();
            //elements = new Kv3Element();
            elements = new Map();
            for (let i = 0; i < count; i++) {
                let nameId = quadReader.getUint32();
                let element = readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, false, compressionFrameSize, readers0);
                elements.set(nameId, element);
                //elements.setProperty(nameId, element);
            }
            return elements;
        case DATA_TYPE_TYPED_ARRAY:
            count = quadReader.getUint32();
            let subType = shiftArray() /*typeArray.shift()*/;
            elements = [];
            for (let i = 0; i < count; i++) {
                elements.push(readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType, true, compressionFrameSize, readers0));
            }
            return elements;
        case DATA_TYPE_INT32:
            return quadReader.getInt32();
        case DATA_TYPE_UINT32:
            return quadReader.getUint32();
        case DATA_TYPE_TRUE:
            return true;
        case DATA_TYPE_FALSE:
            return false;
        case DATA_TYPE_INT_ZERO:
            return 0;
        case DATA_TYPE_INT_ONE:
            return 1;
        case DATA_TYPE_DOUBLE_ZERO:
            return 0.0;
        case DATA_TYPE_DOUBLE_ONE:
            return 1.0;
        case DATA_TYPE_FLOAT$1:
            if (isArray) {
                return quadReader.getFloat32();
            }
            else {
                let value = new SourceKv3Value(elementType);
                value.value = quadReader.getFloat32();
                valueArray.push(value);
                return value;
            }
        case DATA_TYPE_TYPED_ARRAY2:
            count = byteReader.getUint8();
            const subType2 = shiftArray() /*typeArray.shift()*/;
            elements = [];
            for (let i = 0; i < count; i++) {
                elements.push(readBinaryKv3Element(version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType2, true, compressionFrameSize, readers0));
            }
            return elements;
        case DATA_TYPE_TYPED_ARRAY3:
            count = byteReader.getUint8();
            const subType3 = shiftArray() /*typeArray.shift()*/;
            elements = [];
            for (let i = 0; i < count; i++) {
                elements.push(readBinaryKv3Element(version, readers0.reader1, readers0.reader2, readers0.reader4, readers0.reader8, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType3, true, compressionFrameSize, readers0));
            }
            return elements;
        case DATA_TYPE_RESOURCE:
            return new SourceKv3String(quadReader.getInt32());
        default:
            console.error('Unknow element type : ', elementType);
    }
}
function binaryKv32KV3(elementKv3, stringDictionary) {
    let element;
    if (elementKv3 instanceof Map || elementKv3 instanceof Array) {
        if (elementKv3 instanceof Map) {
            element = new Kv3Element();
        }
        else {
            element = [];
        }
        function iterateMap(value, key, map) {
            let newKey;
            if (elementKv3 instanceof Map) {
                newKey = stringDictionary[key];
            }
            if (value instanceof Map) {
                value = binaryKv32KV3(value, stringDictionary);
            }
            else if (value instanceof SourceKv3String) {
                value = stringDictionary[value.id];
            }
            else if (value instanceof Array) {
                value = binaryKv32KV3(value, stringDictionary);
            }
            else if (value instanceof SourceKv3Value) {
                value = value.value;
            }
            if (elementKv3 instanceof Map) {
                element.setProperty(newKey, value);
            }
            else {
                element[key] = value;
            }
        }
        elementKv3.forEach(iterateMap);
    }
    return element;
}
function readElement(reader, stringDictionary, occurences) {
    var type = reader.getUint8();
    //console.log(type);
    switch (type) {
        /*
        kv element:
        2: bool (len 1)
        3:int (len 8)
        5:float (len 8)
        6: string (len 4, index to string dict)
        8:array (len 4 + content)
        9:element
        uint32: properties count
        propertie index uint32
        property type uint8
        property value (len depends on type)


        86: resource(len 1 + 4, index to string dict)*/
        case 0:
            break;
        case 1:
            return null;
        case 2: // Bool
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(reader.getUint8() ? true : false);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                return reader.getUint8() ? true : false; //new SE2Kv3Value(type, reader.getUint8() ? true:false);
            }
        case 3: // Int 64
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    let int64 = reader.getBigInt64(); //TODO: handle int64
                    arr.push(int64 /*(int64.hi << 32) + int64.lo*/);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                let int64 = reader.getBigInt64(); //TODO: handle int64
                return int64; //(int64.hi << 32) + int64.lo;//new SE2Kv3Value(type, (int64.hi << 32) + int64.lo);
            }
        case 5: // Float 64
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(reader.getFloat64());
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                return reader.getFloat64(); //new SE2Kv3Value(type, reader.getFloat64());
            }
        case 6: // String
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    arr.push(propertyName);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                propertyIndex = reader.getUint32();
                propertyName = stringDictionary[propertyIndex];
                return propertyName; //new SE2Kv3Value(type, propertyName);
            }
        case 0x07: // byte array
            var propertiesCount = reader.getUint32();
            var element = []; //new Kv3Array();
            for (let i = 0; i < propertiesCount; i++) {
                element.push(reader.getUint8());
            }
            return element;
        case 8: // Array
            var propertiesCount = reader.getUint32();
            var element = []; //new Kv3Array();
            var propertyName = null;
            var propertyIndex = null;
            var property = null;
            for (var i = 0; i < propertiesCount; i++) {
                //propertyIndex = reader.getUint32();
                //propertyName = stringDictionary(propertyIndex);
                property = readElement(reader, stringDictionary);
                //element.setProperty(property);
                element.push(property);
            }
            return element;
        case 9: // Element
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    var propertiesCount = reader.getUint32();
                    let element = new Kv3Element();
                    var propertyName = null;
                    var propertyIndex = null;
                    var property = null;
                    for (var ii = 0; ii < propertiesCount; ii++) {
                        propertyIndex = reader.getUint32();
                        propertyName = stringDictionary[propertyIndex];
                        property = readElement(reader, stringDictionary);
                        element.setProperty(propertyName, property);
                    }
                    arr.push(element);
                }
                return arr;
            }
            else {
                var propertiesCount = reader.getUint32();
                let element = new Kv3Element();
                var propertyName = null;
                var propertyIndex = null;
                var property = null;
                for (var i = 0; i < propertiesCount; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    property = readElement(reader, stringDictionary);
                    element.setProperty(propertyName, property);
                }
                return element;
            }
        case 0x0A: // vector
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    let count = reader.getUint32();
                    arr.push(readElement(reader, stringDictionary, count));
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                let count = reader.getUint32();
                return readElement(reader, stringDictionary, count);
            }
        case 0x0B: // int32
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(reader.getInt32());
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                return reader.getInt32(); //new SE2Kv3Value(type, reader.getInt32());
            }
        case 0x10: // ????
        case 0x12: // ????
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(1);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                return 1; //new SE2Kv3Value(type, 1);
            }
        case 0x11: // ????
        case 0x0F: // ????
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(0);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                return 0; //new SE2Kv3Value(type, 0);
            }
        case 0x0D: // ????
            //reader.skip(4);//????
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(true);
                }
                return arr;
            }
            else {
                return true;
            }
        case 0x0E: // ????
            //reader.skip(4);//????
            if (occurences) {
                let arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(false);
                }
                return arr;
            }
            else {
                return false;
            }
        case 134: // Resource
            if (occurences) {
                let arr = [];
                reader.getUint8(); //todo: rename variable
                for (let i = 0; i < occurences; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    arr.push(propertyName);
                }
                return arr; //new SE2Kv3Value(type, arr);
            }
            else {
                reader.getUint8(); //todo: rename variable
                propertyIndex = reader.getUint32();
                propertyName = stringDictionary[propertyIndex];
                //console.error(propertyName, test);
                return propertyName; //new SE2Kv3Value(type, propertyName);
            }
        default:
            console.error('Unknown value type : ' + type);
    }
}

class Source2SpriteSheetFrame {
    coords = create$3();
    duration = 0;
}
class Source2SpriteSheetSequence {
    duration = 0;
    frames = [];
    addFrame() {
        let frame = new Source2SpriteSheetFrame();
        this.frames.push(frame);
        return frame;
    }
}
class Source2SpriteSheet {
    sequences = [];
    addSequence() {
        let sequence = new Source2SpriteSheetSequence();
        this.sequences.push(sequence);
        return sequence;
    }
    getFrame(sequenceId, frame) {
        let sequence = this.sequences[sequenceId] ?? this.sequences[0];
        if (sequence) {
            frame = (frame % sequence.frames.length) << 0;
            return sequence.frames[frame];
        }
        return null;
    }
}

function zstd(imports){return _loadWasmModule(0, null, 'AGFzbQEAAAABvAEYYAF/AX9gAn9/AX9gA39/fwF/YAV/f39/fwF/YAF/AGACf38AYAN/f38AYAR/f39/AX9gBn9/f39/fwF/YAABf2AHf39/f39/fwF/YAd/f39/f39/AGABfwF+YAN/fn8BfmACfn4BfmAAAGAFf39/f38AYAl/f39/f39/f38AYAp/f39/f39/f39/AGACf34AYAh/f39/f39/fwF/YA9/f39/f39/f39/f39/f38Bf2ACfn4Bf2ACf38BfgInAQNlbnYfZW1zY3JpcHRlbl9ub3RpZnlfbWVtb3J5X2dyb3d0aAAEA4sBiQEAAQAFAgECDhMAAgUABQIAAAABAQUGBAMFCwUABg4UFQACBRcCAAcCAAQGDwoDEAkGAwMDAwMHBwADBgQEBwcBAwgFAQUCAAEMBgwKAwoKAAYABwsCBAUIBAMIAwEIAxIRCQgJAQEBBgEWAgIHAAcDAggEBgEEAAkABgIAAQEABQ0BAAQHCAQEAAQFAXABBQUFBAEAgAIGCQF/AUHQrMACCwejAQsGbWVtb3J5AgANY3JlYXRlX2J1ZmZlcgCJAQ5kZXN0cm95X2J1ZmZlcgBzD2RlY29tcHJlc3NfWlNURABtCmRlY29tcHJlc3MAaRJnZXRfcmVzdWx0X3BvaW50ZXIAZA9nZXRfcmVzdWx0X3NpemUAYgZfc3RhcnQALAlzdGFja1NhdmUAeApzdGFja0FsbG9jAHcMc3RhY2tSZXN0b3JlAHYJCwEAQQELBCyBAUZ/Cu3HAokBCAAgAEGIf0sLGQAgACgCACAAKAIEQR9xdEEAIAFrQR9xdgt+AQR/QQMhASAAKAIEIgNBIE0EQCAAKAIIIgEgACgCEE8EQCAAEA0PCyAAKAIMIgIgAUYEQEEBQQIgA0EgSRsPCyAAIAEgASACayADQQN2IgQgASAEayACSSIBGyICayIENgIIIAAgAyACQQN0azYCBCAAIAQoAAA2AgALIAELFgAgACABKQAANwAAIAAgASkACDcACAuBBAEDfyACQYAETwRAIAAgASACEHogAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCACQQFIBEAgACECDAELIABBA3FFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANPDQEgAkEDcQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyADQXxqIgQgAEkEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACxsBAX8gACABEAIhAiAAIAAoAgQgAWo2AgQgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQEGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQECACQQN0ams2AgQgAgshACABQs/W077Sx6vZQn4gAHxCH4lCh5Wvr5i23puef34LCQAgACABNwAACx0BAX8gACgCCCAAKAIMRgR/IAAoAgRBIEYFQQALC/MCAgJ/AX4CQCACRQ0AIAAgAmoiA0F/aiABOgAAIAAgAToAACACQQNJDQAgA0F+aiABOgAAIAAgAToAASADQX1qIAE6AAAgACABOgACIAJBB0kNACADQXxqIAE6AAAgACABOgADIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQXxq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mCwtAABBBHENBAJAAkBB9CgoAgAiAwRAQZwsIQADQCAAKAIAIgggA00EQCAIIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABARIgFBf0YNBSACIQZBuCwoAgAiAEF/aiIDIAFxBEAgAiABayABIANqQQAgAGtxaiEGCyAGIAVNIAZB/v///wdLcg0FQZQsKAIAIgAEQEGMLCgCACIDIAZqIgcgA00gByAAS3INBgsgBhARIgAgAUcNAQwHCyAGIAFrIAdxIgZB/v///wdLDQQgBhARIgEgACgCACAAKAIEakYNAyABIQALIABBf0YgBUEwaiAGTXJFBEBBvCwoAgAiASAEIAZrakEAIAFrcSIBQf7///8HSwRAIAAhAQwHCyABEBFBf0cEQCABIAZqIQYgACEBDAcLQQAgBmsQERoMBAsgACIBQX9HDQUMAwtBACEEDAcLQQAhAQwFCyABQX9HDQILQZgsQZgsKAIAQQRyNgIACyACQf7///8HSw0BIAIQESIBQQAQESIATyABQX9GciAAQX9Gcg0BIAAgAWsiBiAFQShqTQ0BC0GMLEGMLCgCACAGaiIANgIAIABBkCwoAgBLBEBBkCwgADYCAAsCQAJAAkBB9CgoAgAiAwRAQZwsIQADQCABIAAoAgAiAiAAKAIEIgRqRg0CIAAoAggiAA0ACwwCC0HsKCgCACIAQQAgASAATxtFBEBB7CggATYCAAtBACEAQaAsIAY2AgBBnCwgATYCAEH8KEF/NgIAQYApQbQsKAIANgIAQagsQQA2AgADQCAAQQN0IgJBjClqIAJBhClqIgM2AgAgAkGQKWogAzYCACAAQQFqIgBBIEcNAAtB6CggBkFYaiIAQXggAWtBB3FBACABQQhqQQdxGyICayIDNgIAQfQoIAEgAmoiAjYCACACIANBAXI2AgQgACABakEoNgIEQfgoQcQsKAIANgIADAILIAAtAAxBCHEgASADTXIgAiADS3INACAAIAQgBmo2AgRB9CggA0F4IANrQQdxQQAgA0EIakEHcRsiAGoiATYCAEHoKEHoKCgCACAGaiICIABrIgA2AgAgASAAQQFyNgIEIAIgA2pBKDYCBEH4KEHELCgCADYCAAwBCyABQewoKAIAIgRJBEBB7CggATYCACABIQQLIAEgBmohAkGcLCEAAkACQAJAAkACQAJAA0Ag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QQAhBCAIQQAgCEEAShshByAAIQEDQCAEIAdGDQIgDyABQQF0aiICIAwgBCANamotAAAgCkH/AXEQJCIREAkgAkEIaiAREAkgBEEBaiEEIAFBCGohAQwAAAsAC0EAIQkgCEEAIAhBAEobIQcgACEBA0AgByAJRg0BIA8gAUEBdGohAkEAIQQgDCAJIA1qai0AACAKQf8BcRAkIREDQCAEIAtIBEAgAiAEQQF0aiIGIBEQCSAGQQhqIBEQCSAGQRBqIBEQCSAGQRhqIBEQCSAEQRBqIQQMAQsLIAlBAWohCSABIAtqIQEMAAALAAsgDkEBaiEOIAggDWohDSAIIAtsIABqIQAgBSgCDCEJDAAACwAFIAMgBEECdCICaigCACEAIAIgCmogATYCACAEQQFqIQQgACABaiEBDAELAAALAAsgECEECyAFQRBqJAAgBAscACABIAMgASADSRsiAQRAIAAgAiABEAUaCyABCwwAIAAoAvzpAUEHRgvaAQEBfyAAEDkhBQJAAkAgACgC6OsBRQRAAn8gBQRAIAAoAsjrASEBQQAMAQsgACgCxOsBIAAoAsjrASIBawshAiAAIAAoAsDrASABaiACIAMgBBBBIgMQAQ0CIAMgBXJFBEAgAEECNgKs6wEMAgsgAEEENgKs6wEgACAAKALI6wEgA2o2AszrAQwBCwJ/IAUEQCABKAIAIQVBAAwBCyACIAEoAgAiBWsLIQIgACAFIAIgAyAEEEEiAxABDQEgASABKAIAIANqNgIAIABBAjYCrOsBC0EAIQMLIAMLQQECfyAAIAAoAqzpASIDNgK46QEgACgCsOkBIQQgACABNgKw6QEgACABIAJqNgKs6QEgACABIAQgA2tqNgK06QELsgEBAX8gACAAKALk6gEQHDYCvOkBIABCADcCrOkBIABBtOkBakIANwIAIABCADcD6OkBIABB8OkBakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOsBIABCADcDgOoBIABCAzcD+OkBIABBrNABakHgDykCADcCACAAQbTQAWpB6A8oAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALTQEBfwJAIAAoApTrAUUNACAAKAKk6wEgAEHc6QFqKAIAEGYiAUUNACAAECogAEF/NgKg6wEgACAB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QSAgBGsQKyAAIAApAwggAikAABAINwMIIAAgACkDECAAKQAwEAg3AxAgACAAKQMYIAApADgQCDcDGCAAIAApAyAgAEFAaykAABAINwMgIAAoAkghAiAAQQA2AkggASACa0EgaiEBCyABQSBqIANLCwRAIAEhAgwBCyADQWBqIQQgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAghCCAHIAEpAAgQCCEHIAYgASkAEBAIIQYgBSABKQAYEAghBSABQSBqIgIhASACIARNDQALIAAgBTcDICAAIAY3AxggACAHNwMQIAAgCDcDCAsgAiADTw0BIABBKGogAiADIAJrIgMQKwsgACADNgJICwviAwICfwF+IABBBGohAgJAIABBB3FFBEAgACEBQsnP2bLx5brqJyEDA0AgAUEIaiIAIAJNBEBCACABKQMAEAggA4VCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whAyAAIQEMAQsLAkAgAUEEaiIAIAJLBEAgASEADAELIAE1AgBCh5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACTw0CIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwAAAsACyAAIQFCyc/ZsvHluuonIQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCCADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACTw0BIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwAAAsACyADQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4ULoQMBA39BuH8hBwJAIAVFDQAgBCwAACIIQf8BcSEJAkAgCEF/TARAIAlBgn9qQQF2IgggBU8NAkFsIQcgCUGBf2oiBkGAAk8NAiAEQQFqIQRBACEFA0AgBSAGTwRAIAYhByAIIQkMAwUgACAFaiAEIAVBAXZqIgctAABBBHY6AAAgACAFQQFyaiAHLQAAQQ9xOgAAIAVBAmohBQwBCwAACwALIAkgBU8NASAAIARBAWogCSAGEIUBIgcQAQ0BCyAHIQZBACEFIAFBAEE0EAshAUEAIQQDQCAFIAZHBEAgACAFaiIHLQAAIghBC0sEQEFsDwUgASAIQQJ0aiIIIAgoAgBBAWo2AgAgBUEBaiEFQQEgBy0AAHRBAXUgBGohBAwCCwALC0FsIQcgBEUNACAEEBBBAWoiBUEMSw0AIAMgBTYCAEEBQQEgBXQgBGsiAxAQIgR0IANHDQAgACAGaiAEQQFqIgA6AAAgASAAQQJ0aiIAIAAoAgBBAWo2AgAgASgCBCIAQQJJIABBAXFyDQAgAiAGQQFqNgIAIAlBAWohBwsgBwuiBQEMfyMAQRBrIgskAAJ/IARBB00EQCALQgA3AwggC0EIaiADIAQQBRogACABIAIgC0EIakEIEBgiAEFsIAAQARsgACAAIARLGwwBCyAAQQAgASgCAEEBaiIOQQF0EAshD0FUIAMoAAAiBkEPcSIFQQpLDQAaIAIgBUEFajYCACADIARqIgBBfGohCSAAQXlqIQwgBUEGaiENQQQhACAGQQR2IQZBICAFdCIKQQFyIQhBACECIAMhBANAAkAgBwRAA0AgBkGAgICAeHJB/////wdzaCIFQRhPBEAgDCAEayEFIAkgBEEDaiAMIARJIgYbIgQoAAAgACAFQQN0a0EfcSAAIAYbIgB2IQYgAkEkaiECDAELCyAAIAVBfnEiB2pBAmohACAFQQF2QQNsIAJqIAYgB3ZBA3FqIgIgDk8NAQJ/IABBB3EgBCAMS0EAIAQgAEEDdWoiBSAJSxtFDQAaIAAgCSIFIARrQQN0a0EfcQshACAFKAAAIAB2IQYgBSEECwJ/IA1Bf2ogBiAKQX9qcSIFIApBAXRBf2oiByAIayIQSQ0AGiAGIAdxIgVBACAQIAUgCkgbayEFIA0LIQcgDyACQQF0aiAFQX9qIgY7AQAgAkEBaiECIAAgB2ohAEEBIAVrIAYgBUEAShsgCGoiCCAKSARAIAhBAkgNAUEBIAgQECIFdCEKIAVBAWohDQsgAiAOTw0AAn8gAEEHcSAEIAxLQQAgBCAAQQN1aiIFIAlLG0UNABogACAJIgUgBGtBA3RrQR9xCyEAIAZFIQcgBSgAACAAdiEGIAUhBAwBCwtBbCAIQQFHDQAaQVAgAiAOSw0AGkFsIABBIEoNABogASACQX9qNgIAIAQgAEEHakEDdWogA2sLIQAgC0EQaiQAIAAL/wwCDX8FfiMAQeAAayIHJAAgByAAKALw6gEiCDYCTCABIAJqIQwgCCAAKAKA6wFqIRACQAJAIAVFBEAgASELDAELIAAoArjpASERIAAoArTpASESIAAoArDpASENIABBATYChOoBQQAhCANAIAhBA0ZFBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCPCAIQQFqIQgMAQsLQWwhDiAHQRBqIAMgBBAHEAENASAHQSRqIAdBEGogACgCABAWIAdBLGogB0EQaiAAKAIIEBYgB0E0aiAHQRBqIAAoAgQQFiAMQWBqIRMgASELA0AgBygCKCAHKAIkQQN0aikCACIUQhCIp0H/AXEhCiAHKAI4IAcoAjRBA3RqKQIAIhVCEIinQf8BcSEJIAcoAjAgBygCLEEDdGopAgAiFkIgiKchAyAVQiCIIRcgFEIgiKchCAJAIBZCEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCADIAdBEGogAkEgIAcoAhRrIgMgAyACSxsiAxAGIAIgA2siAnRqIQQgB0EQahADGiACRQ0BIAdBEGogAhAGIARqIQQMAQsgB0EQaiACEAYgA2ohBCAHQRBqEAMaCyAHKQI8IRggByAENgI8IAcgGDcDQAwBCwJAIAJFBEAgCARAIAcoAjwhBAwDCyAHKAJAIQQMAQsCfyAHQRBqQQEQBiADIAhFamoiAkEDRgRAIAcoAjxBf2oMAQsgAkECdCAHaigCPAsiA0UgA2ohBCACQQFHBEAgByAHKAJANgJECwsgByAHKAI8NgJAIAcgBDYCPAsgF6chAyAJBEAgB0EQaiAJEAYgA2ohAwsgCSAKakEUTwRAIAdBEGoQAxoLIAoEQCAHQRBqIAoQBiAIaiEICyAHQRBqEAMaIAcgBygCECICQQAgFEIYiKdB/wFxIgogBygCFGoiCWtBH3F2IApBAnRBwCVqKAIAcSAUp0H//wNxajYCJCAHIAkgFUIYiKdB/wFxIgpqIgk2AhQgByAKQQJ0QcAlaigCACACQQAgCWtBH3F2cSAVp0H//wNxajYCNCAHQRBqEAMaIAcgFkIYiKdB/wFxIgIgBygCFGoiCjYCFCAHIAJBAnRBwCVqKAIAIAcoAhBBACAKa0EfcXZxIBanQf//A3FqNgIsIAcgCDYCUCAHKAJMIQIgByAENgJYIAcgAzYCVAJAAkACQCALIAMgCGoiCmogE0sNACACIAhqIg8gEEsNACAMIAtrIApBIGpPDQELIAcgBygCWDYCCCAHIAcpA1A3AwAgCyAMIAcgB0HMAGogECANIBIgERAfIQoMAQsgCCALaiEJIAsgAhAEAkAgCEERSQ0AIAtBEGogAkEQaiICEAQgCEFwakERSA0AIAtBIGohCANAIAggAkEQahAEIAhBEGogAkEgaiICEAQgCEEgaiIIIAlJDQALCyAJIARrIQIgByAPNgJMIAQgCSANa0sEQCAEIAkgEmtLBEBBbCEKDAILIBEgAiANayICaiIIIANqIBFNBEAgCSAIIAMQDxoMAgsgCSAIQQAgAmsQDyEIIAcgAiADaiIDNgJUIAggAmshCSANIQILIARBEE8EQCAJIAIQBCADQRFIDQEgAyAJaiEDIAlBEGohCANAIAggAkEQahAEIAhBEGogAkEgaiICEAQgCEEgaiIIIANJDQALDAELAkAgBEEHTQRAIAkgAi0AADoAACAJIAItAAE6AAEgCSACLQACOgACIAkgAi0AAzoAAyAJQQRqIAIgBEECdCIDQcAmaigCAGoiAhAZIAIgA0HgJmooAgBrIQIgBygCVCEDDAELIAkgAhAMCyADQQlJDQAgAyAJaiEPIAlBCGoiBCACQQhqIghrQQ9MBEADQCAEIAgQDCAIQQhqIQggBEEIaiIEIA9JDQAMAgALAAsgBCAIEAQgA0EZSA0AIAlBGGohAgNAIAIgCEEQahAEIAJBEGogCEEgaiIIEAQgAkEgaiICIA9JDQALCyAKEAEEQCAKIQ4MAwsgCiALaiELIAdBEGoQAyECIAVBf2oiBQ0ACyACQQJJDQFBACEIA0AgCEEDRkUEQCAAIAhBAnQiAmpBrNABaiACIAdqKAI8NgIAIAhBAWohCAwBCwsgBygCTCEIC0G6fyEOIBAgCGsiACAMIAtrSw0AIAsEfyALIAggABAFIABqBUEACyABayEOCyAHQeAAaiQAIA4LnhkCE38FfiMAQeABayIHJAAgByAAKALw6gEiCDYCzAEgASACaiERIAggACgCgOsBaiETIAEhCQJAIAUEQCAAKAK46QEhEiAAKAK06QEhFSAAKAKw6QEhECAAQQE2AoTqAUEAIQgDQCAIQQNGRQRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AlQgCEEBaiEIDAELC0FsIQtBACEIAkACQCAHQShqIAMgBBAHEAENACAFQQggBUEISBshFyAHQTxqIAdBKGogACgCABAWIAdBxABqIAdBKGogACgCCBAWIAdBzABqIAdBKGogACgCBBAWIAEgEGshDUEAIQMDQCAHQShqEANBAksgAyAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIaQhCIp0H/AXEhBCAHKAJQIAcoAkxBA3RqKQIAIhtCEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiHEIgiKchCiAbQiCIIR0gGkIgiKchCAJAIBxCEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAKIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAGIAIgCmsiAnRqIQogB0EoahADGiACRQ0BIAdBKGogAhAGIApqIQoMAQsgB0EoaiACEAYgCmohCiAHQShqEAMaCyAHKQJUIR4gByAKNgJUIAcgHjcDWAwBCwJAIAJFBEAgCARAIAcoAlQhCgwDCyAHKAJYIQoMAQsCfyAHQShqQQEQBiAKIAhFamoiDEEDRgRAIAcoAlRBf2oMAQsgDEECdCAHaigCVAsiAkUgAmohCiAMQQFHBEAgByAHKAJYNgJcCwsgByAHKAJUNgJYIAcgCjYCVAsgHachAiAJBEAgB0EoaiAJEAYgAmohAgsgBCAJakEUTwRAIAdBKGoQAxoLIAQEQCAHQShqIAQQBiAIaiEICyAHQShqEAMaIAcgBygCKCIEQQAgGkIYiKdB/wFxIgkgBygCLGoiDGtBH3F2IAlBAnRBwCVqKAIAcSAap0H//wNxajYCPCAHIAwgG0IYiKdB/wFxIglqIgw2AiwgByAJQQJ0QcAlaigCACAEQQAgDGtBH3F2cSAbp0H//wNxajYCTCAHQShqEAMaIAcgHEIYiKdB/wFxIgQgBygCLGoiCTYCLCAHIARBAnRBwCVqKAIAIAcoAihBACAJa0EfcXZxIBynQf//A3FqNgJEIAdB4ABqIANBDGxqIgQgCjYCCCAEIAI2AgQgBCAINgIAIANBAWohAyAIIA1qIAJqIQ0MAQsLQQAhCCADIBdIDQAgEUFgaiEYIAEhCQJAA0AgB0EoahADQQJLIAMgBU5yRQRAIAcoAkAgBygCPEEDdGopAgAiGkIQiKdB/wFxIQggBygCUCAHKAJMQQN0aikCACIbQhCIp0H/AXEhCyAHKAJIIAcoAkRBA3RqKQIAIhxCIIinIQQgG0IgiCEdIBpCIIinIQwCQCAcQhCIp0H/AXEiAkECTwRAAkAgBkUgAkEZSXJFBEAgBCAHQShqIAJBICAHKAIsayIEIAQgAksbIgQQBiACIARrIgJ0aiEPIAdBKGoQAxogAkUNASAHQShqIAIQBiAPaiEPDAELIAdBKGogAhAGIARqIQ8gB0EoahADGgsgBykCVCEeIAcgDzYCVCAHIB43A1gMAQsCQCACRQRAIAwEQCAHKAJUIQ8MAwsgBygCWCEPDAELAn8gB0EoakEBEAYgBCAMRWpqIgJBA0YEQCAHKAJUQX9qDAELIAJBAnQgB2ooAlQLIgRFIARqIQ8gAkEBRwRAIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIA82AlQLIB2nIRQgCwRAIAdBKGogCxAGIBRqIRQLIAggC2pBFE8EQCAHQShqEAMaCyAIBEAgB0EoaiAIEAYgDGohDAsgB0EoahADGiAHIAcoAigiAkEAIBpCGIinQf8BcSIEIAcoAixqIghrQR9xdiAEQQJ0QcAlaigCAHEgGqdB//8DcWo2AjwgByAIIBtCGIinQf8BcSIEaiIINgIsIAcgBEECdEHAJWooAgAgAkEAIAhrQR9xdnEgG6dB//8DcWo2AkwgB0EoahADGiAHIBxCGIinQf8BcSICIAcoAixqIgQ2AiwgByACQQJ0QcAlaigCACAHKAIoQQAgBGtBH3F2cSAcp0H//wNxajYCRCAHIAdB4ABqIANBB3FBDGxqIhYoAggiBDYC2AEgByAWKQIAIho3A9ABAkACQAJAIAcoAswBIg4gGqciAmoiGSATSw0AIAkgBygC1AEiCiACaiILaiAYSw0AIBEgCWsgC0Egak8NAQsgByAHKALYATYCECAHIAcpA9ABNwMIIAkgESAHQQhqIAdBzAFqIBMgECAVIBIQHyELDAELIAIgCWohCCAJIA4QBAJAIAJBEUkNACAJQRBqIA5BEGoiDhAEIAJBcGpBEUgNACAJQSBqIQIDQCACIA5BEGoQBCACQRBqIA5BIGoiDhAEIAJBIGoiAiAISQ0ACwsgCCAEayECIAcgGTYCzAEgBCAIIBBrSwRAIAQgCCAVa0sEQEFsIQsMAgsgEiACIBBrIgJqIg4gCmogEk0EQCAIIA4gChAPGgwCCyAIIA5BACACaxAPIQggByACIApqIgo2AtQBIAggAmshCCAQIQILIARBEE8EQCAIIAIQBCAKQRFIDQEgCCAKaiEEIAhBEGohCANAIAggAkEQahAEIAhBEGogAkEgaiICEAQgCEEgaiIIIARJDQALDAELAkAgBEEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBEECdCIEQcAmaigCAGoiAhAZIAIgBEHgJmooAgBrIQIgBygC1AEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohDiAIQQhqIgQgAkEIaiICa0EPTARAA0AgBCACEAwgAkEIaiECIARBCGoiBCAOSQ0ADAIACwALIAQgAhAEIApBGUgNACAIQRhqIQgDQCAIIAJBEGoQBCAIQRBqIAJBIGoiAhAEIAhBIGoiCCAOSQ0ACwsgCxABDQIgFiAMNgIAIBYgDzYCCCAWIBQ2AgQgA0EBaiEDIAkgC2ohCSAMIA1qIBRqIQ0MAQsLQQAhCCADIAVIBEBBbCELDAMLIAMgF2shCkEAIQQDQCAKIAVOBEBBASEIA0AgBEEDRg0FIAAgBEECdCICakGs0AFqIAIgB2ooAlQ2AgAgBEEBaiEEDAAACwALIAcgB0HgAGogCkEHcUEMbGoiAigCCCIDNgLYASAHIAIpAgAiGjcD0AECQAJAAkAgBygCzAEiBiAapyICaiIPIBNLDQAgCSAHKALUASINIAJqIgtqIBhLDQAgESAJayALQSBqTw0BCyAHIAcoAtgBNgIgIAcgBykD0AE3AxggCSARIAdBGGogB0HMAWogEyAQIBUgEhAfIQsMAQsgAiAJaiEIIAkgBhAEAkAgAkERSQ0AIAlBEGogBkEQaiIMEAQgAkFwakERSA0AIAlBIGohAgNAIAIgDEEQahAEIAJBEGogDEEgaiIMEAQgAkEgaiICIAhJDQALCyAIIANrIQIgByAPNgLMASADIAggEGtLBEAgAyAIIBVrSwRAQWwhCwwCCyASIAIgEGsiAmoiBiANaiASTQRAIAggBiANEA8aDAILIAggBkEAIAJrEA8hBiAHIAIgDWoiDTYC1AEgBiACayEIIBAhAgsgA0EQTwRAIAggAhAEIA1BEUgNASAIIA1qIQMgCEEQaiEIA0AgCCACQRBqEAQgCEEQaiACQSBqIgIQBCAIQSBqIgggA0kNAAsMAQsCQCADQQdNBEAgCCACLQAAOgAAIAggAi0AAToAASAIIAItAAI6AAIgCCACLQADOgADIAhBBGogAiADQQJ0IgNBwCZqKAIAaiICEBkgAiADQeAmaigCAGshAiAHKALUASENDAELIAggAhAMCyANQQlJDQAgCCANaiEGIAhBCGoiAyACQQhqIgJrQQ9MBEADQCADIAIQDCACQQhqIQIgA0EIaiIDIAZJDQAMAgALAAsgAyACEAQgDUEZSA0AIAhBGGohCANAIAggAkEQahAEIAhBEGogAkEgaiICEAQgCEEgaiIIIAZJDQALCyALEAENASAKQQFqIQogCSALaiEJDAAACwALQQAhCAwBCyABIQkLIAhFDQEgBygCzAEhCAtBun8hCyATIAhrIgAgESAJa0sNACAJBH8gCSAIIAAQBSAAagVBAAsgAWshCwsgB0HgAWokACALC0YBA38gAEEIaiEDIAAoAgQhAkEAIQADQCAAIAJ2RQRAIAEgAyAAQQN0ai0AAkEWS2ohASAAQQFqIQAMAQsLIAFBCCACa3QLJQAgAEIANwIAIABBADsBCCAAQQA6AAsgACABNgIMIAAgAjoACgtsAQN/IwBBEGsiASQAAkAgACgCAEUgACgCBEVzDQAgASAAKAIINgIIIAEgACkCADcDAEGw7AkgARBIIgJFDQAgAiAAKQIANwL06gEgAkH86gFqIAAoAgg2AgAgAhBZIAIhAwsgAUEQaiQAIAMLqAMBBn9BuH8hBwJAIANFDQAgAi0AACIERQRAIAFBADYCAEEBQbh/IANBAUYbDwsCfyACQQFqIgUgBEEYdEEYdSIGQX9KDQAaIAZBf0YEQCADQQNIDQIgBS8AAEGA/gFqIQQgAkEDagwBCyADQQJIDQEgAi0AASAEQQh0ckGAgH5qIQQgAkECagshBSABIAQ2AgAgBUEBaiIBIAIgA2oiA0sNAEFsIQcgAEEQaiAAIAUtAAAiBUEGdkEjQQkgASADIAFrQbATQcAUQdAVIAAoAoTqASAAKAKc6wEgBCAAQazVAWoiBiAAKAKM6wEQICIIEAEiCQ0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAhqIAkbIgEgAyABa0HgGUHgGkHgGyAAKAKE6gEgACgCnOsBIAQgBiAAKAKM6wEQICIIEAEiCQ0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAhqIAkbIgEgAyABa0HwHUHQH0GwISAAKAKE6gEgACgCnOsBIAQgBiAAKAKM6wEQICIAEAENACAAIAFqIAJrIQcLIAcLiAUCCX8BfiACQQFqIQ4gAEEIaiEMQYCABCAFQX9qdEEQdSEJQQAhAkEBIQdBASAFdCILQX9qIg0hCANAIAIgDkZFBEACQCABIAJBAXQiD2ovAQAiCkH//wNGBEAgDCAIQQN0aiACNgIEIAhBf2ohCEEBIQoMAQsgB0EAIAkgCkEQdEEQdUobIQcLIAYgD2ogCjsBACACQQFqIQIMAQsLIAAgBTYCBCAAIAc2AgAgC0EDdiALQQF2akEDaiEKQQAhBwJAIAggDUYEQCAGQeoAaiEJQQAhAANAIAcgDkYEQCAKQQF0IQFBACEAQQAhCANAQQAhAiAIIAtPDQQDQCACQQJGRQRAIAwgAiAKbCAAaiANcUEDdGogCSACIAhqai0AADYCBCACQQFqIQIMAQsLIAhBAmohCCAAIAFqIA1xIQAMAAALAAUgASAHQQF0ai4BACEIIAAgCWoiDyAQEAlBCCECA0AgAiAITkUEQCACIA9qIBAQCSACQQhqIQIMAQsLIBBCgYKEiJCgwIABfCEQIAdBAWohByAAIAhqIQAMAQsAAAsAC0EAIQIDQCAHIA5GDQFBACEAIAEgB0EBdGouAQAiCUEAIAlBAEobIQkDQCAAIAlGRQRAIAwgAkEDdGogBzYCBANAIAIgCmogDXEiAiAISw0ACyAAQQFqIQAMAQsLIAdBAWohBwwAAAsAC0EAIQADQCAAIAtGRQRAIAYgDCAAQQN0aiIBKAIEIgdBAXRqIgIgAi8BACICQQFqOwEAIAEgBSACEBBrIgg6AAMgASACIAhB/wFxdCALazsBACABIAQgB0ECdCICaigCADoAAiABIAIgA2ooAgA2AgQgAEEBaiEADAELCwvzBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCgOoBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOsBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEH46wFqIQIgACgCjOsBGiAAKAIMIQYgBQRAIAIgAyABIAQgBhBcDAILIAIgAyABIAQgBhBaDAELIABBrNUBaiECIAEgBmohASAAQfjrAWohBiAAQajQAGohCCAAKAKM6wEaIAUEQCAIIAYgAyABIAQgAhBbDAELIAggBiADIAEgBCACEFgLEAENAiAAIAM2AoDrASAAQQE2AoDqASAAIABB+OsBajYC8OoBIAlBAkYEQCAAIABBqNAAajYCDAsgACADaiIAQZDsAWpCADcAACAAQYjsAWpCADcAACAAQYDsAWpCADcAACAAQfjrAWpCADcAACAKDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhBCADQQN2DAILQQIhBCABLwAAQQR2DAELQQMhBCABECFBBHYLIgMgBGoiBUEgaiACSwRAIAUgAksNAiAAQfjrAWogASAEaiADEAUhASAAIAM2AoDrASAAIAE2AvDqASABIANqIgBCADcAGCAAQgA3ABAgAEIANwAIIABCADcAACAFDwsgACADNgKA6wEgACABIARqNgLw6gEgBQ8LAn8CQAJAAkAgA0ECdkEDcUF/aiIEQQJLDQAgBEEBaw4CAAIBC0EBIQcgA0EDdgwCC0ECIQcgAS8AAEEEdgwBCyACQQRJIAEQISICQY+AgAFLcg0BQQMhByACQQR2CyECIABB+OsBaiABIAdqLQAAIAJBIGoQCyEBIAAgAjYCgOsBIAAgATYC8OoBIAdBAWohBwsgBwt2AQN/IwBBMGsiASQAIAAEQCABIABBuNUBaiICKAIANgIoIAEgACkCsNUBNwMgIAAoAgAhAyABIAIoAgA2AhggASAAKQKw1QE3AxAgAyABQRBqEBUgASABKAIoNgIIIAEgASkDIDcDACAAIAEQFQsgAUEwaiQAC8wBAQF/IAAgASgCqNUBNgKY6wEgACABKAIEIgI2ArTpASAAIAI2ArDpASAAIAIgASgCCGoiAjYCrOkBIAAgAjYCuOkBIAEoAqzVAQRAIABCgYCAgBA3A4DqASAAIAFBpNAAajYCDCAAIAFBlCBqNgIIIAAgAUGcMGo2AgQgACABQQxqNgIAIABBrNABaiABQajQAWooAgA2AgAgAEGw0AFqIAFBrNABaigCADYCACAAQbTQAWogAUGw0AFqKAIANgIADwsgAEIANwOA6gELOwAgAkUEQEG6fw8LIARFBEBBbA8LIAIgBBBdBEAgACABIAIgAyAEIAUQXg8LIAAgASACIAMgBCAFEGML1wEBAn8jAEEgayIBJAAgAEEANgKI6wEgAEIANwOQ6wEgAEEANgLE6wEgAEEANgK06wEgAEIANwKc6wEgAEEANgK46QEgAEEANgKs7AkgAEEANgLk6wEgAEIANwLU6wEgAEIANwKs6wEgAUIANwIQIAFCADcCGCABIAEpAxg3AwggASABKQMQNwMAIAEoAghBCHZBAXEhAiAAQQA2AqTrASAAIAI2AozrASAAQQA2AujrASAAQYGAgMAANgK86wEgAEIANwLk6gEgAEEANgKo6wEgAUEgaiQAC0YBAX8jAEEQayIFJAAgBUEIaiAEEA4CfyAFLQAJBEAgACABIAIgAyAEEDMMAQsgACABIAIgAyAEEDULIQAgBUEQaiQAIAALNAAgACADIAQgBRA3IgUQAQRAIAUPCyAFIARJBH8gASACIAMgBWogBCAFayAAEDYFQbh/CwtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBBfDAELIAAgASACIAMgBBA2CyEAIAVBEGokACAAC1kBAX9BDyECIAEgAEkEQCABQQR0IABuIQILIABBCHYiASACQRhsIgBBvBBqKAIAbCAAQbgQaigCAGoiAkEDdiACaiAAQbAQaigCACAAQbQQaigCACABbGpJCzcAIAAgAyAEIAVBgBQQNCIFEAEEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABAzBUG4fwsLzwMBA38jAEEgayIFJAAgBUEIaiACIAMQByICEAFFBEAgACABaiIHQX1qIQYgBSAEEA4gBEEEaiECIAUtAAIhAwNAQQAgACAGSSAFQQhqEAMbBEAgACACIAVBCGogAxACQQJ0aiIELwEAOwAAIAUgBSgCDCAELQACajYCDCAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFIAUoAgwgAC0AAmo2AgwgBCAALQADaiEADAEFIAdBfmohBANAIAVBCGoQAyAAIARLckUEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBSAFKAIMIAYtAAJqNgIMIAAgBi0AA2ohAAwBCwsDQCAAIARLRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFIAUoAgwgBi0AAmo2AgwgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBSAFKAIMIAAtAAJqNgIMDAELIAUoAgwiAEEfSw0AIAUgACACIANBAnRqLQACaiIAQSAgAEEgSRs2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILmgIBBX8jAEEQayIKJAAgCSADQTQQBSEJAkAgBEECSA0AIAkgBEECdGooAgAhAyAKQQxqIAgQIyAKQQE6AA8gCiACOgAOQQAhBCAKKAIMIQwDQCADIARGDQEgACAEQQJ0aiAMNgEAIARBAWohBAwAAAsAC0EAIQMDQCADIAZGRQRAIAkgBSADQQF0aiILLQABIg1BAnRqIgwoAgAhBCAKQQxqIAstAABBCHQgCGpB//8DcRAjIApBAjoADyAKIAcgDWsiCyACajoADiAEQQEgASALa3QiC2ohDSAKKAIMIQ4DQCAAIARBAnRqIA42AQAgBEEBaiIEIA1JDQALIAwgDCgCACALajYCACADQQFqIQMMAQsLIApBEGokAAuwAgEKfyMAQRBrIgokACAIIAVBNBAFIg9BNGohECAHIAZrIREgByABayESQQAhCANAAkAgAyAIRwRAQQEgASAHIAIgCEEBdGoiBi0AASILayIJayIMdCENIAYtAAAhDiAPIAtBAnRqIgsoAgAhBiAMIBFPBEAgACAGQQJ0aiAMIAkgBSAJQTRsaiAJIBJqIgZBASAGQQFKGyIGIAIgBCAGQQJ0aigCACIGQQF0aiADIAZrIAcgDiAQEGAMAgsgCkEMaiAOECMgCkEBOgAPIAogCToADiAGIAYgDWoiCSAJIA1JGyEJIAooAgwhDANAIAYgCUYNAiAAIAZBAnRqIAw2AQAgBkEBaiEGDAAACwALIApBEGokAA8LIAsgCygCACANajYCACAIQQFqIQgMAAALAAsIAEGEKCgCAAs0ACAAIAMgBCAFEDciBRABBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNQVBuH8LCwgAQYAoKAIACzYCAX8BfiMAQRBrIgIkACACIAE2AgwgAkEMahBLIQMgACgCBCEAIAJBEGokACADpyAAQX9qcQuHAQEFfyAAIAEQZSECIAAoAgRBf2ohBgNAIAECf0EAIAAoAgAgAiIEQQJ0aigCACIFRQ0AGiAFKAIEIQNBACECAkAgBSgCCEEISQ0AIAMoAABBt8jC4X5HDQAgAygABCECCyACCyIDRwRAIAQgBnFBAWohAiADDQELCyAAKAIAIARBAnRqKAIAC1oBAX8CQCAAKALo6wFBAUcNACAAKAKs6wFFDQACQCAAKALs6wEgASgCAEcNACAAQfTrAWooAgAgASgCCEcNACAAQfDrAWooAgAgASgCBEYNAQtBmH8hAgsgAguDDgIWfwF+IwBBIGsiBiQAIAIoAgghESACKAIEIRIgAigCACEDIAEoAgQhEyAGIAEoAgAiCSABKAIIIhVqIhc2AhwCQCARIBJLDQACQCAVIBNLDQAgACABEGcQAQ0BIAkgE2ohCyAAQfTqAWohDiAAQZzsCWohGCADIBJqIgwgAyARaiINayEWIABBmOwJaiEUIABBwOkBaiEPIABB7OsBaiEQQQEhBCANIQMCQANAAkAgAyEHIAQiCUUNACAAKAKs6wEiA0EESw0EAkACQAJAIA8gFAJ/AkACQCADQQFrDgQAAwQFAQsgACgC0OsBDAELIABBATYCrOsBIABCADcDyOsBIABCADcC3OsBIABBADYC0OsBIABBADYCuOsBIBAgASkCADcCACAQIAEoAgg2AghBAAsgACgC5OoBECchCAJAIAAoAqjrAUUNACAAKAKk6wFFDQAgABA9CyAIEAENByAIBEAgCCAAKALQ6wEiBGsiAyAMIAdrIgVLBEAgBQRAIAAgBGpBmOwJaiAHIAUQBRogACAAKALQ6wEgBWo2AtDrAQsgAiACKAIENgIIIAAoAuTqARoMCQsgACAEakGY7AlqIAcgAxAFGiAAIAg2AtDrASADIAdqIQMgCSEEDAULAkAgDykDACIZQn9RDQAgACgC1OkBQQFGDQAgGSALIAYoAhwiBGsiA61WDQAgDSAWEHUiBSAWSw0AIAAgBCADIA0gBSAAECYQQiIJEAENCCAGIAQgCWo2AhxBACEEIABBADYCrOsBIABBADYCvOkBIAUgDWohAwwFCwJAIAAoAujrAUEBRw0AIAAoAtTpAUEBRg0AIA8pAwAiGUJ/UQ0AIBkgCyAGKAIca61WDQcLIAAgABAmEENBABABDQcCfyAUKAAAQXBxQdDUtMIBRgRAQQchBCAYKAAADAELIAAgFCAAKALQ6wEQJRABDQhBAiEEQQMLIQMgACAENgL86QEgACADNgK86QEgACAAKQPI6QEiGUKACCAZQoAIVhsiGTcDyOkBIBkgADUCvOsBVg0HQQAhBCAAAn8gACgC0OkBIgNBBCADQQRLGyIIIQUgACgC6OsBRQRAIBkgDykDABBqIQQLIAQhA0EAIAAoAsTrASAAKAK06wFqIAMgBWpBA2xJDQAaIAAoAqzsCUEBags2AqzsCUEAIAAoArTrASAITwR/IAAoAsTrASAESQVBAQtFIAAoAqzsCUH/AEsbRQRAIAQgCGohBQJAAkAgACgCiOsBIgMEQCAFIANB0JN2ak0NAQwJCyAAKAKw6wEhAyAGIA4oAgg2AhggBiAOKQIANwMQIAMgBkEQahAVIABBADYCxOsBIABBADYCtOsBIAYgDigCCDYCCCAGIA4pAgA3AwAgACAFIAYQSCIDNgKw6wEgA0UNCAwBCyAAKAKw6wEhAwsgACAENgLE6wEgACAINgK06wEgACADIAhqNgLA6wELIABBAjYCrOsBCyAAIAwgB2siAxBAIgVFBEBBACEEIABBADYCrOsBIAchAwwECyADIAVPBEAgBSAHaiEDIAkhBCAAIAZBHGogCyAHIAUQOhABRQ0EDAcLQQAhBCAHIAwiA0YNAyAAQQM2AqzrAQsgACgCvOkBIgUgACgCuOsBIgRrIQoCQCAAEDkEQCAKIAwgB2siAyAKIANJGyEIDAELIAogACgCtOsBIARrSw0GIAAoArDrASAEaiAKIAcgDCAHaxA4IQggACgCuOsBIQQLIAAgBCAIajYCuOsBIAcgCGohA0EAIQQgCCAKSQ0CIABBADYCuOsBIAkhBCAAIAZBHGogCyAAKAKw6wEgBRA6EAFFDQIMBQsgBiAGKAIcIgQgCyAEayAAKALI6wEiAyAAKALA6wFqIAAoAszrASADayIIEDgiCiAEajYCHCAAIAogACgCyOsBaiIFNgLI6wFBACEEIAchAyAIIApHDQEgAEECNgKs6wEgCSEEIAApA8DpASAAKALE6wEiCa1YDQEgACgC0OkBIAVqIAlNDQEgAEIANwPI6wEMAQsLIAIgByACKAIAazYCCCABIAYoAhwiAyABKAIAayIJNgIIIBAgCTYCCCAQIAEpAgA3AgACQCAHIA1HIAMgF0dyRQRAIAAgACgC5OsBIgFBAWo2AuTrASABQQ9IDQEgEyAVRg0EIBEgEkcNAQwECyAAQQA2AuTrAQsgACgCvOkBIgFFBEAgACgC4OsBIQEgACgCzOsBIAAoAsjrAUYEQCABRQ0EIAIoAggiASACKAIETwRAIABBAjYCrOsBDAULIAIgAUEBajYCCAwECyABDQMgAiACKAIIQX9qNgIIIABBATYC4OsBDAMLIAEgACgCuOsBa0EDQQAgABBuQQJGG2oaCwsLIAZBIGokAAvyAQEGfyMAQTBrIgIkAEGAgAgQEiEFEDAhByACQQA2AiwgAkEANgIoIAJBLGogAkEoahCCASEDA0AgAUEBTgRAQQAhBiACQQA2AiAgAiAANgIYIAIgAUGDgAggAUGDgAhJGyIENgIcA0AgBiAESQRAIAJBADYCECACQYCACDYCDCACIAU2AgggByACQQhqIAJBGGoQaCADKAJMGiAFIAIoAhAgAxB7GiACKAIcIQQgAigCICEGDAELCyAAIARqIQAgAUGDgAhrIQEMAQsLIAMQhAFBgCggAigCLDYCAEGEKCACKAIoIgA2AgAgAkEwaiQAIAALLwBBcCABIAAgAEKAgAggAEKAgAhUG3xCQH0iACAAIAFWGyIApyAAQv////8PVhsLaQEBfwJ/AkACQCACQQdNDQAgASgAAEG3yMLhfkcNACAAIAEoAAQ2ApjrAUFiIABBEGogASACEGwiAxABDQIaIABCgYCAgBA3A4DqASAAIAEgA2ogAiADaxA7DAELIAAgASACEDsLQQALC/YDAQh/IwBBgAFrIgMkAEFiIQkCQCACQQlJDQAgAEGY0ABqIAFBCGoiBCACQXhqIABBmNAAEDQiBhABIgUNACADQR82AnwCQCADIANB/ABqIANB+ABqIAQgBCAGaiIEIAUbIgUgASACaiIGIAVrEBgiAhABDQAgAygCfCIHQR9LDQAgAygCeCIIQQhLDQAgAEGIIGogAyAHQYAIQYAJIAggAEGo0AFqEBogAiAFaiEEQQEhCgsgCkUNACADQTQ2AnxBACECAkAgAyADQfwAaiADQfgAaiAEIAYgBGsQGCIFEAENACADKAJ8IgdBNEsNACADKAJ4IghBCUsNACAAQZAwaiADIAdBgApB4AsgCCAAQajQAWoQGiAEIAVqIQRBASECCyACRQ0AIANBIzYCfEEAIQICQCADIANB/ABqIANB+ABqIAQgBiAEaxAYIgUQAQ0AIAMoAnwiB0EjSw0AIAMoAngiCEEJSw0AIAAgAyAHQcANQdAOIAggAEGo0AFqEBogBCAFaiEEQQEhAgsgAkUNACAEQQxqIgUgBksNACAGIAVrIQZBACECA0AgAkEDRwRAIAQoAAAiB0F/aiAGTw0CIAAgAkECdGpBnNABaiAHNgIAIAJBAWohAiAEQQRqIQQMAQsLIAUgAWshCQsgA0GAAWokACAJCwwAIAAgASACIAMQbwsjACAAKAL86QFBfmoiAEEFTQRAIABBAnRBkBBqKAIADwtBAAsoAQF/EDAiBEUEQEFADwsgBCAAIAEgAiADIAQQJhBCIQAgBBCIASAAC8oDAgd/AX4jAEEQayIJJABBuH8hBgJAIAQoAgAiCEEFQQkgACgC5OoBIgUbSQ0AIAMoAgAiB0EBQQUgBRsgBRAoIgUQAQRAIAUhBgwBCyAIIAVBA2pJDQAgACAHIAUQJSIGEAENACABIAJqIQogAEGI6gFqIQsgCCAFayECIAUgB2ohByABIQUDQCAHIAIgCRAiIgYQAQ0BIAJBfWoiAiAGSQRAQbh/IQYMAgsgCSgCACIIQQJLBEBBbCEGDAILIAdBA2ohBwJ/AkACQAJAIAhBAWsOAgIAAQsgACAFIAogBWsgByAGEDIMAgsgBSAKIAVrIAcgBhA/DAELIAUgCiAFayAHLQAAIAkoAggQPgsiCBABBEAgCCEGDAILIAAoAuzqAQRAIAsgBSAIEEoLIAIgBmshAiAGIAdqIQcgBSAIaiEFIAkoAgRFDQALIAApA8DpASIMQn9SBEBBbCEGIAwgBSABa6xSDQELIABB4OkBaigCAARAQWohBiACQQRJDQEgACgC6OoBRQRAIAsQSSEMIAcoAAAgDKdHDQILIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAEDwCf0EAQQAQAQ0AGiABRSACRXJFBEBBYiAAIAEgAhBrEAENARoLQQALC9MCAQd/IwBBEGsiBiQAIAYgBDYCCCAGIAM2AgwgBQRAIAUoAgQhCiAFKAIIIQkLIAEhCAJAAkADQCAAKALk6gEQHCELAkADQCAEIAtJDQEgAygAAEFwcUHQ1LTCAUYEQCADIAQQRCIHEAENBCAEIAdrIQQgAyAHaiEDDAELCyAGIAM2AgwgBiAENgIIAkAgBQRAIAAgBRBDQQAhB0EAEAFFDQEMBQsgACAKIAkQcSIHEAENBAsgACAIIAIQMSAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEHAiByIDa0EAIAMQARtBCkdyRQRAQbh/IQcMBAsgBxABDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLBgAgABAXC68CAgR/AX4jAEFAaiIEJAACQAJAIAJBCEkNACABKAAAQXBxQdDUtMIBRw0AIAEgAhBEIQEgAEIANwMIIABBADYCBCAAIAE2AgAMAQsgBEEYaiABIAJBABAnIgMQAQRAIAAgAxAbDAELIAMEQCAAQbh/EBsMAQsgAiAEKAIwIgNrIQIgASADaiEDA0ACQCAAIAMgAiAEQQhqECIiBRABBH8gBQUgAiAFQQNqIgVPDQFBuH8LEBsMAgsgBkEBaiEGIAIgBWshAiADIAVqIQMgBCgCDEUNAAsgBCgCOARAIAJBA00EQCAAQbh/EBsMAgsgA0EEaiEDCyAEKAIoIQIgBCkDGCEHIABBADYCBCAAIAMgAWs2AgAgACACIAZsrSAHIAdCf1EbNwMICyAEQUBrJAALJQEBfyMAQRBrIgIkACACIAAgARB0IAIoAgAhACACQRBqJAAgAAsGACAAJAALEAAjACAAa0FwcSIAJAAgAAsEACMACyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJB/AMgAkH8A0kbIgMQBSEAIAFB/ANqIQEgAEH8A2ohACACIANrIgINAAsLC7YBAQR/AkAgAigCECIDBH8gAwUgAhB8DQEgAigCEAsgAigCFCIFayABSQRAIAIgACABIAIoAiQRAgAPCwJAIAIsAEtBAEgNACABIQQDQCAEIgNFDQEgACADQX9qIgRqLQAAQQpHDQALIAIgACADIAIoAiQRAgAiBCADSQ0BIAEgA2shASAAIANqIQAgAigCFCEFIAMhBgsgBSAAIAEQBRogAiACKAIUIAFqNgIUIAEgBmohBAsgBAtZAQF/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAucBwEJfyAAKAIEIgdBA3EhAiAAIAdBeHEiBmohBEHsKCgCACEFAkAgAkUEQEEAIQIgAUGAAkkNASAGIAFBBGpPBEAgACECIAYgAWtBvCwoAgBBAXRNDQILQQAPCwJAIAYgAU8EQCAGIAFrIgJBEEkNASAAIAdBAXEgAXJBAnI2AgQgACABaiIBIAJBA3I2AgQgBCAEKAIEQQFyNgIEIAEgAhBFDAELQQAhAiAEQfQoKAIARgRAQegoKAIAIAZqIgUgAU0NAiAAIAdBAXEgAXJBAnI2AgQgACABaiICIAUgAWsiAUEBcjYCBEHoKCABNgIAQfQoIAI2AgAMAQsgBEHwKCgCAEYEQEHkKCgCACAGaiIFIAFJDQICQCAFIAFrIgJBEE8EQCAAIAdBAXEgAXJBAnI2AgQgACABaiIBIAJBAXI2AgQgACAFaiIFIAI2AgAgBSAFKAIEQX5xNgIEDAELIAAgB0EBcSAFckECcjYCBCAAIAVqIgEgASgCBEEBcjYCBEEAIQJBACEBC0HwKCABNgIAQeQoIAI2AgAMAQsgBCgCBCIDQQJxDQEgA0F4cSAGaiIJIAFJDQEgCSABayEKAkAgA0H/AU0EQCAEKAIIIgYgA0EDdiIFQQN0QYQpakcaIAYgBCgCDCIIRgRAQdwoQdwoKAIAQX4gBXdxNgIADAILIAYgCDYCDCAIIAY2AggMAQsgBCgCGCEIAkAgBCAEKAIMIgNHBEAgBSAEKAIIIgJNBEAgAigCDBoLIAIgAzYCDCADIAI2AggMAQsCQCAEQRRqIgIoAgAiBg0AIARBEGoiAigCACIGDQBBACEDDAELA0AgAiEFIAYiA0EUaiICKAIAIgYNACADQRBqIQIgAygCECIGDQALIAVBADYCAAsgCEUNAAJAIAQgBCgCHCIFQQJ0QYwraiICKAIARgRAIAIgAzYCACADDQFB4ChB4CgoAgBBfiAFd3E2AgAMAgsgCEEQQRQgCCgCECAERhtqIAM2AgAgA0UNAQsgAyAINgIYIAQoAhAiAgRAIAMgAjYCECACIAM2AhgLIAQoAhQiAkUNACADIAI2AhQgAiADNgIYCyAKQQ9NBEAgACAHQQFxIAlyQQJyNgIEIAAgCWoiASABKAIEQQFyNgIEDAELIAAgB0EBcSABckECcjYCBCAAIAFqIgIgCkEDcjYCBCAAIAlqIgEgASgCBEEBcjYCBCACIAoQRQsgACECCyACC4ABAQJ/IABFBEAgARASDwsgAUFATwRAQdgoQTA2AgBBAA8LIABBeGpBECABQQtqQXhxIAFBC0kbEH0iAgRAIAJBCGoPCyABEBIiAkUEQEEADwsgAiAAIABBfGooAgAiA0F4cUEEQQggA0EDcRtrIgMgASADIAFJGxAFGiAAEBcgAgsEAEEAC1oBAn8jAEEgayICJAAgAARAIAAoAgAiAwRAIAIgASgCCDYCGCACIAEpAgA3AxAgAyACQRBqEBULIAIgASgCCDYCCCACIAEpAgA3AwAgACACEBULIAJBIGokAAuKAQEBfyMAQRBrIgMkAAJ+AkAgAkEDTw0AIAAoAlQhACADQQA2AgQgAyAAKAIINgIIIAMgACgCEDYCDEEAIANBBGogAkECdGooAgAiAmusIAFVQf////8HIAJrrCABU3INACAAIAIgAadqIgA2AgggAK0MAQtB2ChBHDYCAEJ/CyEBIANBEGokACABC8gBAQJ/QagJEBIiAgR/QQEQEiIDRQRAIAIQF0EADwsgAkEAQagBEAsaIAIgATYClAEgAiAANgKQASACIAJBkAFqNgJUIAFBADYCACACQgA3AqABIAJBADYCmAEgACADNgIAIAIgAzYCnAEgA0EAOgAAIAJBfzYCPCACQQQ2AgAgAkH/AToASyACQYAINgIwIAIgAkGoAWo2AiwgAkECNgIoIAJBAzYCJCACQQQ2AgxBnCgoAgBFBEAgAkF/NgJMCyACEIMBBUEACwsrAQF/IABBlCgoAgA2AjhBlCgoAgAiAQRAIAEgADYCNAtBlCggADYCACAAC4QBAQN/IAAoAkxBAE4Ef0EBBUEACxogACgCAEEBcSIDRQRAIAAoAjQiAQRAIAEgACgCODYCOAsgACgCOCICBEAgAiABNgI0CyAAQZQoKAIARgRAQZQoIAI2AgALCyAAEEcaIAAgACgCDBEAABogACgCYCIBBEAgARAXCyADRQRAIAAQFwsLzwYBB38jAEEwayIEJAAgBEH/ATYCAAJAIAMgBCAEQQRqIAEgAhAuIgYQAQRAIAYhBQwBC0FUIQUgBCgCBCIHQQZLDQAgBCgCACIJQQF0QQJqrUIBIAethkEBIAd0QQFqIgqsQgKGfHxCjwR8QnyDQugGVg0AIANBgARqIgggAyAJIAcgCCAKQQJ0IgVqQeQCIAVrEIYBIgUQAQ0AIAIgBmshAiABIAZqIQEgAEH/AWoiBkF9aiEHIAMvAYIEBEAgBEEYaiABIAIQByIFEAENASAEQRBqIARBGGogCBAdIARBCGogBEEYaiAIEB0gACEBA0ACQCAEQRhqEAMgASAHT3JFBEAgASAEQRBqIARBGGoQFDoAACABIARBCGogBEEYahAUOgABIARBGGoQA0UNASABQQJqIQELIAZBfmohAwJ/A0BBun8hBSABIgIgA0sNBSACIARBEGogBEEYahAUOgAAIAJBAWohASAEQRhqEANBA0YEQEECIQUgBEEIagwCCyABIANLDQUgAiAEQQhqIARBGGoQFDoAASACQQJqIQFBAyEFIARBGGoQA0EDRw0ACyAEQRBqCyEDIAEgAyAEQRhqEBQ6AAAgAiAFaiAAayEFDAMLIAEgBEEQaiAEQRhqEBQ6AAIgASAEQQhqIARBGGoQFDoAAyABQQRqIQEMAAALAAsgBEEYaiABIAIQByIFEAENACAEQRBqIARBGGogCBAdIARBCGogBEEYaiAIEB0gACEBA0ACQCAEQRhqEAMgASAHT3JFBEAgASAEQRBqIARBGGoQEzoAACABIARBCGogBEEYahATOgABIARBGGoQA0UNASABQQJqIQELIAZBfmohAwJ/A0BBun8hBSABIgIgA0sNBCACIARBEGogBEEYahATOgAAIAJBAWohASAEQRhqEANBA0YEQEECIQUgBEEIagwCCyABIANLDQQgAiAEQQhqIARBGGoQEzoAASACQQJqIQFBAyEFIARBGGoQA0EDRw0ACyAEQRBqCyEDIAEgAyAEQRhqEBM6AAAgAiAFaiAAayEFDAILIAEgBEEQaiAEQRhqEBM6AAIgASAEQQhqIARBGGoQEzoAAyABQQRqIQEMAAALAAsgBEEwaiQAIAULqAUCCX8BfkFSIQYCQCACQf8BSw0AIAJBAWoiDEEBdK1CASADrYZ8Qgh8IAWtVg0AQVQhBiADQQxLDQAgAEEEaiEKIAQgAkEBdGpBAmohCEGAgAQgA0F/anRBEHUhDUEAIQJBASEFQQEgA3QiCUF/aiILIQcDQCACIAxGRQRAAkAgASACQQF0Ig5qLwEAIgZB//8DRgRAIAogB0ECdGogAjoAAiAHQX9qIQdBASEGDAELIAVBACANIAZBEHRBEHVKGyEFCyAEIA5qIAY7AQAgAkEBaiECDAELCyAAIAU7AQIgACADOwEAIAlBA3YgCUEBdmpBA2ohAEEAIQUCQCAHIAtGBEBBACEGA0AgBSAMRgRAIABBAXQhAUEAIQZBACEHA0BBACECIAcgCU8NBANAIAJBAkZFBEAgCiAAIAJsIAZqIAtxQQJ0aiAIIAIgB2pqLQAAOgACIAJBAWohAgwBCwsgB0ECaiEHIAEgBmogC3EhBgwAAAsABSABIAVBAXRqLgEAIQcgBiAIaiINIA8QCUEIIQIDQCACIAdORQRAIAIgDWogDxAJIAJBCGohAgwBCwsgD0KBgoSIkKDAgAF8IQ8gBUEBaiEFIAYgB2ohBgwBCwAACwALQQAhAgNAIAUgDEZFBEBBACEGIAEgBUEBdGouAQAiCEEAIAhBAEobIQgDQCAGIAhGRQRAIAogAkECdGogBToAAgNAIAAgAmogC3EiAiAHSw0ACyAGQQFqIQYMAQsLIAVBAWohBQwBCwtBfyEGIAINAQtBACEGQQAhAgNAIAIgCUYNASAEIAogAkECdGoiAC0AAkEBdGoiASABLwEAIgFBAWo7AQAgACADIAEQEGsiBToAAyAAIAEgBUH/AXF0IAlrOwEAIAJBAWohAgwAAAsACyAGC0sAIABCADcDGCAAQgA3AwAgAEL56tDQ58mh5OEANwMgIABCz9bTvtLHq9lCNwMQIABC1uuC7ur9ifXgADcDCCAAQShqQQBBKBALGgvAAQECfyMAQUBqIgEkAAJAIABFDQAgACgCiOsBDQAgASAAQfzqAWooAgA2AjggASAAKQL06gE3AzAgABAqIAAoArDrASECIAEgASgCODYCKCABIAEpAzA3AyAgAiABQSBqEBUgAEEANgKw6wEgACgCpOsBIgIEQCABIAEoAjg2AhggASABKQMwNwMQIAIgAUEQahCAASAAQQA2AqTrAQsgASABKAI4NgIIIAEgASkDMDcDACAAIAEQFQsgAUFAayQACwYAIAAQEgsL0BwOAEGECAvPAwEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAMC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQNC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkA8LWQEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAAQAAAAQAAAAIAEH0DwsxAQAAAAIAAAAEAAAAAAAAAAIAAAAEAAAACAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABQBBuBALDQEAAAABAAAAAgAAAAIAQdAQC+8DAQAAAAEAAAACAAAAAgAAACYAAACCAAAAIQUAAEoAAABnCAAAJgAAAMABAACAAAAASQUAAEoAAAC+CAAAKQAAACwCAACAAAAASQUAAEoAAAC+CAAALwAAAMoCAACAAAAAigUAAEoAAACECQAANQAAAHMDAACAAAAAnQUAAEoAAACgCQAAPQAAAIEDAACAAAAA6wUAAEsAAAA+CgAARAAAAJ4DAACAAAAATQYAAEsAAACqCgAASwAAALMDAACAAAAAwQYAAE0AAAAfDQAATQAAAFMEAACAAAAAIwgAAFEAAACmDwAAVAAAAJkEAACAAAAASwkAAFcAAACxEgAAWAAAANoEAACAAAAAbwkAAF0AAAAjFAAAVAAAAEUFAACAAAAAVAoAAGoAAACMFAAAagAAAK8FAACAAAAAdgkAAHwAAABOEAAAfAAAANICAACAAAAAYwcAAJEAAACQBwAAkgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEgAAABQAAAAWAAAAGAAAABwAAAAgAAAAKAAAADAAAABAAAAAgAAAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAAABAEGAFQvWBAEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAAQABAQYAAAAAAAAEAAAAABAAAAQAAAAAIAAABQEAAAAAAAAFAwAAAAAAAAUEAAAAAAAABQYAAAAAAAAFBwAAAAAAAAUJAAAAAAAABQoAAAAAAAAFDAAAAAAAAAYOAAAAAAABBRAAAAAAAAEFFAAAAAAAAQUWAAAAAAACBRwAAAAAAAMFIAAAAAAABAUwAAAAIAAGBUAAAAAAAAcFgAAAAAAACAYAAQAAAAAKBgAEAAAAAAwGABAAACAAAAQAAAAAAAAABAEAAAAAAAAFAgAAACAAAAUEAAAAAAAABQUAAAAgAAAFBwAAAAAAAAUIAAAAIAAABQoAAAAAAAAFCwAAAAAAAAYNAAAAIAABBRAAAAAAAAEFEgAAACAAAQUWAAAAAAACBRgAAAAgAAMFIAAAAAAAAwUoAAAAAAAGBEAAAAAQAAYEQAAAACAABwWAAAAAAAAJBgACAAAAAAsGAAgAADAAAAQAAAAAEAAABAEAAAAgAAAFAgAAACAAAAUDAAAAIAAABQUAAAAgAAAFBgAAACAAAAUIAAAAIAAABQkAAAAgAAAFCwAAACAAAAUMAAAAAAAABg8AAAAgAAEFEgAAACAAAQUUAAAAIAACBRgAAAAgAAIFHAAAACAAAwUoAAAAIAAEBTAAAAAAABAGAAABAAAADwYAgAAAAAAOBgBAAAAAAA0GACAAQeQZC4MEAQAAAAEAAAAFAAAADQAAAB0AAAA9AAAAfQAAAP0AAAD9AQAA/QMAAP0HAAD9DwAA/R8AAP0/AAD9fwAA/f8AAP3/AQD9/wMA/f8HAP3/DwD9/x8A/f8/AP3/fwD9//8A/f//Af3//wP9//8H/f//D/3//x/9//8//f//fwAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAAQABAQUAAAAAAAAFAAAAAAAABgQ9AAAAAAAJBf0BAAAAAA8F/X8AAAAAFQX9/x8AAAADBQUAAAAAAAcEfQAAAAAADAX9DwAAAAASBf3/AwAAABcF/f9/AAAABQUdAAAAAAAIBP0AAAAAAA4F/T8AAAAAFAX9/w8AAAACBQEAAAAQAAcEfQAAAAAACwX9BwAAAAARBf3/AQAAABYF/f8/AAAABAUNAAAAEAAIBP0AAAAAAA0F/R8AAAAAEwX9/wcAAAABBQEAAAAQAAYEPQAAAAAACgX9AwAAAAAQBf3/AAAAABwF/f//DwAAGwX9//8HAAAaBf3//wMAABkF/f//AQAAGAX9//8AQfAdC9MBAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJQAAACcAAAApAAAAKwAAAC8AAAAzAAAAOwAAAEMAAABTAAAAYwAAAIMAAAADAQAAAwIAAAMEAAADCAAAAxAAAAMgAAADQAAAA4AAAAMAAQBB0CALUQEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAQAAAAFAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEABBsCELhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBxCULvAIBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAAAQAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAHAAAACAAAAAkAAAAKAAAACwAAAAAAAAABAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AEHQLAsD8BZQ', imports)}

const Zstd = new (function () {
    class Zstd {
        #webAssembly;
        #HEAPU8;
        async decompress(compressedDatas) {
            const wa = await this.getWebAssembly();
            if (!wa) {
                return null;
            }
            if (!this.#HEAPU8) {
                return null;
            }
            const api = wa.instance.exports;
            let srcSize = compressedDatas.length;
            const src = api.create_buffer(srcSize);
            this.#HEAPU8.set(compressedDatas, src);
            let result = api.decompress(src, srcSize);
            api.destroy_buffer(src);
            if (result >= 0) {
                const resultPointer = api.get_result_pointer();
                let temp = new Uint8Array(new Uint8Array(this.#HEAPU8.buffer, resultPointer, api.get_result_size()));
                api.destroy_buffer(resultPointer);
                return temp;
            }
            return null;
        }
        async decompress_ZSTD(compressedDatas, uncompressedDatas) {
            if (!this.#HEAPU8) {
                return null;
            }
            const wa = await this.getWebAssembly();
            const api = wa.instance.exports;
            let srcSize = compressedDatas.length;
            let dstSize = uncompressedDatas.length;
            const src = api.create_buffer(srcSize);
            const dst = api.create_buffer(dstSize);
            this.#HEAPU8.set(compressedDatas, src);
            let result = api.decompress_ZSTD(dst, dstSize, src, srcSize);
            console.error(result);
            const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, dst, dstSize);
            uncompressedDatas.set(resultView);
            api.destroy_buffer(src);
            api.destroy_buffer(dst);
            return result;
        }
        async getWebAssembly() {
            if (this.#webAssembly) {
                return this.#webAssembly;
            }
            const env = {
                'abortStackOverflow': (_) => { throw new Error('overflow'); },
                'emscripten_notify_memory_growth': (_) => { this.#initHeap(); },
                'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
                'tableBase': 0,
                'memoryBase': 1024,
                'STACKTOP': 0,
            };
            this.#webAssembly = await zstd({ env }); //await WebAssembly.instantiateStreaming(fetch('zstd.wasm'), {env});
            this.#initHeap();
            return this.#webAssembly;
        }
        #initHeap() {
            this.#HEAPU8 = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
        }
    }
    return Zstd;
}());

const DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
const DXGI_FORMAT_R32G32B32_FLOAT = 6;
const DXGI_FORMAT_R16G16B16A16_SINT = 14;
const DXGI_FORMAT_R32G32_FLOAT = 16;
const DXGI_FORMAT_R8G8B8A8_UNORM = 28;
const DXGI_FORMAT_R8G8B8A8_UINT = 30;
const DXGI_FORMAT_R16G16_FLOAT = 34;
const DXGI_FORMAT_R16G16_SNORM = 37;
const DXGI_FORMAT_R16G16_SINT = 38;
const DXGI_FORMAT_R32_FLOAT = 41;
const DXGI_FORMAT_R32_UINT = 42;

const DATA_TYPE_STRUCT = 1;
const DATA_TYPE_ENUM = 2;
const DATA_TYPE_HANDLE = 3;
const DATA_TYPE_BYTE = 10;
const DATA_TYPE_UBYTE = 11;
const DATA_TYPE_SHORT = 12;
const DATA_TYPE_USHORT = 13;
const DATA_TYPE_INTEGER = 14;
const DATA_TYPE_UINTEGER = 15;
const DATA_TYPE_INT64 = 16;
const DATA_TYPE_UINT64 = 17;
const DATA_TYPE_FLOAT = 18;
const DATA_TYPE_VECTOR2 = 21;
const DATA_TYPE_VECTOR3 = 22;
const DATA_TYPE_VECTOR4 = 23;
const DATA_TYPE_QUATERNION = 25;
const DATA_TYPE_BOOLEAN = 30;
const DATA_TYPE_NAME = 31;
function sNormUint16(uint16) {
    //https://www.khronos.org/opengl/wiki/Normalized_Integer
    return Math.max(uint16 / 0x7FFF, -1.0);
}
const Source2BlockLoader = new (function () {
    class Source2BlockLoader {
        constructor() {
        }
        async parseBlock(reader, file, block, parseVtex) {
            let introspection = file.blocks['NTRO'];
            let reference = file.blocks['RERL'];
            switch (block.type) {
                case 'RERL':
                    loadRerl(reader, block);
                    break;
                case 'REDI':
                    break;
                case 'NTRO':
                    loadNtro(reader, block);
                    break;
                case 'DATA':
                case 'ANIM':
                case 'CTRL':
                case 'MRPH':
                case 'MDAT':
                case 'ASEQ':
                case 'AGRP':
                case 'PHYS':
                case 'LaCo':
                    await this.loadData(reader, reference, block, introspection, parseVtex);
                    break;
                case 'VBIB':
                case 'MBUF':
                    loadVbib(reader, block);
                    break;
                case 'SNAP':
                    let decodeLength, sa;
                    decodeLength = reader.getUint32(block.offset);
                    if ((decodeLength >>> 24) == 0x80) {
                        //no compression see particles/models/heroes/antimage/antimage_weapon_primary.vsnap_c
                        sa = reader.getBytes(decodeLength & 0xFFFFFF);
                    }
                    else {
                        sa = new Uint8Array(new ArrayBuffer(decodeLength));
                        decodeMethod1(reader, sa, decodeLength);
                    }
                    block.datas = sa;
                    break;
                default:
                    console.warn('Unknown block type ' + block.type, block.offset, block.length, block);
            }
        }
        async loadData(reader, reference, block, introspection, parseVtex) {
            var bytes = reader.getUint32(block.offset);
            switch (bytes) {
                case 0x03564B56: // VKV3
                    return loadDataVkv(reader, block);
                case 0x4B563301: // kv31
                    return await loadDataKv3(reader, block, 1);
                case 0x4B563302: // kv32 ?? new since wind ranger arcana
                    return await loadDataKv3(reader, block, 2);
                case 0x4B563303: // KV3 v3 new since muerta
                    return await loadDataKv3(reader, block, 3);
                case 0x4B563304: // KV3 v4 new since dota 7.33
                    return await loadDataKv3(reader, block, 4);
                case 0x4B563305: // KV3 v5 new since frostivus 2024
                    return await loadDataKv3(reader, block, 5);
                default:
                    console.warn('Unknown block data type:', bytes);
            }
            if (!introspection || !introspection.structsArray) {
                if (parseVtex) { //TODO
                    return loadDataVtex(reader, block);
                }
                return null;
            }
            block.structs = {};
            let structList = introspection.structsArray;
            var startOffset = block.offset;
            for (var structIndex = 0; structIndex < 1 /*removeme*/ /*structList.length*/; structIndex++) {
                var struct = structList[structIndex]; //introspection.firstStruct;
                block.structs[struct.name] = loadStruct(reader, reference, struct, block, startOffset, introspection);
                startOffset += struct.discSize;
            }
        }
    }
    return Source2BlockLoader;
}());
function ab2str(arrayBuf) {
    var s = '';
    for (var i = 0; i < arrayBuf.length; i++) {
        s += String.fromCharCode(arrayBuf[i]);
    }
    return s;
}
function loadRerl(reader, block) {
    reader.seek(block.offset);
    var resOffset = reader.getInt32(); // Seems to be always 0x00000008
    var resCount = reader.getInt32();
    block.externalFiles = {};
    block.externalFiles2 = [];
    reader.seek(block.offset + resOffset);
    for (var resIndex = 0; resIndex < resCount; resIndex++) {
        reader.seek(block.offset + resOffset + 16 * resIndex);
        var handle = readHandle(reader); //reader.getUint64(fieldOffset);
        var strOffset = reader.getInt32();
        reader.skip(strOffset - 4);
        var s = reader.getNullString();
        block.externalFiles[handle] = s;
        block.externalFiles2[resIndex] = s;
    }
}
function readHandle(reader) {
    var str = '';
    var c;
    var hex;
    for (var i = 0; i < 8; i++) {
        c = reader.getUint8();
        hex = c.toString(16); // convert to hex
        hex = (hex.length == 1 ? '0' + hex : hex);
        str += hex;
    }
    return str;
}
function loadNtro(reader, block) {
    var _NTRO_STRUCT_LENGTH_ = 40;
    var _NTRO_FIELD_LENGTH_ = 24;
    reader.seek(block.offset);
    // NTRO header
    reader.getInt32(); //TODO: check version
    var ntroOffset = reader.getInt32();
    var structCount = reader.getInt32();
    block.structs = {};
    block.structsArray = [];
    block.firstStruct = null;
    for (var structIndex = 0; structIndex < structCount; structIndex++) {
        reader.seek(block.offset + ntroOffset + 4 + _NTRO_STRUCT_LENGTH_ * structIndex);
        var ntroStruct = {};
        ntroStruct.version = reader.getInt32();
        //console.log(ntroStruct.version);
        ntroStruct._offset = reader.tell();
        ntroStruct.id = reader.getUint32();
        var strStart = reader.tell();
        var strOffset = reader.getInt32();
        ntroStruct.crc = reader.getInt32();
        ntroStruct.unknown1 = reader.getInt32();
        ntroStruct.discSize = reader.getInt16();
        ntroStruct.unknown = reader.getInt16(); //TODO
        ntroStruct.baseId = reader.getUint32();
        var fieldStart = reader.tell();
        var fieldOffset = reader.getInt32();
        var fieldCount = reader.getInt32();
        ntroStruct.flags = reader.getInt32();
        // Read struct Name
        reader.seek(strStart + strOffset);
        ntroStruct.name = reader.getNullString();
        //Read struct fields
        ntroStruct.fields = [];
        for (var fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {
            reader.seek(fieldStart + fieldOffset + _NTRO_FIELD_LENGTH_ * fieldIndex);
            var field = {};
            field._offset = fieldStart + fieldOffset + _NTRO_FIELD_LENGTH_ * fieldIndex;
            var strStart = reader.tell();
            var strOffset = reader.getInt32();
            field.count = reader.getInt16();
            field.offset = reader.getInt16();
            var indStart = reader.tell();
            field.indirectionOffset = reader.getInt32();
            field.level = reader.getInt32();
            field.typeOffset = reader.tell();
            field.type = reader.getUint32();
            field.type2 = reader.getUint16();
            // Read field Name
            reader.seek(strStart + strOffset);
            field.name = reader.getNullString();
            ntroStruct.fields.push(field);
            if (field.indirectionOffset) {
                field.indirectionByte = reader.getInt8(indStart + field.indirectionOffset);
                field.indirectionByte1 = indStart + field.indirectionOffset; //TODO: wtf ?
            }
        }
        block.structs[ntroStruct.id] = ntroStruct;
        block.structsArray.push(ntroStruct);
        if (block.firstStruct == null) {
            block.firstStruct = ntroStruct;
        }
    }
}
const defaultValuesPosition = create$4();
const defaultValuesNormal = create$4();
const defaultValuesTangent = create$3();
const defaultValuesCoord = create();
const defaultValuesBoneIndice = create$3();
const defaultValuesBoneWeight = fromValues$3(1.0, 0, 0, 0);
const VERTEX_POSITION_LEN = 3;
const VERTEX_NORMAL_LEN = 4;
const VERTEX_TANGENT_LEN = 4;
const VERTEX_COORD_LEN = 2;
const VERTEX_BONE_INDICE_LEN = 4;
const VERTEX_BONE_WEIGHT_LEN = 4;
const BYTES_PER_VERTEX_POSITION = VERTEX_POSITION_LEN * 4;
const BYTES_PER_VERTEX_NORMAL = VERTEX_NORMAL_LEN * 4;
const BYTES_PER_VERTEX_TANGENT = VERTEX_TANGENT_LEN * 4;
const BYTES_PER_VERTEX_COORD = VERTEX_COORD_LEN * 4;
const BYTES_PER_VERTEX_BONE_INDICE = VERTEX_BONE_INDICE_LEN * 4;
const BYTES_PER_VERTEX_BONE_WEIGHT = VERTEX_BONE_WEIGHT_LEN * 4;
const BYTES_PER_INDEX = 1 * 4;
function loadVbib(reader, block) {
    var VERTEX_HEADER_SIZE = 24;
    var INDEX_HEADER_SIZE = 24;
    var DESC_HEADER_SIZE = 56;
    var DESC_HEADER_NAME_SIZE = 36;
    reader.seek(block.offset);
    var vertexOffset = reader.tell() + reader.getInt32();
    var vertexCount = reader.getInt32();
    var indexOffset = reader.tell() + reader.getInt32();
    var indexCount = reader.getInt32();
    block.vertices = [];
    block.indices = [];
    for (var i = 0; i < vertexCount; i++) { // header size: 24 bytes
        reader.seek(vertexOffset + i * VERTEX_HEADER_SIZE);
        var s1 = {};
        s1.vertexCount = reader.getInt32();
        s1.bytesPerVertex = reader.getInt32();
        s1.headerOffset = reader.tell() + reader.getInt32();
        s1.headerCount = reader.getInt32();
        s1.dataOffset = reader.tell() + reader.getInt32();
        s1.dataLength = reader.getInt32();
        let vertexDataSize = s1.vertexCount * s1.bytesPerVertex;
        let vertexReader = reader;
        if (vertexDataSize != s1.dataLength) {
            let vertexBuffer = new Uint8Array(new ArrayBuffer(vertexDataSize));
            MeshoptDecoder.decodeVertexBuffer(vertexBuffer, s1.vertexCount, s1.bytesPerVertex, new Uint8Array(reader.buffer.slice(s1.dataOffset, s1.dataOffset + s1.dataLength)));
            //SaveFile('sa.obj', new Blob([vertexBuffer]));
            vertexReader = new BinaryReader(vertexBuffer);
            s1.dataOffset = 0;
        }
        s1.headers = [];
        for (var j = 0; j < s1.headerCount; j++) { // header size: 24 bytes
            var header = {};
            var headerOffset = s1.headerOffset + j * DESC_HEADER_SIZE;
            reader.seek(headerOffset);
            header.name = reader.getNullString();
            reader.seek(headerOffset + DESC_HEADER_NAME_SIZE);
            header.type = reader.getUint32();
            header.offset = reader.getUint32();
            s1.headers.push(header);
        }
        s1.vertices = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_POSITION);
        s1.normals = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_NORMAL);
        s1.tangents = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_TANGENT);
        s1.coords = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_COORD);
        s1.boneIndices = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_BONE_INDICE);
        s1.boneWeight = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_BONE_WEIGHT);
        let s1Vertices = new Float32Array(s1.vertices);
        let s1Normals = new Float32Array(s1.normals);
        let s1Tangents = new Float32Array(s1.tangents);
        let s1Coords = new Float32Array(s1.coords);
        let s1BoneIndices = new Float32Array(s1.boneIndices);
        let s1BoneWeight = new Float32Array(s1.boneWeight);
        for (var vertexIndex = 0; vertexIndex < s1.vertexCount; vertexIndex++) {
            vertexReader.seek(s1.dataOffset + vertexIndex * s1.bytesPerVertex);
            var positionFilled = false; //TODOv3: remove this
            var normalFilled = false;
            var tangentFilled = false;
            var texCoordFilled = false;
            var blendIndicesFilled = false;
            var blendWeightFilled = false;
            for (var headerIndex = 0; headerIndex < s1.headers.length; headerIndex++) {
                var headerName = s1.headers[headerIndex].name;
                var headerType = s1.headers[headerIndex].type;
                let tempValue; // = vec4.create();//TODO: optimize
                vertexReader.seek(s1.dataOffset + vertexIndex * s1.bytesPerVertex + s1.headers[headerIndex].offset);
                switch (headerType) {
                    case DXGI_FORMAT_R32G32B32A32_FLOAT:
                        tempValue = create$3(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        tempValue[2] = vertexReader.getFloat32();
                        tempValue[3] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R32G32B32_FLOAT: // 3 * float32
                        tempValue = create$4(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        tempValue[2] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R16G16B16A16_SINT:
                        tempValue = create$3(); //TODO: optimize
                        tempValue[0] = vertexReader.getInt16();
                        tempValue[1] = vertexReader.getInt16();
                        tempValue[2] = vertexReader.getInt16();
                        tempValue[3] = vertexReader.getInt16();
                        break;
                    case DXGI_FORMAT_R32G32_FLOAT: // 2 * float32
                        tempValue = create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R8G8B8A8_UNORM:
                        tempValue = create$3(); //TODO: optimize
                        tempValue[0] = vertexReader.getUint8() / 255;
                        tempValue[1] = vertexReader.getUint8() / 255;
                        tempValue[2] = vertexReader.getUint8() / 255;
                        tempValue[3] = vertexReader.getUint8() / 255;
                        //vertexReader.getUint8();
                        break;
                    case DXGI_FORMAT_R8G8B8A8_UINT: // 4 * uint8
                        tempValue = create$3(); //TODO: optimize
                        tempValue[0] = vertexReader.getUint8();
                        tempValue[1] = vertexReader.getUint8();
                        tempValue[2] = vertexReader.getUint8();
                        tempValue[3] = vertexReader.getUint8();
                        break;
                    case DXGI_FORMAT_R16G16_FLOAT: // 2 * float16
                        tempValue = create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat16();
                        tempValue[1] = vertexReader.getFloat16();
                        break;
                    case DXGI_FORMAT_R16G16_SNORM: //New with battlepass 2022
                        tempValue = create(); //TODO: optimize
                        tempValue[0] = sNormUint16(vertexReader.getInt16());
                        tempValue[1] = sNormUint16(vertexReader.getInt16());
                        break;
                    case DXGI_FORMAT_R16G16_SINT:
                        tempValue = create(); //TODO: optimize
                        tempValue[0] = vertexReader.getInt16();
                        tempValue[1] = vertexReader.getInt16();
                        break;
                    case DXGI_FORMAT_R32_FLOAT: // single float32 ??? new in half-life Alyx
                        tempValue = [];
                        tempValue[0] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R32_UINT: // single uint32 ??? new since DOTA2 2023_08_30
                        tempValue = [];
                        tempValue[0] = vertexReader.getUint32();
                        s1.decompressTangentV2 = true;
                        break;
                    default:
                        //TODO add types when needed. see DxgiFormat.js
                        console.error('Warning: unknown type ' + headerType + ' for value ' + headerName);
                        tempValue = create$3(); //TODO: optimize
                        tempValue[0] = 0;
                        tempValue[1] = 0;
                        tempValue[2] = 0;
                        tempValue[3] = 0;
                }
                switch (headerName) {
                    case 'POSITION':
                        s1Vertices.set(tempValue, vertexIndex * VERTEX_POSITION_LEN);
                        positionFilled = true;
                        break;
                    case 'NORMAL':
                        s1Normals.set(tempValue, vertexIndex * VERTEX_NORMAL_LEN); //TODOv3
                        normalFilled = true;
                        break;
                    case 'TANGENT':
                        s1Tangents.set(tempValue, vertexIndex * VERTEX_NORMAL_LEN); //TODOv3
                        tangentFilled = true;
                        break;
                    case 'TEXCOORD':
                        if (!texCoordFilled) { //TODO: handle 2 TEXCOORD
                            let test = clone(tempValue); //todov3: fixme see //./Alyx/models/props_industrial/hideout_doorway.vmdl_c
                            s1Coords.set(test /*tempValue*/, vertexIndex * VERTEX_COORD_LEN);
                            texCoordFilled = true;
                        }
                        break;
                    case 'BLENDINDICES':
                        /*s1.boneIndices.push(tempValue[0]);
                        s1.boneIndices.push(tempValue[1]);
                        s1.boneIndices.push(tempValue[2]);
                        s1.boneIndices.push(tempValue[3]);*/
                        s1BoneIndices.set(tempValue, vertexIndex * VERTEX_BONE_INDICE_LEN);
                        blendIndicesFilled = true;
                        break;
                    case 'BLENDWEIGHT':
                        /*s1.boneWeight.push(tempValue[0]);
                        s1.boneWeight.push(tempValue[1]);
                        s1.boneWeight.push(tempValue[2]);
                        s1.boneWeight.push(tempValue[3]);*/
                        //vec4.scale(tempValue, tempValue, 1 / 255.0);
                        s1BoneWeight.set(tempValue, vertexIndex * VERTEX_BONE_WEIGHT_LEN);
                        blendWeightFilled = true;
                        break;
                    //TODOv3: add "texcoord" lowercase maybe a z- tex coord ?
                }
            }
            //TODOv3: remove this
            if (!positionFilled) {
                /*s1.vertices.push(0);
                s1.vertices.push(0);
                s1.vertices.push(0);*/
                s1Vertices.set(defaultValuesPosition, vertexIndex * VERTEX_POSITION_LEN);
            }
            if (!normalFilled) {
                /*s1.normals.push(0);
                s1.normals.push(0);
                s1.normals.push(0);*/
                s1Normals.set(defaultValuesNormal, vertexIndex * VERTEX_NORMAL_LEN);
            }
            if (!tangentFilled) {
                s1Tangents.set(defaultValuesTangent, vertexIndex * VERTEX_TANGENT_LEN);
            }
            if (!texCoordFilled) {
                /*s1.coords.push(0);
                s1.coords.push(0);*/
                s1Coords.set(defaultValuesCoord, vertexIndex * VERTEX_COORD_LEN);
            }
            if (!blendIndicesFilled) {
                /*s1.boneIndices.push(0);
                s1.boneIndices.push(0);
                s1.boneIndices.push(0);
                s1.boneIndices.push(0);*/
                s1BoneIndices.set(defaultValuesBoneIndice, vertexIndex * VERTEX_BONE_INDICE_LEN);
            }
            if (!blendWeightFilled) {
                /*s1.boneWeight.push(255);
                s1.boneWeight.push(0);
                s1.boneWeight.push(0);
                s1.boneWeight.push(0);*/
                s1BoneWeight.set(defaultValuesBoneWeight, vertexIndex * VERTEX_BONE_WEIGHT_LEN);
            }
        }
        block.vertices.push(s1);
    }
    //console.log(block.vertices);
    for (var i = 0; i < indexCount; i++) { // header size: 24 bytes
        reader.seek(indexOffset + i * INDEX_HEADER_SIZE);
        var s2 = {};
        s2.indexCount = reader.getInt32();
        s2.bytesPerIndex = reader.getInt32();
        s2.headerOffset = reader.tell() + reader.getInt32();
        s2.headerCount = reader.getInt32();
        s2.dataOffset = reader.tell() + reader.getInt32();
        s2.dataLength = reader.getInt32();
        let indexDataSize = s2.indexCount * s2.bytesPerIndex;
        let indexReader = reader;
        if (indexDataSize != s2.dataLength) {
            let indexBuffer = new Uint8Array(new ArrayBuffer(indexDataSize));
            MeshoptDecoder.decodeIndexBuffer(indexBuffer, s2.indexCount, s2.bytesPerIndex, new Uint8Array(reader.buffer.slice(s2.dataOffset, s2.dataOffset + s2.dataLength)));
            indexReader = new BinaryReader(indexBuffer);
            s2.dataOffset = 0;
        }
        s2.indices = new ArrayBuffer(s2.indexCount * BYTES_PER_INDEX);
        let s2Indices = new Uint32Array(s2.indices);
        for (var indicesIndex = 0; indicesIndex < s2.indexCount; indicesIndex++) {
            indexReader.seek(s2.dataOffset + indicesIndex * s2.bytesPerIndex);
            //s2.indices.push(indexReader.getUint16());
            if (s2.bytesPerIndex == 2) {
                s2Indices[indicesIndex] = indexReader.getUint16();
            }
            else {
                s2Indices[indicesIndex] = indexReader.getUint32();
            }
        }
        block.indices.push(s2);
    }
}
function getStruct(block, structId) {
    return block.structs[structId];
}
function loadStruct(reader, reference, struct, block, startOffset, introspection, depth) {
    var dataStruct = {};
    if (struct.baseId) {
        var baseStruct = getStruct(introspection, struct.baseId);
        if (baseStruct) {
            dataStruct = loadStruct(reader, reference, baseStruct, block, startOffset, introspection);
        }
    }
    var fieldList = struct.fields;
    for (var fieldIndex = 0; fieldIndex < fieldList.length; fieldIndex++) {
        var field = fieldList[fieldIndex];
        if (field.count) {
            dataStruct[field.name] = [];
            FIELD_SIZE[field.type2];
            for (var i = 0; i < field.count; i++) {
                dataStruct[field.name].push(255); //TODOv3 dafuck ?
            }
        }
        else {
            dataStruct[field.name] = loadField(reader, reference, field, block, startOffset, introspection, field.offset, field.indirectionByte, field.level);
        }
    }
    dataStruct._name = struct.name;
    return dataStruct;
}
const FIELD_SIZE = [0, 0 /*STRUCT*/, 0 /*ENUM*/, 8 /*HANDLE*/, 0, 0, 0, 0, 0, 0,
    1 /*BYTE*/, 1 /*BYTE*/, 2 /*SHORT*/, 2 /*SHORT*/, 4 /*INTEGER*/, 4 /*INTEGER*/, 8 /*INT64*/, 8 /*INT64*/,
    4 /*FLOAT*/, 0, 0, 0, 12 /*VECTOR3*/, 0, 0, 16 /*QUATERNION*/, 0, 16, 4, 0, 1, 4];
function loadField(reader, reference, field, block, startOffset, introspection, field_offset, field_indirectionByte, field_level, depth) {
    var fieldOffset = startOffset + field_offset;
    if (field_level > 0) {
        reader.getInt8(fieldOffset);
        if (field_indirectionByte == 3) { // Pointer
            var struct = introspection.structs[field.type];
            if (struct) {
                var pos = reader.getUint32(fieldOffset);
                return loadStruct(reader, reference, struct, null, fieldOffset + pos, introspection);
            }
            else {
                console.log('Unknown struct ' + field.type, fieldOffset);
            }
            console.log(fieldOffset);
            return fieldOffset;
        }
        else if (field_indirectionByte == 4) { // Array
            //console.log("indirect type 4", reader.getUint32(fieldOffset));
            var arrayOffset2 = reader.getUint32(fieldOffset);
            if (arrayOffset2) {
                var arrayOffset = fieldOffset + arrayOffset2;
                var arrayCount = reader.getUint32();
                var values = [];
                if (field.type) {
                    if (field.type2 == DATA_TYPE_STRUCT) { // STRUCT
                        var struct = introspection.structs[field.type];
                        if (struct) {
                            for (var i = 0; i < arrayCount; i++) {
                                var pos = arrayOffset + struct.discSize * i;
                                //reader.seek(reader.getUint32(pos) + pos);
                                reader.seek(pos);
                                //var name = reader.getNullString();
                                //values[name] = this.loadStruct(reader, struct, null, pos, introspection);
                                values.push(loadStruct(reader, reference, struct, block, pos, introspection));
                            }
                        }
                        else {
                            console.log('Unknown struct ' + field.type, fieldOffset);
                        }
                    }
                    else if (field.type2 == DATA_TYPE_HANDLE) { // HANDLE
                        // Handle to an external ressource in the RERL block
                        for (var i = 0; i < arrayCount; i++) {
                            var pos = arrayOffset + 8 * i;
                            reader.seek(pos);
                            var handle = readHandle(reader);
                            values[i] = reference ? reference.externalFiles[handle] : null;
                        }
                        //reader.seek(fieldOffset);
                        //var handle = readHandle(reader);
                        return values; //this.reference.externalFiles[handle];
                    }
                    else {
                        console.log('Unknown struct type for array ' + field, fieldOffset);
                    }
                }
                else {
                    // single field
                    var values = [];
                    var fieldSize = FIELD_SIZE[field.type2];
                    if (field.type2 == 11) ;
                    for (var i = 0; i < arrayCount; i++) {
                        var pos = arrayOffset + fieldSize * i;
                        /*reader.seek(reader.getUint32(pos) + pos);
                        var name = reader.getNullString();*/
                        values.push(loadField(reader, reference, field, null, pos, introspection, 0, 0, 0));
                    }
                    return values;
                }
            }
            return values;
        }
        else {
            // No indirection
            return null;
        }
    }
    else {
        //fieldOffset += field_offset;
        switch (field.type2) {
            case DATA_TYPE_STRUCT: //1
                var struct = introspection.structs[field.type];
                if (struct) {
                    return loadStruct(reader, reference, struct, null, fieldOffset, introspection);
                }
                console.log(fieldOffset);
                return;
            case DATA_TYPE_ENUM: //2
                return ['enum', field.name, field.type2, fieldOffset, reader.getInt32(fieldOffset)];
            case DATA_TYPE_HANDLE: //3
                // Handle to an external ressource in the RERL block
                reader.seek(fieldOffset);
                var handle = readHandle(reader);
                return reference ? reference.externalFiles[handle] : null;
            case DATA_TYPE_BYTE: //10
                return reader.getInt8(fieldOffset);
            case DATA_TYPE_UBYTE: //11
                return reader.getUint8(fieldOffset);
            case DATA_TYPE_SHORT: //12
                return reader.getInt16(fieldOffset);
            case DATA_TYPE_USHORT: //13
                return reader.getUint16(fieldOffset);
            case DATA_TYPE_INTEGER: //14
                return reader.getInt32(fieldOffset);
            case DATA_TYPE_UINTEGER: //15
                return reader.getUint32(fieldOffset);
            case DATA_TYPE_INT64: //16
                let i64 = reader.getBigInt64(fieldOffset);
                return i64; //i64.lo + i64.hi * 4294967295;
            case DATA_TYPE_UINT64: //17
                let ui64 = reader.getBigUint64(fieldOffset);
                return ui64; //ui64.lo + ui64.hi * 4294967295;
            case DATA_TYPE_FLOAT: //18
                return reader.getFloat32(fieldOffset);
            case DATA_TYPE_VECTOR2: //21
                return reader.getVector2(fieldOffset);
            case DATA_TYPE_VECTOR3: //22
                return reader.getVector3(fieldOffset);
            case DATA_TYPE_VECTOR4: //23
                return reader.getVector4(fieldOffset);
            case DATA_TYPE_QUATERNION: //25
                return reader.getVector4(fieldOffset);
            case DATA_TYPE_BOOLEAN: //30
                return (reader.getInt8(fieldOffset)) ? true : false;
            case DATA_TYPE_NAME: //31
                var strOffset = reader.getInt32(fieldOffset);
                /*if ((strOffset<0) || (strOffset>10000)) {
                    console.log(strOffset);
                }*/
                reader.seek(fieldOffset + strOffset);
                return reader.getNullString();
            case 40: //DATA_TYPE_VECTOR4://40
                return reader.getVector4(fieldOffset);
            default:
                console.error(`Unknown field type: ${field.type2}`);
        }
    }
}
function loadDataVtex(reader, block) {
    const DATA_FALLBACK_BITS = 1;
    const DATA_SHEET = 2;
    const DATA_FILL_TO_POWER_OF_TWO = 3;
    const DATA_COMPRESSED_MIP_SIZE = 4;
    const DATA_CUBEMAP_RADIANCE = 5;
    reader.seek(block.offset);
    block.vtexVersion = reader.getUint16();
    block.flags = reader.getUint16();
    block.reflectivity = reader.getVector4();
    block.width = reader.getUint16();
    block.height = reader.getUint16();
    block.depth = reader.getUint16();
    block.imageFormat = reader.getUint8();
    block.numMipLevels = reader.getUint8();
    block.picmip0Res = reader.getUint32();
    reader.tell() + reader.getUint32();
    let extraDataCount = reader.getUint32();
    let compressedMips = null; //new Uint32Array(mips);
    if (extraDataCount) {
        /* read headers */
        let headers = [];
        for (let i = 0; i < extraDataCount; i++) {
            let h = {
                type: reader.getUint32(),
                offset: reader.tell() + reader.getUint32(),
                size: reader.getUint32(),
            };
            headers.push(h);
        }
        for (let i = 0; i < extraDataCount; i++) {
            let h = headers[i];
            let type = h.type;
            let offset = h.offset;
            let size = h.size;
            reader.seek(offset);
            switch (type) {
                case DATA_FALLBACK_BITS:
                    reader.seek(offset + size);
                    break;
                case DATA_FILL_TO_POWER_OF_TWO:
                    reader.getUint16();
                    let nw = reader.getUint16();
                    let nh = reader.getUint16();
                    if (nw > 0 && nh > 0 && block.width >= nw && block.height >= nh) {
                        console.error('code me');
                    }
                    break;
                case DATA_COMPRESSED_MIP_SIZE:
                    let unk1 = reader.getUint32();
                    let unk2 = reader.getUint32();
                    let mips = reader.getUint32();
                    compressedMips = new Array(mips); // we can't upe pop() on a Uint32Array
                    for (let i = 0; i < mips; i++) {
                        compressedMips[i] = reader.getUint32();
                    }
                    console.warn(`compressed mips : ${unk1} ${unk2} ${mips}`, compressedMips);
                    break;
                case DATA_SHEET:
                    loadVtexSpriteSheet(reader, block, offset);
                    /*if (TESTING) {
                        SaveFile(new File([new Blob([reader.getBytes(size, offset)])], 'block_' + size + '_' + offset));
                    }*/
                    break;
                case DATA_CUBEMAP_RADIANCE:
                    loadVtexCubemapRadiance(reader, block, offset);
                    break;
                default:
                    /*if (TESTING) {
                        SaveFile(new File([new Blob([reader.getBytes(size, offset)])], 'block_' + size + '_' + offset));
                    }*/
                    console.error(`Unknow type : ${type}`);
            }
        }
    }
    loadDataVtexImageData(reader, block, compressedMips);
}
function loadDataVtexImageData(reader, block, compressedMips) {
    var faceCount = 1;
    if ((block.flags & VTEX_FLAG_CUBE_TEXTURE) == VTEX_FLAG_CUBE_TEXTURE) { // Handle cube texture
        faceCount = 6;
    }
    // Goto
    reader.seek(block.file.fileLength);
    var mipmapWidth = block.width * Math.pow(0.5, block.numMipLevels - 1);
    var mipmapHeight = block.height * Math.pow(0.5, block.numMipLevels - 1);
    block.imageData = [];
    // Only keep last (biggest) mipmap
    for (var mipmapIndex = 0; mipmapIndex < block.numMipLevels; mipmapIndex++) {
        // Todo : add frame support + depth support
        for (var faceIndex = 0; faceIndex < faceCount; faceIndex++) {
            let compressedLength = compressedMips ? compressedMips.pop() : null; //TODO: check how this actually works with depth / frames
            block.imageData[faceIndex] = getImage(reader, mipmapWidth, mipmapHeight, block.imageFormat, compressedLength);
        }
        mipmapWidth *= 2;
        mipmapHeight *= 2;
    }
}
function getImage(reader, mipmapWidth, mipmapHeight, imageFormat, compressedLength) {
    let entrySize = 0;
    switch (imageFormat) {
        case VTEX_FORMAT_DXT1:
            entrySize = Math.max(mipmapWidth * mipmapHeight * 0.5, 8); // 0.5 byte per pixel
            break;
        case VTEX_FORMAT_DXT5:
            entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel
            break;
        case VTEX_FORMAT_R8:
            entrySize = Math.max(mipmapWidth, 1) * Math.max(mipmapHeight, 1); // 1 byte per pixel;
            break;
        case VTEX_FORMAT_R8G8B8A8_UINT:
        case VTEX_FORMAT_BGRA8888:
            // 4 bytes per pixel
            entrySize = mipmapWidth * mipmapHeight * 4;
            break;
        case VTEX_FORMAT_PNG_R8G8B8A8_UINT:
            entrySize = reader.byteLength - reader.tell();
            let a = reader.tell();
            //SaveFile('loadout.obj', b64toBlob(encode64(reader.getString(entrySize))));//TODOv3: removeme
            reader.seek(a);
            break;
        case VTEX_FORMAT_BC4:
        case VTEX_FORMAT_BC5:
            entrySize = Math.ceil(mipmapWidth / 4) * Math.ceil(mipmapHeight / 4) * 8; // 0.5 byte per pixel
            break;
        case VTEX_FORMAT_BC7:
            entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel, blocks of 16 bytes
            break;
        default:
            console.warn('Unknown image format ' + imageFormat, reader, mipmapWidth, mipmapHeight, compressedLength);
    }
    let imageDatas;
    if (compressedLength === null || compressedLength === entrySize) {
        let start = reader.tell();
        //return reader.getString(entrySize);
        imageDatas = new Uint8Array(reader.buffer, reader.tell(), entrySize);
        reader.seek(start + entrySize);
    }
    else {
        let start = reader.tell();
        var buf = new ArrayBuffer(entrySize);
        imageDatas = new Uint8Array(buf);
        decodeLz4(reader, imageDatas, compressedLength, entrySize);
        reader.seek(start + compressedLength); // decoder may overread, place the reader at the start of the next image block
        if ((start + compressedLength) != reader.tell()) {
            console.error('error decoding texture: wrong decompressed size: ', start, compressedLength, entrySize);
        }
    }
    if (imageDatas && imageFormat == VTEX_FORMAT_BGRA8888) {
        for (let i = 0, l = imageDatas.length; i < l; i += 4) {
            let b = imageDatas[i];
            imageDatas[i] = imageDatas[i + 2];
            imageDatas[i + 2] = b;
        }
    }
    return imageDatas;
}
//KV3_ENCODING_BLOCK_COMPRESSED = '\x46, \x1A, \x79, \x95, \xBC, \x95, \x6C, \x4F, \xA7, \x0B, \x05, \xBC, \xA1, \xB7, \xDF, \xD2';
function loadDataVkv(reader, block) {
    const KV3_ENCODING_BLOCK_COMPRESSED = '\x46\x1A\x79\x95\xBC\x95\x6C\x4F\xA7\x0B\x05\xBC\xA1\xB7\xDF\xD2';
    const KV3_ENCODING_BLOCK_COMPRESSED_LZ4 = '\x8A\x34\x47\x68\xA1\x63\x5C\x4F\xA1\x97\x53\x80\x6F\xD9\xB1\x19';
    //const KV3_ENCODING_BLOCK_COMPRESSED_UNKNOWN = '\x7C\x16\x12\x74\xE9\x06\x98\x46\xAF\xF2\xE6\x3E\xB5\x90\x37\xE7';
    reader.seek(block.offset);
    reader.skip(4); //TODO: improve detection
    let encoding = reader.getString(16);
    reader.getString(16);
    let decodeLength, sa;
    decodeLength = reader.getUint32();
    if ((decodeLength >>> 24) == 0x80) {
        sa = reader.getBytes(decodeLength & 0xFF);
        //sa = reader.getBytes(undefined, 0);
    }
    else {
        sa = new Uint8Array(new ArrayBuffer(decodeLength));
        switch (encoding) {
            case KV3_ENCODING_BLOCK_COMPRESSED:
                /*if ((decodeLength >>> 24) == 0x80) {

                } else {*/
                decodeMethod1(reader, sa, decodeLength);
                //}
                break;
            case KV3_ENCODING_BLOCK_COMPRESSED_LZ4:
                decodeLz4(reader, sa, block.length, decodeLength);
                break;
            default:
                console.error('Unknow kv3 encoding ', encoding.split(''));
                break;
        }
    }
    block.keyValue = BinaryKv3Loader.getBinaryVkv3(ab2str(sa));
}
/*
Struct of a kv3 block
In a single lz4 compressed block:
uint32 string count
byte array
four bytes array
eight bytes array
array of null terminated strings
type array (1 byte)
V2 only : uint32 * blobCount array
0xFFDDEE00 // don't ask why this is no more at the end
V2 only : uint16 * blobCount array


Follows the compressed blobs
*/
async function loadDataKv3(reader, block, version) {
    reader.seek(block.offset);
    let bufferCount = 1;
    const uncompressedBufferSize = [];
    const compressedBufferSize = [];
    const bytesBufferSize1 = [];
    const bytesBufferSize2 = [];
    const bytesBufferSize4 = [];
    const bytesBufferSize8 = [];
    const objectCount = [];
    const arrayCount = [];
    reader.skip(4);
    reader.getString(16);
    let compressionMethod = reader.getUint32();
    let compressionFrameSize;
    let dictionaryTypeLength, blobCount = 0, totalUncompressedBlobSize;
    if (version >= 2) {
        reader.getUint16();
        compressionFrameSize = reader.getUint16();
        //unknown1 = reader.getUint32();//0 or 0x40000000 depending on compression method
    }
    bytesBufferSize1.push(reader.getUint32());
    bytesBufferSize2.push(0);
    bytesBufferSize4.push(reader.getUint32());
    bytesBufferSize8.push(reader.getUint32());
    let compressedLength = block.length;
    if (version >= 2) {
        dictionaryTypeLength = reader.getUint32();
        objectCount.push(reader.getUint16());
        arrayCount.push(reader.getUint16());
    }
    var decodeLength = reader.getUint32();
    if (version >= 2) {
        compressedLength = reader.getUint32();
        blobCount = reader.getUint32();
        totalUncompressedBlobSize = reader.getUint32();
    }
    if (version >= 4) {
        reader.getUint32();
        reader.getUint32();
    }
    if (version >= 5) {
        bufferCount = 2;
        uncompressedBufferSize.push(reader.getUint32());
        compressedBufferSize.push(reader.getUint32());
        uncompressedBufferSize.push(reader.getUint32());
        compressedBufferSize.push(reader.getUint32());
        bytesBufferSize1.push(reader.getUint32());
        bytesBufferSize2.push(reader.getUint32());
        bytesBufferSize4.push(reader.getUint32());
        bytesBufferSize8.push(reader.getUint32());
        // TODO: use those values
        reader.getUint32();
        objectCount.push(reader.getUint32());
        arrayCount.push(reader.getUint32());
        reader.getUint32();
        //console.info(block.type, block, uncompressedBufferSize, compressedBufferSize, bytesBufferSize1, bytesBufferSize2, bytesBufferSize4, bytesBufferSize8)
    }
    else {
        uncompressedBufferSize.push(decodeLength);
        compressedBufferSize.push(compressedLength);
    }
    let sa;
    let compressedBlobReader;
    let uncompressedBlobReader;
    let stringDictionary;
    let buffer0;
    for (let i = 0; i < bufferCount; i++) {
        switch (compressionMethod) {
            case 0:
                sa = reader.getBytes(uncompressedBufferSize[i]);
                break;
            case 1:
                let buf = new ArrayBuffer(uncompressedBufferSize[i]);
                sa = new Uint8Array(buf);
                if (blobCount > 0) {
                    compressedBlobReader = new BinaryReader(reader, reader.tell() + compressedBufferSize[i]);
                }
                decodeLz4(reader, sa, compressedBufferSize[i], uncompressedBufferSize[i]);
                break;
            case 2: //new since spectre arcana
                //SaveFile(new File([new Blob([reader.getBytes(block.length, block.offset)])], 'block_' + block.offset + '_' + block.length));
                let compressedBytes = reader.getBytes(compressedBufferSize[i]);
                //SaveFile(new File([new Blob([compressedBytes])], 'block_' + block.offset + '_' + block.length));
                let decompressedBytes = await Zstd.decompress(compressedBytes);
                sa = new Uint8Array(new Uint8Array(decompressedBytes.buffer, 0, uncompressedBufferSize[i]));
                if (blobCount > 0) {
                    if (version < 5) {
                        uncompressedBlobReader = new BinaryReader(decompressedBytes, uncompressedBufferSize[i]);
                    }
                    else {
                        if (i == 1) {
                            const compressedBlobSize = compressedLength - (compressedBufferSize[0] + compressedBufferSize[1]);
                            let compressedBlobBytes = reader.getBytes(compressedBlobSize);
                            //SaveFile(new File([new Blob([compressedBlobBytes])], 'compressed_zstd' + block.type + '_' + i + '_' + block.length + '_' + block.offset));
                            let decompressedBlobBytes = await Zstd.decompress(compressedBlobBytes);
                            //console.info(decompressedBlobBytes);
                            uncompressedBlobReader = new BinaryReader(decompressedBlobBytes);
                            //SaveFile(new File([new Blob([decompressedBlobBytes])], 'decompressed_zstd' + block.type + '_' + i + '_' + block.length + '_' + block.offset));
                        }
                        //compressedBlobReader = new BinaryReader(reader, reader.tell());
                    }
                }
                //console.error(sa);
                //SaveFile(new File([new Blob([sa])], 'zstd'));
                break;
            default:
                throw 'Unknow kv3 compressionMethod ' + compressionMethod;
        }
        const result = BinaryKv3Loader.getBinaryKv3(version, sa, bytesBufferSize1, bytesBufferSize2, bytesBufferSize4, bytesBufferSize8, dictionaryTypeLength, blobCount, totalUncompressedBlobSize, compressedBlobReader, uncompressedBlobReader, compressionFrameSize, i, stringDictionary, objectCount[i], arrayCount[i], buffer0);
        if (version >= 5 && i == 0) {
            stringDictionary = result;
            buffer0 = sa;
        }
        else {
            //console.log(block.type, result);
            block.keyValue = result;
        }
    }
}
function decodeMethod1(reader, sa, decodeLength) {
    let mask = null;
    let outputIndex = 0;
    let decodedeBytes = 0;
    decodeLoop: for (let i = 0;; i++) {
        mask = reader.getUint16();
        if (mask == 0) {
            /* TODO: copy 16 bytes at once */
            for (let j = 0; j < 16; j++) {
                sa[outputIndex++] = reader.getBytes(1)[0];
                ++decodedeBytes;
                if (decodedeBytes >= decodeLength) {
                    break decodeLoop;
                }
            }
        }
        else {
            for (let j = 0; j < 16; j++) {
                let decode = mask & (1 << j);
                if (decode) {
                    let decodeMask = reader.getUint16(); // offset 12 bits, len 4 bits
                    let decodeOffset = (decodeMask & 0xFFF0) >> 4;
                    let decodeLen = (decodeMask & 0xF) + 3; // Min len is 3
                    for (let k = 0; k < decodeLen; k++) {
                        sa[outputIndex] = sa[outputIndex - decodeOffset - 1];
                        ++decodedeBytes;
                        if (decodedeBytes >= decodeLength) {
                            break decodeLoop;
                        }
                        ++outputIndex;
                    }
                }
                else { // Single byte
                    sa[outputIndex++] = reader.getBytes(1)[0];
                    ++decodedeBytes;
                    if (decodedeBytes >= decodeLength) {
                        break decodeLoop;
                    }
                }
            }
        }
    }
}
function loadVtexSpriteSheet(reader, block, offset, size) {
    reader.seek(offset);
    reader.getUint32();
    let sequenceCount = reader.getUint32();
    let headerOffset = reader.tell();
    let spriteSheet = new Source2SpriteSheet();
    block.spriteSheet = spriteSheet;
    while (sequenceCount--) {
        let spriteSheetSequence = spriteSheet.addSequence();
        reader.getUint32(headerOffset);
        reader.getUint32(); //1 ? probably some flag -> clamp //0 in materials/particle/water_ripples/allripples
        //unknown1 is most likely 2 uint16 -> see dota2 texture materials/particle/smoke3/smoke3b
        let sequenceDataOffset = reader.tell() + reader.getUint32();
        let frameCount = reader.getUint32();
        spriteSheetSequence.duration = reader.getFloat32();
        reader.getUint32(); //offset to 'CDmeSheetSequence'
        reader.getUint32(); //0
        reader.getUint32(); //0
        headerOffset = reader.tell();
        reader.seek(sequenceDataOffset);
        let frameHeaderOffset = reader.tell();
        let frameIndex = frameCount;
        while (frameIndex--) {
            let spriteSheetFrame = spriteSheetSequence.addFrame();
            spriteSheetFrame.duration = reader.getFloat32(frameHeaderOffset);
            let frameOffset = reader.tell() + reader.getUint32();
            reader.getUint32();
            frameHeaderOffset = reader.tell();
            reader.seek(frameOffset);
            //while (frameCoords--) we should use all coords but they are identical ? probably one per channel
            {
                spriteSheetFrame.coords[0] = reader.getFloat32();
                spriteSheetFrame.coords[1] = reader.getFloat32();
                spriteSheetFrame.coords[2] = reader.getFloat32();
                spriteSheetFrame.coords[3] = reader.getFloat32();
            }
        }
        //console.error(sequenceId, frameCount, spriteSheetSequence.duration, sequenceDataOffset);
        //console.error(unknown1, unknown2, unknown3, unknown4);
    }
    //console.error(version, sequenceCount);
}
function loadVtexCubemapRadiance(reader, block, offset, size) {
    reader.seek(offset);
    const coeffOffset = reader.getUint32();
    const coeffCount = reader.getUint32();
    //Spherical Harmonics
    const coefficients = new Array(coeffCount);
    reader.seek(offset + coeffOffset);
    for (let i = 0; i < coeffCount; i++) {
        coefficients[i] = reader.getFloat32();
    }
    block.cubemapRadiance = coefficients;
}

class Source2FileLoader extends SourceBinaryLoader {
    vtex;
    constructor(vtex = false) {
        super();
        this.vtex = vtex;
    }
    async parse(repository, fileName, arrayBuffer) {
        let reader = new BinaryReader(arrayBuffer);
        let file = new Source2File(repository, fileName);
        await this.#parseHeader(reader, file, this.vtex);
        return file;
    }
    async #parseHeader(reader, file, parseVtex) {
        reader.tell();
        file.fileLength = reader.getUint32();
        file.versionMaj = reader.getUint16();
        file.versionMin = reader.getUint16();
        let headerOffset = reader.tell() + reader.getUint32();
        let resCount = reader.getUint32();
        let resType, resOffset, resLength, block;
        file.maxBlockOffset = 0;
        reader.seek(headerOffset); //Should already be at the right place, but just in case
        for (let i = 0; i < resCount; i++) {
            resType = reader.getString(4);
            resOffset = reader.tell() + reader.getUint32();
            resLength = reader.getUint32();
            file.maxBlockOffset = Math.max(file.maxBlockOffset, resOffset + resLength);
            block = new Source2FileBlock(file, resType, resOffset, resLength);
            file.addBlock(block);
        }
        for (let block of file.blocksArray) {
            if (block.length > 0) {
                await Source2BlockLoader.parseBlock(reader, file, block, parseVtex);
            }
        }
        return;
    }
}

/**
 * Mesh manager
 */
const MeshManager = new function () {
    var meshList = {};
    //this.renderMode = 2;
    //TODO
    var getMesh = async function (repository, meshName) {
        meshName = meshName.toLowerCase();
        meshName = meshName.replace(/.vmesh_c$/, '');
        meshName = meshName.replace(/.vmesh$/, '');
        var mesh = meshList[meshName];
        if (!mesh) {
            mesh = await new Source2FileLoader().load(repository, meshName + '.vmesh_c');
        }
        if (mesh) {
            meshList[meshName] = mesh;
        }
        else {
            //TODO; create a dummy mesh
            console.error('No mesh loaded');
        }
        return mesh;
    };
    //TODO
    var removeMesh = function (meshName) {
        meshList[meshName] = null;
    };
    this.getMesh = getMesh;
    this.removeMesh = removeMesh;
};

const tempPos = create$4();
const tempQuat$7 = create$2();
class Source2ModelAttachement {
    name;
    ignoreRotation = false;
    influenceNames = [];
    influenceWeights = [];
    influenceOffsets = [];
    influenceRotations = [];
    constructor(name) {
        this.name = name;
    }
}
class Source2ModelAttachementInstance extends Entity {
    model;
    attachement;
    constructor(model, attachement) {
        super({ name: attachement.name });
        this.model = model;
        this.attachement = attachement;
    }
    #getBone(boneName) {
        if (this.model) {
            return this.model.skeleton.getBoneByName(boneName);
        }
    }
    //TODO: compute with all bones, not only the first one
    getWorldPosition(vec = create$4()) {
        let bone = this.#getBone(this.attachement.influenceNames[0]);
        if (bone) {
            bone.getWorldPosition(vec);
            bone.getWorldQuaternion(tempQuat$7);
            transformQuat$1(tempPos, this.attachement.influenceOffsets[0], tempQuat$7);
            add$5(vec, vec, tempPos);
        }
        else {
            copy$4(vec, this._position);
        }
        return vec;
    }
    getWorldQuaternion(q = create$2()) {
        let bone = this.#getBone(this.attachement.influenceNames[0]);
        if (bone) {
            bone.getWorldQuaternion(q);
            mul$2(q, q, this.attachement.influenceRotations[0]);
        }
        else {
            copy$2(q, this._quaternion);
        }
        return q;
    }
}

class Source2MaterialLoader {
    static #materials = new Map();
    static load(repository, fileName) {
        let promise = new Promise((resolve, reject) => {
            fileName = fileName.replace(/.vmat_c$/, '');
            let vmatPromise = new Source2FileLoader().load(repository, fileName + '.vmat_c');
            vmatPromise.then((source2File) => {
                let material = this.#loadMaterial(repository, source2File);
                if (material) {
                    resolve(material);
                }
                else {
                    reject(source2File);
                }
            }).catch((error) => reject(error));
        });
        return promise;
    }
    static #loadMaterial(repository, file) {
        let shaderName = file.getBlockStruct('DATA.keyValue.root.m_shaderName') || file.getBlockStruct('DATA.structs.MaterialResourceData_t.m_shaderName');
        let material;
        let materialClass = this.#materials.get(shaderName.toLowerCase());
        if (materialClass !== undefined) {
            material = new materialClass(repository, file);
        }
        else {
            console.error(`Unknown material : ${shaderName} in ${file.fileName}`);
        }
        return material;
    }
    static registerMaterial(materialName, materialClass) {
        this.#materials.set(materialName.toLowerCase(), materialClass);
    }
}

function cleanSource2MaterialName(name) {
    name = name.replace(/\\/g, '/').toLowerCase().replace(/.vmat_c$/g, '').replace(/.vmat$/g, '');
    name = name + '.vmat_c';
    return name;
}
class Source2MaterialManager {
    static #materialList = new Map();
    static #materialList2 = new Set();
    static addMaterial(material) {
        this.#materialList2.add(material);
    }
    static removeMaterial(material) {
        this.#materialList2.delete(material);
    }
    static getMaterial(repository, fileName, searchPaths) {
        console.assert(searchPaths == null, 'searchPaths must be null'); //TODOv3 remove searchPaths
        fileName = cleanSource2MaterialName(fileName);
        if (searchPaths) {
            let promises = [];
            for (let searchPath of searchPaths) {
                promises.push(this.#getMaterial(repository, 'materials/' + searchPath + fileName));
            }
            let promise = new Promise(resolve => {
                Promise.allSettled(promises).then((promises) => {
                    for (let promise of promises) {
                        if (promise.status == 'fulfilled') {
                            resolve(promise.value);
                        }
                    }
                    resolve(null);
                });
            });
            return promise;
        }
        else {
            return this.#getMaterial(repository, fileName);
        }
    }
    static #getMaterial(repository, fileName) {
        let material = this.#materialList.get(fileName);
        if (material instanceof Promise) {
            let promise = new Promise((resolve, reject) => {
                material.then((material) => {
                    let newMaterial = material.clone();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                }).catch((value) => reject(value));
            });
            return promise;
        }
        if (material !== undefined) {
            return new Promise((resolve, reject) => {
                let newMaterial = material.clone();
                this.#materialList2.add(newMaterial);
                resolve(newMaterial);
            });
        }
        else {
            let promise = new Promise((resolve, reject) => {
                Source2MaterialLoader.load(repository, fileName).then((material) => {
                    this.#materialList.set(fileName, material);
                    let newMaterial = material.clone();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                }).catch((value) => reject(value));
            });
            this.#materialList.set(fileName, promise);
            return promise;
        }
    }
}

const identityVec3$1 = create$4();
const identityQuat = create$2();
const initSkeletonTempVec3 = create$4();
const initSkeletonTempQuat = create$2();
let animSpeed$1 = 1.0;
const defaultMaterial$2 = new MeshBasicMaterial();
class Source2ModelInstance extends Entity {
    isSource2ModelInstance = true;
    #skeleton;
    #skin = 0;
    #materialsUsed = new Set();
    #animName;
    animable = true;
    #lod = 1n;
    bodyParts = {};
    poseParameters = {};
    meshes = new Set();
    attachements = new Map();
    activity = '';
    activityModifiers = new Set();
    sequences = {};
    mainAnimFrame = 0;
    animationSpeed = 1.0;
    sourceModel;
    hasAnimations = true;
    #bodyGroups = new Map();
    constructor(sourceModel, isDynamic) {
        defaultMaterial$2.addUser(Source2ModelInstance);
        super();
        this.sourceModel = sourceModel;
        this.name = sourceModel?.vmdl?.displayName;
        if (isDynamic) {
            this.#skeleton = new Skeleton({ name: `Skeleton ${this.name}` });
            this.addChild(this.#skeleton);
        }
        if (isDynamic) {
            this.#initSkeleton();
            this.#initAttachements();
        }
        this.#init();
        this.#updateMaterials();
    }
    #initDefaultBodyGroups() {
        this.#bodyGroups.set('autodefault', undefined);
        for (const bodyGroup of this.sourceModel.bodyGroups) {
            this.#bodyGroups.set(bodyGroup, 0);
        }
        this.#refreshMeshesVisibility();
    }
    setBodyGroup(name, choice) {
        if (this.sourceModel.bodyGroups.has(name)) {
            this.#bodyGroups.set(name, choice);
        }
        this.#refreshMeshesVisibility();
    }
    #refreshMeshesVisibility() {
        let mask = 0n;
        for (const bodyGroupsChoice of this.sourceModel.bodyGroupsChoices) {
            const choice = this.#bodyGroups.get(bodyGroupsChoice.bodyGroup);
            if ((choice === undefined) || (bodyGroupsChoice.choice == `${bodyGroupsChoice.bodyGroup}_@${choice}`)) {
                mask += BigInt(Math.pow(2, bodyGroupsChoice.bodyGroupId));
            }
        }
        if (mask == 0n) {
            mask = 0xffffffffffffffffn;
        }
        for (const mesh of this.meshes) {
            const geometry = mesh.geometry;
            mesh.setVisible(undefined);
            if (geometry) {
                const meshGroupMask = BigInt(geometry.properties.get('mesh_group_mask'));
                const lodGroupMask = BigInt(geometry.properties.get('lodGroupMask'));
                mesh.setVisible((meshGroupMask & mask) > 0 ? undefined : false);
                if (lodGroupMask && ((lodGroupMask & this.#lod) == 0n)) {
                    mesh.setVisible(false);
                }
            }
        }
    }
    get skeleton() {
        return this.#skeleton;
    }
    set position(position) {
        super.position = position;
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    get position() {
        return clone$4(this._position);
    }
    addChild(child) {
        if (!child) {
            return;
        }
        let ret = super.addChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(this.#skeleton);
        }
        /*if (child instanceof Source2ModelInstance) {
            for (let mesh of child.meshes) {
                if (mesh.skeleton) {
                    mesh.skeleton.setParentSkeleton(this.#skeleton);
                }
            }
        }*/
        if ((this.#skeleton != child) && child instanceof Skeleton) {
            child.setParentSkeleton(this.#skeleton);
        }
        return ret;
    }
    removeChild(child) {
        super.removeChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(null);
        }
    }
    set skin(skin) {
        this.#skin = skin;
        this.#updateMaterials();
    }
    get skin() {
        return this.#skin;
    }
    setLOD(lod) {
        this.#lod = BigInt(lod);
        this.#refreshMeshesVisibility();
        this.forEach((child) => {
            if (child != this && child.setLOD) {
                child.setLOD(lod);
            }
        });
    }
    setPoseParameter(paramName, paramValue) {
        this.poseParameters[paramName] = paramValue;
    }
    playSequence(activity, activityModifiers = []) {
        this.activity = activity;
        this.setActivityModifiers(activityModifiers);
    }
    playAnimation(name) {
        this.#animName = name;
    }
    async setAnimation(id, name, weight) {
        this.#animName = name;
    }
    setActivityModifiers(activityModifiers = []) {
        this.activityModifiers.clear();
        for (let modifier of activityModifiers) {
            if (modifier) {
                this.activityModifiers.add(modifier);
            }
        }
    }
    update(scene, camera, delta) {
        if (this.#skeleton && this.isPlaying()) {
            this.#playSequences(delta * animSpeed$1 * this.animationSpeed);
            this.#skeleton.setBonesMatrix();
        }
        for (let mesh of this.meshes) {
            mesh.skeleton?.setBonesMatrix();
        }
    }
    #playSequences(delta) {
        if (this.#skeleton === null) {
            return null;
        }
        let animDesc;
        if (this.#animName) {
            animDesc = this.sourceModel.getAnimation(this.#animName);
        }
        else {
            animDesc = this.sourceModel.getAnim(this.activity, this.activityModifiers);
        }
        if (animDesc) {
            const posArray = animDesc.getFrame(Math.floor(this.mainAnimFrame % (animDesc.lastFrame + 1)));
            this.mainAnimFrame += delta * animDesc.fps;
            for (let i = 0; i < posArray.length; ++i) {
                var pos = posArray[i];
                let boneName = pos.name.toLowerCase();
                let propBone = this.#skeleton.getBoneByName(boneName);
                if (propBone) {
                    if (!propBone.locked) {
                        propBone.quaternion = pos.Angle || identityQuat;
                        propBone.position = pos.Position || identityVec3$1;
                    }
                }
            }
        }
        else {
            for (let bone of this.#skeleton.bones) {
                if (!bone.locked) {
                    bone.quaternion = bone.refQuaternion;
                    bone.position = bone.refPosition;
                }
            }
        }
    }
    #updateMaterials() {
        //console.error(this);
        let materials0 = this.sourceModel.getSkinMaterials(0);
        let materials = this.sourceModel.getSkinMaterials(this.#skin);
        /*if (!materials) {
            return;
        }*/
        //console.error(materials, this);
        for (let mesh of this.meshes) {
            if (materials0 && materials) {
                for (let i in materials0) {
                    if (materials0[i] == mesh.geometry.properties.get('materialPath')) {
                        let materialPath = materials[i];
                        if (materialPath) {
                            mesh.properties.set('materialPath', materialPath);
                        }
                        break;
                    }
                }
                /*let materialPath = materials[mesh.geometry.materialId];
                if (materialPath) {
                    mesh.materialPath = materialPath;
                }*/
            }
            else {
                mesh.properties.set('materialPath', mesh.geometry.properties.get('materialPath'));
            }
            Source2MaterialManager.getMaterial(this.sourceModel.repository, mesh.properties.get('materialPath')).then((material) => {
                material.addUser(this);
                mesh.setMaterial(material);
                this.#materialsUsed.add(material);
            });
        }
    }
    #init() {
        let sourceModel = this.sourceModel;
        for (let [bodyPartName, bodyPart] of sourceModel.bodyParts) {
            let newBodyPart = [];
            for (let model of bodyPart) {
                if (model) {
                    let newModel = [];
                    for (let geometry of model) {
                        let mesh;
                        if (this.#skeleton) {
                            mesh = new SkeletalMesh(geometry, defaultMaterial$2, this.#skeleton);
                            mesh.name = bodyPartName;
                            mesh.bonesPerVertex = 4;
                        }
                        else {
                            mesh = new Mesh(geometry, defaultMaterial$2);
                        }
                        if (geometry.hasAttribute('aVertexTangent')) {
                            mesh.setDefine('USE_VERTEX_TANGENT');
                        }
                        mesh.setVisible(undefined);
                        mesh.properties.set('materialPath', geometry.properties.get('materialPath'));
                        newModel.push(mesh);
                        this.addChild(mesh);
                        this.meshes.add(mesh);
                        mesh.setGeometry(geometry);
                    }
                    newBodyPart.push(newModel);
                }
            }
            this.bodyParts[bodyPartName] = newBodyPart;
        }
        this.#refreshMeshesVisibility();
        this.#initDefaultBodyGroups();
    }
    #initSkeleton() {
        let bones = this.sourceModel.getBones();
        if (bones) {
            let bonesName = bones.m_boneName;
            let bonePosParent = bones.m_bonePosParent;
            let boneRotParent = bones.m_boneRotParent;
            let boneParent = bones.m_nParent;
            if (bonesName && bonePosParent && boneRotParent && boneParent) {
                for (let modelBoneIndex = 0, m = bonesName.length; modelBoneIndex < m; ++modelBoneIndex) {
                    let boneName = bonesName[modelBoneIndex];
                    let bone = this.#skeleton.addBone(modelBoneIndex, boneName);
                    //bone.name = boneName;
                    bone.quaternion = boneRotParent[modelBoneIndex];
                    bone.position = bonePosParent[modelBoneIndex];
                    bone.refQuaternion = boneRotParent[modelBoneIndex];
                    bone.refPosition = bonePosParent[modelBoneIndex];
                    //const poseToBone = mat4.fromRotationTranslation(mat4.create(), bone.refQuaternion, bone.refPosition);//TODO: optimize
                    //mat4.invert(poseToBone, poseToBone);
                    let parent = Number(boneParent[modelBoneIndex]);
                    if (parent >= 0) {
                        //bone.parent = this.#skeleton.getBoneByName(bonesName[parent]);
                        let parentBone = this.#skeleton.getBoneByName(bonesName[parent]);
                        if (parentBone) {
                            parentBone.addChild(bone);
                            bone.getTotalRefQuaternion(initSkeletonTempQuat);
                            normalize$3(initSkeletonTempQuat, initSkeletonTempQuat);
                            const poseToBone = fromRotationTranslation$1(create$5(), initSkeletonTempQuat, bone.getTotalRefPosition(initSkeletonTempVec3));
                            invert$3(poseToBone, poseToBone);
                            bone.poseToBone = poseToBone;
                        }
                    }
                    else {
                        this.#skeleton.addChild(bone);
                        const poseToBone = fromRotationTranslation$1(create$5(), bone.refQuaternion, bone.refPosition); //TODO: optimize
                        invert$3(poseToBone, poseToBone);
                        bone.poseToBone = poseToBone;
                    }
                }
            }
        }
    }
    #initAttachements() {
        let attachements = new Group({ name: 'Attachements' });
        this.addChild(attachements);
        for (let attachement of this.sourceModel.attachements.values()) {
            let attachementInstance = new Source2ModelAttachementInstance(this, attachement);
            this.attachements.set(attachement.name, attachementInstance);
            attachements.addChild(attachementInstance);
        }
    }
    getAnimations() {
        return this.sourceModel.getAnimations();
    }
    buildContextMenu() {
        let skins = this.sourceModel.getSkinList();
        let skinMenu = [];
        for (let skin of skins) {
            let item = {};
            item.name = skin;
            item.f = () => this.skin = skin;
            skinMenu.push(item);
        }
        return Object.assign(super.buildContextMenu(), {
            Source2ModelInstance_1: null,
            skin: { i18n: '#skin', submenu: skinMenu },
            animation: { i18n: '#animation', f: async (entity) => { let animation = await new Interaction().getString(0, 0, await entity.sourceModel.getAnimations()); if (animation) {
                    entity.playAnimation(animation);
                } } },
            Source2ModelInstance_2: null,
            animate: { i18n: '#animate', selected: this.animationSpeed != 0.0, f: () => this.animationSpeed == 0 ? this.animationSpeed = 1 : this.animationSpeed = 0 },
            frame: { i18n: '#frame', f: () => { let frame = prompt('Frame', String(this.mainAnimFrame)); if (frame) {
                    this.animationSpeed = 0;
                    this.mainAnimFrame = Number(frame);
                } } },
        });
    }
    getParentModel() {
        return this;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        let meshes = this.meshes;
        for (let mesh of meshes) {
            mesh.getRandomPointOnModel(vec, initialVec, bones);
            return vec;
        }
        return vec;
    }
    getAttachement(name) {
        return this.attachements.get(name.toLowerCase());
    }
    static set animSpeed(speed) {
        let s = Number(speed);
        animSpeed$1 = Number.isNaN(s) ? 1 : s;
    }
    dispose() {
        super.dispose();
        this.#skeleton?.dispose();
        for (const material of this.#materialsUsed) {
            material.removeUser(this);
        }
        for (const mesh of this.meshes) {
            mesh.dispose();
        }
    }
    static getEntityName() {
        return 'Source 2 model';
    }
}

const BASE_BYTES_PER_BONE = 4 * 3;
const DELTA_BYTES_PER_BONE = 2 * 3;
var baseX, baseY, baseZ, deltaX, deltaY, deltaZ;
function decodeCCompressedDeltaVector3(reader, elementCount, elementIndex, frame) {
    baseX = reader.getFloat32(8 + elementCount * 2 + elementIndex * BASE_BYTES_PER_BONE);
    baseY = reader.getFloat32();
    baseZ = reader.getFloat32();
    deltaX = reader.getFloat16(8 + elementCount * (2 + BASE_BYTES_PER_BONE) + elementCount * frame * DELTA_BYTES_PER_BONE + elementIndex * DELTA_BYTES_PER_BONE);
    deltaY = reader.getFloat16();
    deltaZ = reader.getFloat16();
    return fromValues$4(baseX + deltaX, baseY + deltaY, baseZ + deltaZ);
}

class Source2AnimationDesc {
    #source2Model;
    #fps = 30;
    #lastFrame = 0;
    data;
    animationResource;
    frameBlockArray;
    constructor(source2Model, data, animationResource) {
        this.#source2Model = source2Model;
        this.data = data;
        this.animationResource = animationResource;
        this.frameBlockArray = null;
        if (data) {
            this.#fps = data.fps ?? 30;
            if (data.m_pData) {
                this.#lastFrame = data.m_pData.m_nFrames - 1;
                this.frameBlockArray = data.m_pData.m_frameblockArray;
            }
        }
    }
    get fps() {
        return this.#getActualAnimDesc()?.fps ?? this.#fps;
    }
    get lastFrame() {
        return this.#getActualAnimDesc()?.lastFrame ?? this.#lastFrame;
    }
    #getActualAnimDesc() {
        let fetch = this.data?.m_fetch;
        if (fetch) {
            let localReferenceArray = fetch.m_localReferenceArray;
            //TODO: mix multiple anims
            if (localReferenceArray[0] !== undefined) {
                let animName = this.animationResource.localSequenceNameArray[localReferenceArray[0]];
                if (animName) {
                    let animDesc = this.#source2Model.getAnimationByName(animName);
                    if (animDesc) {
                        return animDesc;
                    }
                }
            }
        }
    }
    getFrame(frameIndex) {
        frameIndex = clamp(frameIndex, 0, this.lastFrame);
        var frameBlockArray = this.frameBlockArray;
        var segmentIndexArray = null;
        var frameBlock = null;
        var decodeKey = this.animationResource.getDecodeKey();
        var decodeArray = this.animationResource.getDecoderArray();
        var boneArray = [];
        /*
        let fetch = this.data?.m_fetch;
        if (fetch) {
            let localReferenceArray = fetch.m_localReferenceArray;
            //TODO: mix multiple anims
            if (localReferenceArray[0] !== undefined) {
                let animName = this.animationResource.localSequenceNameArray[localReferenceArray[0]];
                if (animName) {
                    //console.log(localReference);
                    let animDesc = this.#source2Model.getAnimationByName(animName);
                    if (animDesc) {
                        return animDesc.getFrame(frameIndex);
                    }
                }
                return [];
            }
        }*/
        let actualAnimDesc = this.#getActualAnimDesc();
        if (actualAnimDesc) {
            return actualAnimDesc.getFrame(frameIndex);
        }
        if (frameBlockArray && decodeArray && decodeKey && decodeKey.m_boneArray) {
            for (var i = 0; i < decodeKey.m_boneArray.length; i++) {
                boneArray.push({ name: decodeKey.m_boneArray[i].m_name });
            }
            for (var i = 0; i < frameBlockArray.length; i++) {
                frameBlock = frameBlockArray[i];
                if ((frameBlock.m_nStartFrame <= frameIndex) && (frameBlock.m_nEndFrame >= frameIndex)) {
                    segmentIndexArray = frameBlock.m_segmentIndexArray;
                    //console.log(this);
                    //console.log(decodeKey);
                    for (var j = 0; j < segmentIndexArray.length; j++) {
                        var segment = this.animationResource.getSegment(segmentIndexArray[j]);
                        //console.log(frameIndex, frameIndex - frameBlock.m_nStartFrame);
                        //console.log(frameIndex);
                        this.readSegment(frameIndex - frameBlock.m_nStartFrame, segment, boneArray, decodeKey.m_dataChannelArray, decodeArray);
                    }
                }
            }
        }
        //console.log(boneArray);
        return boneArray;
    }
    readSegment(frameIndex, segment, boneArray, dataChannelArray, decodeArray) {
        //console.log(segment);
        var channel = dataChannelArray[segment.m_nLocalChannel];
        var segmentToBoneIndex = {};
        var channelVar = channel.m_szVariableName;
        var container = segment.m_container;
        var reader = segment.dataReader;
        if (!reader) {
            reader = new BinaryReader(container);
            segment.dataReader = reader;
        }
        var decoderId = container[0] + (container[1] << 8);
        var bytesPerBone = container[2] + (container[3] << 8);
        var boneCount = container[4] + (container[5] << 8);
        container[6] + (container[7] << 8);
        bytesPerBone = 0;
        var segmentBoneArray = [];
        if (channel.m_nElementIndexArray) {
            var elementIndexArray = channel.m_nElementIndexArray;
            for (var i = 0; i < elementIndexArray.length; i++) {
                segmentToBoneIndex[elementIndexArray[i]] = i;
            }
        }
        else {
            //TODO
            return;
        }
        var decoder = decodeArray[decoderId];
        //console.log(decoderId, bytesPerBone, boneCount, dataLength);
        if (decoder && decoder.m_szName) {
            var decoderName = decoder.m_szName;
            //console.log(decoderName);
            switch (decoderName) {
                case 'CCompressedStaticFullVector3':
                    bytesPerBone = 12;
                    frameIndex = 0;
                    break;
                case 'CCompressedAnimQuaternion':
                    bytesPerBone = 6;
                    break;
                case 'CCompressedStaticVector3':
                    bytesPerBone = 6;
                    frameIndex = 0;
                    break;
                case 'CCompressedFullVector3':
                    bytesPerBone = 12;
                    break;
                case 'CCompressedDeltaVector3':
                    break;
                case 'CCompressedAnimVector3':
                    bytesPerBone = 12;
                    frameIndex = 0;
                    //TODO
                    break;
                case 'CCompressedFullFloat':
                case 'CCompressedStaticFloat':
                    bytesPerBone = 4;
                    frameIndex = 0;
                    //TODO
                    break;
                default:
                    return;
            }
            var byteIndex = 8;
            for (var boneIndex = 0; boneIndex < boneCount; boneIndex++, byteIndex += 2) {
                segmentBoneArray.push(container[byteIndex + 0] + (container[byteIndex + 1] << 8));
            }
            var byteIndex = 8 + boneCount * 2 + frameIndex * boneCount * bytesPerBone;
            for (var boneIndex = 0; boneIndex < boneCount; boneIndex++) {
                var boneIndex2 = segmentToBoneIndex[segmentBoneArray[boneIndex]];
                /*if (boneIndex2 === undefined) {//removeme
                    return;
                }*/
                var bytes = [];
                var byteIndex2 = byteIndex + boneIndex * bytesPerBone;
                for (var j = 0; j < bytesPerBone; j++) {
                    bytes.push(container[byteIndex2 + j]);
                }
                var tmpValue = null;
                switch (decoderName) {
                    case 'CCompressedFullFloat':
                    case 'CCompressedStaticFloat':
                        tmpValue = _getFloat32(bytes, 0);
                        break;
                    case 'CCompressedStaticFullVector3':
                    case 'CCompressedFullVector3':
                        //case 'CCompressedAnimVector3':
                        var x = _getFloat32(bytes, 0);
                        var y = _getFloat32(bytes, 4);
                        var z = _getFloat32(bytes, 8);
                        tmpValue = fromValues$4(x, y, z);
                        break;
                    case 'CCompressedDeltaVector3':
                        tmpValue = decodeCCompressedDeltaVector3(reader, boneCount, boneIndex, frameIndex);
                        break;
                    case 'CCompressedStaticVector3':
                        var x = _getFloat16(bytes, 0);
                        var y = _getFloat16(bytes, 2);
                        var z = _getFloat16(bytes, 4);
                        tmpValue = fromValues$4(x, y, z);
                        break;
                    case 'CCompressedAnimQuaternion':
                        tmpValue = _readQuaternion48(bytes, boneIndex2, boneArray[boneIndex2]?.name);
                        break;
                    //TODO
                }
                if (tmpValue && boneArray[boneIndex2]) {
                    boneArray[boneIndex2][channelVar] = tmpValue;
                }
            }
        }
    }
    matchActivity(activityName) {
        let activityArray = this.data?.m_activityArray;
        if (activityArray) {
            for (let activity of activityArray) {
                if (activity.m_name == activityName) {
                    return true;
                }
            }
        }
    }
    getActivityName() {
        return this.data?.m_activityArray?.[0]?.m_name;
    }
    hasModifiers() {
        return this.data?.m_activityArray?.length > 1;
    }
    modifiersScore(activityName, modifiers) {
        let activityArray = this.data?.m_activityArray;
        if (activityArray && activityArray.length > 0) {
            if (activityArray[0].m_name != activityName) {
                return -1;
            }
            if (activityArray.length == 1 && modifiers.size == 0) {
                // We have no modifiers and activityArray only contains the activity
                return 1;
            }
            const matchingModifiers = {};
            for (const modifier of modifiers) {
                for (const activity of activityArray) {
                    if (activityName == activity.m_name) {
                        continue;
                    }
                    if (modifier == activity.m_name) {
                        matchingModifiers[modifier] = 1;
                        break;
                    }
                }
            }
            return Object.keys(matchingModifiers).length;
        }
        return -1;
    }
    matchModifiers(activityName, modifiers) {
        let activityArray = this.data?.m_activityArray;
        if (activityArray && activityArray.length > 0) {
            if (activityArray[0].m_name != activityName) {
                return false;
            }
            if (activityArray.length == 1 && modifiers.size == 0) {
                // We have no modifiers and activityArray only contains the activity
                return true;
            }
            if (activityArray.length - 1 != modifiers.size) {
                return false;
            }
            const matchingModifiers = {};
            for (const modifier of modifiers) {
                for (const activity of activityArray) {
                    if (activityName == activity.m_name) {
                        continue;
                    }
                    if (modifier == activity.m_name) {
                        matchingModifiers[modifier] = 1;
                        break;
                    }
                }
            }
            return (Object.keys(matchingModifiers).length == modifiers.size);
        }
        return false;
    }
}
function _getFloat16(b, offset) {
    var sign = b[1 + offset] >> 7;
    var exponent = ((b[1 + offset] & 0x7C) >> 2);
    var mantissa = ((b[1 + offset] & 0x03) << 8) | b[0 + offset];
    if (exponent == 0) {
        return (sign ? -1 : 1) * Math.pow(2, -14) * (mantissa / Math.pow(2, 10));
    }
    else if (exponent == 0x1F) {
        return mantissa ? NaN : ((sign ? -1 : 1) * Infinity);
    }
    return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + (mantissa / Math.pow(2, 10)));
}
function _getFloat32(b, offset) {
    let sign = 1 - (2 * (b[3 + offset] >> 7)), exponent = (((b[3 + offset] << 1) & 0xff) | (b[2 + offset] >> 7)) - 127, mantissa = ((b[2 + offset] & 0x7f) << 16) | (b[1 + offset] << 8) | b[0 + offset];
    if (exponent === 128) {
        if (mantissa !== 0) {
            return NaN;
        }
        else {
            return sign * Infinity;
        }
    }
    if (exponent === -127) { // Denormalized
        return sign * mantissa * pow2(-126 - 23);
    }
    return sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
}
let QUATERNION48_SCALE = Math.SQRT1_2 / 0x4000;
function _readQuaternion48(bytes, boneIndexRemoveMe, boneNameRemoveMe) {
    // Values
    let i1 = bytes[0] + ((bytes[1] & 127) << 8) - 0x4000;
    let i2 = bytes[2] + ((bytes[3] & 127) << 8) - 0x4000;
    let i3 = bytes[4] + ((bytes[5] & 127) << 8) - 0x4000;
    // Signs
    let s1 = bytes[1] & 128;
    let s2 = bytes[3] & 128;
    let s3 = bytes[5] & 128;
    let x = QUATERNION48_SCALE * i1;
    let y = QUATERNION48_SCALE * i2;
    let z = QUATERNION48_SCALE * i3;
    let w = Math.sqrt(1 - (x * x) - (y * y) - (z * z));
    // Apply sign 3
    if (s3 == 128) {
        w *= -1;
    }
    // Apply sign 1 and 2
    if (s1 == 128) {
        return s2 == 128 ? fromValues$2(y, z, w, x) : fromValues$2(z, w, x, y);
    }
    else {
        return s2 == 128 ? fromValues$2(w, x, y, z) : fromValues$2(x, y, z, w);
    }
}

class Source2Animation {
    #animArray;
    #animNames = new Map();
    animGroup;
    filePath;
    file;
    decoderArray;
    segmentArray;
    frameData;
    constructor(animGroup, filePath) {
        this.animGroup = animGroup;
        this.filePath = filePath;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        this.setAnimDatas(sourceFile.getBlockStruct('DATA.structs.AnimationResourceData_t')
            ?? sourceFile.getBlockStruct('DATA.keyValue.root')
            ?? sourceFile.getBlockStruct('DATA.keyValue.root.m_localS1SeqDescArray')
            ?? sourceFile.getBlockStruct('ANIM.keyValue.root'));
    }
    setAnimDatas(data) {
        if (data) {
            this.#animArray = data.m_animArray ?? [];
            //console.error('data.m_animArray', data.m_animArray);
            this.decoderArray = data.m_decoderArray;
            this.segmentArray = data.m_segmentArray;
            this.frameData = data.m_frameData;
            if (this.#animArray) {
                for (let i = 0; i < this.#animArray.length; i++) {
                    let anim = this.#animArray[i];
                    this.#animNames.set(anim.m_name, new Source2AnimationDesc(this.animGroup.source2Model, anim, this));
                }
            }
        }
    }
    getAnimDesc(name) {
        return this.#animNames.get(name);
    }
    getDecodeKey() {
        return this.animGroup.decodeKey;
    }
    getDecoderArray() {
        return this.decoderArray;
    }
    getSegment(segmentIndex) {
        //TODO: check segement
        return this.segmentArray[segmentIndex];
    }
    async getAnimations(animations = new Set()) {
        for (let i = 0; i < this.#animArray.length; i++) {
            let anim = this.#animArray[i];
            animations.add(anim.m_name);
            for (let activity of anim.m_activityArray ?? []) {
                animations.add(activity.m_name);
            }
        }
        return animations;
    }
    getAnimationByActivity(activityName, activityModifiers) {
        if (!this.#animArray) {
            return [,];
        }
        let bestMatch;
        let bestScore = Infinity;
        for (let anim of this.#animArray) {
            if (!anim.m_activityArray) {
                continue;
            }
            let matchingActivity = false;
            let unmatchingModifiers = 0;
            for (let activity of anim.m_activityArray ?? []) {
                if (activity.m_name == activityName) {
                    matchingActivity = true;
                }
                let modifierMatching = false;
                for (let activityModifier of activityModifiers) {
                    if (activity.m_name == activityModifier) {
                        modifierMatching = true;
                        break;
                    }
                }
                if (!modifierMatching) {
                    ++unmatchingModifiers;
                }
            }
            if (matchingActivity) {
                for (let activityModifier of activityModifiers) {
                    let modifierMatching = false;
                    for (let activity of anim.m_activityArray ?? []) {
                        if (activity.m_name == activityModifier) {
                            modifierMatching = true;
                            break;
                        }
                    }
                    if (!modifierMatching) {
                        ++unmatchingModifiers;
                    }
                }
                if (unmatchingModifiers < bestScore) {
                    let animDesc = this.#animNames.get(anim.m_name);
                    if (animDesc) {
                        bestMatch = animDesc;
                        bestScore = unmatchingModifiers;
                    }
                }
            }
        }
        return [bestMatch, bestScore];
    }
    getAnimationsByActivity(activityName) {
        let anims = [];
        for (let [animName, animDesc] of this.#animNames) {
            if (animDesc.matchActivity(activityName)) {
                anims.push(animDesc);
            }
        }
        return anims;
    }
    get animArray() {
        return this.#animArray;
    }
    getAnimationByName(animName) {
        return this.#animNames.get(animName);
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        /*for (let source2Animation in this.#animArray) {
            let anim = source2Animation.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }*/
    }
}

class Source2Activity {
    name;
    weight;
    flags;
    activity;
    constructor(name, weight, flags, activity) {
        this.name = name;
        this.weight = weight;
        this.flags = flags;
        this.activity = activity;
        if (flags != 0) {
            throw 'Check this: flags != 0';
        }
        if (activity != 0) {
            throw 'Check this: activity != 0';
        }
    }
}

class Source2Sequence {
    name;
    fps;
    frameCount;
    activities;
    animNames;
    constructor(name, params = {}) {
        this.name = name;
        this.fps = params.fps ?? 30;
        this.frameCount = params.frameCount ?? 0;
        if (params.activities) {
            this.activities = params.activities;
        }
        if (params.animNames) {
            this.animNames = params.animNames;
        }
    }
    matchActivity(activity, modifiers) {
        if (modifiers) {
            if (this.activities.length == modifiers.size + 1) {
                if (this.activities[0].name == activity) {
                    let matchCount = 0;
                    for (let i = 1; i < this.activities.length; i++) {
                        for (let modifier of modifiers) {
                            if (this.activities[i] == modifier) {
                                ++matchCount;
                            }
                        }
                    }
                    if (matchCount == modifiers.size) {
                        return true;
                    }
                }
            }
            return false;
        }
        else {
            if (this.activities[0]?.name == activity) {
                return true;
            }
        }
    }
}

class Source2SeqGroup {
    #animNames = new Map();
    #animGroup;
    #localSequenceNameArray;
    sequences = [];
    file;
    m_localS1SeqDescArray;
    animArray;
    loaded = false;
    constructor(animGroup) {
        this.#animGroup = animGroup;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        let sequenceGroupResourceData_t = sourceFile.getBlockStruct('DATA.structs.SequenceGroupResourceData_t');
        let localSequenceNameArray;
        if (sequenceGroupResourceData_t) {
            this.m_localS1SeqDescArray = sequenceGroupResourceData_t.m_localS1SeqDescArray;
            localSequenceNameArray = sequenceGroupResourceData_t.m_localSequenceNameArray;
        }
        else {
            this.m_localS1SeqDescArray = sourceFile.getBlockStruct('DATA.keyValue.root.m_localS1SeqDescArray') ?? sourceFile.getBlockStruct('ASEQ.keyValue.root.m_localS1SeqDescArray');
            localSequenceNameArray = sourceFile.getBlockStruct('DATA.keyValue.root.m_localSequenceNameArray') ?? sourceFile.getBlockStruct('ASEQ.keyValue.root.m_localSequenceNameArray');
        }
        this.#localSequenceNameArray = localSequenceNameArray;
        this.#processSeqDesc(this.m_localS1SeqDescArray, localSequenceNameArray);
        this.animArray = this.m_localS1SeqDescArray;
        if (this.animArray) {
            for (let i = 0; i < this.animArray.length; i++) {
                let anim = this.animArray[i];
                this.#animNames.set(anim.m_sName, new Source2AnimationDesc(this.#animGroup.source2Model, anim, this));
            }
        }
        let anims = sourceFile.getBlockStruct('DATA.keyValue.root') ?? sourceFile.getBlockStruct('DATA.structs.SequenceGroupResourceData_t');
        if (anims) {
            let loadedAnim = new Source2Animation(this, '');
            loadedAnim.setAnimDatas(anims);
            this.#animGroup._changemyname = this.#animGroup._changemyname || [];
            this.#animGroup._changemyname.push(loadedAnim);
        }
        this.loaded = true;
    }
    getAnimDesc(name) {
        return this.#animNames.get(name);
    }
    #processSeqDesc(m_localS1SeqDescArray, localSequenceNameArray) {
        if (m_localS1SeqDescArray) {
            for (let i = 0; i < m_localS1SeqDescArray.length; ++i) {
                let sequence = m_localS1SeqDescArray[i];
                let activities = [];
                if (sequence.m_activityArray) {
                    for (let j = 0; j < sequence.m_activityArray.length; ++j) {
                        let activity = sequence.m_activityArray[j];
                        activities.push(new Source2Activity(activity.m_name, activity.m_nWeight, activity.m_nFlags, activity.m_nActivity));
                    }
                }
                let localReferenceArray = sequence?.m_fetch?.m_localReferenceArray;
                let animNames = [];
                if (localReferenceArray) {
                    for (let localReference of localReferenceArray) {
                        animNames.push(localSequenceNameArray[localReference]);
                    }
                }
                let s2Seq = new Source2Sequence(sequence.m_sName, { activities: activities, animNames: animNames });
                //console.error(s2Seq);
                this.sequences.push(s2Seq);
            }
        }
    }
    matchActivity(activity, modifiers) {
        for (let i = 0; i < this.sequences.length; i++) {
            let sequence = this.sequences[i];
            if (sequence.matchActivity(activity, modifiers)) {
                return sequence.animNames[0]; //TODO
            }
        }
        return null;
    }
    getAnimationsByActivity(activityName) {
        let anims = [];
        for (let [animName, animDesc] of this.#animNames) {
            if (animDesc.matchActivity(activityName)) {
                anims.push(animDesc);
            }
        }
        return anims;
    }
    getDecodeKey() {
        return this.#animGroup.getDecodeKey();
    }
    getDecoderArray() {
        return this.#animGroup.decoderArray;
    }
    get localSequenceNameArray() {
        return this.#localSequenceNameArray;
    }
}

class Source2AnimGroup {
    #source2Model;
    #_changemyname = [];
    repository;
    file;
    decoderArray;
    localAnimArray;
    decodeKey;
    directHSeqGroup;
    loaded = false;
    constructor(source2Model, repository) {
        //TODO: remove repository param. redundant with model
        this.#source2Model = source2Model;
        this.repository = repository;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        let localAnimArray;
        let decodeKey;
        let animationGroupData = sourceFile.getBlockStruct('DATA.structs.AnimationGroupResourceData_t');
        let directHSeqGroup;
        if (animationGroupData) {
            localAnimArray = animationGroupData.m_localHAnimArray;
            decodeKey = animationGroupData.m_decodeKey;
            directHSeqGroup = animationGroupData.m_directHSeqGroup;
        }
        else {
            localAnimArray = sourceFile.getBlockStruct('DATA.keyValue.root.m_localHAnimArray');
            decodeKey = sourceFile.getBlockStruct('DATA.keyValue.root.m_decodeKey');
            directHSeqGroup = sourceFile.getBlockStruct('DATA.keyValue.root.m_directHSeqGroup');
        }
        this.decoderArray = sourceFile.getBlockStruct('ANIM.keyValue.root.m_decoderArray');
        if (directHSeqGroup) {
            (async () => {
                this.directHSeqGroup = await getSequenceGroup(this.repository, directHSeqGroup, this);
            })();
        }
        this.setAnimationGroupResourceData(localAnimArray, decodeKey);
        let anims = sourceFile.getBlockStruct('ANIM.keyValue.root');
        if (anims) {
            let loadedAnim = new Source2Animation(this, '');
            loadedAnim.setAnimDatas(anims);
            this._changemyname = this._changemyname || [];
            this._changemyname.push(loadedAnim);
            /*let m_animArray = anims.m_animArray;
            for (let i = 0; i < m_animArray.length; i++) {
            }*/
        }
        this.loaded = true;
    }
    setAnimationGroupResourceData(localAnimArray, decodeKey) {
        this.localAnimArray = localAnimArray;
        this.decodeKey = decodeKey;
        //this.getAnim(0);
        if (localAnimArray) {
            for (const localAnim of localAnimArray) {
                getAnim(this.repository, localAnim, this);
                //console.info(anim);
            }
        }
    }
    getAnim(animIndex) {
        if (this.localAnimArray && this.localAnimArray[animIndex]) {
            return getAnim(this.repository, this.localAnimArray[animIndex], this);
        }
        return null;
    }
    getAnimDesc(name) {
        let animation;
        for (const a of this.#_changemyname) {
            animation = a.getAnimDesc(name);
            if (animation) {
                return animation;
            }
        }
    }
    matchActivity(activity, modifiers) {
        if (this.directHSeqGroup) {
            return this.directHSeqGroup.matchActivity(activity, modifiers);
        }
    }
    getAnims() {
        let anims = new Set();
        for (let anim of this._changemyname) {
            if (anim) {
                anims.add(anim);
            }
        }
        if (this.localAnimArray) {
            for (let animName of this.localAnimArray) {
                if (animName) {
                    let anim = getAnim(this.repository, animName, this);
                    if (anim) {
                        anims.add(anim);
                    }
                }
            }
        }
        return anims;
    }
    getAnimationsByActivity(activityName) {
        let anims = [];
        for (let anim of this._changemyname) {
            if (anim) {
                anims.push(...anim.getAnimationsByActivity(activityName));
            }
        }
        if (this.localAnimArray) {
            for (let animName of this.localAnimArray) {
                if (animName) {
                    let anim = getAnim(this.repository, animName, this);
                    if (anim) {
                        anims.push(...anim.getAnimationsByActivity(activityName));
                    }
                }
            }
        }
        if (this.directHSeqGroup) {
            anims.push(...this.directHSeqGroup.getAnimationsByActivity(activityName));
        }
        return anims;
    }
    getDecodeKey() {
        return this.decodeKey;
    }
    get source2Model() {
        return this.#source2Model;
    }
    getAnimationByName(animName) {
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        for (let source2Animation of this.getAnims()) {
            let anim = source2Animation.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }
    }
    //TODO: remove setter and getter
    set _changemyname(_changemyname) {
        this.#_changemyname = _changemyname;
    }
    get _changemyname() {
        return this.#_changemyname;
    }
}
let seqGroupList = {};
function getSequenceGroup(repository, seqGroupName, animGroup) {
    var seqGroup = seqGroupList[seqGroupName];
    if (!seqGroup) {
        seqGroup = loadSequenceGroup(repository, seqGroupName, animGroup);
    }
    if (seqGroup) {
        seqGroupList[seqGroupName] = seqGroup;
    }
    else {
        //TODO; create dummy
        console.error('No anim group loaded');
    }
    return seqGroup;
}
async function loadSequenceGroup(repository, seqGroupName, animGroup) {
    repository = repository.toLowerCase();
    seqGroupName = seqGroupName.replace(/\.(vseq_c$|vseq)/, '');
    //seqGroupName = repository + seqGroupName;
    let seqGroup = new Source2SeqGroup(animGroup);
    await getVseq(repository, seqGroupName, seqGroup);
    return seqGroup;
}
const pending$1 = {};
async function getVseq(repository, seqGroupName, seqGroup) {
    var seqFile = seqGroupName + '.vseq_c';
    if (pending$1[seqFile]) {
        return true;
    }
    pending$1[seqFile] = true;
    await loadVseq(repository, seqFile, seqGroup);
    /*
    let promise = new Promise((resolve, reject) => {
        fetch(new Request(seqFile)).then((response) => {
            response.arrayBuffer().then(async (arrayBuffer) => {
                await this.loadVseq(repository, seqFile, arrayBuffer, seqGroup);
                pending[seqFile] = null;
                resolve(true);
            })
        });
    });
    */
    return true;
}
async function loadVseq(repository, fileName, seqGroup) {
    let vseq = await new Source2FileLoader().load(repository, fileName);
    if (vseq) {
        seqGroup.setFile(vseq);
    }
}
let animList = {};
function getAnim(repository, animName, animGroup) {
    if (!animName) {
        return "";
    }
    let anim = animList[animName];
    if (anim === undefined) {
        loadAnim(repository, animName, animGroup).then(anim => {
            animList[animName] = anim;
            animGroup._changemyname.push(anim);
        });
        return null;
    }
    else {
        return anim;
    }
}
async function loadAnim(repository, animName, animGroup) {
    animName = animName.toLowerCase();
    animName = animName.replace(/\.(vanim_c$|vanim$)/, '');
    //this.fileName = animName;
    //animName = repository + animName;
    //this.animName = animName;
    let anim = new Source2Animation(animGroup, animName);
    await getVanim(repository, animName, anim);
    return anim;
}
async function getVanim(repository, animName, anim) {
    var animFile = animName + '.vanim_c';
    if (pending$1[animFile]) {
        return true;
    }
    pending$1[animFile] = true;
    /*
                fetch(new Request(animFile)).then((response) => {
                    response.arrayBuffer().then((arrayBuffer) => {
                        this.loadVanim(repository, animFile, arrayBuffer, anim);
                    })
                });
                */
    loadVanim(repository, animFile, anim);
    /*
    let promise = new Promise((resolve, reject) => {
        fetch(new Request(animFile)).then((response) => {
            response.arrayBuffer().then(async (arrayBuffer) => {
                this.loadVanim(repository, animFile, arrayBuffer, anim);
                pending[animFile] = null;
                resolve(true);
            })
        });
    });
    */
    return true;
}
async function loadVanim(repository, fileName, anim) {
    let vanim = await new Source2FileLoader().load(repository, fileName);
    if (vanim) {
        anim.setFile(vanim);
        let dataBlock = vanim.blocks.DATA;
        if (dataBlock) {
            anim.setAnimDatas(vanim.getBlockStruct('DATA.structs.AnimationResourceData_t') || vanim.getBlockStruct('DATA.keyValue.root'));
        }
    }
    //this.fileLoaded(model);TODOv3
}

const pending = {};
async function loadAnimGroup(source2Model, repository, animGroupName) {
    animGroupName = animGroupName.toLowerCase();
    animGroupName = animGroupName.replace(/\.(vagrp_c$|vagrp$)/, '');
    let animGroup = new Source2AnimGroup(source2Model, repository);
    await getVagrp(repository, animGroupName, animGroup);
    return animGroup;
}
async function getVagrp(repository, animGroupName, animGroup) {
    var agrpFile = animGroupName + '.vagrp_c';
    if (pending[agrpFile]) {
        return true;
    }
    pending[agrpFile] = true;
    await loadVagrp(repository, agrpFile, animGroup);
    /*
    let promise = new Promise((resolve, reject) => {
        fetch(new Request(agrpFile)).then((response) => {
            response.arrayBuffer().then(async (arrayBuffer) => {
                await this.#loadVagrp(repository, agrpFile, arrayBuffer, animGroup);
                pending[agrpFile] = null;
                resolve(true);
            })
        });
    });
    0*/
    return true;
}
async function loadVagrp(repository, fileName, animGroup) {
    let vagrp = await new Source2FileLoader().load(repository, fileName);
    if (vagrp) {
        animGroup.setFile(vagrp);
        var dataBlock = vagrp.blocks.DATA;
        if (dataBlock) {
            //animGroup.meshesNames = vagrp.getPermModelData('m_meshGroups');
            vagrp.getPermModelData('m_refMeshes');
        }
    }
    //this.fileLoaded(model);TODOv3
}

const AnimManager = new (function () {
    let animGroupList = {};
    class AnimManager {
        async getAnimGroup(source2Model, repository, animGroupName) {
            let animGroup = animGroupList[animGroupName];
            if (!animGroup) {
                animGroup = await loadAnimGroup(source2Model, repository, animGroupName);
            }
            if (animGroup) {
                animGroupList[animGroupName] = animGroup;
            }
            else {
                //TODO; create dummy
                console.error('No anim group loaded');
            }
            return animGroup;
        }
        removeAnimGroup(animGroupName) {
            animGroupList[animGroupName] = null;
        }
    }
    return AnimManager;
}());

const EMPTY_MODIFIERS = new Set();
class Source2Animations {
    #animations = [];
    addAnimations(animations) {
        this.#animations.push(...animations);
    }
    getAnimations() {
        return this.#animations;
    }
    getAnimation(activityName, activityModifiers = EMPTY_MODIFIERS) {
        for (const animation of this.#animations) {
            if (animation.matchModifiers(activityName, activityModifiers)) {
                return animation;
            }
        }
        // Try without modifiers
        for (const animation of this.#animations) {
            if (animation.matchModifiers(activityName, EMPTY_MODIFIERS)) {
                return animation;
            }
        }
    }
    getBestAnimation(activityName, activityModifiers) {
        let bestMatch = this.getAnimation(activityName);
        let bestScore = bestMatch ? 0 : -1;
        for (let animDesc of this.#animations) {
            /*if (animDesc.matchModifiers(activityName, activityModifiers)) {
                return animDesc;
            }*/
            const score = animDesc.modifiersScore(activityName, activityModifiers);
            if (score > bestScore) {
                bestMatch = animDesc;
                bestScore = score;
            }
        }
        return bestMatch;
    }
}

class Source2Model {
    #internalAnimGroup;
    #includeModels = [];
    repository;
    vmdl;
    requiredLod = 0;
    drawBodyPart = {};
    currentSkin = 0;
    currentSheen = null;
    animLayers = [];
    animGroups = new Set();
    materialRepository = null;
    dirty = true;
    geometries = new Set();
    bodyParts = new Map();
    attachements = new Map();
    #seqGroup;
    bodyGroups = new Set();
    bodyGroupsChoices = new Set();
    constructor(repository, vmdl) {
        this.repository = repository;
        this.vmdl = vmdl;
        this.#loadInternalAnimGroup();
        this.#createAnimGroup();
        this.#createBodyGroups();
    }
    #createAnimGroup() {
        let aseq = this.vmdl.getBlockByType('ASEQ');
        if (aseq) {
            this.#seqGroup = new Source2SeqGroup(this.#internalAnimGroup);
            this.#seqGroup.setFile(this.vmdl);
        }
    }
    #createBodyGroups() {
        let meshGroups = this.vmdl.getPermModelData('m_meshGroups');
        if (meshGroups) {
            let bodyGroupId = 0;
            let bodyGroup;
            for (const choice of meshGroups) {
                if (choice == 'autodefault') {
                    bodyGroup = choice;
                }
                else {
                    const result = /(.*)_@\d$/.exec(choice);
                    bodyGroup = result?.[1];
                }
                if (bodyGroup) {
                    this.bodyGroups.add(bodyGroup);
                    this.bodyGroupsChoices.add({ choice: choice, bodyGroup: bodyGroup, bodyGroupId: bodyGroupId });
                }
                bodyGroupId++;
            }
        }
    }
    matchActivity(activity, modifiers) {
        if (this.#seqGroup) {
            return this.#seqGroup.matchActivity(activity, modifiers);
        }
        return null;
    }
    addGeometry(geometry, bodyPartName, bodyPartModelId) {
        if (bodyPartName !== undefined) {
            let bodyPart = this.bodyParts.get(bodyPartName);
            if (bodyPart === undefined) {
                bodyPart = [];
                this.bodyParts.set(bodyPartName, bodyPart);
            }
            if (bodyPartModelId !== undefined) {
                let meshes = bodyPart[bodyPartModelId];
                if (meshes === undefined) {
                    meshes = [];
                    bodyPart[bodyPartModelId] = meshes;
                }
                meshes.push(geometry);
            }
        }
        this.geometries.add(geometry);
    }
    createInstance(isDynamic) {
        return new Source2ModelInstance(this, isDynamic);
    }
    getBodyNumber(bodygroups) {
        let bodyPartCount = 1;
        let bodyPartNumber = 0;
        //for (let bodyPartIndex = 0; bodyPartIndex < this.bodyParts.size; ++bodyPartIndex) {
        //			const bodyPart = this.bodyParts[bodyPartIndex];
        for (const [_, bodyPart] of this.bodyParts) {
            if (bodyPart && bodyPart.models && (bodyPart.models.length > 1)) {
                const bodyPartModel = bodygroups[bodyPart.name];
                bodyPartNumber += (bodyPartModel ? bodyPartModel.modelId : 0) * bodyPartCount;
                bodyPartCount *= (bodyPart.models.length);
            }
        }
        return bodyPartNumber;
    }
    getBones() {
        let skeleton = this.vmdl.getPermModelData('m_modelSkeleton');
        if (skeleton) {
            return skeleton;
        }
        return null;
    }
    /*
    getAttachments() {
        if (this.mdl) {
            return this.mdl.getAttachments();
        }
        return null;
    }

    getBone(boneIndex) {
        if (this.mdl) {
            return this.mdl.getBone(boneIndex);
        }
        return null;
    }

    getAttachementById(attachementIndex) {
        if (this.mdl) {
            return this.mdl.getAttachementById(attachementIndex);
        }
        return null;
    }

    getBoneByName(boneName) {
        if (this.mdl) {
            return this.mdl.getBoneByName(boneName);
        }
        return null;
    }

    getAttachement(attachementName) {
        if (this.mdl) {
            return this.mdl.getAttachement(attachementName);
        }
        return null;
    }

    getBodyPart(bodyPartId) {
        if (this.mdl) {
            return this.mdl.getBodyPart(bodyPartId);
        }
        return null;
    }

    getBodyParts() {
        if (this.mdl) {
            return this.mdl.getBodyParts();
        }
        return null;
    }
*/
    getSkinMaterials(skin) {
        let materialGroups = this.vmdl.getPermModelData('m_materialGroups');
        if (materialGroups) {
            let materials = materialGroups[skin];
            if (materials) {
                return materials.m_materials;
            }
        }
        return null;
    }
    getSkinList() {
        const skinList = [];
        let materialGroups = this.vmdl.getPermModelData('m_materialGroups');
        if (materialGroups) {
            for (let skinIndex = 0; skinIndex < materialGroups.length; skinIndex++) {
                skinList.push(materialGroups[skinIndex].m_name);
            }
        }
        return skinList;
    }
    async loadAnimGroups() {
        if (this.vmdl) {
            var m_refAnimGroups = this.vmdl.getPermModelData('m_refAnimGroups');
            if (m_refAnimGroups) {
                for (var meshIndex = 0; meshIndex < m_refAnimGroups.length; meshIndex++) {
                    var meshName = m_refAnimGroups[meshIndex];
                    let animGroup = await AnimManager.getAnimGroup(this, this.repository, meshName);
                    this.animGroups.add(animGroup);
                }
            }
        }
    }
    #loadInternalAnimGroup() {
        //TODOv3: make a common code where external and internal group are loaded
        if (this.vmdl) {
            let sourceFile = this.vmdl;
            let localAnimArray = sourceFile.getBlockStruct('AGRP.keyValue.root.m_localHAnimArray');
            let decodeKey = sourceFile.getBlockStruct('AGRP.keyValue.root.m_decodeKey');
            if (localAnimArray && decodeKey) {
                let animGroup = new Source2AnimGroup(this, this.repository);
                animGroup.setFile(this.vmdl);
                animGroup.setAnimationGroupResourceData(localAnimArray, decodeKey);
                this.#internalAnimGroup = animGroup;
                let anims = sourceFile.getBlockStruct('ANIM.keyValue.root');
                if (anims) {
                    let loadedAnim = new Source2Animation(animGroup, '');
                    loadedAnim.setAnimDatas(anims);
                    animGroup._changemyname = animGroup._changemyname || [];
                    animGroup._changemyname.push(loadedAnim);
                }
                this.animGroups.add(animGroup);
            }
        }
    }
    getIncludeModels() {
        if (!this.vmdl) {
            return [];
        }
        const sourceFile = this.vmdl;
        const refAnimIncludeModels = sourceFile.getBlockStruct('DATA.keyValue.root.m_refAnimIncludeModels');
        return refAnimIncludeModels ?? [];
    }
    addIncludeModel(includeModel) {
        this.#includeModels.push(includeModel);
    }
    getAnim(activityName, activityModifiers) {
        const animations = this.getAnimationsByActivity(activityName);
        for (const model of this.#includeModels) {
            model.getAnimationsByActivity(activityName, animations);
        }
        return animations.getBestAnimation(activityName, activityModifiers);
        // Fallback to no modifier
        /*for (let animDesc of animations) {
            if (animDesc.matchModifiers(activityName)) {
                return animDesc;
            }
        }*/
    }
    getAnimation(name) {
        let animation;
        animation = this.#seqGroup?.getAnimDesc(name);
        if (animation) {
            return animation;
        }
        for (const animGroup of this.animGroups) {
            animation = animGroup?.getAnimDesc(name);
            if (animation) {
                return animation;
            }
        }
    }
    getAnimationsByActivity(activityName, animations = new Source2Animations()) {
        let anims = [];
        if (this.#seqGroup) {
            anims.push(...this.#seqGroup.getAnimationsByActivity(activityName));
        }
        for (let animGroup of this.animGroups) {
            anims.push(...animGroup.getAnimationsByActivity(activityName));
        }
        animations.addAnimations(anims);
        return animations;
    }
    async getAnimations() {
        let animations = new Set();
        for (let animGroup of this.animGroups) {
            if (animGroup.localAnimArray) {
                for (var localAnimIndex = 0; localAnimIndex < animGroup.localAnimArray.length; localAnimIndex++) {
                    const animRemoveMe = await animGroup.getAnim(localAnimIndex);
                    if (animRemoveMe) {
                        animRemoveMe.getAnimations(animations);
                    }
                }
            }
            if (animGroup._changemyname) {
                for (var animResIndex = 0; animResIndex < animGroup._changemyname.length; animResIndex++) {
                    const animRemoveMe = animGroup._changemyname[animResIndex];
                    if (animRemoveMe) {
                        animRemoveMe.getAnimations(animations);
                    }
                }
            }
        }
        return animations;
    }
    _addAttachements(attachements) {
        for (let attachement of attachements) {
            let attachementValue = attachement.value;
            if (attachementValue) {
                let name = attachementValue.m_name.toLowerCase();
                let source2ModelAttachement = new Source2ModelAttachement(name);
                this.attachements.set(name, source2ModelAttachement);
                source2ModelAttachement.ignoreRotation = attachementValue.m_bIgnoreRotation;
                for (let influenceIndex = 0; influenceIndex < attachementValue.m_nInfluences; ++influenceIndex) {
                    let influenceName = attachementValue.m_influenceNames[influenceIndex];
                    if (influenceName) {
                        source2ModelAttachement.influenceNames.push(influenceName.toLowerCase());
                        source2ModelAttachement.influenceWeights.push(attachementValue.m_influenceWeights[influenceIndex]);
                        source2ModelAttachement.influenceOffsets.push(clone$4(attachementValue.m_vInfluenceOffsets[influenceIndex]));
                        source2ModelAttachement.influenceRotations.push(clone$3(attachementValue.m_vInfluenceRotations[influenceIndex]));
                    }
                }
            }
        }
    }
    getAnimationByName(animName) {
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        for (let animGroup of this.animGroups) {
            let anim = animGroup.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }
    }
}

var _a$1;
const defaultMaterial$1 = new MeshBasicMaterial();
class Source2ModelLoader {
    static #loadPromisesPerRepo = {};
    static {
        defaultMaterial$1.addUser(_a$1);
    }
    load(repositoryName, fileName) {
        // Cleanup filename
        fileName = fileName.replace(/.vmdl_c$/, '').replace(/.vmdl$/, '');
        let repoPromises = _a$1.#loadPromisesPerRepo[repositoryName];
        if (!repoPromises) {
            repoPromises = {};
            _a$1.#loadPromisesPerRepo[repositoryName] = repoPromises;
        }
        let promise = repoPromises[fileName];
        if (promise) {
            return promise;
        }
        promise = new Promise((resolve, reject) => {
            let vmdlPromise = new Source2FileLoader().load(repositoryName, fileName + '.vmdl_c');
            vmdlPromise.then(async (source2File) => {
                let newSourceModel = new Source2Model(repositoryName, source2File);
                this.#loadIncludeModels(newSourceModel);
                await this.testProcess2(source2File, newSourceModel, repositoryName);
                newSourceModel.loadAnimGroups();
                resolve(newSourceModel);
            }).catch((error) => reject(error));
            return;
        });
        repoPromises[fileName] = promise;
        return promise;
    }
    async testProcess2(vmdl, model, repository) {
        let group = new Entity();
        let ctrlRoot = vmdl.getBlockStruct('CTRL.keyValue.root');
        let m_refLODGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refLODGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refLODGroupMasks');
        let m_refMeshGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refMeshGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshGroupMasks');
        if (ctrlRoot && m_refLODGroupMasks) {
            let embeddedMeshes = ctrlRoot.embedded_meshes;
            for (let meshIndex = 0; meshIndex < embeddedMeshes.length; ++meshIndex) {
                let lodGroupMask = Number(m_refLODGroupMasks[meshIndex]);
                let meshGroupMask = m_refMeshGroupMasks?.[meshIndex];
                let embeddedMesh = embeddedMeshes[meshIndex];
                this.#loadMesh(repository, model, group, vmdl.getBlockById(embeddedMesh.data_block), vmdl.getBlockById(embeddedMesh.vbib_block), lodGroupMask, vmdl, meshIndex, meshGroupMask);
                /*data_block: 1
                mesh_index: 0
                morph_block: 0
                morph_texture: "models/heroes/antimage_female/antimage_female/antimage_female_base_vmorf.vtex"
                name: "antimage_female_base"
                vbib_block: 2*/
            }
        }
        await this._loadExternalMeshes(group, vmdl, model, repository);
        return group;
    }
    #loadMesh(repository, model, group, dataBlock, vbibBlock, lodGroupMask, vmdl, meshIndex, meshGroupMask) {
        const remappingTable = vmdl.getRemappingTable(meshIndex);
        model._addAttachements(dataBlock.getKeyValue('m_attachments'));
        let drawCalls = dataBlock.getKeyValue('m_sceneObjects.0.m_drawCalls') || dataBlock.getKeyValue('root.m_drawCalls');
        if (drawCalls) {
            for (let drawCallIndex = 0, l = drawCalls.length; drawCallIndex < l; ++drawCallIndex) { //TODOv3: mutualize buffer if used by multiple drawcalls
                let drawCall = drawCalls[drawCallIndex];
                let useCompressedNormalTangent = drawCall.m_bUseCompressedNormalTangent ?? drawCall.m_nFlags?.includes('MESH_DRAW_FLAGS_USE_COMPRESSED_NORMAL_TANGENT');
                let vertexBuffers = drawCall.m_vertexBuffers[0]; //TODOv3 why 0 ?
                if (!vertexBuffers) {
                    continue;
                }
                let bufferIndex = vertexBuffers.m_hBuffer;
                let indices = new Uint32BufferAttribute(vbibBlock.getIndices(bufferIndex), 1, Number(drawCall.m_nStartIndex) * 4, Number(drawCall.m_nIndexCount)); //NOTE: number is here to convert bigint TODO: see if we can do better
                let vertexPosition = new Float32BufferAttribute(vbibBlock.getVertices(bufferIndex), 3);
                let vertexNormal, vertexTangent;
                if (useCompressedNormalTangent) {
                    let [normal, tangent] = vbibBlock.getNormalsTangents(bufferIndex);
                    vertexNormal = new Float32BufferAttribute(normal, 3);
                    vertexTangent = new Float32BufferAttribute(tangent, 4);
                }
                else {
                    vertexNormal = new Float32BufferAttribute(vbibBlock.getNormal(bufferIndex), 4);
                    vertexTangent = new Float32BufferAttribute(vbibBlock.getTangent(bufferIndex), 4);
                }
                let textureCoord = new Float32BufferAttribute(vbibBlock.getCoords(bufferIndex), 2);
                let vertexWeights = new Float32BufferAttribute(vbibBlock.getBoneWeight(bufferIndex), 4);
                let vertexBones = new Float32BufferAttribute(vmdl.remapBuffer(vbibBlock.getBoneIndices(bufferIndex), remappingTable), 4);
                let geometry = new BufferGeometry();
                geometry.properties.set('lodGroupMask', lodGroupMask);
                geometry.properties.set('mesh_group_mask', meshGroupMask ?? 0xffffffffffffffffn);
                geometry.setIndex(indices);
                geometry.setAttribute('aVertexPosition', vertexPosition);
                geometry.setAttribute('aVertexNormal', vertexNormal);
                geometry.setAttribute('aVertexTangent', vertexTangent);
                geometry.setAttribute('aTextureCoord', textureCoord);
                geometry.setAttribute('aBoneWeight', vertexWeights);
                geometry.setAttribute('aBoneIndices', vertexBones);
                geometry.count = Number(drawCall.m_nIndexCount); //NOTE: number is here to convert bigint TODO: see if we can do better
                geometry.properties.set('materialPath', drawCall.m_material);
                geometry.properties.set('bones', dataBlock.getKeyValue('m_skeleton.m_bones'));
                let material = defaultMaterial$1;
                let staticMesh = new Mesh(geometry, material);
                group.addChild(staticMesh);
                const materialPath = geometry.properties.get('materialPath');
                Source2MaterialManager.getMaterial(repository, materialPath).then((material) => staticMesh.setMaterial(material)).catch((error) => console.error('unable to find material ' + materialPath, error));
                model.addGeometry(geometry, FileNameFromPath(drawCall.m_material), 0 /*TODOv3*/);
            }
        }
    }
    async _loadExternalMeshes(group, vmdl, model, repository) {
        let callback = (mesh, lodGroupMask, meshIndex, meshGroupMask) => {
            //TODO: only load highest LOD
            this.#loadMesh(repository, model, group, mesh.getBlockByType('DATA'), mesh.getBlockByType('VBIB'), lodGroupMask, vmdl, meshIndex, meshGroupMask);
        };
        await this.loadMeshes(vmdl, callback);
    }
    async loadMeshes(vmdl, callback) {
        let promises = new Set();
        let m_refMeshes = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refMeshes') || vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshes');
        let m_refLODGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refLODGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refLODGroupMasks');
        let m_refMeshGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refMeshGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshGroupMasks');
        if (m_refMeshes && m_refLODGroupMasks) {
            for (let meshIndex = 0; meshIndex < m_refMeshes.length; meshIndex++) { //TODOv3
                let meshName = m_refMeshes[meshIndex];
                let lodGroupMask = Number(m_refLODGroupMasks[meshIndex]);
                let meshGroupMask = m_refMeshGroupMasks?.[meshIndex];
                if (meshName) {
                    let promise = MeshManager.getMesh(vmdl.repository, meshName);
                    promises.add(promise);
                    promise.then((mesh) => {
                        callback(mesh, lodGroupMask, meshIndex, meshGroupMask);
                    });
                }
            }
        }
        await Promise.all(promises);
    }
    async #loadIncludeModels(model) {
        const includeModels = model.getIncludeModels();
        for (const includeModel of includeModels) {
            const refModel = await new _a$1().load(model.repository, includeModel);
            if (refModel) {
                model.addIncludeModel(refModel);
            }
        }
    }
}
_a$1 = Source2ModelLoader;

class Source2ModelManager {
    static #modelListPerRepository = {};
    static #modelsPerRepository = {};
    static #modelList = new Map();
    static instances = new Set();
    static async #createModel(repositoryName, fileName) {
        if (!fileName) {
            return;
        }
        fileName = fileName.replace(/.vmdl_c$/, '').replace(/.vmdl$/, '');
        /*let fullPath = repository + fileName;
        let model = this.#modelList.get(fullPath);*/
        let model = this.#getModel(repositoryName, fileName);
        if (model) {
            return model;
        }
        model = await new Source2ModelLoader().load(repositoryName, fileName);
        if (model) {
            this.#modelsPerRepository[repositoryName][fileName] = model;
        }
        else {
            console.error('Model not found', repositoryName, fileName);
        }
        return model;
        /*if (model) {
            return model;
        } else {
            model = await new Source2ModelLoader().load(repository, fileName);
            if (model) {
                this.#modelList.set(fullPath, model);
                return model;
            } else {
                console.error(`Model not found : ${fullPath}`);
            }
        }*/
    }
    static #getModel(repositoryName, fileName) {
        if (!this.#modelsPerRepository[repositoryName]) {
            this.#modelsPerRepository[repositoryName] = {};
        }
        return this.#modelsPerRepository[repositoryName][fileName];
    }
    static async createInstance(repository, fileName, dynamic) {
        if (!repository) {
            //try to get repository from filename
            for (let repo in this.#modelListPerRepository) {
                if (fileName.startsWith(repo)) {
                    repository = repo;
                    fileName = fileName.replace(repo, '');
                    break;
                }
            }
        }
        let model = await this.#createModel(repository, fileName);
        if (model) {
            let instance = model.createInstance(dynamic);
            return instance;
        }
        return null;
    }
    static async loadManifest(repositoryName) {
        const modelList = this.#modelListPerRepository[repositoryName];
        if (modelList === undefined) {
            this.#modelListPerRepository[repositoryName] = null;
        }
    }
    static async getModelList() {
        const repoList = [];
        let modelListPerRepository = this.#modelListPerRepository;
        for (let repositoryName in modelListPerRepository) {
            let repo = modelListPerRepository[repositoryName];
            if (repo === null) {
                /*
                const repository = new Repositories().getRepository(repositoryName);
                if (!repository) {
                    continue;
                }
                    */
                //let response = await customFetch(new URL('models_manifest.json', repository.base));//todo variable
                //repo = await response.json();
                const response = await new Repositories().getFileAsJson(repositoryName, 'models_manifest.json'); //todo variable
                if (!response.error) {
                    this.#modelListPerRepository[repositoryName] = response.json;
                    repo = response.json;
                }
            }
            if (repo) {
                repoList.push({ name: repositoryName, files: [repo] });
            }
        }
        return { name: '', path: '', files: repoList };
    }
}

class Source1ParticleControler {
    static #loadManifestPromises = {};
    static speed = 1.0;
    static visible = true;
    static #systemList = {}; //TODOv3: make map
    static #activeSystemList = new Map();
    static #pcfList = {};
    static #systemNameToPcf = {};
    static #sourceEngineParticleSystem;
    static fixedTime;
    static {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
            this.stepSystems(this.fixedTime ? (this.fixedTime * event.detail.speed) : event.detail.delta); //TODOv3: imporve this
        });
    }
    static setParticleConstructor(ps) {
        this.#sourceEngineParticleSystem = ps;
    }
    /**
     * Reset all active systems
     */
    static resetAll() {
        for (let system of this.#activeSystemList.values()) {
            system.reset();
        }
    }
    /**
     * Step systems
     * @param {Number} elapsedTime Step time
     */
    static stepSystems(elapsedTime) {
        if (elapsedTime) {
            elapsedTime *= this.speed;
            elapsedTime = Math.min(elapsedTime, 0.1);
            for (let system of this.#activeSystemList.values()) {
                if (system.parentSystem === undefined) {
                    system.step(elapsedTime);
                }
            }
        }
    }
    /**
     * Add system TODO
     * @param {Number} elapsedTime Step time
     */
    static addSystem2(system) {
        this.#systemList[system.id] = system;
    }
    /**
     * Create system
     * @param {Number} elapsedTime Step time
     */
    static async createSystem(repository, systemName) {
        if (!repository) {
            //try to get repository from filename
            for (let repo in this.#systemNameToPcf) {
                if (systemName.startsWith(repo)) {
                    repository = repo;
                    systemName = systemName.replace(repo, '');
                    break;
                }
            }
            let index = systemName.lastIndexOf('.pcf/');
            if (index != -1) {
                systemName = systemName.substring(index + 5);
            }
        }
        let ps = new this.#sourceEngineParticleSystem({ repository: repository, name: systemName }); //TODOV2
        this.#systemList[ps.id] = ps;
        await this.#createSystem(repository, ps);
        return ps;
    }
    /**
     * Create system
     * @param {Number} elapsedTime Step time
     */
    static async #createSystem(repositoryName, system) {
        let pcfName = await this.#getPcfBySystemName(repositoryName, system.name);
        if (pcfName) {
            let pcf = await this.#getPcf(repositoryName, 'particles/' + pcfName);
            if (pcf) {
                pcf.initSystem(system);
            }
        }
    }
    static async #getPcfBySystemName(repository, systemName) {
        await this.#loadManifest(repository);
        let systemNameToPcfRepo = this.#systemNameToPcf[repository];
        if (systemNameToPcfRepo) {
            return systemNameToPcfRepo[systemName];
        }
        return null;
        /*

                    let promise = new Promise((resolve, reject) => {
                        let systemNameToPcfRepo = systemNameToPcf[repository];
                        if (systemNameToPcfRepo) {
                            resolve(systemNameToPcfRepo[systemName]);
                        } else {
                            let kallback = () => {
                                resolve(systemNameToPcf[repository][systemName]);
                            }
                            this.#loadManifest(repository).then(kallback, reject);//TODOv2: root
                        }
                    });
                    return promise;*/
    }
    static async loadManifest(repository) {
        if (this.#systemNameToPcf[repository] === undefined) {
            this.#systemNameToPcf[repository] = null;
        }
    }
    /**
     * TODO
     */
    static async #loadManifest(repositoryName) {
        this.#loadManifestPromises[repositoryName] = this.#loadManifestPromises[repositoryName] ?? new Promise(async (resolve, reject) => {
            let systemNameToPcfRepo = {};
            this.#systemNameToPcf[repositoryName] = systemNameToPcfRepo;
            const response = await new Repositories().getFileAsJson(repositoryName, 'particles/manifest.json'); //TODO const
            if (response.error) {
                reject(false);
            }
            const json /*TODO: change type*/ = response.json;
            if (json && json.files) {
                for (let file of json.files) {
                    let pcfName = file.name;
                    for (let definition of file.particlesystemdefinitions) {
                        systemNameToPcfRepo[definition] = pcfName;
                    }
                }
                resolve(true);
            }
            else {
                reject(false);
            }
        });
        return this.#loadManifestPromises[repositoryName];
    }
    /**
     * Start all systems
     */
    static startAll() {
        for (let system of this.#activeSystemList.values()) {
            system.start();
        }
    }
    /**
     * Stop all systems
     */
    static stopAll() {
        for (let system of this.#activeSystemList.values()) {
            system.stop();
        }
    }
    /**
     * Set a system active
     */
    static setActive(system) {
        if (!system) {
            return;
        }
        this.#activeSystemList.set(system.id, system);
    }
    /**
     * Set a system inactive
     */
    static setInactive(system) {
        if (!system) {
            return;
        }
        this.#activeSystemList.delete(system.id);
    }
    /**
     * Get a pcf from cache or load it
     * @param {String} name Name of the pcf
     * @return {Object SourcePCF} Pcf
     */
    static async #getPcf(repositoryName, pcfName) {
        let promise = new Promise((resolve, reject) => {
            let pcf = this.#pcfList[pcfName];
            if (!pcf) {
                let callback1 = (pcf) => {
                    if (pcf) {
                        this.#pcfList[pcfName] = pcf;
                        pcf.repositoryName = repositoryName;
                    }
                    resolve(pcf);
                };
                this.#loadPcf(repositoryName, pcfName).then(callback1);
            }
            else {
                resolve(pcf);
            }
        });
        return promise;
    }
    /**
     * Load a pcf
     * @param {String} name Name of the pcf
     * @return {Object SourcePCF} Pcf or null
     */
    static async #loadPcf(repositoryName, pcfName) {
        //TODO: return an empty system if not found?
        let promise = new Promise((resolve, reject) => {
            let pcfLoader = getLoader('SourceEnginePCFLoader');
            new pcfLoader().load(repositoryName, pcfName).then((pcf) => resolve(pcf)); //TODOv3: handle reject
        });
        return promise;
    }
    static setSpeed(s) {
        this.speed = s;
    }
    static async getSystemList() {
        let repoList = [];
        let pcfs = {};
        for (let repoName in this.#systemNameToPcf) {
            await this.#loadManifest(repoName);
            let repo = this.#systemNameToPcf[repoName];
            for (let systemName in repo) {
                let pcfName = repo[systemName];
                if (!pcfs[pcfName]) {
                    pcfs[pcfName] = [];
                }
                pcfs[pcfName].push({ name: systemName });
            }
            let pcfList = [];
            for (let pcfName in pcfs) {
                pcfList.push({ name: pcfName, files: pcfs[pcfName] });
            }
            repoList.push({ name: repoName, files: pcfList });
        }
        return { name: '', path: '', files: repoList };
    }
    static set renderSystems(renderSystems) {
        this.visible = renderSystems ? undefined : false;
    }
}

class Source2ParticleManagerClass {
    #vpcfs = {}; //TODO: turn to map
    #fileList = {}; //TODO: turn to map and improve type
    speed = 1.0;
    activeSystemList = new Set();
    visible;
    constructor() {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
            this.stepSystems(event.detail.delta); //TODOv3: improve this
        });
    }
    async #getVpcf(repository, vpcfPath) {
        let fullPath = repository + vpcfPath;
        let vpcf = this.#vpcfs[fullPath];
        if (vpcf === undefined) {
            vpcf = await getLoader('Source2ParticleLoader').load(repository, vpcfPath);
            this.#vpcfs[fullPath] = vpcf;
        }
        return vpcf;
    }
    async getSystem(repository, vpcfPath, snapshotModifiers) {
        vpcfPath = vpcfPath.replace(/.vpcf_c/, '').replace(/.vpcf/, '');
        vpcfPath = vpcfPath + '.vpcf_c';
        let vpcf = await this.#getVpcf(repository, vpcfPath);
        if (vpcf) {
            return getLoader('Source2ParticleLoader').getSystem(repository, vpcf, snapshotModifiers);
        }
    }
    stepSystems(elapsedTime) {
        if (elapsedTime) {
            elapsedTime *= this.speed;
            elapsedTime = Math.min(elapsedTime, 0.1);
            for (let system of this.activeSystemList.values()) {
                if (system.parentSystem === undefined) {
                    system.step(elapsedTime);
                }
            }
        }
    }
    setActive(system) {
        this.activeSystemList.add(system);
    }
    setInactive(system) {
        this.activeSystemList.delete(system);
    }
    renderSystems(render) {
        this.visible = render ? undefined : false;
    }
    async getSystemList() {
        const repoList = [];
        for (let repoName in this.#fileList) {
            if (this.#fileList[repoName]) {
                continue;
            }
            await this.#loadManifest(repoName);
            const repo = this.#fileList[repoName];
            repoList.push({ name: repoName, files: repo });
        }
        return { name: '', path: '', files: repoList };
    }
    async loadManifests(...repositories) {
        for (const repository of repositories) {
            this.#fileList[repository] = undefined;
        }
    }
    async #loadManifest(repositoryName) {
        /*
        const repository = new Repositories().getRepository(repositoryName);
        if (!repository) {
            console.error(`Unknown repository ${repositoryName} in Source1ParticleControler.#loadManifest`);
            return;
        }
            */
        //const manifestUrl = new URL('particles_manifest.json', repository.base);//todo variable
        const response = await new Repositories().getFileAsJson(repositoryName, 'particles_manifest.json'); //TODO const
        //const response = await customFetch(new Request(manifestUrl));
        if (response.error) {
            return;
        }
        const json = response.json;
        if (json && json.files) {
            this.#fileList[repositoryName] = json.files;
        }
    }
}
const Source2ParticleManager = new Source2ParticleManagerClass();

var sceneExplorerCSS = ":host {\n\tbackground-color: var(--theme-scene-explorer-bg-color);\n\twidth: 100%;\n\theight: 100%;\n\toverflow: auto;\n\t/*padding: 5px;*/\n\t/*box-sizing: border-box;*/\n\tdisplay: flex;\n\tflex-direction: column;\n\tfont-size: 1.5em;\n\tuser-select: none;\n}\n\n.scene-explorer-contextmenu {\n\tposition: absolute;\n\theight: 50px;\n\twidth: 50px;\n\tbackground-color: turquoise;\n}\n\n.scene-explorer-scene {\n\tflex: 1;\n\toverflow: auto;\n}\n\n.scene-explorer-file-selector {\n\tflex: 1;\n\toverflow: auto;\n\tdisplay: flex;\n}\n\n.scene-explorer-properties {\n\tbackground-color: orange;\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\n}\n\n.scene-explorer-properties>div,\n.scene-explorer-properties>label {\n\twidth: 50%;\n}\n\n.scene-explorer-properties>.scene-explorer-entity-title {\n\twidth: 100%;\n}\n\n.scene-explorer-selector {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: bisque;\n\tmargin: 10px;\n}\n\n\nscene-explorer-entity {\n\tflex-direction: column;\n}\n\n.scene-explorer-entity-header {\n\tcursor: pointer;\n\tdisplay: flex;\n}\n\nscene-explorer-entity>.scene-explorer-entity-header {\n\tbackground-color: teal;\n}\n\nscene-explorer-entity.selected>.scene-explorer-entity-header {\n\tbackground-color: var(--theme-scene-explorer-entity-selected-bg-color);\n}\n\n.scene-explorer-entity-buttons {\n\tdisplay: flex;\n}\n\n.scene-explorer-entity-buttons>div {\n\twidth: 20px;\n\theight: 20px;\n\tcursor: pointer;\n}\n\n.scene-explorer-entity-button-properties {\n\tbackground-color: blue;\n}\n\n.scene-explorer-entity-button-childs {\n\tbackground-color: green;\n}\n\n.scene-explorer-entity-visible {\n\tcursor: pointer;\n}\n\n.scene-explorer-entity-childs {\n\tbackground-color: teal;\n\t/*padding: 5px;*/\n\tpadding-left: 20px;\n}\n\n.file-explorer-file {\n\tcursor: pointer;\n}\n\n.file-explorer-file-header:hover {\n\tfont-weight: bold;\n}\n\n.file-explorer-childs {\n\tpadding-left: 20px;\n}\n\nfile-selector {\n\tdisplay: flex;\n\tflex-direction: column;\n\toverflow: auto;\n\twidth: 100%;\n}\n\n.file-selector-header {\n\tflex: 0;\n}\n\n.file-selector-content {\n\tflex: 1;\n\toverflow: auto;\n}\n\nfile-selector-directory {\n\tdisplay: block;\n\tcursor: pointer;\n}\n\nfile-selector-file {\n\tdisplay: block;\n\tcursor: pointer;\n}\n\nfile-selector-tile {\n\tdisplay: block;\n\toverflow: hidden;\n\twidth: 100%;\n\tcursor: pointer;\n}\n\n.file-selector-directory-header:hover,\nfile-selector-file:hover,\nfile-selector-tile:hover {\n\tbackground-color: var(--theme-file-selector-item-hover-bg-color);\n}\n\n.file-selector-directory-content {\n\tpadding-left: 20px;\n}\n\n.manipulator {\n\tdisplay: inline-flex;\n}\n\n.manipulator-button {\n\tbackground-color: var(--theme-scene-explorer-bg-color);\n\tcursor: pointer;\n}\n";

function FormatArray(array) {
    let arr = [];
    array.forEach((element) => arr.push(element.toFixed(2)));
    return arr.join(' ');
}
const ENTITIES = [
    '',
    'AmbientLight',
    'Bone',
    'ControlPoint',
    'Light',
    'Camera',
    'PointLight',
    'Source1ModelInstance',
    'Source2ModelInstance',
];
let sceneExplorer = null;
function getSceneExplorer() {
    if (!sceneExplorer) {
        sceneExplorer = new SceneExplorer();
    }
    return sceneExplorer;
}
class SceneExplorer {
    static #instance;
    #scene;
    #selectedEntity;
    #manipulator;
    #skeletonHelper = new SkeletonHelper({ visible: false });
    #htmlProperties;
    #htmlFileExplorer;
    #htmlMaterialEditor;
    #htmlExtra;
    #htmlHeader;
    htmlFileSelector;
    #htmlNameFilter;
    #htmlContextMenu;
    #htmlTypeFilter;
    #htmlDisplayBoneJoints;
    #shadowRoot;
    #htmlName;
    #htmlId;
    #htmlPos;
    #htmlQuat;
    #htmlScale;
    #htmlWorldPos;
    #htmlWorldQuat;
    #htmlWorldScale;
    //#htmlVisible!: HTMLInputElement;
    #htmlScene;
    #filterName = '';
    #filterType = '';
    #isVisible = false;
    //selectedEntity?: Entity;
    constructor() {
        if (SceneExplorer.#instance) {
            return SceneExplorer.#instance;
        }
        this.#initHtml();
        SceneExplorer.#instance = this;
        initEntitySubmenu();
        SceneExplorerEntity.setExplorer(this);
        this.#manipulator = new Manipulator({ visible: false });
        new IntersectionObserver((entries, observer) => {
            let isVisible = this.#isVisible;
            for (let e of entries) {
                this.#isVisible = e.isIntersecting;
            }
            if (this.#isVisible && (this.#isVisible != isVisible)) {
                this.applyFilter();
                if (this.#selectedEntity) {
                    SceneExplorerEntity.getEntityElement(this.#selectedEntity)?.select();
                }
            }
        }).observe(this.#shadowRoot.host);
        EntityObserver.addEventListener(PROPERTY_CHANGED$1, (event) => this.#handlePropertyChanged(event.detail));
        SceneExplorerEvents.addEventListener('bonepicked', (event) => this.selectEntity(event.detail.bone, true));
    }
    /**
     * @deprecated Please use `setScene` instead.
     */
    set scene(scene) {
        console.warn('deprecated, use setScene instead');
        this.setScene(scene);
    }
    setScene(scene) {
        this.#scene = scene;
        this.selectEntity(scene, true);
        this.applyFilter();
    }
    get scene() {
        return this.#scene;
    }
    #refreshScene() {
        if (this.#scene) {
            this.#htmlScene.innerText = '';
            this.#htmlScene.append(this.#createEntityElement(this.#scene, true));
        }
    }
    get htmlElement() {
        return this.#shadowRoot.host;
    }
    #initHtml() {
        defineHarmonyAccordion();
        this.#shadowRoot = createShadowRoot('scene-explorer', {
            attributes: { tabindex: 1, },
            adoptStyle: sceneExplorerCSS,
            childs: [
                this.#htmlHeader = createElement('div', { class: 'scene-explorer-header' }),
                this.#htmlScene = createElement('div', { class: 'scene-explorer-scene', attributes: { tabindex: 1, }, }),
                this.htmlFileSelector = createElement('div', {
                    class: 'scene-explorer-file-selector',
                    hidden: true,
                    attributes: { tabindex: 1, },
                }),
                this.#htmlExtra = createElement('harmony-accordion', {
                    multiple: 1,
                    childs: [
                        createElement('harmony-item', {
                            id: 'properties',
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#properties',
                                }),
                                this.#htmlProperties = createElement('div', {
                                    class: 'scene-explorer-properties',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                        createElement('harmony-item', {
                            id: 'files',
                            hidden: 1,
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#files',
                                }),
                                this.#htmlFileExplorer = createElement('div', {
                                    class: 'file-explorer',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                        createElement('harmony-item', {
                            id: 'material',
                            hidden: 1,
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#material_editor',
                                }),
                                this.#htmlMaterialEditor = createElement('div', {
                                    class: 'material-editor',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                    ],
                }),
            ],
        });
        I18n.observeElement(this.#shadowRoot);
        defineHarmonyMenu();
        this.#htmlContextMenu = createElement('harmony-menu');
        this.#initHtmlHeader();
        this.#initHtmlProperties();
        this.applyFilter();
        ShortcutHandler.addContext('scene-explorer,scene-explorer-nodes', this.#htmlScene);
        ShortcutHandler.addContext('scene-explorer,scene-explorer-files', this.htmlFileSelector);
        ShortcutHandler.addContext('scene-explorer,scene-explorer-properties', this.#htmlProperties);
    }
    #initHtmlHeader() {
        this.#htmlNameFilter = createElement('input', {
            parent: this.#htmlHeader,
        });
        this.#htmlTypeFilter = createElement('select', {
            parent: this.#htmlHeader,
        });
        let htmlManipulator;
        createElement('span', {
            class: 'manipulator',
            parent: this.#htmlHeader,
            childs: [
                createElement('label', {
                    childs: [
                        htmlManipulator = createElement('input', {
                            type: 'checkbox',
                            events: {
                                change: (event) => this.#manipulator.setVisible(event.target.checked),
                            },
                        }),
                        createElement('span', { i18n: '#display_manipulator', }),
                    ],
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: dragPanSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Translation);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: rotateSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Rotation);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: panZoomSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Scale);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
            ],
        });
        createElement('label', {
            parent: this.#htmlHeader,
            childs: [
                createElement('input', {
                    type: 'checkbox',
                    events: {
                        change: (event) => {
                            const checked = event.target.checked;
                            this.#skeletonHelper.setVisible(checked);
                            display(this.#htmlDisplayBoneJoints, checked);
                        }
                    }
                }),
                createElement('span', {
                    i18n: '#display_skeleton',
                }),
            ]
        });
        this.#htmlDisplayBoneJoints = createElement('label', {
            parent: this.#htmlHeader,
            hidden: true,
            childs: [
                createElement('input', {
                    type: 'checkbox',
                    checked: true,
                    events: {
                        change: (event) => this.#skeletonHelper.displayBoneJoints(event.target.checked)
                    }
                }),
                createElement('span', {
                    i18n: '#display_bone_joints',
                }),
            ]
        });
        /*
        let propertiesId = 'display_properties';
        let htmlDisplayProperties = createElement('input') as HTMLInputElement;
        htmlDisplayProperties.type = 'checkbox';
        htmlDisplayProperties.id = propertiesId;
        htmlDisplayProperties.checked = false;

        /*
        let htmlDisplayPropertiesSpan = createElement('span');
        let htmlDisplayPropertiesLabel = createElement('label', { i18n: '#display_properties', htmlFor: propertiesId });

        this.#htmlHeader.append(htmlDisplayPropertiesSpan);
        htmlDisplayPropertiesSpan.append(htmlDisplayProperties, htmlDisplayPropertiesLabel);
        */
        this.#htmlNameFilter.addEventListener('change', (event) => { this.#filterName = event.target.value.toLowerCase(); this.applyFilter(); });
        this.#htmlTypeFilter.addEventListener('change', (event) => { this.#filterType = event.target.value; this.applyFilter(); });
        //htmlDisplayProperties.addEventListener('change', (event) => toggle(this.#htmlProperties));
        this.#populateTypeFilter();
    }
    #populateTypeFilter() {
        for (let type of ENTITIES) {
            let option = createElement('option', { innerText: type, value: type });
            this.#htmlTypeFilter.append(option);
        }
    }
    applyFilter() {
        if (this.#isVisible) {
            if (this.#filterName == '' && this.#filterType == '') {
                this.#refreshScene();
            }
            else {
                if (this.#scene) {
                    let allEntities = this.#scene.getChildList();
                    this.#htmlScene.innerText = '';
                    for (let entity of allEntities) {
                        if (this.#matchFilter(entity, this.#filterName, this.#filterType)) {
                            const htmlEntityElement = this.#createEntityElement(entity);
                            if (htmlEntityElement) {
                                this.#htmlScene.append();
                            }
                        }
                    }
                }
            }
        }
    }
    #matchFilter(entity, name, type) {
        return (name ? entity.name && entity.name.toLowerCase().includes(name) : true) && (type ? entity.is(type) : true);
    }
    #initHtmlProperties() {
        this.#htmlName = createElement('div', { class: 'scene-explorer-entity-title' });
        const htmlIdLabel = createElement('label', { i18n: '#id' });
        this.#htmlId = createElement('div', { class: 'scene-explorer-entity-id' });
        const htmlPosLabel = createElement('label', { i18n: '#position' });
        this.#htmlPos = createElement('div', { class: 'scene-explorer-entity-pos' });
        const htmlQuatLabel = createElement('label', { i18n: '#quaternion' });
        this.#htmlQuat = createElement('div', { class: 'scene-explorer-entity-quat' });
        const htmlScaleLabel = createElement('label', { i18n: '#scale' });
        this.#htmlScale = createElement('div', { class: 'scene-explorer-entity-scale' });
        const htmlWorldPosLabel = createElement('label', { i18n: '#world_position' });
        this.#htmlWorldPos = createElement('div', { class: 'scene-explorer-entity-world-pos' });
        const htmlWorldQuatLabel = createElement('label', { i18n: '#world_quaternion' });
        this.#htmlWorldQuat = createElement('div', { class: 'scene-explorer-entity-world-quat' });
        const htmlWorldScaleLabel = createElement('label', { i18n: '#world_scale' });
        this.#htmlWorldScale = createElement('div', { class: 'scene-explorer-entity-world-scale' });
        /*
        const htmlVisibleLabel = createElement('label', { i18n: '#visible' });
        this.#htmlVisible = createElement('input', {
            class: 'scene-explorer-entity-visible',
            type: 'checkbox',
            events: {
                input: () => this.#selectedEntity?.toggleVisibility?.()
            }
        }) as HTMLInputElement;
        */
        //this.htmlVisible.addEventListener('input', () => {if (this._currentEntity) this._currentEntity.toggleVisibility()});
        this.#htmlProperties.append(this.#htmlName, htmlIdLabel, this.#htmlId, htmlPosLabel, this.#htmlPos, htmlQuatLabel, this.#htmlQuat, htmlScaleLabel, this.#htmlScale, htmlWorldPosLabel, this.#htmlWorldPos, htmlWorldQuatLabel, this.#htmlWorldQuat, htmlWorldScaleLabel, this.#htmlWorldScale /*, htmlVisibleLabel, this.#htmlVisible*/);
    }
    #createEntityElement(entity, createExpanded = false) {
        let htmlEntityElement = SceneExplorerEntity.getEntityElement(entity);
        if (createExpanded) {
            htmlEntityElement?.expand();
        }
        return htmlEntityElement;
    }
    selectEntity(entity, scrollIntoView = false) {
        if (this.#selectedEntity == entity) {
            return;
        }
        this.#selectedEntity = entity;
        entity.addChild(this.#manipulator);
        entity.addChild(this.#skeletonHelper);
        if (this.#isVisible) {
            this.#updateEntityElement(entity);
            SceneExplorerEntity.getEntityElement(entity)?.select();
            if (scrollIntoView) {
                SceneExplorerEntity.getEntityElement(entity)?.display();
            }
        }
    }
    getSelectedEntity() {
        return this.#selectedEntity;
    }
    #updateEntityElement(entity) {
        if (entity) {
            //this.#updateEntityTitle(entity);
            this.#htmlName.innerText = entity.name ?? entity.constructor.getEntityName();
            this.#htmlId.innerText = entity.id;
            this.#htmlPos.innerText = FormatArray(entity.position);
            this.#htmlQuat.innerText = FormatArray(entity.quaternion);
            this.#htmlScale.innerText = FormatArray(entity.scale);
            this.#htmlWorldPos.innerText = FormatArray(entity.getWorldPosition());
            this.#htmlWorldQuat.innerText = FormatArray(entity.getWorldQuaternion());
            this.#htmlWorldScale.innerText = FormatArray(entity.getWorldScale());
            //this.#htmlVisible.checked = entity.visible;
            /*
            if (entity.visibleSelf === undefined) {
                this.#htmlVisible.indeterminate = true;
            } else {
                this.#htmlVisible.indeterminate = false;
            }
            */
        }
    }
    getEntityHtml(entity) {
        throw 'remove me';
        //return this._entitiesHtml.get(entity);
    }
    #handlePropertyChanged(detail /*TODO: create a proper type*/) {
        if (this.#isVisible && detail.entity == this.#selectedEntity) {
            this.#updateEntityElement(this.#selectedEntity);
        }
        /*const entity = detail.entity;
        SceneExplorerEntity.#updateEntity(entity);
        if (detail.name === 'visible') {
            for (let child of entity.children) {
                SceneExplorerEntity.#updateEntity(child);
            }
        }*/
    }
    showContextMenu(contextMenu, x, y, entity) {
        this.#htmlContextMenu.showContextual(contextMenu, x, y, entity);
    }
    editMaterial(material) {
        const materialEditor = getMaterialEditor();
        materialEditor.editMaterial(material);
        this.#htmlMaterialEditor.append(materialEditor.getHTML());
        this.#htmlExtra.expand('material');
    }
    setJointsRadius(radius) {
        this.#skeletonHelper.setJointsRadius(radius);
    }
}
function initEntitySubmenu() {
    Entity.addSubMenu = [
        {
            i18n: '#primitives', submenu: [
                { i18n: '#box', f: (entity) => entity.addChild(new Box()) },
                { i18n: '#cone', f: (entity) => entity.addChild(new Cone()) },
                { i18n: '#cylinder', f: (entity) => entity.addChild(new Cylinder()) },
                { i18n: '#fullscreenquad', f: (entity) => entity.addChild(new FullScreenQuad()) },
                { i18n: '#metaballs', f: (entity) => entity.addChild(new Metaballs()) },
                { i18n: '#plane', f: (entity) => entity.addChild(new Plane({ width: 1000, height: 1000 })) },
                { i18n: '#sphere', f: (entity) => entity.addChild(new Sphere()) },
                { i18n: '#text', f: (entity) => entity.addChild(new Text3D()) },
            ]
        },
        {
            i18n: '#entities', submenu: [
                { i18n: '#group', f: (entity) => entity.addChild(new Group()) },
                { i18n: '#target', f: (entity) => entity.addChild(new Target()) },
                { i18n: '#keeponlylastchild', f: (entity) => entity.addChild(new KeepOnlyLastChild()) },
                { i18n: '#decal', f: (entity) => entity.addChild(new Decal()) },
            ]
        },
        {
            i18n: '#lights', submenu: [
                { i18n: '#ambient_light', f: (entity) => entity.addChild(new AmbientLight()) },
                { i18n: '#point_light', f: (entity) => entity.addChild(new PointLight()) },
                { i18n: '#spot_light', f: (entity) => entity.addChild(new SpotLight()) },
            ]
        },
        { i18n: '#camera', f: (entity) => ContextObserver.observe(GraphicsEvents, entity.addChild(new Camera())) },
        {
            i18n: '#control', submenu: [
                {
                    i18n: '#rotation_control', f: (entity) => {
                        let control = new RotationControl();
                        let parent = entity.parent;
                        if (parent) {
                            parent.addChild(control);
                        }
                        control.addChild(entity);
                    }
                },
                {
                    i18n: '#translation_control', f: (entity) => {
                        let control = new TranslationControl();
                        let parent = entity.parent;
                        if (parent) {
                            parent.addChild(control);
                        }
                        control.addChild(entity);
                    }
                },
            ]
        },
        { i18n: '#helper', f: (entity) => { let helper = getHelper(entity); if (helper) {
                entity.addChild(helper);
            } } },
        { i18n: '#wireframe', f: (entity) => entity.addChild(new WireframeHelper()) },
        { i18n: '#wireframe2', f: (entity) => entity.addChild(new Wireframe()) },
        { i18n: '#hitboxes', f: (entity) => entity.addChild(new HitboxHelper()) },
        {
            i18n: '#source1', submenu: [
                {
                    i18n: '#model', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source1ModelManager.getModelList(), async (repository, modelName) => {
                            console.error(modelName);
                            //let instance = await Source1ModelManager.createInstance(modelName.repository, modelName.path + modelName.name, true);
                            let instance = await Source1ModelManager.createInstance(repository, modelName, true);
                            if (!instance) {
                                return;
                            }
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(instance);
                            let seq = instance.sourceModel.mdl.getSequenceById(0);
                            if (seq) {
                                instance.playSequence(seq.name);
                            }
                        });
                    }
                },
                {
                    i18n: '#particle_system', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source1ParticleControler.getSystemList(), async (repository, systemPath) => {
                            let systemName = systemPath.split('/');
                            let sys = await Source1ParticleControler.createSystem(repository, systemName[systemName.length - 1]);
                            sys.start();
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(sys);
                        });
                    }
                },
            ]
        },
        {
            i18n: '#source2', submenu: [
                {
                    i18n: '#model', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source2ModelManager.getModelList(), async (repository, modelName) => {
                            console.error(modelName);
                            let instance = await Source2ModelManager.createInstance(repository, modelName, true);
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(instance);
                            /*let seq = instance.sourceModel.mdl.getSequenceById(0);
                            if (seq) {
                                instance.playSequence(seq.name);
                            }*/
                        });
                    }
                },
                {
                    i18n: '#particle_system', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source2ParticleManager.getSystemList(), async (repository, systemPath) => {
                            let systemName = systemPath.split('/');
                            let sys = await Source2ParticleManager.getSystem(repository, systemPath);
                            sys.name = systemName[systemName.length - 1];
                            sys.start();
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(sys);
                        });
                    }
                },
            ]
        },
    ];
}
Entity.editMaterial = function (entity) {
    const material = entity.material;
    if (!material) {
        return;
    }
    const sceneExplorer = getSceneExplorer();
    sceneExplorer.editMaterial(material);
    //materialEditor.editEntity(entity);
    //this.#htmlMaterialEditor.append(materialEditor.getHTML());
    /*
    let entityHtml = SceneExplorer.getEntityHtml(entity);
    if (entityHtml) {
        entityHtml.append(MaterialEditor.html);
    }
        */
};

var compute_fragment_cube_map = `
vec3 cameraToFrag = normalize (vVertexPositionWorldSpace.xyz - uCameraPosition);
vec3 reflectDir = reflect(cameraToFrag, normalize(vVertexNormalWorldSpace));
#ifdef USE_CUBE_MAP
	vec4 cubeMapColor = textureCube(cubeMap, reflectDir);
#endif
`;

var compute_fragment_detail_map = `
#ifdef USE_DETAIL_MAP
	vec4 texelDetail = texture2D(detailMap, vDetailTextureCoord.xy);
#else
	vec4 texelDetail = vec4(0.0);
#endif
`;

var compute_fragment_diffuse = `
#ifdef USE_MESH_COLOR
	vec4 diffuseColor = uColor;
#else
	#ifdef USE_VERTEX_COLOR
		vec4 diffuseColor = vVertexColor;
	#else
		vec4 diffuseColor = vec4(1.0);
	#endif
#endif
`;

var compute_fragment_mask_map = `
#ifdef USE_MASK_MAP
	vec4 texelMask = texture2D(maskMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_mask1_map = `
#ifdef USE_MASK1_MAP
	vec4 texelMask1 = texture2D(mask1Map, vTextureCoord.xy);
#endif
`;

var compute_fragment_mask2_map = `
#ifdef USE_MASK2_MAP
	vec4 texelMask2 = texture2D(mask2Map, vTextureCoord.xy);
#endif
`;

var compute_fragment_normal_map = `
#ifdef USE_NORMAL_MAP
	vec4 texelNormal = texture2D(normalMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_normal_world_space = `
#ifdef FLAT_SHADING
	vec3 fdx = vec3(dFdx(vVertexPositionWorldSpace.x), dFdx(vVertexPositionWorldSpace.y), dFdx(vVertexPositionWorldSpace.z));
	vec3 fdy = vec3(dFdy(vVertexPositionWorldSpace.x), dFdy(vVertexPositionWorldSpace.y), dFdy(vVertexPositionWorldSpace.z));
	vec3 fragmentNormalWorldSpace = normalize(cross(fdx, fdy));
	vec3 fragmentTangentWorldSpace = normalize(fdx);
	vec3 fragmentBitangentWorldSpace = normalize(fdy);
#else
	vec3 fragmentNormalWorldSpace = normalize(vVertexNormalWorldSpace.xyz);
	vec3 fragmentTangentWorldSpace = normalize(vVertexTangentWorldSpace.xyz);
	vec3 fragmentBitangentWorldSpace = normalize(vVertexBitangentWorldSpace.xyz);
#endif
mat3 TBNMatrixWorldSpace = mat3(fragmentTangentWorldSpace, fragmentBitangentWorldSpace, fragmentNormalWorldSpace);
`;

var compute_fragment_phong_exponent_map = `
#ifdef USE_PHONG_EXPONENT_MAP
	vec4 texelPhongExponent = texture2D(phongExponentMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_specular_map = `
#ifdef USE_SPECULAR_MAP
	vec4 texelSpecular = texture2D(specularMap, vTextureCoord.xy);
#endif
`;

var compute_pbr = `

const vec3 Fdielectric = vec3(0.04);

#ifndef NUM_PBR_LIGHTS
	#define NUM_PBR_LIGHTS 0
#endif

struct PBRLight {
	vec3 position;
	vec3 radiance;
};

#if NUM_PBR_LIGHTS > 0
	uniform PBRLight uPbrLights[NUM_PBR_LIGHTS];
#endif

// GGX/Towbridge-Reitz normal distribution function.
// Uses Disney's reparametrization of alpha = roughness^2.
float ndfGGX(float cosLh, float roughness)
{
	float alpha   = roughness * roughness;
	float alphaSq = alpha * alpha;

	float denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;
	return alphaSq / (PI * denom * denom);
}

// Single term for separable Schlick-GGX below.
float gaSchlickG1(float cosTheta, float k)
{
	return cosTheta / (cosTheta * (1.0 - k) + k);
}

// Schlick-GGX approximation of geometric attenuation function using Smith's method.
float gaSchlickGGX(float cosLi, float cosLo, float roughness)
{
	float r = roughness + 1.0;
	float k = (r * r) / 8.0; // Epic suggests using this roughness remapping for analytic lights.
	return gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);
}

// Shlick's approximation of the Fresnel factor.
vec3 fresnelSchlick(vec3 F0, float cosTheta)
{
	return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 computeLightPBR(PBRLight light, vec3 normal, vec3 fragmentPositionWorldSpace, vec3 Lo, float cosLo, vec3 F0, float metalness, float roughness, vec3 albedo) {
		vec3 Li = light.position - fragmentPositionWorldSpace;
		float d = length(Li);
		Li = normalize(Li);
		vec3 Lradiance = light.radiance / (d * d);

		// Half-vector between Li and Lo.
		vec3 Lh = normalize(Li + Lo);

		// Calculate angles between surface normal and various light vectors.
		float cosLi = max(0.0, dot(normal, Li));
		float cosLh = max(0.0, dot(normal, Lh));

		// Calculate Fresnel term for direct lighting.
		vec3 F  = fresnelSchlick(F0, max(0.0, dot(Lh, Lo)));
		// Calculate normal distribution for specular BRDF.
		float D = ndfGGX(cosLh, roughness);
		// Calculate geometric attenuation for specular BRDF.
		float G = gaSchlickGGX(cosLi, cosLo, roughness);

		// Diffuse scattering happens due to light being refracted multiple times by a dielectric medium.
		// Metals on the other hand either reflect or absorb energy, so diffuse contribution is always zero.
		// To be energy conserving we must scale diffuse BRDF contribution based on Fresnel factor & metalness.
		vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);

		// Lambert diffuse BRDF.
		// We don't scale by 1/PI for lighting & material units to be more convenient.
		// See: https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
		vec3 diffuseBRDF = kd * albedo;

		// Cook-Torrance specular microfacet BRDF.
		vec3 specularBRDF = (F * D * G) / max(EPSILON, 4.0 * cosLi * cosLo);

		// Total contribution for this light.
		return (diffuseBRDF + specularBRDF) * Lradiance * cosLi;
}

#if NUM_PBR_LIGHTS > 0
	vec3 computePBR(PBRLight light[NUM_PBR_LIGHTS], vec3 normal, vec3 cameraPosition, vec3 fragmentPositionWorldSpace, vec3 F0, float metalness, float roughness, vec3 albedo, float ao) {
		vec3 Lo = normalize(cameraPosition - fragmentPositionWorldSpace);//vec3 Lo = normalize(eyePosition - vin.position);
		float cosLo = max(0.0, dot(normal, Lo));

		vec3 directLighting = vec3(0);
		for(int i=0; i<NUM_PBR_LIGHTS; ++i) {
			directLighting += computeLightPBR(light[i], normal, fragmentPositionWorldSpace, Lo, cosLo, F0, metalness, roughness, albedo);
		}

		vec3 ambientLighting = uAmbientLight * albedo * ao;
		return directLighting + ambientLighting;
	}
#endif

`;

var compute_silhouette_color = `
#ifdef SILHOUETTE_MODE
	gl_FragColor = SILHOUETTE_COLOR;
#endif
`;

var compute_vertex_color = `
#ifdef USE_VERTEX_COLOR
	vVertexColor = aVertexColor;
#endif
`;

var compute_vertex_detail_uv = `
#ifdef USE_DETAIL_TEXTURE_TRANSFORM
	vDetailTextureCoord.xy = (uDetailTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vDetailTextureCoord.xy = aTextureCoord;
#endif
`;

Includes['compute_fragment_cube_map'] = compute_fragment_cube_map;
Includes['compute_fragment_detail_map'] = compute_fragment_detail_map;
Includes['compute_fragment_diffuse'] = compute_fragment_diffuse;
Includes['compute_fragment_mask_map'] = compute_fragment_mask_map;
Includes['compute_fragment_mask1_map'] = compute_fragment_mask1_map;
Includes['compute_fragment_mask2_map'] = compute_fragment_mask2_map;
Includes['compute_fragment_normal_map'] = compute_fragment_normal_map;
Includes['compute_fragment_normal_world_space'] = compute_fragment_normal_world_space;
Includes['compute_fragment_phong_exponent_map'] = compute_fragment_phong_exponent_map;
Includes['compute_fragment_specular_map'] = compute_fragment_specular_map;
Includes['compute_pbr'] = compute_pbr;
Includes['compute_silhouette_color'] = compute_silhouette_color;
Includes['compute_vertex_color'] = compute_vertex_color;
Includes['compute_vertex_detail_uv'] = compute_vertex_detail_uv;

var compute_fragment_alpha_test = `
#ifndef EXPORT_TEXTURES
	#ifdef ALPHA_TEST
		if (diffuseColor.a < uAlphaTestReference) {
			discard;
		}
	#endif
#endif
`;

var compute_fragment_ao_map = `
#ifdef USE_AO_MAP
	vec4 texelAo = texture2D(aoMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_color_map = `
#ifdef USE_COLOR_MAP
	vec4 texelColor = texture2D(colorMap, vTextureCoord.xy);
#else
	vec4 texelColor = vec4(1.0);
#endif
`;

var compute_fragment_depth = `
#ifdef ALWAYS_ON_TOP
	gl_FragDepth =  gl_FragCoord.z / 100.0;
#endif
#ifdef ALWAYS_BEHIND
	gl_FragDepth =  1.0 - EPSILON;
#endif
`;

var compute_fragment_exponent_map = `
#ifdef USE_EXPONENT_MAP
	vec4 texelExponent = texture2D(exponentMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_lights = `
#if NUM_POINT_LIGHTS > 0
	#if defined(USE_SHADOW_MAPPING) && (NUM_POINT_LIGHT_SHADOWS > 0)
		PointLightShadow pointLightShadow;
	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			computePointLightIrradiance(uPointLights[i], geometry, directLight);
			#ifdef USE_SHADOW_MAPPING
				pointLightShadow = uPointLightShadows[ i ];
				directLight.color *= getPointShadow( uPointShadowMap[i], pointLightShadow.mapSize, /*pointLightShadow.shadowBias*/0.0, /*pointLightShadow.shadowRadius*/0.0, vPointShadowCoord[i], pointLightShadow.near, pointLightShadow.far);
			#endif
			RE_Direct( directLight, geometry, material, reflectedLight );
		}
	#endif

	#pragma unroll
	for ( int i = NUM_POINT_LIGHT_SHADOWS; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if NUM_SPOT_LIGHTS > 0
	#if defined(USE_SHADOW_MAPPING) && (NUM_SPOT_LIGHT_SHADOWS > 0)
		SpotLightShadow spotLightShadow;
	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#pragma unroll
		for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
			computeSpotLightIrradiance(uSpotLights[i], geometry, directLight);
			#ifdef USE_SHADOW_MAPPING
				spotLightShadow = uSpotLightShadows[ i ];
				directLight.color *= getShadow( uSpotShadowMap[ i ], spotLightShadow.mapSize, /*spotLightShadow.shadowBias*/0.0, /*spotLightShadow.shadowRadius*/0.0, vSpotShadowCoord[ i ] );
			#endif
			RE_Direct( directLight, geometry, material, reflectedLight );
		}
	#endif

	#pragma unroll
	for ( int i = NUM_SPOT_LIGHT_SHADOWS; i < NUM_SPOT_LIGHTS; i ++ ) {
		computeSpotLightIrradiance(uSpotLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )
	#ifndef SKIP_LIGHT_WARP
		#ifdef USE_LIGHT_WARP_MAP
			irradiance *= getLightWarp(saturate(luminance(irradiance)));
		#endif
	#endif

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`;

var compute_fragment_log_depth = `
#ifdef USE_LOG_DEPTH
	#ifdef IS_PERSPECTIVE_CAMERA
		gl_FragDepthEXT = log2(vFragDepth) * uProjectionLogDepth * 0.5;
	#endif
	#ifdef IS_ORTHOGRAPHIC_CAMERA
		gl_FragDepthEXT = gl_FragCoord.z;
	#endif
#endif
`;

var compute_fragment_normal = `
#ifdef FLAT_SHADING
	vec3 fdx = vec3(dFdx(vVertexPositionCameraSpace.x), dFdx(vVertexPositionCameraSpace.y), dFdx(vVertexPositionCameraSpace.z));
	vec3 fdy = vec3(dFdy(vVertexPositionCameraSpace.x), dFdy(vVertexPositionCameraSpace.y), dFdy(vVertexPositionCameraSpace.z));
	vec3 fragmentNormalCameraSpace = normalize(cross(fdx, fdy));
	vec3 fragmentTangentCameraSpace = normalize(fdx);
	vec3 fragmentBitangentCameraSpace = normalize(fdy);
#else
	vec3 fragmentNormalCameraSpace = normalize(vVertexNormalCameraSpace.xyz);
	vec3 fragmentTangentCameraSpace = normalize(vVertexTangentCameraSpace.xyz);
	vec3 fragmentBitangentCameraSpace = normalize(vVertexBitangentCameraSpace.xyz);
#endif
mat3 TBNMatrixCameraSpace = mat3(fragmentTangentCameraSpace, fragmentBitangentCameraSpace, fragmentNormalCameraSpace);
`;

var compute_fragment_render_mode = `
#ifdef RENDER_MODE
	#if RENDER_MODE == 1
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexNormalModelSpace.xyz), 1.0);
		#endif
	#elif RENDER_MODE == 2
		gl_FragColor = vec4(abs(vVertexNormalWorldSpace), 1.0);
	#elif RENDER_MODE == 3
		gl_FragColor = vec4(abs(vVertexNormalCameraSpace), 1.0);
	#elif RENDER_MODE == 4
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexTangentModelSpace.xyz), 1.0);
		#endif
	#elif RENDER_MODE == 5
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexTangentWorldSpace), 1.0);
		#endif
	#elif RENDER_MODE == 6
		gl_FragColor = vec4(abs(vVertexTangentCameraSpace), 1.0);
	#elif RENDER_MODE == 7
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexBitangentWorldSpace), 1.0);
		#endif
	#elif RENDER_MODE == 8
		gl_FragColor = vec4(abs(vVertexBitangentCameraSpace), 1.0);
	#elif RENDER_MODE == 10
		gl_FragColor = vec4(tangentSpaceNormal, 1.0);
	#elif RENDER_MODE == 11
		gl_FragColor = vec4(abs(fragmentNormalCameraSpace), 1.0);
	#endif
#endif
`;

var compute_fragment_self_illum_mask_map = `
#ifdef USE_SELF_ILLUM_MASK_MAP
	vec4 texelSelfIllumMask = texture2D(selfIllumMaskMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_standard = `
#include compute_fragment_depth
#include compute_silhouette_color
#ifdef PICKING_MODE
	gl_FragColor = vec4(uPickingColor, 1.0);
#endif
#ifdef WRITE_DEPTH_TO_COLOR
	#ifdef IS_POINT_LIGHT
		float dist = length( vVertexPositionWorldSpace.xyz - uLightPosition );
		dist = ( dist - uLightNear ) / ( uLightFar - uLightNear );
		gl_FragColor = PackDepth32(saturate(dist));
	#else
		gl_FragColor = PackDepth32(0.5 * vPosition.z / vPosition.w + 0.5);
	#endif
#endif
#ifdef RENDER_HIGHLIGHT
	#ifdef HIGHLIGHT
		gl_FragColor.rgb *= 1.5;
	#endif
#endif
#ifdef UNPACK_DEPTH_COLOR
	gl_FragColor = vec4(vec3(1.0 - UnpackDepth32(texelColor)), 1.0);
#endif
#ifdef DESATURATE
	float luminance = 0.2126 * gl_FragColor.r + 0.7152 * gl_FragColor.g + 0.0722 * gl_FragColor.b * 0.0;
	gl_FragColor = vec4(vec3(luminance), gl_FragColor.a);
#endif
#if defined(TONE_MAPPING) && TONE_MAPPING > 0
	gl_FragColor.rgb = ToneMapping(gl_FragColor.rgb);
#endif
`;

var compute_lights_setup_vars = `
	IncidentLight directLight;

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	GeometricContext geometry;
	geometry.position = vVertexPositionCameraSpace.xyz;
	geometry.normal = fragmentNormalCameraSpace;
	geometry.viewDir = normalize(-vVertexPositionCameraSpace.xyz);
	//TODO: check geometry.worldNormal
	geometry.worldNormal = normalize(vVertexNormalWorldSpace);
	geometry.worldNormal = normalize(fragmentNormalCameraSpace);

`;

var compute_vertex_log_depth = `
#ifdef USE_LOG_DEPTH
	vFragDepth = 1.0 + gl_Position.w;
#endif
`;

var compute_vertex_projection = `
#ifdef SKIP_PROJECTION
	gl_Position = vec4(aVertexPosition, 1.0);
#else
	vec4 vertexPositionCameraSpace = uViewMatrix * vertexPositionWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexNormalCameraSpace = uNormalMatrix * vertexNormalWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexTangentCameraSpace = uNormalMatrix * vertexTangentWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexBitangentCameraSpace = uNormalMatrix * vertexBitangentWorldSpace;//TODOv3: use projectionview matrix instead ?
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;

	vVertexPositionCameraSpace = vertexPositionCameraSpace;
	vVertexNormalCameraSpace = vertexNormalCameraSpace;
	vVertexTangentCameraSpace = vertexTangentCameraSpace;
	vVertexBitangentCameraSpace = vertexBitangentCameraSpace;
#endif
`;

var compute_vertex_shadow_mapping = `
#ifdef USE_SHADOW_MAPPING
	vec4 shadowWorldPosition;
	#if (NUM_POINT_LIGHT_SHADOWS > 0)
		for (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++) {
			shadowWorldPosition = vertexPositionWorldSpace;
			vPointShadowCoord[i] = uPointShadowMatrix[i] * shadowWorldPosition;
		}
	#endif
	#if (NUM_SPOT_LIGHT_SHADOWS > 0)
		for (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++) {
			shadowWorldPosition = vertexPositionWorldSpace;
			vSpotShadowCoord[i] = uSpotShadowMatrix[i] * shadowWorldPosition;
		}
	#endif
#endif
`;

var compute_vertex_skinning = `
#ifdef SKELETAL_MESH
	#ifdef HARDWARE_SKINNING
		mat4 skinMat = accumulateSkinMat();
		vec4 vertexPositionWorldSpace = skinMat * vertexPositionModelSpace;
		vec3 vertexNormalWorldSpace = vec3(skinMat * vertexNormalModelSpace).xyz;
		vec3 vertexTangentWorldSpace = vec3(skinMat * vertexTangentModelSpace).xyz;
	#else
		#define vertexPositionWorldSpace vertexPositionModelSpace
		#define vertexNormalWorldSpace vertexNormalModelSpace.xyz
		#define vertexTangentWorldSpace vertexTangentModelSpace.xyz
	#endif
#else
	vec4 vertexPositionWorldSpace = uModelMatrix * vertexPositionModelSpace;
	vec3 vertexNormalWorldSpace = vec3(uModelMatrix * vertexNormalModelSpace).xyz;
	vec3 vertexTangentWorldSpace = vec3(uModelMatrix * vertexTangentModelSpace).xyz;
#endif
vVertexPositionWorldSpace = vertexPositionWorldSpace;
vVertexNormalWorldSpace = vertexNormalWorldSpace;
#ifdef TESTING
	vVertexTangentWorldSpace = vertexTangentWorldSpace;
#endif

#ifdef USE_VERTEX_TANGENT
	vec3 vertexBitangentWorldSpace = cross( vertexNormalWorldSpace, vertexTangentWorldSpace) * aVertexTangent.w;
#else
	//TODO: compute it properly
	vec3 vertexBitangentWorldSpace = cross( vertexNormalWorldSpace, vertexTangentWorldSpace) * -1.0;
#endif
#ifdef TESTING
	vVertexBitangentWorldSpace = vertexBitangentWorldSpace;
#endif
`;

var compute_vertex_standard = `
#ifdef WRITE_DEPTH_TO_COLOR
	vPosition = gl_Position;
#endif
`;

var compute_vertex_uv = `
#ifdef USE_TEXTURE_TRANSFORM
	vTextureCoord.xy = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vTextureCoord.xy = aTextureCoord;
#endif
`;

var compute_vertex_uv2 = `
#ifdef USE_TEXTURE2_TRANSFORM
	vTexture2Coord.xy = (uTexture2Transform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vTexture2Coord.xy = aTextureCoord;
#endif
`;

var compute_vertex = `
vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
#ifdef REVERSE_CULLING
	vec4 vertexNormalModelSpace = vec4(-aVertexNormal, 0.0);
#else
	vec4 vertexNormalModelSpace = vec4(aVertexNormal, 0.0);
#endif

#ifdef USE_VERTEX_TANGENT
	vec4 vertexTangentModelSpace = vec4(aVertexTangent.xyz, 0.0);
#else
	//TODO: compute it properly
	vec4 vertexTangentModelSpace = vec4(0.0, 1.0, 0.0, 0.0);
#endif

vVertexNormalModelSpace = vertexNormalModelSpace;
vVertexTangentModelSpace = vertexTangentModelSpace;
`;

Includes['compute_fragment_alpha_test'] = compute_fragment_alpha_test;
Includes['compute_fragment_ao_map'] = compute_fragment_ao_map;
Includes['compute_fragment_color_map'] = compute_fragment_color_map;
Includes['compute_fragment_depth'] = compute_fragment_depth;
Includes['compute_fragment_exponent_map'] = compute_fragment_exponent_map;
Includes['compute_fragment_lights'] = compute_fragment_lights;
Includes['compute_fragment_log_depth'] = compute_fragment_log_depth;
Includes['compute_fragment_normal'] = compute_fragment_normal;
Includes['compute_fragment_render_mode'] = compute_fragment_render_mode;
Includes['compute_fragment_self_illum_mask_map'] = compute_fragment_self_illum_mask_map;
Includes['compute_fragment_standard'] = compute_fragment_standard;
Includes['compute_lights_setup_vars'] = compute_lights_setup_vars;
Includes['compute_vertex_log_depth'] = compute_vertex_log_depth;
Includes['compute_vertex_projection'] = compute_vertex_projection;
Includes['compute_vertex_shadow_mapping'] = compute_vertex_shadow_mapping;
Includes['compute_vertex_skinning'] = compute_vertex_skinning;
Includes['compute_vertex_standard'] = compute_vertex_standard;
Includes['compute_vertex_uv'] = compute_vertex_uv;
Includes['compute_vertex_uv2'] = compute_vertex_uv2;
Includes['compute_vertex'] = compute_vertex;

var declare_camera_position = `
uniform vec3 uCameraPosition;
`;

var declare_fragment_alpha_test = `
#ifdef ALPHA_TEST
	uniform float uAlphaTestReference;
#endif
`;

var declare_fragment_ao_map = `
#ifdef USE_AO_MAP
	uniform sampler2D aoMap;
#endif
`;

var declare_fragment_exponent_map = `
#ifdef USE_EXPONENT_MAP
	uniform sampler2D exponentMap;
#endif
`;

var declare_fragment_light_warp = `
#ifndef SKIP_LIGHT_WARP
	#ifdef USE_LIGHT_WARP_MAP
		uniform sampler2D lightWarpMap;

		vec3 getLightWarp(const in float value) {
			return texture2D(lightWarpMap, vec2(value, 0.5) ).rgb;
		}
	#endif
#endif
`;

var declare_fragment_self_illum_mask_map = `
#ifdef USE_SELF_ILLUM_MASK_MAP
	uniform sampler2D selfIllumMaskMap;
#endif
`;

var declare_lights = `
#include luminance
#include declare_fragment_light_warp
#ifdef WRITE_DEPTH_TO_COLOR
	#ifdef IS_POINT_LIGHT
		uniform vec3 uLightPosition;
		uniform float uLightNear;
		uniform float uLightFar;
	#endif
#endif
#ifndef NUM_POINT_LIGHTS
	#define NUM_POINT_LIGHTS 0
#endif
#ifndef NUM_SPOT_LIGHTS
	#define NUM_SPOT_LIGHTS 0
#endif
#define NUM_HEMI_LIGHTS 0

uniform vec3 lightProbe[ 9 ];

	uniform vec3 uAmbientLight;
	struct GeometricContext {
		vec3 position;
		vec3 normal;
		vec3 worldNormal;
		vec3 viewDir;
	};

	struct PointLight {
		vec3 position;
		vec3 color;
		float range;
	};

	struct IncidentLight {//TODO: change structure name
		vec3 color;
		vec3 direction;
		bool visible;
	};



	struct ReflectedLight {
		vec3 directDiffuse;
		vec3 directSpecular;
		vec3 indirectDiffuse;
		vec3 indirectSpecular;
	};

#if NUM_POINT_LIGHTS > 0
	uniform PointLight uPointLights[NUM_POINT_LIGHTS];
#endif

	float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	#if defined ( PHYSICALLY_CORRECT_LIGHTS )

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		// this is intended to be used on spot and point lights who are represented as luminous intensity
		// but who must be converted to luminous irradiance for surface lighting calculation
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

		if( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	#else

		if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

		}

		return 1.0;

	#endif

	}

vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 irradiance = shGetIrradianceAt( geometry.worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

	void computePointLightIrradiance(const PointLight pointLight, const GeometricContext geometry, out IncidentLight directLight) {
		vec3 lightVector = pointLight.position - geometry.position;
		directLight.direction = normalize(lightVector);
		float lightDistance = length(lightVector);
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.range, 1.0/*pointLight.decay*/);


/*

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
		*/


	}

#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float range;
		float innerAngleCos;
		float outerAngleCos;
	};
	uniform SpotLight uSpotLights[NUM_SPOT_LIGHTS];

	void computeSpotLightIrradiance(const SpotLight spotLight, const GeometricContext geometry, out IncidentLight directLight) {
		vec3 lightVector = spotLight.position - geometry.position;
		directLight.direction = normalize(lightVector);
		float lightDistance = length(lightVector);
		float angleCos = dot( directLight.direction, spotLight.direction );

		if (angleCos > spotLight.outerAngleCos ) {
			float spotEffect = smoothstep( spotLight.outerAngleCos, spotLight.innerAngleCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect;
			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.range, 1.0/*spotLight.decay*/);
			directLight.visible = true;
		} else {
			directLight.color = vec3(0.0);
			directLight.visible = false;
		}

/*

		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
*/
	}
#endif

struct BlinnPhongMaterial {

	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;

};
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH + EPSILON, shininess );

}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

}vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

}
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	#ifdef TOON

		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#else

		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;

	#endif

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}




#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
`;

var declare_log_depth = `
#ifdef USE_LOG_DEPTH
	uniform float uProjectionLogDepth;
#endif
`;

var declare_matrix_uniforms = `
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uViewProjectionMatrix;
uniform mat3 uNormalMatrix;
`;

var declare_shadow_mapping = `
#ifdef USE_SHADOW_MAPPING
	#if (NUM_SPOT_LIGHT_SHADOWS > 0)
		struct SpotLightShadow{
			bool enabled;
			vec2 mapSize;
		};
		uniform mat4 uSpotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];
		uniform sampler2D uSpotShadowMap[NUM_SPOT_LIGHT_SHADOWS];
		varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];
		uniform SpotLightShadow uSpotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
	#endif

	#if (NUM_POINT_LIGHT_SHADOWS > 0)
		struct PointLightShadow{
			bool enabled;
			vec2 mapSize;
			float near;
			float far;
		};
		uniform mat4 uPointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];
		uniform sampler2D uPointShadowMap[NUM_POINT_LIGHT_SHADOWS];
		varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];
		uniform PointLightShadow uPointLightShadows[NUM_POINT_LIGHT_SHADOWS];
	#endif

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, UnpackDepth32( texture2D( depths, uv )) );
	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0 && shadowCoord.z <= 1.0) {
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z - 0.00001);
		}

		return shadow;
	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize/* * vec2( 4.0, 2.0 ) */);

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;
		dp -= 0.001;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp  + 0.00001);

		#endif

	}

#endif
`;

var declare_vertex_skinning = `
#ifdef HARDWARE_SKINNING
	#ifdef SKELETAL_MESH
		uniform sampler2D uBoneMatrix;

		mat4 getBoneMat(int boneId) {
			mat4 result = mat4(0.0);
			float texelPos = float(boneId) / float(MAX_HARDWARE_BONES);
			result[0] = texture2D(uBoneMatrix, vec2(0.00, texelPos));
			result[1] = texture2D(uBoneMatrix, vec2(0.25, texelPos));
			result[2] = texture2D(uBoneMatrix, vec2(0.50, texelPos));
			result[3] = texture2D(uBoneMatrix, vec2(0.75, texelPos));
			return result;
		}

		mat4 accumulateSkinMat() {
			mat4 result;
			result =		aBoneWeight.x * getBoneMat(int(aBoneIndices.x));
			result = result + aBoneWeight.y * getBoneMat(int(aBoneIndices.y));
			result = result + aBoneWeight.z * getBoneMat(int(aBoneIndices.z));
			return result;
		}
	#endif
#endif
`;

var declare_vertex_uv = `
#ifdef USE_TEXTURE_TRANSFORM
	uniform mat4 uTextureTransform;
#endif
`;

Includes['declare_camera_position'] = declare_camera_position;
Includes['declare_fragment_alpha_test'] = declare_fragment_alpha_test;
Includes['declare_fragment_ao_map'] = declare_fragment_ao_map;
Includes['declare_fragment_exponent_map'] = declare_fragment_exponent_map;
Includes['declare_fragment_light_warp'] = declare_fragment_light_warp;
Includes['declare_fragment_self_illum_mask_map'] = declare_fragment_self_illum_mask_map;
Includes['declare_lights'] = declare_lights;
Includes['declare_log_depth'] = declare_log_depth;
Includes['declare_matrix_uniforms'] = declare_matrix_uniforms;
Includes['declare_shadow_mapping'] = declare_shadow_mapping;
Includes['declare_vertex_skinning'] = declare_vertex_skinning;
Includes['declare_vertex_uv'] = declare_vertex_uv;

var common_defines = `
// conversion from glsl es1 to es3
#ifdef WEBGL2
	#define texture2D texture
	#define textureCube texture
#endif

// conversion from HLSL to glsl
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define lerp mix
#define saturate(x) clamp(x, 0.0, 1.0)
#define tex2D texture2D
#define texCUBE textureCube
#define fmod(x, y) x - y * trunc(x/y)

// Math
#define PI 3.141592653589793
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_TAU 0.15915494309189535
#define HALF_PI 1.5707963267948966
#define TWO_PI 6.283185307179586
#define TAU TWO_PI
#define EPSILON 0.000001

highp float rand(vec2 co) {
	const highp float a = 12.9898;
	const highp float b = 78.233;
	const highp float c = 43758.5453;
	highp float dt= dot(co.xy ,vec2(a,b));
	highp float sn= mod(dt,3.14);
	return fract(sin(sn) * c);
}
`;

var common_functions = `
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
`;

var common_uniforms = `
uniform vec4 uTime;
#define TIME uTime.x
#define FRAME uTime.y
uniform vec4 uResolution;
#ifdef PICKING_MODE
	uniform vec3 uPickingColor;
#endif
`;

var depth_packing = `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}

#define PackDepth32 packDepthToRGBA
#define UnpackDepth32 unpackRGBAToDepth
/*
vec4 PackDepth32(in float depth) {
	depth *= (256.0 * 256.0 * 256.0 - 1.0) / (256.0 * 256.0 * 256.0);
	vec4 encode = fract(depth * vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0));
	return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0 / 512.0;
}

float UnpackDepth32(in vec4 pack){
	float depth = dot( pack, 1.0 / vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0) );
	return depth * (256.0 * 256.0 * 256.0) / (256.0 * 256.0 * 256.0 - 1.0);
}*/
`;

var header_fragment = `
#ifdef WEBGL1
	#extension GL_EXT_frag_depth : enable
#endif
#include precision
#include common_defines
#include common_functions
#include common_uniforms
#include depth_packing

#ifdef WEBGL2
	#define varying in

	out vec4 fragColor;
	#define gl_FragColor fragColor
#endif

#ifdef WEBGL1
	#define gl_FragDepth gl_FragDepthEXT
#endif
#ifdef WEBGL2
	#define gl_FragDepthEXT gl_FragDepth
#endif
`;

var header_vertex = `
#include precision
#include common_defines
#include common_uniforms
#include depth_packing

#ifdef WEBGL2
	#define attribute in
	#define varying out
#endif
`;

var precision = `
#ifdef HIGH_PRECISION
	#ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		precision highp int;
	#else
		precision mediump float;
		precision mediump int;
	#endif
#endif

#ifdef MEDIUM_PRECISION
	precision mediump float;
	precision mediump int;
#endif

#ifdef LOW_PRECISION
	precision lowp float;
	precision lowp int;
#endif
`;

Includes['common_defines'] = common_defines;
Includes['common_functions'] = common_functions;
Includes['common_uniforms'] = common_uniforms;
Includes['depth_packing'] = depth_packing;
Includes['header_fragment'] = header_fragment;
Includes['header_vertex'] = header_vertex;
Includes['precision'] = precision;

var varying_standard = `
varying vec4 vVertexPositionModelSpace;
varying vec4 vVertexPositionWorldSpace;
varying vec4 vVertexPositionCameraSpace;


varying vec4 vVertexNormalModelSpace;
varying vec3 vVertexNormalWorldSpace;
varying vec3 vVertexNormalCameraSpace;

varying vec4 vVertexTangentModelSpace;
varying vec3 vVertexTangentWorldSpace;
varying vec3 vVertexTangentCameraSpace;

varying vec3 vVertexBitangentWorldSpace;
varying vec3 vVertexBitangentCameraSpace;

varying vec4 vTextureCoord;
varying vec4 vTexture2Coord;
#ifdef USE_VERTEX_COLOR
	varying vec4 vVertexColor;
#endif

#ifdef WRITE_DEPTH_TO_COLOR
	varying vec4 vPosition;
#endif
#ifdef USE_LOG_DEPTH
	varying float vFragDepth;
#endif
`;

Includes['varying_standard'] = varying_standard;

var declare_vertex_uv2 = `
#ifdef USE_TEXTURE2_TRANSFORM
	uniform mat4 uTexture2Transform;
#endif
`;

Includes['declare_vertex_uv2'] = declare_vertex_uv2;

var declare_attributes = `
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
#ifdef USE_VERTEX_TANGENT
	attribute vec4 aVertexTangent;//TODO: setup a define tangent is not used everywhere
#endif
#ifdef USE_VERTEX_COLOR
	attribute vec4 aVertexColor;
#endif
attribute vec2 aTextureCoord;
#ifdef USE_TEXTURE_COORD_2
	attribute vec2 aTextureCoord2;
#endif
#ifdef HARDWARE_SKINNING
	#ifdef SKELETAL_MESH
		attribute vec3 aBoneWeight;
		attribute vec3 aBoneIndices;
	#endif
#endif
`;

Includes['declare_attributes'] = declare_attributes;

var declare_fragment_color_map = `
#ifdef USE_COLOR_MAP
	uniform sampler2D colorMap;
#endif
#ifdef USE_COLOR_1_MAP
	uniform sampler2D color1Map;
#endif
`;

var declare_fragment_cube_map = `
#ifdef USE_CUBE_MAP
	uniform samplerCube cubeMap;
#endif
`;

var declare_fragment_detail_map = `
#ifdef USE_DETAIL_MAP
	uniform sampler2D detailMap;
#endif
`;

var declare_fragment_diffuse = `
#ifdef USE_MESH_COLOR
	uniform vec4 uColor;
#endif
`;

var declare_fragment_ibl = `
#ifdef USE_IRRADIANCE_TEXTURE
	uniform samplerCube irradianceTexture;
#endif
#ifdef USE_SPECULAR_TEXTURE
	uniform samplerCube specularTexture;
#endif
`;

var declare_fragment_mask_map = `
#ifdef USE_MASK_MAP
	uniform sampler2D maskMap;
#endif
#ifdef USE_MASK1_MAP
	uniform sampler2D mask1Map;
#endif
#ifdef USE_MASK2_MAP
	uniform sampler2D mask2Map;
#endif
`;

var declare_fragment_normal_map = `
#ifdef USE_NORMAL_MAP
	uniform sampler2D normalMap;
#endif
`;

var declare_fragment_phong_exponent_map = `
#ifdef USE_PHONG_EXPONENT_MAP
	uniform sampler2D phongExponentMap;
#endif
`;

var declare_fragment_specular_map = `
#ifdef USE_SPECULAR_MAP
	uniform sampler2D specularMap;
#endif
`;

var declare_fragment_standard = `
#include declare_fragment_tone_mapping
`;

var declare_fragment_tone_mapping = `

#ifndef TONE_MAPPING_EXPOSURE
	#define TONE_MAPPING_EXPOSURE 1.0
#endif
#ifdef TONE_MAPPING
#if TONE_MAPPING == 0
	vec3 ToneMapping( vec3 color ) {
		return color;
	}
#endif
#if TONE_MAPPING == 2 // Reinhard
	vec3 ToneMapping( vec3 color ) {
		color *= TONE_MAPPING_EXPOSURE;
		return saturate( color / ( vec3( 1.0 ) + color ) );

	}
#endif
#endif

`;

var declare_fragment_uniforms = `
uniform vec4 uColor;
`;

var declare_vertex_detail_uv = `
#ifdef USE_DETAIL_TEXTURE_TRANSFORM
	uniform mat4 uDetailTextureTransform;
#endif
`;

Includes['declare_fragment_color_map'] = declare_fragment_color_map;
Includes['declare_fragment_cube_map'] = declare_fragment_cube_map;
Includes['declare_fragment_detail_map'] = declare_fragment_detail_map;
Includes['declare_fragment_diffuse'] = declare_fragment_diffuse;
Includes['declare_fragment_ibl'] = declare_fragment_ibl;
Includes['declare_fragment_mask_map'] = declare_fragment_mask_map;
Includes['declare_fragment_normal_map'] = declare_fragment_normal_map;
Includes['declare_fragment_phong_exponent_map'] = declare_fragment_phong_exponent_map;
Includes['declare_fragment_specular_map'] = declare_fragment_specular_map;
Includes['declare_fragment_standard'] = declare_fragment_standard;
Includes['declare_fragment_tone_mapping'] = declare_fragment_tone_mapping;
Includes['declare_fragment_uniforms'] = declare_fragment_uniforms;
Includes['declare_vertex_detail_uv'] = declare_vertex_detail_uv;

var luminance = `
float luminance(vec3 color) {
	return dot(color, vec3(0.299, 0.587, 0.114));
}

float luminance(vec4 color) {
	return dot(color.rgb, vec3(0.299, 0.587, 0.114));
}
`;

var rotation_matrix = `
mat4 rotationMatrix(vec3 axis, float angle){
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;

	return mat4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0,
				oc * axis.x * axis.y + axis.z * s,	oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0,
				oc * axis.z * axis.x - axis.y * s,	oc * axis.y * axis.z + axis.x * s,	oc * axis.z * axis.z + c,			0.0,
				0.0,								0.0,								0.0,								1.0);
}
`;

Includes['luminance'] = luminance;
Includes['rotation_matrix'] = rotation_matrix;

var mat4_from_quat = `
#pragma once
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

mat4 mat4FromQuat(vec4 q) {
	mat4 ret;
	float x = q.x;
	float y = q.y;
	float z = q.z;
	float w = q.w;

	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float yx = y * x2;
	float yy = y * y2;
	float zx = z * x2;
	float zy = z * y2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;

	ret[0][0] = 1. - yy - zz;
	ret[0][1] = yx + wz;
	ret[0][2] = zx - wy;
	ret[0][3] = 0.;
	ret[1][0] = yx - wz;
	ret[1][1] = 1. - xx - zz;
	ret[1][2] = zy + wx;
	ret[1][3] = 0.;
	ret[2][0] = zx + wy;
	ret[2][1] = zy - wx;
	ret[2][2] = 1. - xx - yy;
	ret[2][3] = 0.;
	ret[3][0] = 0.;
	ret[3][1] = 0.;
	ret[3][2] = 0.;
	ret[3][3] = 1.;

	return ret;
}
`;

var vec3_transform_quat = `
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec3 vec3_transformQuat (vec3 a, vec4 q) {
	vec3 ret;
	float qx = q.x;
	float qy = q.y;
	float qz = q.z;
	float qw = q.w;

	float x = a.x;
	float y = a.y;
	float z = a.z;

	float uvx = qy * z - qz * y;
	float uvy = qz * x - qx * z;
	float uvz = qx * y - qy * x;

	float uuvx = qy * uvz - qz * uvy;
	float uuvy = qz * uvx - qx * uvz;
	float uuvz = qx * uvy - qy * uvx;

	float w2 = qw * 2.0;
	uvx *= w2;
	uvy *= w2;
	uvz *= w2;

	uuvx *= 2.0;
	uuvy *= 2.0;
	uuvz *= 2.0;

	// return vec3.add(out, a, vec3.add(out, uv, uuv));

	ret.x = x + uvx + uuvx;
	ret.y = y + uvy + uuvy;
	ret.z = z + uvz + uuvz;

	return ret;
}
`;

Includes['mat4_from_quat'] = mat4_from_quat;
Includes['vec3_transform_quat'] = vec3_transform_quat;

var postprocessing_vertex = `
#include declare_attributes
#include declare_matrix_uniforms

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_projection
}
`;

Includes['postprocessing_vertex'] = postprocessing_vertex;

var sample_color_texture = `
#ifdef USE_COLOR_TEXTURE
	vec3 colorTexel = texture2D(uColorTexture, vTextureCoord.xy).rgb;
#else
	vec3 colorTexel = uColor.rgb;
#endif
`;

var sample_cube_uv_mapping = `
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= cubeUV_r1 ) {

			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

		} else if ( roughness >= cubeUV_r4 ) {

			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

		} else if ( roughness >= cubeUV_r5 ) {

			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

		} else if ( roughness >= cubeUV_r6 ) {

			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		sampleDir = sampleDir.xzy * vec3(1.0, 1.0, -1.0);

		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}
`;

Includes['sample_color_texture'] = sample_color_texture;
Includes['sample_cube_uv_mapping'] = sample_cube_uv_mapping;

var varying_line = `
#include varying_standard
varying vec2 vUv;
#ifdef USE_DASH
	varying float vLineDistance;
#endif
`;

Includes['varying_line'] = varying_line;

var meshbasic_fs = `
#include declare_fragment_standard
#include declare_lights
#include declare_shadow_mapping

#include declare_fragment_diffuse
#include declare_fragment_color_map

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

	#include compute_fragment_standard
}
`;

var meshbasic_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_standard
}
`;

var meshphong_fs = `
#include declare_fragment_diffuse
#include declare_fragment_color_map
#include declare_fragment_alpha_test

#include declare_lights
#include declare_shadow_mapping
#include declare_log_depth

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test
	#include compute_fragment_normal

/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

#include compute_fragment_lights

/* TEST SHADING END*/

#include compute_fragment_render_mode
/* TEST SHADING BEGIN*/
gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
gl_FragColor.a = diffuseColor.a;
/* TEST SHADING END*/


	#ifdef SKIP_LIGHTING
		gl_FragColor.rgb = diffuseColor.rgb;
	#else
		gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#endif
	gl_FragColor.a = diffuseColor.a;


	#include compute_fragment_standard
	#include compute_fragment_log_depth
}
`;

var meshphong_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
	#include compute_vertex_log_depth
}
`;

Shaders['meshbasic.fs'] = meshbasic_fs;
Shaders['meshbasic.vs'] = meshbasic_vs;
Shaders['meshphong.fs'] = meshphong_fs;
Shaders['meshphong.vs'] = meshphong_vs;

var fullscreenquad_fs = `
uniform float opacity;
uniform sampler2D tDiffuse;

#include varying_standard

void main() {
	vec4 texel = texture2D(tDiffuse, vTextureCoord.xy);
	gl_FragColor = opacity * texel;
	gl_FragColor = vec4(vTextureCoord.xy, 0.0, 1.0);
	texel = texture2D(tDiffuse, vTextureCoord.xy);
	gl_FragColor = texel;
	#include compute_fragment_standard
}
`;

var fullscreenquad_vs = `
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

#include varying_standard

void main(void) {
	gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
	vTextureCoord.xy = aVertexPosition.xy*0.5 + vec2(0.5);
}
`;

var grid_fs = `
#include declare_fragment_standard
#include declare_fragment_diffuse
#include declare_fragment_color_map

uniform float uSpacing;

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

	#include compute_fragment_standard

	float halfSpacing = uSpacing * 0.5;
	float radSpacing = TWO_PI / uSpacing;

	vec4 xLines = saturate(mix(vec4(0.0), vec4(1.0), cos(vVertexPositionWorldSpace.y * radSpacing) * 100.0 - 99.0));
	vec4 yLines = saturate(mix(vec4(0.0), vec4(1.0), cos(vVertexPositionWorldSpace.x * radSpacing) * 100.0 - 99.0));


	if (abs(vVertexPositionWorldSpace.y) < halfSpacing) {
		xLines.gb = vec2(0.0);
	}
	if (abs(vVertexPositionWorldSpace.x) < halfSpacing) {
		yLines.rb = vec2(0.0);
	}

	gl_FragColor = xLines + yLines;
	gl_FragColor.rgb *= gl_FragColor.a;
}
`;

var grid_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
}
`;

var line_fs = `
#include declare_fragment_standard
#include declare_fragment_diffuse
#include declare_lights

#ifdef USE_DASH
	uniform float dashSize;
	uniform float gapSize;
#endif

#include varying_line
void main() {
	#include compute_fragment_diffuse
	#ifdef USE_DASH
		if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps
		if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX
	#endif

	if ( abs( vUv.y ) > 1.0 ) {
		float a = vUv.x;
		float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
		float len2 = a * a + b * b;
		if ( len2 > 1.0 ) discard;
	}
	gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );
	#include compute_fragment_standard
}
`;

var line_vs = `
#include declare_attributes
#include declare_matrix_uniforms
		uniform float linewidth;
//		uniform vec2 resolution;

		attribute vec3 aSegmentStart;
		attribute vec3 aSegmentEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = uProjectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = uProjectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		#include varying_line

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( aVertexPosition.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( aVertexPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = uResolution.x / uResolution.y;

			vUv = aTextureCoord;

			// camera space
			vec4 start = uModelViewMatrix * vec4( aSegmentStart, 1.0 );
			vec4 end = uModelViewMatrix * vec4( aSegmentEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( uProjectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = uProjectionMatrix * start;
			vec4 clipEnd = uProjectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( aVertexPosition.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( aVertexPosition.y < 0.0 ) {

				offset += - dir;

			} else if ( aVertexPosition.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= uResolution.y;

			// select end
			vec4 clip = ( aVertexPosition.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( aVertexPosition.y < 0.5 ) ? start : end; // this is an approximation


		}
`;

var shadertoy_fs = `
#define iTime TIME
#define iFrame int(FRAME)
#define iResolution vec3(uResolution)
#define iMouse vec4(0.0)
uniform sampler2D noiseMap;

#include shadertoy_code

#include varying_standard

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
	gl_FragColor.a = 1.;
	gl_FragDepth = 0.9999999;
	//#include compute_fragment_standard
}
`;

var shadertoy_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var skybox_fs = `
#include declare_fragment_standard

#ifdef TEXTURE_MAPPING_CUBE_UV
	#include sample_cube_uv_mapping
	uniform sampler2D uCubeTexture;
#else
	uniform samplerCube uCubeTexture;
#endif

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;
	gl_FragColor = vec4(vTextureCoord.xy, 0., 1.);
	gl_FragColor.rgb = (normalize(vVertexPositionModelSpace.rgb));
	//gl_FragColor.rgb = texture2D(colorMap, vTextureCoord.xy);


#ifdef TEXTURE_MAPPING_CUBE_UV
	gl_FragColor = textureCubeUV(uCubeTexture, vVertexPositionModelSpace.xyz, 0.);
#else
	gl_FragColor = textureCube(uCubeTexture, vVertexPositionModelSpace.xyz);
#endif

	#include compute_fragment_standard
}
`;

var skybox_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color

	vVertexPositionModelSpace = vertexPositionModelSpace;

	#include compute_vertex_standard
}
`;

Shaders['fullscreenquad.fs'] = fullscreenquad_fs;
Shaders['fullscreenquad.vs'] = fullscreenquad_vs;
Shaders['grid.fs'] = grid_fs;
Shaders['grid.vs'] = grid_vs;
Shaders['line.fs'] = line_fs;
Shaders['line.vs'] = line_vs;
Shaders['shadertoy.fs'] = shadertoy_fs;
Shaders['shadertoy.vs'] = shadertoy_vs;
Shaders['skybox.fs'] = skybox_fs;
Shaders['skybox.vs'] = skybox_vs;

var meshbasicpbr_fs = `
#include declare_fragment_standard
#include declare_lights
#include declare_shadow_mapping
#include declare_camera_position

#include declare_fragment_diffuse
#include declare_fragment_color_map
#include declare_fragment_uniforms
uniform float uMetalness;
uniform float uRoughness;
uniform sampler2D uColorTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uMetalnessTexture;
uniform sampler2D uRoughnessTexture;

#include declare_fragment_ibl
#include compute_pbr

#include varying_standard

void main(void) {
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

const int NumLights = 1;
/*PBRLight lights[NUM_PBR_LIGHTS] = PBRLight[](PBRLight(vec3(0, -1000, 0), vec3(1)));*/
#include sample_color_texture
vec3 albedo = pow(colorTexel, vec3(2.2));

const vec3 Fdielectric = vec3(0.04);
float metalness = 0.;
float roughness = 0.;
#ifdef USE_METALNESS_TEXTURE
	vec4 metalnessTexel = texture2D(uMetalnessTexture, vTextureCoord.xy);
	metalness = metalnessTexel.r;
#else
	metalness = uMetalness;
#endif
#ifdef USE_ROUGHNESS_TEXTURE
	vec4 roughnessTexel = texture2D(uRoughnessTexture, vTextureCoord.xy);
	roughness = roughnessTexel.r;
#else
	roughness = uRoughness;
#endif


	#ifdef USE_NORMAL_TEXTURE
		vec4 normalTexel = texture2D(uNormalTexture, vTextureCoord.xy);
		vec3 N = normalTexel.rgb * 2.0 - 1.0;
	#else
		vec3 N = vec3(0., 0., 1.0);
	#endif


	N = normalize(TBNMatrixWorldSpace * N);

vec3 F0 = mix(Fdielectric, albedo, metalness);
	#include compute_fragment_standard
	gl_FragColor.rgb = vec3(metalness * roughness);
#if NUM_PBR_LIGHTS > 0
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, 1.);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var meshbasicpbr_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_standard
}
`;

Shaders['meshbasicpbr.fs'] = meshbasicpbr_fs;
Shaders['meshbasicpbr.vs'] = meshbasicpbr_vs;

var copy_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

void main(void) {
	#include compute_fragment_color_map
	gl_FragColor = texelColor;
}
`;

var copy_vs = `
#include postprocessing_vertex
`;

var crosshatch_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / uResolution.xy;

	float lum = length(texture(colorMap, uv).rgb);

	fragColor = vec4(1.0, 1.0, 1.0, 1.0);

	if (lum < 1.00) {
		if (mod(fragCoord.x + fragCoord.y, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.75) {
		if (mod(fragCoord.x - fragCoord.y, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.50) {
		if (mod(fragCoord.x + fragCoord.y - 5.0, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.3) {
		if (mod(fragCoord.x - fragCoord.y - 5.0, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}
}


void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var crosshatch_vs = `
#include postprocessing_vertex
`;

var edgedetection_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform vec2 uTexSize;
uniform vec3 uVisibleEdgeColor;
uniform vec3 uHiddenEdgeColor;

#include varying_standard

void main(void) {
	vec2 invSize = 1.0 / uTexSize;
	vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
	vec4 c1 = texture2D( colorMap, vTextureCoord.xy + uvOffset.xy);
	vec4 c2 = texture2D( colorMap, vTextureCoord.xy - uvOffset.xy);
	vec4 c3 = texture2D( colorMap, vTextureCoord.xy + uvOffset.yw);
	vec4 c4 = texture2D( colorMap, vTextureCoord.xy - uvOffset.yw);
	float diff1 = (c1.r - c2.r)*0.5;
	float diff2 = (c3.r - c4.r)*0.5;
	float d = length( vec2(diff1, diff2) );
	float a1 = min(c1.g, c2.g);
	float a2 = min(c3.g, c4.g);
	float visibilityFactor = min(a1, a2);
	vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? uVisibleEdgeColor : uHiddenEdgeColor;
	gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);

	//#include compute_fragment_standard
}
`;

var edgedetection_vs = `
#include declare_attributes
#include declare_matrix_uniforms

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_projection
}
`;

var grain_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;

#include varying_standard

void main(void) {
	float grain = 1.0 - rand(vTextureCoord.xy) * uGrainIntensity;

	gl_FragColor = texture2D(colorMap, vTextureCoord.xy) * vec4(grain, grain, grain, 1.0);
}
`;

var grain_vs = `
#include postprocessing_vertex
`;

var oldmovie_fs = `
#define iTime TIME
#define iFrame int(FRAME)
#define iResolution vec2(uResolution)
#define iMouse vec3(0.0)
uniform sampler2D noiseMap;


#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;

#include varying_standard

//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+10.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


vec4 SCREEN(in vec4 src, in vec4 dst){
    return ( src + dst ) - ( src * dst );
}

vec3 Blur(sampler2D tex, vec2 uv, float blurSize, float directions, float quality){


    vec2 radius = blurSize/iResolution.xy;
    vec3 res = texture(tex, uv).rgb;
    for(float i=1.0/quality; i<=1.0; i+=1.0/quality)
    {
        for( float d=0.0; d<TWO_PI; d+=TWO_PI/directions)
        {
			res += texture( tex, uv+vec2(cos(d),sin(d))*radius*i).rgb;
        }
    }
    res /= (quality-1.) * directions;
    return res;
}
vec3 Blur(sampler2D tex, vec2 uv){
    return Blur(tex,uv, 4.,16.,4.);
}

vec2 ShakeUV(vec2 uv, float time){
    uv.x += 0.002 * sin(time*3.141) * sin(time*14.14);
    uv.y += 0.002 * sin(time*1.618) * sin(time*17.32);
    return uv;
}

float filmDirt(vec2 uv, float time){
    uv += time * sin(time) * 10.;
    float res = 1.0;

    float rnd = fract(sin(time+1.)*31415.);
    if(rnd>0.3){
        float dirt =
            texture(colorMap,uv*0.1).r *
            texture(colorMap,uv*0.01).r *
            texture(colorMap,uv*0.002).r *
            1.0;
        res = 1.0 - smoothstep(0.4,0.6, dirt);
    }
    return res;
}

float FpsTime(float time, float fps){
    time = mod(time, 60.0);
    time = float(int(time*fps)) / fps;
    return time;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    vec2 mUV = iMouse.xy/iResolution.xy;

    mUV = vec2(0.5,0.7); /*fix mouse pos for thumbnail*/

    vec4 col;

    float time = FpsTime(iTime, 12.);
    fragColor = vec4(mod(uv.x+time*0.5, 0.1)*10.);
    //return; /* Debug FpsTime */

    vec2 suv = ShakeUV(uv, time);
    fragColor = vec4(mod(suv.xy,0.1)*10., 0., 1.0);
    //return; /* Debug ShakeUV */

    //float grain = mix(1.0, fract(sin(dot(suv.xy+time,vec2(12.9898,78.233))) * 43758.5453), 0.25); /* random */
    float grain = mix(1.0, snoise(suv.xy*1234.), 0.15); /* simplex noise */
    fragColor = vec4(vec3(grain), 1.0);
    //return; /* Debug grain */

    vec3 color = texture(colorMap, suv).rgb;
    color *= grain;

    float Size = mUV.x * 8.;
    float Directions = 16.0;
    float Quality = 3.0;
    vec3 blur = Blur(colorMap, suv, Size, Directions, Quality);
    blur *= grain;

    float Threshold = mUV.y;
    vec3 FilterRGB = normalize(vec3(1.5,1.2,1.0));
    float HighlightPower = 3.0;
    HighlightPower *= 1. + fract(sin(time)*3.1415) * 0.3;
    vec3 highlight = clamp(color -Threshold,0.0,1.0)/(1.0-Threshold);
    highlight = blur * Threshold * FilterRGB * HighlightPower;

    /* dirt */
    float dirt = filmDirt(uv, time);
    fragColor = vec4(vec3(dirt), 1.0);
    //return; /* Debug dirt */

    col = SCREEN(vec4(color,1.0), vec4(highlight,1.0));
    //col = vec4(highlight,1.0);
    //col = vec4(blur,1.0);
    col *= dirt;

    vec2 v = uv * (1.0 - uv.yx);
    float vig = v.x*v.y * 15.0;
    vig = pow(vig, 0.5);

    fragColor = col * vig;
    //fragColor = uv.x>0.5 ? colR : colL;
    fragColor.a = 1.0;
}

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var oldmovie_vs = `
#include postprocessing_vertex
`;

var palette_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

// short version of "random pixel sprites" by stb. https://shadertoy.com/view/3ttfzl ( 2371ch )
// Inspired by https://www.youtube.com/watch?v=8wOUe32Pt-E

// What power of 2 the pixel cell sizes are increased to
const int pixel_scale = 1;

// https://lospec.com/palette-list/oil-6
// Should be sorted in increasing order by perceived luminance for best results
// Can work with up to 256 distinct colors
/*const vec4[] palette = vec4[] (
vec4(32./255., 62./255., 62./255.,1.),
vec4(244./255., 114./255., 104./255., 1.),
vec4(245./255., 229./255., 193./255., 1.)
);*/

const vec4[] palette = vec4[] (
vec4(39./255., 39./255., 68./255., 1.),
vec4(73./255., 77./255., 126./255., 1.),
vec4(139./255., 109./255., 156./255.,1.),
vec4(198./255., 159./255., 165./255., 1.),
vec4(242./255., 211./255., 171./255., 1.),
vec4(251./255., 245./255., 239./255., 1.));

// Amount of colors in the palette
// Changing this is not recommended
const int colors = int(palette.length());

// How much the dither effect spreads. By default it is set to decrease as the amount of colors increases.
// Set to 0 to disable the dithering effect for flat color areas.
const float dither_spread = 1./float(colors);

// Precomputed threshold map for dithering
const mat4x4 threshold = mat4x4(0., 8., 2., 10.,
                                12., 4., 14., 6.,
                                3.,11.,1.,9.,
                                15.,7.,13., 5.);

// Chooses a color from the palette based on the current luminance
vec4 applyPalette(float lum)
{
    lum = floor(lum * float(colors));
    return palette[int(lum)];
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // https://luka712.github.io/2018/07/01/Pixelate-it-Shadertoy-Unity/
    float pixelSizeX = 1.0 / uResolution.x;
    float pixelSizeY = 1.0 / uResolution.y;
    float cellSizeX = pow(2., float(pixel_scale)) * pixelSizeX;
    float cellSizeY = pow(2., float(pixel_scale)) * pixelSizeY;

    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/uResolution.xy;

    // Convert pixel coordinates to cell coordinates
    float u = cellSizeX * floor(uv.x / cellSizeX);
    float v = cellSizeY * floor(uv.y / cellSizeY);

    // get pixel information from the cell coordinates
    vec4 col = texture(colorMap, vec2(u,v));

    // https://en.wikipedia.org/wiki/Ordered_dithering
    int x = int(u / cellSizeX) % 4;
    int y = int(v / cellSizeY) % 4;
    col.r = col.r + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.g = col.g + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.b = col.b + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.r = floor(col.r * float(colors-1) + .5)/float(colors-1);
    col.g = floor(col.g * float(colors-1) + .5)/float(colors-1);
    col.b = floor(col.b * float(colors-1) + .5)/float(colors-1);

    // Calculate luminance
    float lum = (0.299*col.r + 0.587*col.g + 0.114*col.b);

    // Apply the new color palette
    col = applyPalette(lum);

    // Output to screen
    fragColor = vec4(col);
    if (col.r <= 0.2) {
        //fragColor.a = 0.0;
    }
}

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var palette_vs = `
#include postprocessing_vertex
`;

var pixelate_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uHorizontalTiles;

#include varying_standard

#define lum(pix) dot( pix, vec4(.3,.59,.11,0) ) //luminance
#define T(x,y) texture( colorMap, uv2 + vec2(x,y) )

void computeSquarePixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 pixelWH = vec2(uHorizontalTiles / uResolution.xy);

	vec2 xy = floor(fragCoord.xy / uHorizontalTiles) * pixelWH + pixelWH / 2.0;

	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;

	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = b;//dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;

	fragColor = texture2D(colorMap, sampleUv + 0.5);
}

void computeDiamondPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 pixelWH = vec2(uHorizontalTiles / uResolution.xy);

	vec2 xy = floor(fragCoord.xy / uHorizontalTiles) * pixelWH + pixelWH / 2.0;

	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;

	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;

	fragColor = texture2D(colorMap, sampleUv + 0.5);
}

void computeRoundPixel1(out vec4 fragColor, in vec2 fragCoord) {
	vec2 div = vec2(uHorizontalTiles) * uResolution.xy / uResolution.y;


	vec2 uv = fragCoord/uResolution.xy;
	vec2 uv2 = floor(uv*div)/div;

	vec2 diff = (uv-uv2)*div;

	vec4 pix = texture(colorMap, uv2);

	if ( pow(diff.x - 0.5,2.0) + pow(diff.y - 0.5,2.0) > 0.25) {

		vec4 pmax;
		vec4 pmin;
		vec2 v2 = 1.0 / div;

		if (diff.x<0.5) { v2.x = -v2.x; }
		if (diff.y<0.5) { v2.y = -v2.y; }

		vec4 p1 = texture(colorMap, uv2 + vec2( 0.0, v2.y ));
		vec4 p2 = texture(colorMap, uv2 + vec2( v2.x, 0.0 ));
		vec4 p3 = texture(colorMap, uv2 + vec2( v2.x, v2.y ));

		if ( lum(p1) > lum(p2) ) {
			pmax = p1;
			pmin = p2;
		} else {
			pmax = p2;
			pmin = p1;
		}

		if ( lum(p3) < lum(pmin) ) {
			pmin = p3;
		}

		if ( lum(pix) > lum(pmax) ) {
			pix = pmax;
		} else if ( lum(pmin) > lum(pix) ) {
			pix = pmin;
		}

	}

	fragColor = pix;
}

void computeRoundPixel2(out vec4 fragColor, in vec2 fragCoord) {
	float pixelSize = uResolution.y / uHorizontalTiles;
	vec2 U = fragCoord / pixelSize;
	vec2 div = pixelSize / uResolution.xy;
	vec2 uv2 = floor(U)*div;
	vec2 diff = fract(U);

	//checkerboard pattern : half of the pixels are not changed
	if (fract( dot(floor(U),vec2(.5)) ) < .5)
	{ fragColor = T(0,0); return; }

	// neighbors
	vec4[4] pix = vec4[4](
		texture( colorMap, uv2 + vec2(0, div.y)),
		texture( colorMap, uv2 + vec2(div.x, 0)),
		texture( colorMap, uv2 + vec2(0, -div.y)),
		texture( colorMap, uv2 + vec2(-div.x, 0)));

	//where is the biggest contrast ?
	int comp = int ( abs( lum(pix[0]) - lum(pix[2]) )
	> abs( lum(pix[1]) - lum(pix[3]) ) );
	vec2 d = abs(diff-.5) - vec2(1-comp,comp); // offset = 0,1 or 1,0
	ivec2 v = ivec2( vec2(3.5,2.5) - diff*2. );

	fragColor = dot(d,d) < .5
	? pix[ v[comp] ]								 // 2 circles on the borders
	: mix( pix[comp+2], pix[comp] , diff[1-comp] ); // a gradient in between
}


float hexDist(in vec2 p) {
	p = abs(p);
	float edgeDist = dot(p, normalize(vec2(1.0, 1.73)));
	return max(edgeDist, p.x);
}

void computeHexagonPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;
	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.73); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;
	float brightness = dot(texture(colorMap, sampleUv + 0.5).rgb, vec3(1.0 / 3.0));
	fragColor = vec4(1.0);//vec4(smoothstep(unit, 0.0, hexDist(hexUv) - brightness * 0.5));
	fragColor.rgb *=texture(colorMap, sampleUv + 0.5).rgb;
}
vec2 hash2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}
void computeVoronoiPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = fragCoord.xy / uResolution.xy;

    vec2 pixelating = uResolution.yx / uResolution.y / uHorizontalTiles;//mix(0.03, 0.005, pow(cos(0.0), 2.0));

    uv = (uv-0.5)/pixelating;

    vec2 n = floor(uv);
    vec2 f = fract(uv);

    //----------------------------------
    // regular voronoi from Inigo Quilez,
    // https://www.shadertoy.com/view/ldl3W8
    //----------------------------------
	vec2 mg, mr;

    // best distance
    float md = 8.0;
    // best delta vector
    vec2 mv;
    for(int j=-1;j<=1;j++)
    for(int i=-1;i<=1;i++) {
        vec2 g = vec2(float(i),float(j));
		vec2 o = hash2(n + g);
        #ifdef ANIMATE_VORONOI
        o = 0.5 + 0.5*sin(iTime + 6.2831*o);
        #endif
        vec2 r = g + o - f;
        float d = dot(r,r);
        if(d < md) {
            md = d;
            mv = r;
        }
    }

    uv += mv;

    uv = uv * pixelating+0.5;

	fragColor = texture(colorMap, uv);
}
void computeTrianglePixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = fragCoord.xy / uResolution.xy;

	vec2 pixelating = uResolution.yx / uResolution.y / uHorizontalTiles;

	uv = (uv - 0.5) / pixelating;
	vec2 uvTriangleSpace = mat2(1.0, 1.0, 0.6, -0.6) * uv;
	uvTriangleSpace = fract(uvTriangleSpace);
	if(uvTriangleSpace.x > uvTriangleSpace.y) uvTriangleSpace.x -= 0.5;
	uv -= mat2(0.5, 0.833, 0.5, -0.833) * uvTriangleSpace + vec2(-0.25, 0.25);

	fragColor = texture(colorMap, clamp(uv * pixelating + 0.5, 0.01, 0.99));
}


#ifndef PIXEL_STYLE
	#define PIXEL_STYLE 0
#endif

void main(void) {

	#if (PIXEL_STYLE == 0)
		computeSquarePixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 1)
		computeDiamondPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 2)
		computeRoundPixel1(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 3)
		computeRoundPixel2(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 4)
		computeHexagonPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 5)
		computeVoronoiPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 6)
		computeTrianglePixel(gl_FragColor, gl_FragCoord.xy);
	#endif
}
`;

var pixelate_vs = `
#include postprocessing_vertex
`;

var saturate_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uSaturation;

#include varying_standard

void main(void) {
	#include compute_fragment_color_map
	float luminance = 0.2126 * texelColor.r + 0.7152 * texelColor.g + 0.0722 * texelColor.b;

	gl_FragColor = mix(vec4(luminance), texelColor, vec4(vec3(uSaturation), 1.0));
}
`;

var saturate_vs = `
#include postprocessing_vertex
`;

var sketch_fs = `
float dist = 6.0; // how far to sample from
int loops = 60; // how many times to sample, more = smoother

#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;
const float PI2 = PI * 2.0;
const int mSize = 9;
const int kSize = (mSize-1)/2;
const float sigma = 3.0;
float kernel[mSize];

// Gaussian PDF
float normpdf(in float x, in float sigma)
{
	return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
}

//
vec3 colorDodge(in vec3 src, in vec3 dst)
{
    return step(0.0, dst) * mix(min(vec3(1.0), dst/ (1.0 - src)), vec3(1.0), step(1.0, src));
}

float greyScale(in vec3 col)
{
    return dot(col, vec3(0.3, 0.59, 0.11));
    //return dot(col, vec3(0.2126, 0.7152, 0.0722)); //sRGB
}

vec2 random(vec2 p){
	p = fract(p * (vec2(314.159, 314.265)));
    p += dot(p, p.yx + 17.17);
    return fract((p.xx + p.yx) * p.xy);
}

vec2 random2(vec2 p)
{
    return texture(colorMap, p / vec2(1024.0)).xy;
    //blue1 = texture(iChannel1, p / vec2(1024.0));
    //blue2 = texture(iChannel1, (p+vec2(137.0, 189.0)) / vec2(1024.0));
}



#include varying_standard

void main(void) {
	float grain = 1.0 - rand(vTextureCoord.xy) * uGrainIntensity;

	gl_FragColor = texture2D(colorMap, vTextureCoord.xy) * vec4(grain, grain, grain, 1.0);
    vec2 q = vTextureCoord.xy;
    vec3 col = texture(colorMap, q).rgb;

    vec2 r = random(q);
    r.x *= PI2;
    vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(r.y);

    vec3 blurred = texture(colorMap, q + cr * (vec2(mSize) / uResolution.xy) ).rgb;

    // comparison
    if (false) {
        blurred = vec3(0.0);
        float Z = 0.0;
        for (int j = 0; j <= kSize; ++j) {
            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
        }
        for (int j = 0; j < mSize; ++j) {
            Z += kernel[j];
        }

		// this can be done in two passes
        for (int i = -kSize; i <= kSize; ++i) {
            for (int j = -kSize; j <= kSize; ++j) {
                blurred += kernel[kSize+j]*kernel[kSize+i]*texture(colorMap, (gl_FragCoord.xy+vec2(float(i),float(j))) / uResolution.xy).rgb;
            }
    	}
   		blurred = blurred / Z / Z;

        // an interesting ink effect
        //r = random2(q);
        //vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(-2.0*r.y);
        //blurred = texture(iChannel0, q + cr * (vec2(mSize) / iResolution.xy) ).rgb;
    }

    vec3 inv = vec3(1.0) - blurred;
    // color dodge
    vec3 lighten = colorDodge(col, inv);
    // grey scale
    vec3 res = vec3(greyScale(lighten));

    // more contrast
    res = vec3(pow(res.x, 3.0));
    //res = clamp(res * 0.7 + 0.3 * res * res * 1.2, 0.0, 1.0);

    // edge effect
    //if (iMouse.z > 0.5) res *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );
	gl_FragColor = vec4(res, 1.0);


}

`;

var sketch_vs = `
#include postprocessing_vertex
`;

Shaders['copy.fs'] = copy_fs;
Shaders['copy.vs'] = copy_vs;
Shaders['crosshatch.fs'] = crosshatch_fs;
Shaders['crosshatch.vs'] = crosshatch_vs;
Shaders['edgedetection.fs'] = edgedetection_fs;
Shaders['edgedetection.vs'] = edgedetection_vs;
Shaders['grain.fs'] = grain_fs;
Shaders['grain.vs'] = grain_vs;
Shaders['oldmovie.fs'] = oldmovie_fs;
Shaders['oldmovie.vs'] = oldmovie_vs;
Shaders['palette.fs'] = palette_fs;
Shaders['palette.vs'] = palette_vs;
Shaders['pixelate.fs'] = pixelate_fs;
Shaders['pixelate.vs'] = pixelate_vs;
Shaders['saturate.fs'] = saturate_fs;
Shaders['saturate.vs'] = saturate_vs;
Shaders['sketch.fs'] = sketch_fs;
Shaders['sketch.vs'] = sketch_vs;

const EDIT_MODE_SHADER = 0;
const EDIT_MODE_INCLUDE = 1;
class ShaderEditor extends HTMLElement {
    #initialized = false;
    #recompileDelay = 1000;
    #annotationsDelay = 500;
    #editMode = EDIT_MODE_SHADER;
    #shadowRoot;
    #shaderEditor;
    #htmlShaderNameSelect;
    #htmlShaderRenderMode;
    #recompileTimeout;
    #editorShaderName;
    #editorIncludeName;
    #shaderType;
    initEditor(options = {}) {
        if (this.#initialized) {
            return;
        }
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        I18n.observeElement(this.#shadowRoot);
        let aceScript = options.aceUrl ?? ACE_EDITOR_URI;
        this.#initialized = true;
        this.style.cssText = 'display: flex;flex-direction: column;height: 100%;width: 100%;';
        this.#htmlShaderNameSelect = createElement('select');
        this.#htmlShaderNameSelect.addEventListener('input', (event) => {
            let selectedOption = event.target.selectedOptions[0];
            if (selectedOption) {
                if (selectedOption.getAttribute('data-shader')) {
                    this.editorShaderName = event.target.value;
                }
                if (selectedOption.getAttribute('data-include')) {
                    this.editorIncludeName = event.target.value;
                }
            }
        });
        this.#htmlShaderRenderMode = createElement('input');
        this.#htmlShaderRenderMode.addEventListener('input', (event) => {
            let n = Number(event.target.value);
            if (Number.isNaN(n)) {
                new Graphics().setIncludeCode('RENDER_MODE', '#undef RENDER_MODE');
            }
            else {
                new Graphics().setIncludeCode('RENDER_MODE', '#define RENDER_MODE ' + n);
            }
        });
        let htmlCustomShaderButtons = createElement('div');
        if (options.displayCustomShaderButtons) {
            let htmlButtonSaveCustomShader = createElement('button', { i18n: '#save_custom_shader' });
            let htmlButtonLoadCustomShader = createElement('button', { i18n: '#load_custom_shader' });
            let htmlButtonRemoveCustomShader = createElement('button', { i18n: '#remove_custom_shader' });
            htmlCustomShaderButtons.append(htmlButtonSaveCustomShader, htmlButtonLoadCustomShader, htmlButtonRemoveCustomShader);
            this.#shadowRoot.append(htmlCustomShaderButtons);
            htmlButtonSaveCustomShader.addEventListener('click', () => this.#saveCustomShader());
            htmlButtonLoadCustomShader.addEventListener('click', () => this.#loadCustomShader());
            htmlButtonRemoveCustomShader.addEventListener('click', () => this.#removeCustomShader());
        }
        let c = createElement('div', { style: 'flex:1;' });
        {
            hide(this.#htmlShaderRenderMode);
        }
        this.#shadowRoot.append(this.#htmlShaderNameSelect, this.#htmlShaderRenderMode, htmlCustomShaderButtons, c);
        if (aceScript == '') {
            this.#initEditor2(c);
        }
        else {
            loadScripts([aceScript], () => this.#initEditor2(c)); //TODO: variable
        }
        ShaderEventTarget.addEventListener('shaderadded', event => this.#reloadGLSLList());
        ShaderEventTarget.addEventListener('includeadded', event => this.#reloadGLSLList());
    }
    #initEditor2(id) {
        this.#shaderEditor = globalThis.ace.edit(id);
        this.#shaderEditor.renderer.attachToShadowRoot();
        this.#shaderEditor.$blockScrolling = Infinity;
        this.#shaderEditor.setTheme('ace/theme/monokai');
        this.#shaderEditor.getSession().setMode('ace/mode/glsl');
        this.#shaderEditor.getSession().on('change', () => {
            clearTimeout(this.#recompileTimeout);
            this.#recompileTimeout = setTimeout(() => { this.recompile(); }, this.#recompileDelay); //TODO:
        });
        this.#shaderEditor.commands.addCommand({
            name: 'myCommand',
            bindKey: { win: 'Ctrl-Shift-C', mac: 'Command-M' },
            exec: () => {
                this.recompile();
            },
        });
        this.#reloadGLSLList();
    }
    #reloadGLSLList() {
        if (!this.#shaderEditor) {
            return;
        }
        this.#htmlShaderNameSelect.innerText = '';
        let shaderGroup = createElement('optgroup', { i18n: { label: '#shader_editor_shaders', }, parent: this.#htmlShaderNameSelect });
        const shaderList = [...ShaderManager.shaderList].sort();
        for (let shaderName of shaderList) {
            const option = createElement('option', {
                class: 'shader-editor-shader-list-shader',
                value: shaderName,
                innerHTML: shaderName,
                'data-shader': true,
                parent: shaderGroup
            });
            if (this.#editMode == EDIT_MODE_SHADER && this.editorShaderName == shaderName) {
                option.selected = true;
            }
        }
        let includeGroup = createElement('optgroup', { i18n: { label: '#shader_editor_includes', }, parent: this.#htmlShaderNameSelect });
        const includeList = [...getIncludeList()].sort();
        for (let includeName of includeList) {
            const option = createElement('option', {
                class: 'shader-editor-shader-list-include',
                value: includeName,
                innerHTML: includeName,
                'data-include': true,
                parent: includeGroup
            });
            if (this.#editMode == EDIT_MODE_INCLUDE && this.editorIncludeName == includeName) {
                option.selected = true;
            }
        }
        if (!this.editorShaderName && !this.editorIncludeName) {
            let selectedOption = this.#htmlShaderNameSelect.selectedOptions[0];
            if (selectedOption) {
                if (selectedOption.getAttribute('data-shader')) {
                    this.editorShaderName = selectedOption.value;
                }
            }
        }
    }
    get editorShaderName() {
        return this.#editorShaderName;
    }
    set editorShaderName(shaderName) {
        if (shaderName) {
            this.#editorShaderName = shaderName;
            const source = ShaderManager.getShaderSource(undefined, this.#editorShaderName, true);
            if (source) {
                if (this.#shaderEditor) {
                    this.#shaderEditor.setValue(source.getSource());
                }
                this.#shaderType = source.getType();
                this.#editMode = EDIT_MODE_SHADER;
            }
        }
    }
    get editorIncludeName() {
        return this.#editorIncludeName;
    }
    set editorIncludeName(includeName) {
        if (includeName) {
            this.#editorIncludeName = includeName;
            const source = getIncludeSource(this.#editorIncludeName);
            if (source) {
                this.#shaderEditor.setValue(source);
                this.#editMode = EDIT_MODE_INCLUDE;
            }
        }
    }
    recompile() {
        clearTimeout(this.#recompileTimeout);
        const customSource = this.#shaderEditor.getValue();
        if (this.#editMode == EDIT_MODE_SHADER) {
            ShaderManager.setCustomSource(this.#shaderType, this.#editorShaderName, customSource);
        }
        else {
            setCustomIncludeSource(this.#editorIncludeName, customSource);
            ShaderManager.resetShadersSource();
            new Graphics().invalidateShaders();
        }
        if (customSource == '') {
            if (this.#editMode == EDIT_MODE_SHADER) {
                this.editorShaderName = this.#editorShaderName;
            }
            else {
                this.editorIncludeName = this.#editorIncludeName;
            }
        }
        else {
            if (this.#editMode == EDIT_MODE_SHADER) {
                new Graphics().invalidateShaders();
                setTimeout(() => this.setAnnotations(this.#editorShaderName), this.#annotationsDelay);
            }
            else {
                setTimeout(() => this.#shaderEditor.getSession().setAnnotations(ShaderManager.getIncludeAnnotations(this.#editorIncludeName)), this.#annotationsDelay);
            }
        }
    }
    setAnnotations(shaderName) {
        if (shaderName == this.#editorShaderName) {
            this.#shaderEditor.getSession().setAnnotations(ShaderManager.getCustomSourceAnnotations(shaderName));
        }
    }
    set recompileDelay(delay) {
        this.#recompileDelay = delay;
    }
    set annotationsDelay(delay) {
        this.#annotationsDelay = delay;
    }
    #saveCustomShader() {
        let type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        let name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        this.dispatchEvent(new CustomEvent('save-custom-shader', { detail: { type: type, name: name, source: this.#shaderEditor.getValue() } }));
    }
    #loadCustomShader() {
        let type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        let name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        let shaderType = this.#editMode == EDIT_MODE_SHADER ? this.#shaderType : null;
        this.dispatchEvent(new CustomEvent('load-custom-shader', { detail: { type: type, name: name, shaderType: shaderType } }));
    }
    #removeCustomShader() {
        let type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        let name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        let shaderType = this.#editMode == EDIT_MODE_SHADER ? this.#shaderType : null;
        this.dispatchEvent(new CustomEvent('remove-custom-shader', { detail: { type: type, name: name, shaderType: shaderType } }));
    }
}
if (window.customElements) {
    customElements.define('shader-editor', ShaderEditor);
}
function loadScripts(array, callback) {
    const loader = function (src, handler) {
        const script = createElement('script');
        script.src = src;
        script.onload = () => {
            script.onload = null;
            handler();
        };
        const head = document.getElementsByTagName('head')[0];
        (head || document.body).appendChild(script);
    };
    (function run() {
        if (array.length != 0) {
            loader(array.shift(), run);
        }
        else {
            callback && callback();
        }
    })();
}

create$4(); //TODO: use IDENTITY_VEC3
create$2();
const tempVec3$k = create$4();
const tempQuat$6 = create$2();
let mat$2 = create$5();
class ControlPoint extends Entity {
    isControlPoint = true;
    #parentControlPoint;
    currentWorldPosition = create$4();
    prevWorldPosition = create$4();
    deltaWorldPosition = create$4();
    currentWorldQuaternion = create$2();
    prevWorldQuaternion = create$2();
    currentWorldTransformation = create$5();
    prevWorldTransformation = create$5();
    deltaWorldTransformation = create$5();
    //TODO: keep these vectors ?
    // Forward vector
    fVector = create$4();
    // Up vector
    uVector = create$4();
    // Right vector
    rVector = create$4();
    parentModel;
    lastComputed = -1;
    snapshot;
    model;
    getWorldTransformation(mat = create$5()) {
        this.getWorldQuaternion(tempQuat$6);
        this.getWorldPosition(tempVec3$k);
        return fromRotationTranslation$1(mat, tempQuat$6, tempVec3$k);
    }
    getWorldQuaternion(q = create$2()) {
        if (this.#parentControlPoint) {
            this.#parentControlPoint.getWorldQuaternion(q);
            mul$2(q, q, this._quaternion);
        }
        else {
            super.getWorldQuaternion(q);
        }
        return q;
    }
    parentChanged(parent) {
        let parentModel = this.getParentModel();
        this.forEach(entity => {
            if (entity.isControlPoint) {
                entity.parentModel = parentModel;
            }
        });
    }
    set parentControlPoint(parentControlPoint) {
        this.#parentControlPoint = parentControlPoint;
    }
    get parentControlPoint() {
        return this.#parentControlPoint;
    }
    step() {
        if (this.lastComputed < new Graphics().currentTick) {
            this.lastComputed = new Graphics().currentTick;
            copy$4(this.prevWorldPosition, this.currentWorldPosition);
            copy$2(this.prevWorldQuaternion, this.currentWorldQuaternion);
            copy$5(this.prevWorldTransformation, this.currentWorldTransformation);
            this.#compute();
        }
    }
    resetDelta() {
        this.#compute();
        zero$4(this.deltaWorldPosition);
        identity$2(this.deltaWorldTransformation);
    }
    #compute() {
        super.getWorldPosition(this.currentWorldPosition);
        super.getWorldQuaternion(this.currentWorldQuaternion);
        fromRotationTranslation$1(this.currentWorldTransformation, this.currentWorldQuaternion, this.currentWorldPosition);
        // compute delta world position
        sub$2(this.deltaWorldPosition, this.currentWorldPosition, this.prevWorldPosition);
        // compute delta world transformation
        invert$3(mat$2, this.prevWorldTransformation);
        mul$5(this.deltaWorldTransformation, this.currentWorldTransformation, mat$2);
    }
    deltaPosFrom(other, out = create$4()) {
        return sub$2(out, other.currentWorldPosition, this.currentWorldPosition);
    }
    static async constructFromJSON(json) {
        return new ControlPoint();
    }
    static getEntityName() {
        return 'ControlPoint';
    }
}
registerEntity(ControlPoint);

let randomFloats;
const MAX_FLOATS = 4096;
function initRandomFloats() {
    randomFloats = new Array(MAX_FLOATS);
    for (let i = 0; i < MAX_FLOATS; i++) {
        randomFloats[i] = Math.random();
    }
}
function ParticleRandomFloat(id, offset) {
    if (!randomFloats) {
        initRandomFloats();
    }
    return randomFloats[(id + offset) % MAX_FLOATS];
}
function ParticleRandomVec3(vec, id, offset1, offset2, offset3) {
    if (!randomFloats) {
        initRandomFloats();
    }
    set$5(vec, randomFloats[(id + offset1) % MAX_FLOATS], randomFloats[(id + offset2) % MAX_FLOATS], randomFloats[(id + offset3) % MAX_FLOATS]);
    return vec;
}

var source_declare_particle = `
#pragma once

#include mat4_from_quat
#include rotation_matrix

#ifdef HARDWARE_PARTICLES
	uniform sampler2D uParticles;
	uniform float uMaxParticles;
	uniform float uVisibilityCameraDepthBias;//TODO: pack some uniforms
	uniform vec4 uOrientationControlPoint;

	#include source1_declare_particle_position
	#include vec3_transform_quat

	struct particle {
		vec3 center;
		vec4 color;
		float radius;
		float roll;
		float yaw;
		vec4 vecDelta;
		vec3 normal;
	};

	particle getParticle(int particleId) {
		particle result;
		vec4 renderScreenVelocityRotate;
		#ifdef WEBGL2
			result.center = texelFetch(uParticles, ivec2(0, particleId), 0).rgb;
			result.color = texelFetch(uParticles, ivec2(1, particleId), 0);
			vec4 rrya = texelFetch(uParticles, ivec2(2, particleId), 0);
			result.vecDelta = texelFetch(uParticles, ivec2(3, particleId), 0);
			result.normal = texelFetch(uParticles, ivec2(4, particleId), 0).rgb;
			renderScreenVelocityRotate = texelFetch(uParticles, ivec2(5, particleId), 0);
		#else
			float texelPos = float(particleId) / uMaxParticles;
			result.center = texture2D(uParticles, vec2(0.00, texelPos)).rgb;
			result.color = texture2D(uParticles, vec2(0.125, texelPos));
			vec4 rrya = texture2D(uParticles, vec2(0.25, texelPos));
			result.vecDelta = texture2D(uParticles, vec2(0.375, texelPos));
			result.normal = texture2D(uParticles, vec2(0.5, texelPos)).rgb;
			renderScreenVelocityRotate = texture2D(uParticles, vec2(0.625, texelPos));
		#endif

		result.color.a = clamp(result.color.a, 0., 1.);
		result.radius = rrya.r;

		if (renderScreenVelocityRotate.x == 0.0) {
			result.roll = rrya.b;
		} else {
			result.roll = atan(result.vecDelta.y, result.vecDelta.x) + renderScreenVelocityRotate.z - 1.57;
		}

		result.yaw = rrya.a;
		return result;
	}
#endif
`;

Includes['source_declare_particle'] = source_declare_particle;

const PROPERTY_ADDED = 'propertyadded';
const PROPERTY_CHANGED = 'propertychanged';
class TimelineObserver extends EventTarget {
    static #instance;
    constructor() {
        if (TimelineObserver.#instance) {
            return TimelineObserver.#instance;
        }
        super();
        TimelineObserver.#instance = this;
    }
    /*
        parentChanged(child: Entity, oldParent: Entity | null, newParent: Entity | null) {
            this.dispatchEvent(new CustomEvent(PARENT_CHANGED, { detail: { child: child, oldParent: oldParent, newParent: newParent } }));
        }

        childAdded(parent: Entity, child: Entity) {
            this.dispatchEvent(new CustomEvent(CHILD_ADDED, { detail: { child: child, parent: parent } }));
        }

        childRemoved(parent: Entity, child: Entity) {
            this.dispatchEvent(new CustomEvent(CHILD_REMOVED, { detail: { child: child, parent: parent } }));
        }

        entityDeleted(entity: Entity) {
            this.dispatchEvent(new CustomEvent(ENTITY_DELETED, { detail: { entity: entity } }));
        }
    */
    propertyAdded(element, propertyName, type, value) {
        this.dispatchEvent(new CustomEvent(PROPERTY_ADDED, { detail: { element: element, name: propertyName, type: type, value: value } }));
    }
    propertyChanged(element, propertyName, oldValue, newValue) {
        this.dispatchEvent(new CustomEvent(PROPERTY_CHANGED, { detail: { element: element, name: propertyName, value: newValue, oldValue: oldValue } }));
    }
}

var TimelinePropertyType;
(function (TimelinePropertyType) {
    TimelinePropertyType[TimelinePropertyType["Unknown"] = 0] = "Unknown";
    TimelinePropertyType[TimelinePropertyType["Int"] = 1] = "Int";
    TimelinePropertyType[TimelinePropertyType["Float"] = 2] = "Float";
    TimelinePropertyType[TimelinePropertyType["Time"] = 3] = "Time";
    TimelinePropertyType[TimelinePropertyType["String"] = 4] = "String";
    TimelinePropertyType[TimelinePropertyType["Bool"] = 5] = "Bool";
    TimelinePropertyType[TimelinePropertyType["Color"] = 6] = "Color";
})(TimelinePropertyType || (TimelinePropertyType = {}));
class TimelineProperty {
    #name;
    #type;
    #value;
    constructor(name, type, value) {
        this.#name = name;
        this.#type = type;
        this.#value = value;
    }
    setValue(value) {
        this.#value = value;
    }
    getValue() {
        return this.#value;
    }
}

/*
export interface TimelineElement {
    name: string;
    setParent(element: TimelineElement): void;
    getParent(element: TimelineElement): TimelineElement | null;
}
*/
var TimelineElementType;
(function (TimelineElementType) {
    TimelineElementType[TimelineElementType["None"] = 0] = "None";
    TimelineElementType[TimelineElementType["Timeline"] = 1] = "Timeline";
    TimelineElementType[TimelineElementType["Group"] = 2] = "Group";
    TimelineElementType[TimelineElementType["Channel"] = 3] = "Channel";
    TimelineElementType[TimelineElementType["Clip"] = 4] = "Clip";
    TimelineElementType[TimelineElementType["Marker"] = 5] = "Marker";
})(TimelineElementType || (TimelineElementType = {}));
class TimelineElement {
    #parent;
    #properties = new Map();
    type = TimelineElementType.None;
    /*#name: string;
    startTime: number = 0;
    endTime: number = Infinity;*/
    constructor(name) {
        this.addProperty('name', TimelinePropertyType.String, name);
    }
    setName(name) {
        this.setPropertyValue('name', name);
    }
    getName() {
        return this.getPropertyValue('name');
    }
    addProperty(name, type, value) {
        const property = new TimelineProperty(name, type, value);
        this.#properties.set(name, property);
        return property;
    }
    setPropertyValue(name, value) {
        const property = this.#properties.get(name);
        if (property) {
            const oldValue = property.getValue();
            property.setValue(value);
            new TimelineObserver().propertyChanged(this, name, oldValue, value);
        }
    }
    getPropertyValue(name) {
        return this.#properties.get(name)?.getValue();
    }
}

class TimelineGroup extends TimelineElement {
    type = TimelineElementType.Group;
    #childs = [];
    addChild(child) {
        this.#childs.push(child);
        return child;
    }
    getChilds() {
        return [...this.#childs];
    }
}

class Actor {
    name;
    channels = [];
    choreography;
    active = false;
    constructor(name) {
        this.name = name;
    }
    addChannel(channel) {
        this.channels.push(channel);
        channel.setActor(this);
    }
    setChoreography(choreography) {
        this.choreography = choreography;
    }
    getCharacter() {
        return this.choreography.actors2[0]; //fixme: variable
    }
    setActive(active) {
        this.active = active;
    }
    toString(indent) {
        indent = indent || '';
        const subindent = indent + '\t';
        let arr = [indent + 'Actor ' + this.name];
        for (let i = 0; i < this.channels.length; ++i) {
            arr.push(this.channels[i].toString(subindent));
        }
        return arr.join('\n');
    }
    step(previousTime, currentTime) {
        //TODOv2
        for (let i = 0; i < this.channels.length; ++i) {
            this.channels[i].step(previousTime, currentTime);
        }
    }
    toTimelineElement() {
        const actor = new TimelineGroup(this.name);
        for (const channel of this.channels) {
            actor.addChild(channel.toTimelineElement());
        }
        return actor;
    }
}

class TimelineChannel extends TimelineElement {
    type = TimelineElementType.Channel;
    #clips = new Set;
    constructor(name = 'Channel') {
        super(name);
    }
    addClip(clip) {
        this.#clips.add(clip);
        return clip;
    }
    getClips() {
        return [...this.#clips];
    }
}

class Channel {
    active = false;
    events = [];
    name;
    actor;
    constructor(name) {
        this.name = name;
    }
    /**
     * Add an event
     * @param {Object ChoreographyEvent} event The event to add
     */
    addEvent(event) {
        this.events.push(event);
        event.setChannel(this);
    }
    /**
     * TODO
     */
    setActor(actor) {
        this.actor = actor;
    }
    /**
     * TODO
     */
    getActor() {
        return this.actor;
    }
    /**
     * Set active
     * @param {Bool} active active
     */
    setActive(active) {
        this.active = active;
    }
    /**
     * toString
     */
    toString(indent) {
        indent = indent || '';
        const subindent = indent + '\t';
        let arr = [indent + 'Channel ' + this.name];
        for (let i = 0; i < this.events.length; ++i) {
            arr.push(this.events[i].toString(subindent));
        }
        if (!this.active) {
            arr.push(indent + 'active 0');
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(previousTime, currentTime) {
        //TODOv2
        for (let i = 0; i < this.events.length; ++i) {
            this.events[i].step(previousTime, currentTime);
        }
    }
    toTimelineElement() {
        const channel = new TimelineChannel(this.name);
        for (const event of this.events) {
            channel.addClip(event.toTimelineElement());
        }
        return channel;
    }
}

class Timeline extends TimelineElement {
    type = TimelineElementType.Timeline;
    name = '';
    #root = new TimelineGroup('');
    constructor(name = 'Timeline') {
        super(name);
    }
    setParent(element) {
        return;
    }
    getRoot() {
        return this.#root;
    }
    addChild(child) {
        return this.#root.addChild(child);
    }
    getChilds() {
        return this.#root.getChilds();
    }
}

class Choreography {
    #repository;
    actors2 = [];
    #events = [];
    #actors = [];
    previousTime = -1;
    currentTime = 0;
    animsSpeed = 1;
    shouldLoop = false;
    sceneLength;
    onStop;
    constructor(repository, name) {
        this.#repository = repository;
    }
    getRepository() {
        return this.#repository;
    }
    /**
     * Add an event
     * @param {Object ChoreographyEvent} event The event to add
     */
    addEvent(event) {
        this.#events.push(event);
        event.setChoreography(this);
    }
    /**
     * Add an actor
     * @param {Object ChoreographyActor} actor The actor to add
     */
    addActor(actor) {
        this.#actors.push(actor);
        actor.setChoreography(this);
    }
    /**
     * toString
     */
    toString(indent = '') {
        let arr = [];
        for (let i = 0; i < this.#events.length; ++i) {
            arr.push(this.#events[i].toString(indent));
        }
        for (let i = 0; i < this.#actors.length; ++i) {
            arr.push(this.#actors[i].toString(indent));
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(delta) {
        if (this.animsSpeed > 0) {
            const currentTime = this.previousTime == -1 ? 0 : this.previousTime + delta * this.animsSpeed;
            if (this.previousTime != -0.5) {
                this.currentTime = currentTime;
            }
            for (let i = 0; i < this.#events.length; ++i) {
                this.#events[i].step(this.previousTime, this.currentTime);
            }
            for (let i = 0; i < this.#actors.length; ++i) {
                this.#actors[i].step(this.previousTime, this.currentTime);
            }
            if (this.shouldLoop) {
                this.shouldLoop = false;
                return true;
            }
            this.previousTime = this.currentTime;
            if (currentTime > this.sceneLength) {
                this.stop();
                return false;
            }
        }
        return true;
    }
    /**
     * Reset
     */
    reset() {
        this.previousTime = -1;
        this.currentTime = 0;
    }
    /**
     * Stop
     */
    stop() {
        if (this.onStop) {
            this.onStop();
        }
    }
    /**
     * Step
     */
    loop(startTime) {
        this.previousTime = startTime - EPSILON$2;
        this.currentTime = startTime;
        this.shouldLoop = true;
    }
    /**
     * Step
     */
    setActors(actors) {
        this.actors2 = actors;
    }
    toTimelineElement() {
        const timeline = new Timeline();
        const events = timeline.addChild(new TimelineGroup('Events'));
        timeline.addChild(new TimelineGroup('Actors'));
        for (const event of this.#events) {
            events.addChild(event.toTimelineElement());
        }
        for (const actor of this.#actors) {
            events.addChild(actor.toTimelineElement());
        }
        /*
        for (let i = 0; i < this.#actors.length; ++i) {
            arr.push(this.#actors[i].toString(indent));
        }
            */
        return timeline;
    }
}

class CurveData {
    ramp = [];
    /**
     * Add a sample TODO
     * @param {Object ChoreographyEvent} event The event to add
     * @return {Object Choreography} The requested choreography or null
     */
    add(time, value, selected) {
        this.ramp.push({ time: time, value: value, selected: selected });
    }
    getValue(time) {
        let previous = null;
        for (let current of this.ramp) {
            if (time <= current.time) {
                if (previous) {
                    return RemapValClamped(time, previous.time, current.time, previous.value, current.value);
                }
                else {
                    return current.value;
                }
            }
            previous = current;
        }
    }
    /**
     * toString
     */
    toString(indent) {
        if (!this.ramp.length) {
            return '';
        }
        indent = indent || '';
        const subindent = indent + '\t';
        let arr = [indent + 'event_ramp'];
        for (let i = 0; i < this.ramp.length; ++i) {
            let rampData = this.ramp[i];
            arr.push(subindent + rampData.time + ' ' + rampData.value);
        }
        return arr.join('\n');
    }
}

class ExpressionSample {
    v = 0.0;
    t = 0.0;
    s = 0;
    c = 0;
    selected = false;
    setCurveType(curveType) {
        this.c = curveType;
    }
    /**
     * toString
     */
    toString(indent = '') {
        return indent + this.t + ' ' + this.v;
    }
}

class FlexAnimationTrack {
    event;
    flags = 0;
    samples = [[], []];
    controllerName;
    min = 0;
    max = 0;
    constructor(event) {
        this.event = event;
    }
    setFlexControllerName(controllerName) {
        this.controllerName = controllerName;
    }
    setFlags(flags) {
        this.flags = flags;
    }
    setMin(min) {
        this.min = min;
    }
    setMax(max) {
        this.max = max;
    }
    isTrackActive() {
        return (this.flags & (1 << 0)) ? true : false;
    }
    isComboType() {
        return (this.flags & (1 << 1)) ? true : false;
    }
    addSample(time, value, type) {
        const sample = new ExpressionSample();
        sample.t = time;
        sample.v = value;
        sample.selected = false;
        this.samples[type].push(sample);
        return sample;
    }
    toString(indent) {
        indent = indent || '';
        const subindent = indent + '\t';
        let arr = [indent + this.controllerName];
        for (let sampleType = 0; sampleType < 2; ++sampleType) {
            const samples = this.samples[sampleType];
            for (let i = 0; i < samples.length; ++i) {
                let sample = samples[i];
                arr.push(subindent + sample.toString());
            }
        }
        return arr.join('\n');
    }
}

class Sound {
    #repository;
    #wave;
    #channel;
    constructor(repository, wave, channel) {
        this.#repository = repository;
        this.#wave = wave;
        this.#channel = channel;
    }
    getRepository() {
        return this.#repository;
    }
    getWave() {
        if (Array.isArray(this.#wave)) {
            const index = Math.floor(Math.random() * this.#wave.length);
            return this.#wave[index];
        }
        else {
            return this.#wave;
        }
    }
    getChannel() {
        return this.#channel;
    }
}

class KvAttribute {
    name;
    value;
    constructor(name, value) {
        if (!name) {
            return;
        }
        this.name = name.toLowerCase();
        this.value = value;
    }
}
class KvElement {
    addElement(name, value) {
        if (!name) {
            return;
        }
        name = name.toLowerCase();
        let newName = name;
        let count = 1;
        while (this[newName]) {
            newName = name + '#' + (++count);
        }
        this[newName] = value;
    }
    toString(linePrefix) {
        linePrefix = linePrefix || '';
        let s = [linePrefix, '"' /*, this.type, '"\n'*/, linePrefix, '{\n'];
        for (let i in this) {
            s.push(this.toString(linePrefix + '\t'));
        }
        s.push(linePrefix);
        s.push('}\n');
        return s.join('');
    }
}
class KvReader {
    root = undefined;
    rootElements = {};
    rootId = 0;
    carSize;
    src;
    offset;
    inQuote = false;
    inComment = false;
    currentAttribute;
    currentElement;
    currentArray;
    name;
    currentValue;
    elementStack;
    attributeStack;
    valuesStack;
    keyStack;
    arrayStack;
    rootElement;
    rootName;
    currentKey;
    constructor(carSize = 1) {
        this.carSize = carSize;
    }
    readText(src) {
        if (!src) {
            return;
        }
        this.src = src;
        let start = src.indexOf('-->');
        if (start > 0) {
            start += 5; //-->/nx
        }
        else {
            start = 0;
        }
        this.offset = start;
        this.inQuote = false;
        this.inComment = false;
        this.currentAttribute = undefined;
        this.currentElement = undefined;
        this.currentArray = undefined;
        this.name = undefined;
        this.currentValue = '';
        this.elementStack = [];
        this.attributeStack = [];
        this.valuesStack = [];
        this.keyStack = [];
        this.arrayStack = [];
        let end = false;
        do {
            end = this.parse();
        } while (!end);
        this.endElement();
    }
    getRootElement() {
        return this.rootElement;
    }
    getRootName() {
        return this.rootName;
    }
    readChar() {
        if (this.offset > this.src.length) {
            return -1;
        }
        const offset = this.offset;
        this.offset += this.carSize;
        return this.src.charAt(offset);
    }
    pickChar() {
        if (this.offset > this.src.length) {
            return -1;
        }
        return this.src.charAt(this.offset);
    }
    pushElement() {
        if (this.currentElement) {
            this.elementStack.push(this.currentElement);
        }
        if (!this.rootElement) ;
        this.currentElement = new KvElement( /*this.popValue()*/);
        this.currentKey = this.popValue();
        this.pushKey();
    }
    popElement() {
        let a = this.currentElement;
        this.currentElement = this.elementStack.pop();
        if (!this.currentElement) {
            //this.rootElements.push(a);
            let rootName = this.popKey();
            if (rootName == undefined) {
                rootName = 'undefined' + (this.rootId++);
            }
            this.rootElements[rootName] = a;
            if (!this.rootElement) {
                this.rootName = rootName;
                this.rootElement = a;
            }
        }
    }
    pushAttribute() {
        if (this.currentAttribute) {
            this.attributeStack.push(this.currentAttribute);
        }
        //this.currentAttribute = new KvElement();
    }
    popAttribute() {
        this.currentAttribute = this.attributeStack.pop();
    }
    pushValue() {
        this.valuesStack.push(this.currentValue);
        this.currentValue = '';
    }
    popValue() {
        if (this.valuesStack.length == 0) ;
        return this.valuesStack.pop();
    }
    pushKey() {
        this.keyStack.push(this.currentKey);
        this.currentKey = '';
    }
    popKey() {
        if (this.keyStack.length == 0) ;
        return this.keyStack.pop();
    }
    pushArray() {
        this.arrayStack.push(this.currentArray);
        this.currentArray = undefined;
    }
    popArray() {
        this.currentArray = this.arrayStack.pop();
    }
    parse() {
        const car = this.readChar();
        if (car == -1)
            return true;
        if (this.inComment && (car != '\r' && car != '\n')) {
            return false;
        }
        this.inComment = false;
        if (this.inQuote && car != '"' && car != '\r' && car != '\n') {
            this.currentValue += car;
        }
        else {
            switch (car) {
                case '\\':
                    if (this.inQuote) {
                        const car2 = this.pickChar();
                        if (car2 == '\"') {
                            this.currentValue += car2;
                        }
                        else {
                            this.currentValue += car;
                        }
                    }
                    else {
                        this.currentValue += car;
                    }
                    break;
                case '/':
                    const car2 = this.pickChar();
                    if (car2 == '/') {
                        this.inComment = true;
                    }
                    else {
                        this.currentValue += car;
                    }
                    break;
                case ' ':
                case '\t':
                    if (this.currentValue != '') {
                        this.setValue();
                    }
                    if (this.valuesStack.length >= 2) {
                        this.newLine();
                        //if (!this.multipleValuesOnSameLine) {//TODOV2
                        this.inComment = true;
                        //}
                    }
                    break;
                case '\r':
                case '\n':
                    if (!this.inQuote && this.currentValue != '')
                        this.setValue();
                    this.newLine();
                    break;
                case '"':
                    if (this.inQuote)
                        this.setValue();
                    this.inQuote = !this.inQuote;
                    break;
                case '{':
                    if (this.currentValue != '') {
                        this.setValue();
                    }
                    this.startElement();
                    break;
                case '}':
                    this.endElement();
                    break;
                case '[':
                    this.startArray();
                    break;
                case ']':
                    this.endArray();
                    break;
                case ',':
                    this.comma();
                    //this.nextArrayValue()
                    break;
                default:
                    this.currentValue += car;
                    break;
            }
        }
        return false;
    }
    startElement() {
        this.pushElement();
        this.newLine();
        this.pushAttribute();
    }
    endElement() {
        if (this.currentElement) {
            const e = this.currentElement;
            this.popElement();
            if (this.currentElement) {
                this.currentElement.addElement(this.popKey(), e);
            }
        }
    }
    startArray() {
        this.pushArray();
        this.currentValue = [];
        this.currentArray = this.currentValue;
        this.pushValue();
        this.newLine();
        this.pushAttribute();
    }
    endArray() {
        this.popAttribute();
        //this.currentAttribute.value.push(this.currentElement);
        this.popArray();
    }
    nextArrayValue() {
        //TODO
    }
    setValue() {
        this.pushValue();
    }
    newLine() {
        if (this.valuesStack.length >= 2) {
            // order matters
            const value = this.popValue();
            const name = this.popValue();
            const newAttribute = new KvAttribute(name, value);
            if (this.currentElement) {
                this.currentElement.addElement(name, value);
            }
            else if (this.currentArray) {
                this.currentArray.push(newAttribute);
            }
            this.currentAttribute = newAttribute;
        }
    }
    comma() {
        if (this.valuesStack.length >= 1) {
            // order matters
            const value = this.popValue();
            const name = this.popValue();
            const newAttribute = new KvAttribute(name, value);
            if (this.currentArray) {
                this.currentArray.push(newAttribute);
            }
            else if (this.currentElement) {
                this.currentElement.addAttribute(newAttribute);
            }
            this.currentAttribute = newAttribute;
        }
    }
}

class Source1SoundManager {
    static #mute = false;
    static #audioList = new Map();
    static #soundList = {};
    static #soundsPerRepository = new Map();
    static #soundListPerRepository = {};
    static #manifestsPerRepository = new Map();
    static #promisePerRepository = new Map();
    /**
     * Play a sound
     * @param {String} soundName soundName
     */
    static async playSound(repositoryName, soundName) {
        if (this.#mute) {
            return;
        }
        const sound = await this.#getSound(repositoryName, soundName);
        //const sound = this.#soundList[soundName];
        if (sound) {
            let wave = sound.getWave();
            // Remove #, *, ( and ) from paths
            wave = wave.replace(/[\(\)\#\*]/g, '').toLowerCase();
            let audio = this.#audioList.get(wave);
            //audio = null;//removeme
            if (!audio) {
                const response = await new Repositories().getFileAsBlob(sound.getRepository(), '/sound/' + wave);
                if (!response.error) {
                    audio = new Audio(URL.createObjectURL(response.blob) /*new URL('/sound/' + wave, repository.base).toString()*/);
                    this.#audioList.set(wave, audio);
                    audio.volume = 0.1;
                    //audio.play();
                    AudioMixer.playAudio('master', audio); //TODO: change master per actual channel
                }
            }
            else {
                AudioMixer.playAudio('master', audio);
            }
            return audio;
        }
    }
    static async #getSound(repositoryName, soundName) {
        await this.#fetchManifests(repositoryName);
        /*const repo = this.#soundsPerRepository[repositoryName];
        if (repo) {
            return repo[soundName];
        }*/
        return this.#soundsPerRepository.get(repositoryName)?.get(soundName);
    }
    static async #fetchManifests(repositoryName) {
        if (this.#promisePerRepository.has(repositoryName)) {
            await this.#promisePerRepository.get(repositoryName);
        }
        if (!this.#soundsPerRepository.has(repositoryName)) {
            this.#soundsPerRepository.set(repositoryName, new Map());
        }
        let promiseResolve;
        this.#promisePerRepository.set(repositoryName, new Promise(resolve => promiseResolve = resolve));
        let manifests = this.#manifestsPerRepository.get(repositoryName);
        if (manifests) {
            this.#manifestsPerRepository.delete(repositoryName);
            for (const manifest of manifests) {
                await this.#fetchManifest(repositoryName, manifest);
            }
        }
        promiseResolve(true);
    }
    static async #fetchManifest(repositoryName, manifestPath) {
        const response = await new Repositories().getFileAsText(repositoryName, manifestPath);
        if (!response.error) {
            this.#loadManifest(repositoryName, response.text);
        }
    }
    static #loadManifest(repositoryName, manifestTxt) {
        const sounds = this.#soundsPerRepository.get(repositoryName);
        const kv = new KvReader();
        kv.readText(manifestTxt);
        const list = kv.rootElements;
        const keyArray = Object.keys(list);
        for (let i = 0; i < keyArray.length; ++i) {
            const soundKey = keyArray[i];
            const sound = list[soundKey] /*TODO: improve type*/;
            let wave;
            if (sound.rndwave) {
                wave = [];
                Object.keys(sound.rndwave).forEach(function (element) {
                    wave.push(sound.rndwave[element]);
                });
            }
            else {
                wave = sound.wave;
            }
            //const wave = sound.rndwave ? sound.rndwave : sound.wave;
            const s = new Sound(repositoryName, wave, sound.channel);
            sounds?.set(soundKey, s);
        }
    }
    /**
     * Load soundManifest
     */
    /*

        static loadManifest(repositoryName, fileName) {
            const callback =
                async (response) => {
                    if (!response.ok) {
                        return;
                    }
                    let arg1 = await response.text();
                    if (arg1) {
                        const kv = new KvReader();
                        kv.readText(arg1);
                        const list = kv.rootElements//['Demoman.Death'];
                        const keyArray = Object.keys(list);
                        for (let i = 0; i < keyArray.length; ++i) {
                            const soundKey = keyArray[i];
                            const sound = list[soundKey];
                            let wave;
                            if (sound.rndwave) {
                                wave = [];
                                Object.keys(sound.rndwave).forEach(function(element) {
                                    wave.push(sound.rndwave[element]);
                                });
                            } else {
                                wave = sound.wave;
                            }
                            //const wave = sound.rndwave ? sound.rndwave : sound.wave;
                            this.#soundList[soundKey] = new Sound(wave);
                            this.#soundList[soundKey].repositoryName = repositoryName;
                            this.#soundList[soundKey].channel = sound.channel;
                        }
                    }
                    this.#initialisationPhase = 2;//TODO: per file
                }
            const ajaxReject =
                function(value) {
                    //TODO: ????
                };


            const repository = new Repositories().getRepository(repositoryName);
            if (!repository) {
                console.error(`Unknown repository ${repositoryName} in Source1SoundManager.loadManifest`);
                return null;
            }

            customFetch(new URL(fileName, repository.base)).then(callback, ajaxReject);
        }
        */
    static loadManifest(repositoryName, fileName) {
        let manifests = this.#manifestsPerRepository.get(repositoryName);
        if (!manifests) {
            manifests = [];
            this.#manifestsPerRepository.set(repositoryName, manifests);
        }
        manifests.push(fileName);
    }
    static mute() {
        this.#mute = true;
    }
    static unmute() {
        this.#mute = false;
    }
}

class TimelineClip extends TimelineElement {
    type = TimelineElementType.Clip;
    constructor(name = 'Clip', startTime = 0, endTime = Infinity) {
        super(name);
        this.addProperty('start', TimelinePropertyType.Time, startTime);
        this.addProperty('end', TimelinePropertyType.Time, endTime);
    }
    setStartTime(start) {
        this.setPropertyValue('start', start);
    }
    getStartTime() {
        return this.getPropertyValue('start');
    }
    setEndTime(end) {
        this.setPropertyValue('end', end);
    }
    getEndTime() {
        return this.getPropertyValue('end');
    }
    getLength() {
        return this.getPropertyValue('end') - this.getPropertyValue('start');
    }
}

let Event$1 = class Event {
    #repository;
    type;
    name;
    startTime;
    endTime;
    param1;
    param2;
    param3;
    flags;
    distanceToTarget = 0;
    flexAnimTracks = {};
    ramp;
    ccType;
    ccToken;
    choreography;
    channel;
    m_nNumLoops;
    constructor(repository, eventType, name, startTime, endTime, param1, param2, param3, flags, distanceToTarget) {
        this.#repository = repository;
        this.type = eventType;
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
        this.param1 = param1;
        this.param2 = param2;
        this.param3 = param3;
        this.flags = flags;
        this.distanceToTarget = distanceToTarget;
    }
    getRepository() {
        return this.#repository;
    }
    /**
     * Get the startTime
     * @return {Number} startTime
     */
    getStartTime() {
        return this.startTime;
    }
    /**
     * Get the endTime
     * @return {Number} endTime
     */
    getEndTime() {
        return this.endTime;
    }
    /**
     * Get the type
     * @return {Number} The loaded file
     */
    getType() {
        return this.type;
    }
    /**
     * Set the ramp
     * @param {Object CurveData} ramp The ramp to set
     */
    setRamp(ramp) {
        this.ramp = ramp;
    }
    /**
     * TODO
     */
    setCloseCaptionType(ccType) {
        this.ccType = ccType;
    }
    /**
     * TODO
     */
    setCloseCaptionToken(token) {
        this.ccToken = token;
    }
    /**
     * TODO
     */
    setChoreography(choreography) {
        this.choreography = choreography;
    }
    /**
     * TODO
     */
    setChannel(channel) {
        this.channel = channel;
    }
    //TODO
    AddRelativeTag() {
        console.error('TODO');
    }
    //TODO
    addRelativeTag() {
        console.error('TODO');
    }
    //TODO
    addTimingTag() {
        console.error('TODO');
    }
    //TODO
    addAbsoluteTag() {
        console.error('TODO');
    }
    /**
     * TODO
     */
    isResumeCondition() {
        return (this.flags & (1 << 0)) ? true : false;
    }
    /**
     * TODO
     */
    isLockBodyFacing() {
        return (this.flags & (1 << 1)) ? true : false;
    }
    /**
     * TODO
     */
    isFixedLength() {
        return (this.flags & (1 << 2)) ? true : false;
    }
    /**
     * TODO
     */
    isActive() {
        return (this.flags & (1 << 3)) ? true : false;
    }
    /**
     * TODO
     */
    getForceShortMovement() {
        return (this.flags & (1 << 4)) ? true : false;
    }
    /**
     * TODO
     */
    getPlayOverScript() {
        return (this.flags & (1 << 5)) ? true : false;
    }
    /**
     * TODO
     * Add a flex animation track
     */
    addTrack(controllerName) {
        let track = new FlexAnimationTrack(this);
        track.setFlexControllerName(controllerName);
        this.flexAnimTracks[controllerName] = track;
        return track;
    }
    /**
     * toString
     */
    toString(indent) {
        indent = indent || '';
        const subindent = indent + '\t';
        let arr = [];
        arr.push(indent + 'Event ' + EventType[this.type] + ' ' + this.name);
        arr.push(subindent + 'time ' + this.startTime + ' ' + this.endTime);
        if (this.param1) {
            arr.push(subindent + 'param1 ' + this.param1);
        }
        if (this.param2) {
            arr.push(subindent + 'param2 ' + this.param2);
        }
        if (this.param3) {
            arr.push(subindent + 'param3 ' + this.param3);
        }
        if (this.ramp) {
            arr.push(this.ramp.toString(subindent));
        }
        if (this.getType() == EventType.Flexanimation) {
            arr.push(subindent + 'flexanimations');
        }
        for (let i in this.flexAnimTracks) {
            arr.push(this.flexAnimTracks[i].toString(subindent + '\t'));
        }
        if (this.getType() == EventType.Speak) {
            arr.push(subindent + 'cctype ' + CloseCaptionType[this.ccType]);
            arr.push(subindent + 'cctoken ' + this.ccToken);
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(previousTime, currentTime) {
        let actor = this.getActor();
        if (actor) {
            actor.frame = currentTime;
        }
        //TODOv2
        if (previousTime < this.startTime && currentTime >= this.startTime) {
            //console.info(frame2, currentTime, this.type, this.param1, this.param2, this.param3);
            switch (this.type) {
                case EventType.Speak:
                    Source1SoundManager.playSound(this.#repository, this.param1);
                    break;
                case EventType.Sequence:
                    //mainCharacter.characterModel.playSequence(this.param1);//TODOv2
                    if (actor) {
                        actor.playSequence(this.param1); //TODOv2
                        //actor.frame = currentTime;
                        /*if (actor.characterModel) {
                            actor.playSequence(this.param1);//TODOv2
                        }
                        if (actor.sourceModel) {
                            actor.playSequence(this.param1);//TODOv2
                        }*/
                    }
                    //frame2 = currentTime;
                    break;
                case EventType.Loop:
                    //TODO: loop count
                    if (this.choreography) {
                        this.choreography.loop(this.param1 * 1.0);
                        //frame2 = this.param1 * 1.0;
                    }
                    break;
            }
            return;
        }
        if (previousTime < this.endTime && currentTime >= this.endTime) {
            //console.info(frame2, currentTime, this.type, this.param1, this.param2, this.param3);
            switch (this.type) {
                case EventType.Sequence:
                    const actor = this.getActor();
                    if (actor) {
                        if (actor.characterModel) {
                            actor.characterModel.playSequence('stand_secondary'); //TODOv2
                        }
                    }
                    //frame2 = currentTime;
                    break;
            }
        }
        if (currentTime >= this.startTime && currentTime <= this.endTime) {
            switch (this.type) {
                /*case EventType.Expression:
                    let actor = this.getActor();
                    if (actor) {
                        let flexParameters = {};
                        flexParameters[this.param2.toLowerCase()] = this.ramp.getValue(currentTime);
                        actor.setFlexes(flexParameters);
                    }
                    break;*/
            }
        }
    }
    /**
     * TODO
     */
    getActor() {
        const channel = this.channel;
        if (channel) {
            const actor = channel.getActor();
            if (actor) {
                return actor.getCharacter();
            }
        }
    }
    toTimelineElement() {
        const clip = new TimelineClip(this.name, this.startTime, this.endTime);
        return clip;
    }
};
var EventType;
(function (EventType) {
    EventType[EventType["Unspecified"] = 0] = "Unspecified";
    EventType[EventType["Section"] = 1] = "Section";
    EventType[EventType["Expression"] = 2] = "Expression";
    EventType[EventType["LookAt"] = 3] = "LookAt";
    EventType[EventType["MoveTo"] = 4] = "MoveTo";
    EventType[EventType["Speak"] = 5] = "Speak";
    EventType[EventType["Gesture"] = 6] = "Gesture";
    EventType[EventType["Sequence"] = 7] = "Sequence";
    EventType[EventType["Face"] = 8] = "Face";
    EventType[EventType["FireTrigger"] = 9] = "FireTrigger";
    EventType[EventType["Flexanimation"] = 10] = "Flexanimation";
    EventType[EventType["SubScene"] = 11] = "SubScene";
    EventType[EventType["Loop"] = 12] = "Loop";
    EventType[EventType["Interrupt"] = 13] = "Interrupt";
    EventType[EventType["StopPoint"] = 14] = "StopPoint";
    EventType[EventType["PermitResponses"] = 15] = "PermitResponses";
    EventType[EventType["Generic"] = 16] = "Generic";
})(EventType || (EventType = {}));
//TODO: setup const
/*
Event.EventType = {
    UNSPECIFIED: 0,
    SECTION: 1,
    EXPRESSION: 2,
    LOOKAT: 3,
    MOVETO: 4,
    SPEAK: 5,
    GESTURE: 6,
    SEQUENCE: 7,
    FACE: 8,
    FIRETRIGGER: 9,
    FLEXANIMATION: 10,
    SUBSCENE: 11,
    LOOP: 12,
    INTERRUPT: 13,
    STOPPOINT: 14,
    PERMIT_RESPONSES: 15,
    GENERIC: 16
}
Event.EventTypeString = ['UNSPECIFIED', 'SECTION', 'EXPRESSION', 'LOOKAT', 'MOVETO', 'SPEAK', 'GESTURE', 'SEQUENCE', 'FACE', 'FIRETRIGGER', 'FLEXANIMATION', 'SUBSCENE', 'LOOP', 'INTERRUPT', 'STOPPOINT', 'PERMIT_RESPONSES', 'GENERIC']
*/
var TimeType;
(function (TimeType) {
    TimeType[TimeType["Default"] = 0] = "Default";
    TimeType[TimeType["Simulation"] = 1] = "Simulation";
    TimeType[TimeType["Display"] = 2] = "Display";
})(TimeType || (TimeType = {}));
/*
Event.TimeType = {
    DEFAULT: 0,
    SIMULATION: 1,
    DISPLAY: 2
}
Event.TimeTypeString = ['DEFAULT', 'SIMULATION', 'DISPLAY'];
*/
var CloseCaptionType;
(function (CloseCaptionType) {
    CloseCaptionType[CloseCaptionType["Master"] = 0] = "Master";
    CloseCaptionType[CloseCaptionType["Slave"] = 1] = "Slave";
    CloseCaptionType[CloseCaptionType["Disabled"] = 2] = "Disabled";
})(CloseCaptionType || (CloseCaptionType = {}));
/*
Event.CloseCaptionType = {
    CC_MASTER: 0,
    CC_SLAVE: 1,
    CC_DISABLED: 2
}
Event.CloseCaptionTypeString = ['CC_MASTER', 'CC_SLAVE', 'CC_DISABLED'];
*/

/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/*
References:
- "LZMA SDK" by Igor Pavlov
    http://www.7-zip.org/sdk.html
- "The .lzma File Format" from xz documentation
    https://github.com/joachimmetz/xz/blob/master/doc/lzma-file-format.txt
*/
class OutWindow {
    #windowSize = 0;
    #buffer;
    #pos;
    #streamPos;
    #stream;
    create(windowSize) {
        if ((!this.#buffer) || (this.#windowSize !== windowSize)) {
            // using a typed array here gives a big boost on Firefox
            // not much change in chrome (but more memory efficient)
            this.#buffer = new Uint8Array(windowSize);
        }
        this.#windowSize = windowSize;
        this.#pos = 0;
        this.#streamPos = 0;
    }
    flush() {
        var size = this.#pos - this.#streamPos;
        if (size !== 0) {
            if (this.#stream.writeBytes) {
                this.#stream.writeBytes(this.#buffer, size);
            }
            else {
                for (var i = 0; i < size; i++) {
                    this.#stream.writeByte(this.#buffer[i]);
                }
            }
            if (this.#pos >= this.#windowSize) {
                this.#pos = 0;
            }
            this.#streamPos = this.#pos;
        }
    }
    releaseStream() {
        this.flush();
        this.#stream = null;
    }
    setStream(stream) {
        this.releaseStream();
        this.#stream = stream;
    }
    init(solid) {
        if (!solid) {
            this.#streamPos = 0;
            this.#pos = 0;
        }
    }
    copyBlock(distance, len) {
        var pos = this.#pos - distance - 1;
        if (pos < 0) {
            pos += this.#windowSize;
        }
        while (len--) {
            if (pos >= this.#windowSize) {
                pos = 0;
            }
            this.#buffer[this.#pos++] = this.#buffer[pos++];
            if (this.#pos >= this.#windowSize) {
                this.flush();
            }
        }
    }
    putByte(b) {
        this.#buffer[this.#pos++] = b;
        if (this.#pos >= this.#windowSize) {
            this.flush();
        }
    }
    getByte(distance) {
        var pos = this.#pos - distance - 1;
        if (pos < 0) {
            pos += this.#windowSize;
        }
        return this.#buffer[pos];
    }
}
class RangeDecoder {
    #stream;
    #code;
    #range;
    setStream(stream) {
        this.#stream = stream;
    }
    releaseStream() {
        this.#stream = null;
    }
    init() {
        var i = 5;
        this.#code = 0;
        this.#range = -1;
        while (i--) {
            this.#code = (this.#code << 8) | this.#stream.readByte();
        }
    }
    decodeDirectBits(numTotalBits) {
        var result = 0, i = numTotalBits, t;
        while (i--) {
            this.#range >>>= 1;
            t = (this.#code - this.#range) >>> 31;
            this.#code -= this.#range & (t - 1);
            result = (result << 1) | (1 - t);
            if ((this.#range & 0xff000000) === 0) {
                this.#code = (this.#code << 8) | this.#stream.readByte();
                this.#range <<= 8;
            }
        }
        return result;
    }
    decodeBit(probs, index) {
        var prob = probs[index], newBound = (this.#range >>> 11) * prob;
        if ((this.#code ^ 0x80000000) < (newBound ^ 0x80000000)) {
            this.#range = newBound;
            probs[index] += (2048 - prob) >>> 5;
            if ((this.#range & 0xff000000) === 0) {
                this.#code = (this.#code << 8) | this.#stream.readByte();
                this.#range <<= 8;
            }
            return 0;
        }
        this.#range -= newBound;
        this.#code -= newBound;
        probs[index] -= prob >>> 5;
        if ((this.#range & 0xff000000) === 0) {
            this.#code = (this.#code << 8) | this.#stream.readByte();
            this.#range <<= 8;
        }
        return 1;
    }
}
class LZMA {
    static initBitModels(probs, len) {
        while (len--) {
            probs[len] = 1024;
        }
    }
    static reverseDecode2(models, startIndex, rangeDecoder, numBitLevels) {
        var m = 1, symbol = 0, i = 0, bit;
        for (; i < numBitLevels; ++i) {
            bit = rangeDecoder.decodeBit(models, startIndex + m);
            m = (m << 1) | bit;
            symbol |= bit << i;
        }
        return symbol;
    }
    static decompress(properties, inStream, outStream, outSize) {
        var decoder = new Decoder();
        if (!decoder.setDecoderProperties(properties)) {
            throw Error("Incorrect lzma stream properties");
        }
        if (!decoder.decodeBody(inStream, outStream, outSize)) {
            throw Error("Error in lzma data stream");
        }
        return outStream;
    }
}
class BitTreeDecoder {
    #models = [];
    #numBitLevels;
    constructor(numBitLevels) {
        this.#numBitLevels = numBitLevels;
    }
    init() {
        LZMA.initBitModels(this.#models, 1 << this.#numBitLevels);
    }
    decode(rangeDecoder) {
        var m = 1, i = this.#numBitLevels;
        while (i--) {
            m = (m << 1) | rangeDecoder.decodeBit(this.#models, m);
        }
        return m - (1 << this.#numBitLevels);
    }
    reverseDecode(rangeDecoder) {
        var m = 1, symbol = 0, i = 0, bit;
        for (; i < this.#numBitLevels; ++i) {
            bit = rangeDecoder.decodeBit(this.#models, m);
            m = (m << 1) | bit;
            symbol |= bit << i;
        }
        return symbol;
    }
}
class LenDecoder {
    #choice = [];
    #lowCoder = [];
    #midCoder = [];
    #highCoder = new BitTreeDecoder(8);
    #numPosStates = 0;
    create(numPosStates) {
        for (; this.#numPosStates < numPosStates; ++this.#numPosStates) {
            this.#lowCoder[this.#numPosStates] = new BitTreeDecoder(3);
            this.#midCoder[this.#numPosStates] = new BitTreeDecoder(3);
        }
    }
    init() {
        var i = this.#numPosStates;
        LZMA.initBitModels(this.#choice, 2);
        while (i--) {
            this.#lowCoder[i].init();
            this.#midCoder[i].init();
        }
        this.#highCoder.init();
    }
    decode(rangeDecoder, posState) {
        if (rangeDecoder.decodeBit(this.#choice, 0) === 0) {
            return this.#lowCoder[posState].decode(rangeDecoder);
        }
        if (rangeDecoder.decodeBit(this.#choice, 1) === 0) {
            return 8 + this.#midCoder[posState].decode(rangeDecoder);
        }
        return 16 + this.#highCoder.decode(rangeDecoder);
    }
}
class Decoder2 {
    #decoders = [];
    init() {
        LZMA.initBitModels(this.#decoders, 0x300);
    }
    decodeNormal(rangeDecoder) {
        var symbol = 1;
        do {
            symbol = (symbol << 1) | rangeDecoder.decodeBit(this.#decoders, symbol);
        } while (symbol < 0x100);
        return symbol & 0xff;
    }
    decodeWithMatchByte(rangeDecoder, matchByte) {
        var symbol = 1, matchBit, bit;
        do {
            matchBit = (matchByte >> 7) & 1;
            matchByte <<= 1;
            bit = rangeDecoder.decodeBit(this.#decoders, ((1 + matchBit) << 8) + symbol);
            symbol = (symbol << 1) | bit;
            if (matchBit !== bit) {
                while (symbol < 0x100) {
                    symbol = (symbol << 1) | rangeDecoder.decodeBit(this.#decoders, symbol);
                }
                break;
            }
        } while (symbol < 0x100);
        return symbol & 0xff;
    }
}
class LiteralDecoder {
    #coders;
    #numPrevBits;
    #numPosBits;
    #posMask;
    create(numPosBits, numPrevBits) {
        var i;
        if (this.#coders
            && (this.#numPrevBits === numPrevBits)
            && (this.#numPosBits === numPosBits)) {
            return;
        }
        this.#numPosBits = numPosBits;
        this.#posMask = (1 << numPosBits) - 1;
        this.#numPrevBits = numPrevBits;
        this.#coders = [];
        i = 1 << (this.#numPrevBits + this.#numPosBits);
        while (i--) {
            this.#coders[i] = new Decoder2();
        }
    }
    init() {
        var i = 1 << (this.#numPrevBits + this.#numPosBits);
        while (i--) {
            this.#coders[i].init();
        }
    }
    getDecoder(pos, prevByte) {
        return this.#coders[((pos & this.#posMask) << this.#numPrevBits)
            + ((prevByte & 0xff) >>> (8 - this.#numPrevBits))];
    }
}
class Decoder {
    #outWindow = new OutWindow();
    #rangeDecoder = new RangeDecoder();
    #isMatchDecoders = [];
    #isRepDecoders = [];
    #isRepG0Decoders = [];
    #isRepG1Decoders = [];
    #isRepG2Decoders = [];
    #isRep0LongDecoders = [];
    #posSlotDecoder = [new BitTreeDecoder(6), new BitTreeDecoder(6), new BitTreeDecoder(6), new BitTreeDecoder(6)];
    #posDecoders = [];
    #posAlignDecoder = new BitTreeDecoder(4);
    #lenDecoder = new LenDecoder();
    #repLenDecoder = new LenDecoder();
    #literalDecoder = new LiteralDecoder();
    #dictionarySize = -1;
    #dictionarySizeCheck = -1;
    #posStateMask;
    setDictionarySize(dictionarySize) {
        if (dictionarySize < 0) {
            return false;
        }
        if (this.#dictionarySize !== dictionarySize) {
            this.#dictionarySize = dictionarySize;
            this.#dictionarySizeCheck = Math.max(this.#dictionarySize, 1);
            this.#outWindow.create(Math.max(this.#dictionarySizeCheck, 4096));
        }
        return true;
    }
    setLcLpPb(lc, lp, pb) {
        var numPosStates = 1 << pb;
        if (lc > 8 || lp > 4 || pb > 4) {
            return false;
        }
        this.#literalDecoder.create(lp, lc);
        this.#lenDecoder.create(numPosStates);
        this.#repLenDecoder.create(numPosStates);
        this.#posStateMask = numPosStates - 1;
        return true;
    }
    setProperties(props) {
        if (!this.setLcLpPb(props.lc, props.lp, props.pb)) {
            throw Error("Incorrect stream properties");
        }
        if (!this.setDictionarySize(props.dictionarySize)) {
            throw Error("Invalid dictionary size");
        }
    }
    decodeHeader(inStream) {
        var properties, lc, lp, pb, uncompressedSize, dictionarySize;
        if (inStream.size < 13) {
            return false;
        }
        // +------------+----+----+----+----+--+--+--+--+--+--+--+--+
        // | Properties |	Dictionary Size	|	 Uncompressed Size	 |
        // +------------+----+----+----+----+--+--+--+--+--+--+--+--+
        properties = inStream.readByte();
        lc = properties % 9;
        properties = ~~(properties / 9);
        lp = properties % 5;
        pb = ~~(properties / 5);
        dictionarySize = inStream.readByte();
        dictionarySize |= inStream.readByte() << 8;
        dictionarySize |= inStream.readByte() << 16;
        dictionarySize += inStream.readByte() * 16777216;
        uncompressedSize = inStream.readByte();
        uncompressedSize |= inStream.readByte() << 8;
        uncompressedSize |= inStream.readByte() << 16;
        uncompressedSize += inStream.readByte() * 16777216;
        inStream.readByte();
        inStream.readByte();
        inStream.readByte();
        inStream.readByte();
        return {
            // The number of high bits of the previous
            // byte to use as a context for literal encoding.
            lc: lc,
            // The number of low bits of the dictionary
            // position to include in literal_pos_state.
            lp: lp,
            // The number of low bits of the dictionary
            // position to include in pos_state.
            pb: pb,
            // Dictionary Size is stored as an unsigned 32-bit
            // little endian integer. Any 32-bit value is possible,
            // but for maximum portability, only sizes of 2^n and
            // 2^n + 2^(n-1) should be used.
            dictionarySize: dictionarySize,
            // Uncompressed Size is stored as unsigned 64-bit little
            // endian integer. A special value of 0xFFFF_FFFF_FFFF_FFFF
            // indicates that Uncompressed Size is unknown.
            uncompressedSize: uncompressedSize
        };
    }
    init() {
        var i = 4;
        this.#outWindow.init(false);
        LZMA.initBitModels(this.#isMatchDecoders, 192);
        LZMA.initBitModels(this.#isRep0LongDecoders, 192);
        LZMA.initBitModels(this.#isRepDecoders, 12);
        LZMA.initBitModels(this.#isRepG0Decoders, 12);
        LZMA.initBitModels(this.#isRepG1Decoders, 12);
        LZMA.initBitModels(this.#isRepG2Decoders, 12);
        LZMA.initBitModels(this.#posDecoders, 114);
        this.#literalDecoder.init();
        while (i--) {
            this.#posSlotDecoder[i].init();
        }
        this.#lenDecoder.init();
        this.#repLenDecoder.init();
        this.#posAlignDecoder.init();
        this.#rangeDecoder.init();
    }
    decodeBody(inStream, outStream, maxSize) {
        var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0, posState, decoder2, len, distance, posSlot, numDirectBits;
        this.#rangeDecoder.setStream(inStream);
        this.#outWindow.setStream(outStream);
        this.init();
        while (maxSize < 0 || nowPos64 < maxSize) {
            posState = nowPos64 & this.#posStateMask;
            if (this.#rangeDecoder.decodeBit(this.#isMatchDecoders, (state << 4) + posState) === 0) {
                decoder2 = this.#literalDecoder.getDecoder(nowPos64++, prevByte);
                if (state >= 7) {
                    prevByte = decoder2.decodeWithMatchByte(this.#rangeDecoder, this.#outWindow.getByte(rep0));
                }
                else {
                    prevByte = decoder2.decodeNormal(this.#rangeDecoder);
                }
                this.#outWindow.putByte(prevByte);
                state = state < 4 ? 0 : state - (state < 10 ? 3 : 6);
            }
            else {
                if (this.#rangeDecoder.decodeBit(this.#isRepDecoders, state) === 1) {
                    len = 0;
                    if (this.#rangeDecoder.decodeBit(this.#isRepG0Decoders, state) === 0) {
                        if (this.#rangeDecoder.decodeBit(this.#isRep0LongDecoders, (state << 4) + posState) === 0) {
                            state = state < 7 ? 9 : 11;
                            len = 1;
                        }
                    }
                    else {
                        if (this.#rangeDecoder.decodeBit(this.#isRepG1Decoders, state) === 0) {
                            distance = rep1;
                        }
                        else {
                            if (this.#rangeDecoder.decodeBit(this.#isRepG2Decoders, state) === 0) {
                                distance = rep2;
                            }
                            else {
                                distance = rep3;
                                rep3 = rep2;
                            }
                            rep2 = rep1;
                        }
                        rep1 = rep0;
                        rep0 = distance;
                    }
                    if (len === 0) {
                        len = 2 + this.#repLenDecoder.decode(this.#rangeDecoder, posState);
                        state = state < 7 ? 8 : 11;
                    }
                }
                else {
                    rep3 = rep2;
                    rep2 = rep1;
                    rep1 = rep0;
                    len = 2 + this.#lenDecoder.decode(this.#rangeDecoder, posState);
                    state = state < 7 ? 7 : 10;
                    posSlot = this.#posSlotDecoder[len <= 5 ? len - 2 : 3].decode(this.#rangeDecoder);
                    if (posSlot >= 4) {
                        numDirectBits = (posSlot >> 1) - 1;
                        rep0 = (2 | (posSlot & 1)) << numDirectBits;
                        if (posSlot < 14) {
                            rep0 += LZMA.reverseDecode2(this.#posDecoders, rep0 - posSlot - 1, this.#rangeDecoder, numDirectBits);
                        }
                        else {
                            rep0 += this.#rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
                            rep0 += this.#posAlignDecoder.reverseDecode(this.#rangeDecoder);
                            if (rep0 < 0) {
                                if (rep0 === -1) {
                                    break;
                                }
                                return false;
                            }
                        }
                    }
                    else {
                        rep0 = posSlot;
                    }
                }
                if (rep0 >= nowPos64 || rep0 >= this.#dictionarySizeCheck) {
                    return false;
                }
                this.#outWindow.copyBlock(rep0, len);
                nowPos64 += len;
                prevByte = this.#outWindow.getByte(0);
            }
        }
        this.#outWindow.flush();
        this.#outWindow.releaseStream();
        this.#rangeDecoder.releaseStream();
        return true;
    }
    setDecoderProperties(properties) {
        var value, lc, lp, pb, dictionarySize;
        if (properties.size < 5) {
            return false;
        }
        value = properties.readByte();
        lc = value % 9;
        value = ~~(value / 9);
        lp = value % 5;
        pb = ~~(value / 5);
        if (!this.setLcLpPb(lc, lp, pb)) {
            return false;
        }
        dictionarySize = properties.readByte();
        dictionarySize |= properties.readByte() << 8;
        dictionarySize |= properties.readByte() << 16;
        dictionarySize += properties.readByte() * 16777216;
        return this.setDictionarySize(dictionarySize);
    }
}

function StringStrip(s) {
    return s.replace(/^[\s\0]+/, '').replace(/[\s\0]+$/, '');
}
function DecompressLZMA(properties, compressedDatas, uncompressedSize) {
    const inStream = {
        data: compressedDatas,
        offset: 0,
        readByte: function () {
            return this.data[this.offset++];
        }
    };
    const propStream = {
        data: properties,
        offset: 0,
        readByte: function () {
            return this.data[this.offset++];
        }
    };
    const outStream = {
        data: [],
        offset: 0,
        writeByte: function (value) {
            this.data[this.offset++] = value;
        }
    };
    if (LZMA.decompress(propStream, inStream, outStream, uncompressedSize)) {
        /*function Uint8ToString(u8a){
            const CHUNK_SZ = 0x8000;
            let c = [];
            for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
                c.push(String.fromCharCode.apply(null, u8a.slice(i, i+CHUNK_SZ)));
            }
            return c.join('');
        }*/
        return new Uint8Array(outStream.data); //Uint8ToString(outStream.data);
    }
    return null;
}

class Choreographies {
    #repository;
    choreographies = {};
    stringPool = {}; //TODO: use map instead ?
    #reader;
    fileId;
    fileVersion;
    scenesCount;
    stringsCount;
    scenesOffset;
    #sceneEntries = new Map();
    #initialized = false;
    async loadFile(repositoryName, fileName) {
        //const repository = new Repositories().getRepository(repositoryName);
        this.#repository = repositoryName;
        /*
        if (!repository) {
            console.error(`Unknown repository ${repositoryName} in Choreographies.loadFile`);
            return null;
        }
            */
        const respone = await new Repositories().getFile(repositoryName, fileName);
        if (respone.error) {
            return null;
        }
        /*
        p.then((arrayBuffer) => {
            if (arrayBuffer) {
                resolve(this.parse(repositoryName, fileName, arrayBuffer));
            } else {
                resolve(null);
            }
        });
        */
        //this.#reader = new RemoteBinaryReader(new URL(fileName, repository.base), undefined, CHOREOGRAPHIES_CHUNK_SIZE);
        this.#reader = new BinaryReader(respone.buffer, undefined, undefined, true);
        await this.#parseHeader();
    }
    async #parseHeader() {
        this.fileId = this.#reader.getUint32(0);
        this.fileVersion = this.#reader.getUint32();
        this.scenesCount = this.#reader.getUint32();
        this.stringsCount = this.#reader.getUint32();
        this.scenesOffset = this.#reader.getUint32();
    }
    async getChoreography(fileName) {
        const choreoCRC = crc32(fileName.replace(/\//g, '\\').toLowerCase());
        if (!this.#initialized) {
            await this.#parseSceneEntries();
            this.#initialized = true;
            if (!this.#initialized) {
                return null;
            }
        }
        if (this.choreographies[choreoCRC]) ;
        if (this.#sceneEntries.get(choreoCRC)) {
            const choreo = await this.#parseSceneData(this.#repository, choreoCRC);
            if (choreo) {
                this.choreographies[choreoCRC] = choreo;
                //console.info(choreo);
                return choreo;
            }
        }
        return null;
    }
    async #parseSceneEntries() {
        //await this.#reader.getLock();
        if (this.scenesOffset && this.scenesCount) {
            this.scenesCount * 16;
            // Ensure we have enough data
            //if (this.hasChunk(this.scenesOffset, size))
            {
                this.#sceneEntries.clear();
                this.#initialized = true;
                this.#reader.seek(this.scenesOffset);
                for (let i = 0; i < this.scenesCount; i++) {
                    const sceneCRC = this.#reader.getUint32();
                    let doo = this.#reader.getUint32();
                    let dl = this.#reader.getUint32();
                    let sso = this.#reader.getUint32();
                    const sceneEntry = { 'do': doo, 'dl': dl, 'sso': sso };
                    this.#sceneEntries.set(sceneCRC, sceneEntry);
                }
            }
        }
        //this.#reader.releaseLock();
    }
    async #parseSceneData(repository, sceneCRC) {
        //await this.#reader.getLock();
        let choreography = null;
        const sceneEntry = this.#sceneEntries.get(sceneCRC);
        if (sceneEntry) {
            //if (this.hasChunk(sceneEntry['do'], sceneEntry['dl']) && this.hasChunk(sceneEntry['sso'], 8))
            {
                //this.#reader.seek(sceneEntry['do']);
                //reader.skip(4);//LZMA
                const format = this.#reader.getString(4, sceneEntry['do']);
                let decompressedDatas;
                try {
                    if (format == 'LZMA') {
                        const HEADER_SIZE = 17; // 4 + 4 + 4 + 5
                        const uncompressedSize = this.#reader.getUint32();
                        const compressedSize = this.#reader.getUint32();
                        const properties = this.#reader.getBytes(5);
                        const compressedDatas = this.#reader.getBytes(sceneEntry['dl'] - HEADER_SIZE);
                        //decompressedDatas = _decompress(properties, compressedDatas, uncompressedSize);
                        decompressedDatas = DecompressLZMA(properties, compressedDatas, uncompressedSize);
                    }
                    else {
                        decompressedDatas = this.#reader.getString(sceneEntry['dl'], sceneEntry['do']);
                    }
                    choreography = await this.#loadChoreography(repository, decompressedDatas);
                }
                catch (e) {
                    //fixme: add error code
                    console.error(e);
                }
                if (choreography) {
                    //this.#reader.seek(sceneEntry['sso']);
                    choreography.sceneLength = (this.#reader.getUint32(sceneEntry['sso'])) * 0.001;
                }
            }
        }
        //this.#reader.releaseLock();
        return choreography;
    }
    async #loadChoreography(repository, fileContent) {
        const reader = new BinaryReader(fileContent, undefined, undefined, true);
        //SaveFile(new File([new Blob([reader.buffer])], '#parseSceneData'));
        const choreography = new Choreography(repository);
        await reader.getInt32();
        await reader.getInt8();
        await reader.getInt32();
        await this.#loadChoreoEvents(reader, choreography);
        await this.#loadChoreoActors(reader, choreography);
        return choreography;
    }
    /**
    * load choreography events
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoEvents(reader, choreography) {
        const repository = choreography.getRepository();
        const eventCount = await reader.getUint8();
        for (let eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            choreography.addEvent(await this.#loadChoreoEvent(reader, repository));
        }
    }
    /**
    * load choreography actors
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoActors(reader, choreography) {
        const actorCount = await reader.getUint8();
        for (let actorIndex = 0; actorIndex < actorCount; ++actorIndex) {
            choreography.addActor(await this.#loadChoreoActor(reader, choreography.getRepository()));
        }
    }
    /**
    * load an actor
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoActor(reader, repository) {
        const actorName = await this.readString(reader);
        const actor = new Actor(actorName);
        const channelCount = await reader.getUint8();
        for (let channelIndex = 0; channelIndex < channelCount; ++channelIndex) {
            actor.addChannel(await this.#loadChoreoChannel(reader, repository));
        }
        actor.setActive(await reader.getInt8());
        return actor;
    }
    /**
    * load an channel
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoChannel(reader, repository) {
        const channelName = await this.readString(reader);
        const channel = new Channel(channelName);
        const eventCount = await reader.getUint8();
        for (let eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            channel.addEvent(await this.#loadChoreoEvent(reader, repository));
        }
        channel.setActive(await reader.getInt8());
        return channel;
    }
    /**
    * load an event
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoEvent(reader, repository) {
        const eventType = await reader.getInt8();
        const eventName = await this.readString(reader);
        const startTime = await reader.getFloat32();
        const endTime = await reader.getFloat32();
        const param1 = await this.readString(reader);
        const param2 = await this.readString(reader);
        const param3 = await this.readString(reader);
        const ramp = await this.#loadCurveData(reader);
        const flags = await reader.getUint8();
        const distToTarget = await reader.getFloat32();
        const event = new Event$1(repository, eventType, eventName, startTime, endTime, param1, param2, param3, flags, distToTarget);
        event.setRamp(ramp);
        // Relative & timing tags
        for (let tagtype = 0; tagtype < 2; ++tagtype) {
            const numTags = await reader.getUint8();
            for (let j = 0; j < numTags; ++j) {
                await this.readString(reader);
                await reader.getUint8() / 255.0;
                if (tagtype == 0) {
                    event.addRelativeTag( /*tagName, percentage*/);
                }
                else {
                    event.addTimingTag( /*tagName, percentage, false*/);
                }
            }
        }
        // Absolute tags PLAYBACK / ORIGINAL
        for (let tagtype = 0; tagtype < 2; ++tagtype) {
            const numTags = await reader.getUint8();
            for (let j = 0; j < numTags; ++j) {
                await this.readString(reader);
                await reader.getUint16() / 4096.0;
                event.addAbsoluteTag( /*tagtype, tagName, percentage*/);
            }
        }
        if (event.getType() == EventType.Gesture) {
            await reader.getFloat32();
            console.error('TODO');
        }
        if (await reader.getInt8()) {
            await this.readString(reader);
            await this.readString(reader);
            console.error('TODO');
        }
        await this.#loadFlexAnimations(reader, event);
        if (event.getType() == EventType.Loop) {
            event.m_nNumLoops = await reader.getInt8();
        }
        if (event.getType() == EventType.Speak) {
            event.setCloseCaptionType(await reader.getInt8());
            event.setCloseCaptionToken(await this.readString(reader));
            await reader.getInt8();
            console.error('TODO');
        }
        return event;
    }
    /**
    * load flex animations
    * @param {Object jDataView} reader File reader
    */
    async #loadFlexAnimations(reader, event) {
        const numTracks = await reader.getUint8();
        for (let i = 0; i < numTracks; ++i) {
            console.error('TODO');
            // Controller name
            const track = event.addTrack(await this.readString(reader));
            track.setFlags(await reader.getUint8());
            track.setMin(await reader.getFloat32());
            track.setMax(await reader.getFloat32());
            const sampleTypeCount = track.isComboType() ? 2 : 1;
            for (let sampleType = 0; sampleType < sampleTypeCount; ++sampleType) { //TODO: improve condition
                const sampleCount = await reader.getUint16();
                for (let j = 0; j < sampleCount; ++j) {
                    const sample = track.addSample(await reader.getFloat32(), await reader.getUint8() / 255.0, sampleType);
                    sample.setCurveType(await reader.getUint16());
                    /*t = await reader.getFloat32();
                    v = await reader.getUint8() / 255.0;*/
                    //TODO: add sample
                    //					await reader.getUint16();
                }
            }
        }
    }
    /**
    * load curve data
    * @param {Object jDataView} reader File reader
    */
    async #loadCurveData(reader) {
        const curveData = new CurveData();
        let count = await reader.getUint8();
        /*if (count == 3) {
            //	TODO: there is an issue with choreo 'scenes/workshop/player/engineer/low/taunt_jackhammer_rodeo.vcd'
            count is stored as an unsigned char but actual count is 259
            count += 256;
        }*/
        for (let i = 0; i < count; ++i) {
            const t = await reader.getFloat32();
            const v = await reader.getUint8() / 255.0;
            curveData.add(t, v, false);
        }
        return curveData;
    }
    /**
    * Read string index, return the string
    * @return {String} The read string or null
    */
    async readString(reader) {
        return await this.getString(await reader.getInt16());
    }
    /**
    * Get a string
    * @param {Number} stringIndex stringIndex
    * @return {String} The read string or error string
    */
    async getString(stringIndex) {
        const s = this.stringPool[stringIndex];
        if (s === undefined) {
            const stringOffsetOffset = 20 + stringIndex * 4;
            const stringOffset = this.#reader.getUint32(stringOffsetOffset);
            return this.#reader.getNullString(stringOffset);
        }
        throw new Error(`String not found ${stringIndex}`);
    }
}
const makeCRCTable = function () {
    let c;
    let crcTable = [];
    for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};
let CacheCrcTable;
const crc32 = function (str) {
    let crcTable = CacheCrcTable ?? (CacheCrcTable = makeCRCTable());
    let crc = 0 ^ (-1);
    for (let i = 0; i < str.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
};

class ChoreographiesManager {
    static #instance;
    #playbackSpeed = 1.0;
    #playing = true;
    #choreographies = new Set();
    #sceneImage;
    constructor() {
        if (ChoreographiesManager.#instance) {
            return ChoreographiesManager.#instance;
        }
        ChoreographiesManager.#instance = this;
    }
    async init(repositoryName, fileName) {
        if (!this.#sceneImage) {
            this.#sceneImage = new Choreographies();
            await this.#sceneImage.loadFile(repositoryName, fileName);
            GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
                this.step(event.detail.delta);
            });
        }
    }
    async playChoreography(choreoName, actors, onStop) {
        if (this.#sceneImage) {
            const choreography = await this.#sceneImage.getChoreography(choreoName);
            if (choreography) {
                //choreography.play();
                this.#choreographies.add(choreography);
                choreography.setActors(actors);
                choreography.onStop = onStop;
            }
            else {
                onStop && onStop();
            }
            /* else {
                setTimeout(function() {playChoreo(choreoName, actors, onStop)}, 100);
            }*/
        }
    }
    async getChoreography(choreoName) {
        if (this.#sceneImage) {
            return await this.#sceneImage.getChoreography(choreoName);
        }
        return null;
    }
    step(elapsed) {
        if (!this.#playing) {
            return;
        }
        elapsed = elapsed * this.#playbackSpeed;
        for (let choreography of this.#choreographies) {
            if (!choreography.step(elapsed)) {
                this.#choreographies.delete(choreography);
            }
        }
    }
    reset() {
        for (let choreography of this.#choreographies) {
            choreography.reset();
        }
    }
    stopAll() {
        for (let choreography of this.#choreographies) {
            choreography.stop();
            this.#choreographies.delete(choreography);
        }
    }
    play() {
        this.#playing = true;
    }
    pause() {
        this.#playing = false;
    }
    set playbackSpeed(playbackSpeed) {
        this.#playbackSpeed = playbackSpeed;
    }
}

const COLLISION_GROUP_NONE = 0;
const COLLISION_GROUP_DEBRIS = 1;
//TODO: add other collision groups
/*
enum Collision_Group_t
{
    COLLISION_GROUP_NONE  = 0,
    COLLISION_GROUP_DEBRIS,			// Collides with nothing but world and static stuff
    COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers
    COLLISION_GROUP_INTERACTIVE_DEBRIS,	// Collides with everything except other interactive debris or debris
    COLLISION_GROUP_INTERACTIVE,	// Collides with everything except interactive debris or debris
    COLLISION_GROUP_PLAYER,
    COLLISION_GROUP_BREAKABLE_GLASS,
    COLLISION_GROUP_VEHICLE,
    COLLISION_GROUP_PLAYER_MOVEMENT,  // For HL2, same as Collision_Group_Player, for
                                        // TF2, this filters out other players and CBaseObjects
    COLLISION_GROUP_NPC,			// Generic NPC group
    COLLISION_GROUP_IN_VEHICLE,		// for any entity inside a vehicle
    COLLISION_GROUP_WEAPON,			// for any weapons that need collision detection
    COLLISION_GROUP_VEHICLE_CLIP,	// vehicle clip brush to restrict vehicle movement
    COLLISION_GROUP_PROJECTILE,		// Projectiles!
    COLLISION_GROUP_DOOR_BLOCKER,	// Blocks entities not permitted to get near moving doors
    COLLISION_GROUP_PASSABLE_DOOR,	// Doors that the player shouldn't collide with
    COLLISION_GROUP_DISSOLVING,		// Things that are dissolving are in this group
    COLLISION_GROUP_PUSHAWAY,		// Nonsolid on client and server, pushaway in player code

    COLLISION_GROUP_NPC_ACTOR,		// Used so NPCs in scripts ignore the player.
    COLLISION_GROUP_NPC_SCRIPTED,	// USed for NPCs in scripts that should not collide with each other

    LAST_SHARED_COLLISION_GROUP
};
*/

class FlexController {
    controllers = {};
    controllers2 = {};
    controllerIndex = 0;
    getController(name, min, max) {
        if (!this.controllers[name]) {
            this.controllers2[this.controllerIndex] = 0;
            this.controllers[name] = { i: this.controllerIndex++, min: min, max: max };
            /*
            if (typeof AddController !== 'undefined') {
                AddController(name, min, max);
            }
                */
            this.setControllerValue(name, 0);
        }
        return this.controllers[name].i;
    }
    getControllers() {
        return this.controllers;
    }
    getControllerValue(name) {
        const index = this.controllers[name].i;
        if (index !== undefined) {
            return this.controllers2[index];
        }
        return 0;
    }
    getControllerRealValue(name) {
        const controller = this.controllers[name];
        if (controller !== undefined) {
            const index = this.controllers[name].i;
            return RemapValClamped(this.controllers2[index], 0.0, 1.0, controller.min, controller.max);
        }
        return 0;
    }
    setControllerValue(name, value) {
        const controller = this.controllers[name];
        if (controller !== undefined) {
            value = RemapValClamped(value, controller.min, controller.max, 0.0, 1.0);
            this.controllers2[controller.i] = value;
        }
    }
    setAllValues(value) {
        for (let i in this.controllers) {
            this.setControllerValue(i, value);
        }
    }
    removeAllControllers() {
        this.controllers = {};
        this.controllers2 = {};
        this.controllerIndex = 0;
    }
}

/**
 * MDL Model
 */
//TODOv3 remove parse* function
const STUDIO_FLEX_OP_CONST = 1;
const STUDIO_FLEX_OP_FETCH1 = 2;
const STUDIO_FLEX_OP_ADD = 4;
const STUDIO_FLEX_OP_SUB = 5;
const STUDIO_FLEX_OP_MUL = 6;
const STUDIO_FLEX_OP_DIV = 7;
const STUDIO_FLEX_OP_NEG = 8;
const STUDIO_FLEX_OP_MAX = 13;
const STUDIO_FLEX_OP_MIN = 14;
const STUDIO_FLEX_OP_DME_LOWER_EYELID = 20;
const STUDIO_FLEX_OP_DME_UPPER_EYELID = 21;
const MAX_STUDIO_FLEX_DESC = 1024;
const MAX_STUDIO_FLEX_CTRL = 96;
class SourceMDL {
    repository;
    externalMdlsV2 = [];
    attachementNames = {};
    flexController = new FlexController();
    skinReferences;
    textures;
    modelGroups;
    header;
    bodyParts;
    sequences = [];
    texturesDir = [];
    flexRules = [];
    flexControllers = [];
    boneCount;
    bones = [];
    boneNames = [];
    numflexdesc = 0;
    attachements = [];
    animDesc = [];
    loader;
    reader;
    poseParameters = [];
    hitboxSets = [];
    constructor(repository) {
        this.repository = repository;
    }
    getMaterialName(skinId, materialId, materialOverride = []) {
        if (skinId >= this.skinReferences.length) {
            skinId = 0; // default to 0
        }
        const skinRef = this.skinReferences[skinId];
        if (!skinRef) {
            return '';
        }
        if (materialId >= skinRef.length) {
            materialId = skinRef.length - 1;
        }
        let textureId = skinRef[materialId];
        if (textureId >= this.textures.length) {
            textureId = 0;
        }
        return materialOverride[textureId] ? materialOverride[textureId].name : this.textures[textureId].name;
    }
    getSkinList() {
        const skinReferences = this.skinReferences;
        const skinList = [];
        for (let skinIndex = 0; skinIndex < skinReferences.length; ++skinIndex) {
            skinList.push(skinIndex);
        }
        return skinList;
    }
    getBodyPart(bodyPartId) {
        return this.bodyParts[bodyPartId];
    }
    getBodyParts() {
        return this.bodyParts;
    }
    async getSequence(sequenceName) {
        const list = this.sequences;
        for (let seqIndex = 0; seqIndex < list.length; ++seqIndex) {
            const seq = list[seqIndex];
            if ((seq.name == sequenceName) && seq.flags != 0x800) { //TODOV2: const
                return seq;
            }
        }
        // Seek in external Mdl's
        const extCount = this.getExternalMdlCount();
        for (let extIndex = 0; extIndex < extCount; ++extIndex) {
            const mdl = await this.getExternalMdl(extIndex);
            if (mdl) {
                const seq = await mdl.getSequence(sequenceName);
                if (seq) {
                    return seq;
                }
            }
        }
        return null;
    }
    getModelGroup(modelGroupId) {
        return this.modelGroups[modelGroupId];
    }
    getModelGroups() {
        return this.modelGroups;
    }
    getExternalMdlCount() {
        return this.modelGroups.length;
    }
    async getExternalMdl(externalId) {
        if (this.externalMdlsV2[externalId] !== undefined) {
            return this.externalMdlsV2[externalId];
        }
        const modelGroup = this.modelGroups[externalId];
        if (modelGroup) {
            let p = new Promise(async (resolve) => {
                let mdlLoader = getLoader('SourceEngineMDLLoader');
                let mdl = await (new mdlLoader().load(this.repository, modelGroup.name));
                if (mdl) {
                    this.externalMdlsV2[externalId] = mdl;
                    resolve(mdl);
                }
                else {
                    resolve(null);
                }
            });
            this.externalMdlsV2[externalId] = p;
            return p;
        }
        return null;
    }
    getTextureDir() {
        return this.texturesDir;
    }
    getDimensions(out = create$4()) {
        if (this.header) {
            sub$2(out, this.header.hull_max, this.header.hull_min);
        }
        return out;
    }
    getBBoxMin(out = create$4()) {
        if (this.header) {
            copy$4(out, this.header.hull_min);
        }
        return out;
    }
    getBBoxMax(out = create$4()) {
        if (this.header) {
            copy$4(out, this.header.hull_max);
        }
        return out;
    }
    async getAnimList() {
        const animList = new Set;
        //animList = animList.concat(this.getSequences());
        for (const seq of this.getSequences()) {
            animList.add(seq);
        }
        const extCount = this.getExternalMdlCount();
        for (let extIndex = 0; extIndex < extCount; ++extIndex) {
            const mdl = await this.getExternalMdl(extIndex);
            if (mdl) {
                for (const seq of mdl.getSequences()) {
                    animList.add(seq);
                }
            }
        }
        return animList;
    }
    getFlexRules() {
        return this.flexRules;
    }
    getFlexControllers() {
        return this.flexControllers;
    }
    runFlexesRules(flexesWeight, g_flexdescweight) {
        //this.g_flexdescweight = this.g_flexdescweight || new Float32Array(MAX_STUDIO_FLEX_DESC);
        const src = new Float32Array(MAX_STUDIO_FLEX_CTRL * 4); //TODO: optimize
        const flexControllers = this.getFlexControllers();
        if (flexControllers) {
            for (let controllerIndex = 0, l = flexControllers.length; controllerIndex < l; ++controllerIndex) {
                const flexController = flexControllers[controllerIndex];
                //console.error(controllerIndex, flexController.name);
                const j = flexController.localToGlobal;
                // remap m_flexweights to full dynamic range, global flexcontroller indexes
                if (j >= 0 && j < MAX_STUDIO_FLEX_CTRL * 4) {
                    const flexWeight = flexesWeight[flexController.name] ?? this.flexController.getControllerValue(flexController.name);
                    src[j] = flexWeight /*m_flexweight[controllerIndex]*/ * (flexController.max - flexController.min) + flexController.min;
                }
            }
            this.#runFlexesRules(src, g_flexdescweight);
        }
        //return g_flexdescweight;
    }
    #runFlexesRules(src, dest) {
        for (let i = 0; i < this.numflexdesc; ++i) {
            dest[i] = 0;
        }
        const flexRules = this.getFlexRules();
        if (flexRules) {
            for (let i = 0, l = flexRules.length; i < l; ++i) {
                const stack = new Float32Array(32);
                let k = 0;
                const rule = flexRules[i];
                const numops = rule.ops.length;
                for (let j = 0; j < numops; j++) {
                    const op = rule.ops[j];
                    let pCloseLidV;
                    let flCloseLidV;
                    let pCloseLid;
                    let flCloseLid;
                    let nEyeUpDownIndex;
                    let flEyeUpDown;
                    switch (op.op) {
                        case STUDIO_FLEX_OP_ADD:
                            stack[k - 2] = stack[k - 2] + stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_SUB:
                            stack[k - 2] = stack[k - 2] - stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_MUL:
                            stack[k - 2] = stack[k - 2] * stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_DIV:
                            if (stack[k - 1] > 0.0001) {
                                stack[k - 2] = stack[k - 2] / stack[k - 1];
                            }
                            else {
                                stack[k - 2] = 0;
                            }
                            k--;
                            break;
                        case STUDIO_FLEX_OP_NEG:
                            stack[k - 1] = -stack[k - 1];
                            break;
                        case STUDIO_FLEX_OP_MAX:
                            stack[k - 2] = Math.max(stack[k - 2], stack[k - 1]);
                            k--;
                            break;
                        case STUDIO_FLEX_OP_MIN:
                            stack[k - 2] = Math.min(stack[k - 2], stack[k - 1]);
                            k--;
                            break;
                        case STUDIO_FLEX_OP_CONST:
                            stack[k] = op.value;
                            k++;
                            break;
                        case STUDIO_FLEX_OP_FETCH1:
                            const m = this.flexControllers[op.index].localToGlobal;
                            stack[k] = src[m];
                            ++k;
                            break;
                        case STUDIO_FLEX_OP_DME_LOWER_EYELID:
                            pCloseLidV = this.flexControllers[op.index];
                            flCloseLidV = RemapValClamped(src[pCloseLidV.localToGlobal], pCloseLidV.min, pCloseLidV.max, 0.0, 1.0);
                            pCloseLid = this.flexControllers[stack[k - 1]];
                            flCloseLid = RemapValClamped(src[pCloseLid.localToGlobal], pCloseLid.min, pCloseLid.max, 0.0, 1.0);
                            nEyeUpDownIndex = stack[k - 3];
                            flEyeUpDown = 0.0;
                            if (nEyeUpDownIndex >= 0) {
                                const pEyeUpDown = this.flexControllers[stack[k - 3]];
                                flEyeUpDown = RemapValClamped(src[pEyeUpDown.localToGlobal], pEyeUpDown.min, pEyeUpDown.max, -1.0, 1.0);
                            }
                            if (flEyeUpDown > 0.0) {
                                stack[k - 3] = (1.0 - flEyeUpDown) * (1.0 - flCloseLidV) * flCloseLid;
                            }
                            else {
                                stack[k - 3] = (1.0 - flCloseLidV) * flCloseLid;
                            }
                            //console.error(stack [k - 3]);
                            k -= 2;
                            break;
                        case STUDIO_FLEX_OP_DME_UPPER_EYELID:
                            pCloseLidV = this.flexControllers[op.index];
                            flCloseLidV = RemapValClamped(src[pCloseLidV.localToGlobal], pCloseLidV.min, pCloseLidV.max, 0.0, 1.0);
                            pCloseLid = this.flexControllers[stack[k - 1]];
                            flCloseLid = RemapValClamped(src[pCloseLid.localToGlobal], pCloseLid.min, pCloseLid.max, 0.0, 1.0);
                            nEyeUpDownIndex = stack[k - 3];
                            flEyeUpDown = 0.0;
                            if (nEyeUpDownIndex >= 0) {
                                const pEyeUpDown = this.flexControllers[stack[k - 3]];
                                flEyeUpDown = RemapValClamped(src[pEyeUpDown.localToGlobal], pEyeUpDown.min, pEyeUpDown.max, -1.0, 1.0);
                            }
                            if (flEyeUpDown < 0.0) {
                                stack[k - 3] = (1.0 + flEyeUpDown) * flCloseLidV * flCloseLid;
                            }
                            else {
                                stack[k - 3] = flCloseLidV * flCloseLid;
                            }
                            //stack [k - 3] = Math.random();
                            k -= 2;
                            break;
                        //console.error('Unknown op ' + op.op)//TODOV2
                    }
                    //pops++;
                }
                dest[rule.flex] = stack[0];
            }
        }
        //console.log(stack);
    }
    addExternalMdl(mdlName) {
        //TODOV2: check name exists
        const modelgroup = new MdlStudioModelGroup();
        modelgroup.label = '';
        modelgroup.name = mdlName;
        this.modelGroups.push(modelgroup);
    }
    getBoneCount() {
        return this.boneCount;
    }
    getBones() {
        return this.bones;
    }
    getBone(boneIndex) {
        const bones = this.getBones();
        if (bones) {
            return bones[boneIndex];
        }
        return null;
    }
    getBoneByName(boneName) {
        const bones = this.getBones();
        if (this.boneNames) {
            const boneIndex = this.boneNames[boneName];
            if (bones) {
                return bones[boneIndex];
            }
        }
        return null;
    }
    getBoneId(boneName) {
        const bones = this.getBones();
        if (bones && this.boneNames) {
            const boneIndex = this.boneNames[boneName];
            return boneIndex;
        }
        return -1;
    }
    getAttachments() {
        return this.attachements;
    }
    getAttachementsNames(out) {
        const list = this.getAttachments();
        if (list) {
            out = out || [];
            for (let i = 0, l = list.length; i < l; ++i) {
                out.push(list[i].name);
            }
        }
        return out;
    }
    getAttachementById(attachementId) {
        const list = this.getAttachments();
        if (list) {
            return list[attachementId];
        }
        return null;
    }
    getAttachement(attachementName) {
        attachementName = attachementName.toLowerCase();
        if (this.attachementNames) {
            return this.attachementNames[attachementName];
        }
        return null;
    }
    getSequenceById(sequenceId) {
        return this.sequences[sequenceId];
    }
    getSequencesList() {
        let sequencesList = [];
        sequencesList = sequencesList.concat(this.getSequences());
        const list = this.externalMdlsV2;
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            sequencesList = sequencesList.concat(mdl.getSequences());
        }
        return sequencesList;
    }
    getSequencesList2() {
        let sequencesList = [];
        sequencesList = sequencesList.concat(this.getSequences2());
        const list = this.externalMdlsV2;
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            sequencesList = sequencesList.concat(mdl.getSequences2());
        }
        return sequencesList;
    }
    getSequences() {
        const list = this.sequences;
        let animList = [];
        for (let seqIndex = 0; seqIndex < list.length; ++seqIndex) {
            let seq = list[seqIndex];
            animList.push(seq.name);
        }
        return animList;
    }
    getSequences2() {
        const list = this.sequences;
        const animList = [];
        for (let seqIndex = 0; seqIndex < list.length; ++seqIndex) {
            let seq = list[seqIndex];
            //if ((seq.activity != -1) && (seq.activityName != '')) {
            //if (seq.activityName != '') {
            //if (seq.name == 'run_melee') {
            if ((seq.activity == 0)) {
                animList.push(seq.name);
            }
        }
        return animList;
    }
    getAnimDescription(animIndex) {
        return this.animDesc[animIndex];
    }
    getAnimFrame(dynamicProp, animDesc, frameIndex) {
        //console.info(frameIndex);
        //const animDesc = this.getAnimDescription(animIndex);
        if (animDesc && this.getBones()) {
            const section = this.loader._parseAnimSection(this.reader, animDesc, frameIndex); //TODOv3
            //const section = animDesc.animSections[0];
            animDesc.frames = [];
            let frame = dynamicProp.frameframe; // = dynamicProp.frameframe || Object.create(null);
            if (frame === undefined) {
                frame = Object.create(null);
                frame.bones = Object.create(null);
                dynamicProp.frameframe = frame;
            }
            //frame.bones = Object.create(null);
            //for (let frameIndex=0; frameIndex < animDesc.numframes; ++frameIndex)
            {
                //frame = Object.create(null);
                //frame.bones = frame.bones || Object.create(null);
                //const sectionIndex = 0;
                let frameIndex2 = frameIndex;
                if (animDesc.sectionframes != 0) {
                    //sectionIndex = Math.floor(frameIndex / animDesc.sectionframes);
                    frameIndex2 = frameIndex % animDesc.sectionframes;
                }
                //frameIndex % animDesc.sectionframes;
                const blockList = section; //animDesc.animSections[sectionIndex];
                if (blockList) {
                    for (let blockIndex = 0; blockIndex < blockList.length; ++blockIndex) {
                        const block = blockList[blockIndex];
                        const bone = this.bones[block.bone];
                        if (bone != undefined) {
                            //const fb1 = (this.frame && this.frame.bones) ? this.frame.bones[bone.name] || Object.create(null) : Object.create(null);
                            //const fb = Object.create(null);
                            let fb = frame.bones[bone.name];
                            if (fb === undefined) {
                                fb = Object.create(null);
                                frame.bones[bone.name] = fb;
                                fb.rot = create$4();
                                fb.pos = create$4();
                                fb.boneId = bone.boneId; //TODOv2
                            }
                            //frame.bones[bone.name] = fb;
                            //frame.bones[bone.boneId] = fb;
                            block.getRot(fb.rot, this, bone, frameIndex2);
                            block.getPos(fb.pos, this, bone, frameIndex2);
                            fb.valid = true;
                            //console.log(bone.name, fb.pos, fb.rot);
                        }
                    }
                    //animDesc.frames.push(frame);
                    //this.frame = frame;
                    return frame;
                }
            }
        }
        return null;
    }
    getLocalPoseParameter(poseIndex) {
        return this.poseParameters[poseIndex];
    }
    getPoseParameters() {
        return this.poseParameters;
    }
    getAllPoseParameters() {
        const poseList = Object.create(null);
        //poseList = poseList.concat(this.getPoseParameters());
        const list = this.externalMdlsV2.concat(this);
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            let pp = mdl.getPoseParameters();
            if (!pp) {
                return null;
            }
            for (let j = 0; j < pp.length; j++) {
                poseList[pp[j].name] = 1;
            }
        }
        return poseList;
    }
    boneFlags(boneIndex) {
        const bone = this.getBone(boneIndex);
        if (bone) {
            return bone.flags;
        }
        return 0;
    }
}
class MdlStudioModelGroup {
    name;
    label;
}
class MdlTexture {
    name;
    originalName;
}
class MdlBodyPart {
    name;
    base;
    models;
}

class AnimationDescription {
    #animation;
    #weight;
    #frame = 0;
    constructor(animation, weight) {
        this.#animation = animation;
        this.#weight = weight;
    }
    set weight(weight) {
        this.#weight = weight;
    }
    get weight() {
        return this.#weight;
    }
    set frame(frame) {
        this.#frame = Math.floor(frame % this.#animation.frameCount);
    }
    get name() {
        return this.#animation.name;
    }
    get animation() {
        return this.#animation;
    }
}

class Animations {
    #animations = [];
    [Symbol.iterator] = () => {
        return this.#animations.entries();
    };
    clear() {
        this.#animations.length = 0;
    }
    set(id, animation) {
        this.#animations[id] = animation;
        this.#computeWeights();
    }
    remove(id) {
        this.#animations[id] = undefined;
        this.#computeWeights();
    }
    get animations() {
        return this.#animations;
    }
    get(id) {
        return this.#animations[id];
    }
    setWeight(id, weight) {
        let animation = this.#animations[id];
        if (!animation) {
            return false;
        }
        animation.weight = weight;
        this.#computeWeights();
        return true;
    }
    #computeWeights() {
    }
}

class Hitbox {
    name;
    boundingBoxMin = create$4();
    boundingBoxMax = create$4();
    parent;
    constructor(name, boundingBoxMin, boundingBoxMax, parent) {
        this.name = name;
        copy$4(this.boundingBoxMin, boundingBoxMin);
        copy$4(this.boundingBoxMax, boundingBoxMax);
        this.parent = parent;
    }
}

function cleanSource1MaterialName(name) {
    name = name.replace(/\\/g, '/').toLowerCase().replace(/.vmt$/g, '').replace(/^materials\//g, '');
    name = name + '.vmt';
    //name = 'materials/' + name;
    return name;
}
class SourceEngineMaterialManager {
    static #fileListPerRepository = new Map();
    static #materialList = new Map();
    static #materialList2 = new Set();
    static #materialListPerRepository = {};
    static getMaterial(repositoryName, fileName, searchPaths) {
        fileName = cleanSource1MaterialName(fileName);
        if (searchPaths) {
            let promises = [];
            for (let searchPath of searchPaths) {
                promises.push(this.#getMaterial(repositoryName, 'materials/' + searchPath + fileName));
            }
            let promise = new Promise((resolve, reject) => {
                Promise.allSettled(promises).then((promises) => {
                    for (let promise of promises) {
                        if (promise.status == 'fulfilled') {
                            resolve(promise.value);
                            return;
                        }
                    }
                    this.#getMaterial(repositoryName, 'materials/' + fileName).then((material) => resolve(material), () => reject(null));
                });
            });
            return promise;
        }
        else {
            return this.#getMaterial(repositoryName, 'materials/' + fileName);
        }
    }
    static #getMaterial(repositoryName, fileName) {
        let material = this.#materialList.get(fileName);
        if (material instanceof Promise) {
            let promise = new Promise((resolve, reject) => {
                material.then((material) => {
                    let newMaterial = material.clone();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                }).catch((value) => reject(value));
            });
            return promise;
        }
        if (material !== undefined) {
            return new Promise((resolve, reject) => {
                let newMaterial = material.clone();
                this.#materialList2.add(newMaterial);
                resolve(newMaterial);
            });
        }
        else {
            let promise = new Promise((resolve, reject) => {
                let vmtLoader = getLoader('SourceEngineVMTLoader');
                vmtLoader.load(repositoryName, fileName).then((material) => {
                    this.#materialList.set(fileName, material);
                    let newMaterial = material.clone();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                }).catch((value) => reject(value));
            });
            this.#materialList.set(fileName, promise);
            return promise;
        }
    }
    static async copyMaterial(repositoryName, sourcePath, destPath, searchPaths) {
        let material = await this.getMaterial(repositoryName, sourcePath, searchPaths);
        this.#materialList.set(destPath, material.clone());
    }
    static addRepository(repositoryPath) {
        this.#fileListPerRepository.set(repositoryPath, null);
    }
    static async getMaterialList() {
        let repoList = [];
        for (let [repositoryName, repository] of this.#fileListPerRepository) {
            console.error(repositoryName, repository);
            if (repository == null) {
                repository = new Promise(async (resolve) => {
                    try {
                        let manifestUrl = repositoryName + 'materials_manifest.json'; //todo variable
                        let response = await customFetch(manifestUrl);
                        resolve(await response.json());
                    }
                    catch (e) {
                        resolve({ files: [] });
                    }
                });
                this.#fileListPerRepository.set(repositoryName, repository);
            }
            repoList.push({ name: repositoryName, files: [await repository] });
        }
        return { files: repoList };
    }
}

const BONE_USED_BY_ANYTHING = 0x0007FF00;
const BONE_ALWAYS_PROCEDURAL = 0x04;
const BONE_USED_BY_BONE_MERGE = 0x00040000;
const BONE_FIXED_ALIGNMENT = 0x00100000;
const tempMat4$2 = create$5();
create$4();
create$2();
//TODOV4: cleanup unused code
class MdlBone {
    _poseToBone = create$5();
    _invPoseToBone = create$5();
    _initPoseToBone = create$5();
    _boneMat = create$5();
    _position = create$4();
    _quaternion = create$2();
    _worldPos = create$4();
    _worldQuat = create$2();
    _worldMat = create$5();
    _parent = null; /*TODO:remove ?*/
    dirty = true;
    lastComputed = 0;
    #skeleton; /*TODO:remove*/
    parentBone = -1;
    boneId = -1;
    name = '';
    lowcasename = '';
    bonecontroller = [];
    rot = create$4();
    posscale = create$4();
    rotscale = create$4();
    qAlignment = create$3();
    flags = 0;
    proctype = 0;
    procindex = 0;
    physicsbone = 0;
    surfacepropidx = 0;
    contents = 0;
    constructor(skeleton /*TODO:remove*/) {
        this.#skeleton = skeleton; /*TODO:remove*/
    }
    get skeleton() {
        return this.#skeleton;
    }
    set quaternion(quaternion) {
        copy$2(this._quaternion, quaternion);
        this.dirty = true;
    }
    get quaternion() {
        return this._quaternion;
    }
    set position(position) {
        copy$4(this._position, position);
        this.dirty = true;
    }
    get position() {
        return this._position;
    }
    set parent(parent) {
        this._parent = parent;
        this.dirty = true;
    }
    get parent() {
        return this._parent;
    }
    set worldPos(worldPos) {
        copy$4(this._worldPos, worldPos);
        fromRotationTranslation$1(tempMat4$2, this._worldQuat, this._worldPos);
        multiply$6(this._boneMat, tempMat4$2, this._poseToBone);
    }
    set worldQuat(worldQuat) {
        copy$2(this._worldQuat, worldQuat);
        fromRotationTranslation$1(tempMat4$2, this._worldQuat, this._worldPos);
        multiply$6(this._boneMat, tempMat4$2, this._poseToBone);
    }
    getWorldPos(offset, out = create$4()) {
        transformQuat$1(out, offset, this.worldQuat);
        add$5(out, this.worldPos, out);
        return out;
    }
    getRelativePos() {
        return clone$4(this.position);
    }
    set poseToBone(poseToBone) {
        copy$5(this._poseToBone, poseToBone);
        invert$3(this._invPoseToBone, poseToBone);
        this.dirty = true;
    }
    get poseToBone() {
        return this._poseToBone;
    }
    set initPoseToBone(initPoseToBone) {
        copy$5(this._initPoseToBone, initPoseToBone);
        this.dirty = true;
    }
    get initPoseToBone() {
        return this._initPoseToBone;
    }
    getWorldQuat() {
        return this.worldQuat;
    }
    /**
     * Is a procedural bone ?
     * @returns {bool} yes is procedural bone
     */
    isProcedural() {
        return (this.flags & BONE_ALWAYS_PROCEDURAL) == BONE_ALWAYS_PROCEDURAL;
    }
    /**
     * Use bone merge
     * @returns {bool} yes bone is available for bone merge to occur against it
     */
    useBoneMerge() {
        return (this.flags & BONE_USED_BY_BONE_MERGE) == BONE_USED_BY_BONE_MERGE; //TODO: test engine verion; TF2 seems not use this flag
    }
}

const STUDIO_AL_SPLINE = 0x0040;
const STUDIO_AL_XFADE = 0x0080;
const STUDIO_AL_NOBLEND = 0x0200;
const STUDIO_AL_LOCAL = 0x1000;
const STUDIO_AL_POSE = 0x4000;
class MdlStudioSeqDesc {
    paramindex = [];
    paramstart = [];
    paramend = [];
    blend = [];
    weightlist = [];
    groupsize = [];
    mdl;
    previousTime;
    currentTime;
    posekeyindex;
    autolayer = [];
    events = [];
    name;
    flags;
    activity;
    id;
    startOffset;
    actweight;
    numevents;
    eventindex;
    bbmin;
    bbmax;
    numblends;
    animindexindex;
    movementindex;
    paramparent;
    fadeintime;
    fadeouttime;
    localentrynode;
    localexitnode;
    nodeflags;
    entryphase;
    exitphase;
    lastframe;
    nextseq;
    pose;
    numikrules;
    numautolayers;
    autolayerindex;
    weightlistindex;
    numiklocks;
    iklockindex;
    keyvalueindex;
    keyvaluesize;
    cycleposeindex;
    activityName;
    keyvalueText;
    pBoneweight(boneIndex) {
        return this.weightlist[boneIndex];
    }
    //MdlStudioSeqDesc.prototype.weight = MdlStudioSeqDesc.prototype.pBoneweight;//TODOV2
    getBlend(x, y) {
        x = clamp(x, 0, this.groupsize[0] - 1);
        y = clamp(y, 0, this.groupsize[1] - 1);
        return this.blend[y][x];
    }
    poseKey(iParam, iAnim) {
        if (this.mdl && this.posekeyindex) {
            const mdl = this.mdl;
            const offset = this.posekeyindex + (iParam * this.groupsize[0] + iAnim) * 4;
            return mdl.reader.getFloat32(offset); //TODOv3
        }
        //float				*pPoseKey(int iParam, int iAnim) const { return (float *)(((byte *)this) + posekeyindex) + iParam * groupsize[0] + iAnim; }
        return 0;
    }
    getAutoLayer(autoLayerIndex) {
        return this.autolayer[autoLayerIndex];
    }
    get length() {
        const anim = this.mdl.getAnimDescription(this.blend[0][0]);
        if (!anim) {
            return 0;
        }
        return (anim.numframes - 1) / anim.fps;
    }
    play(dynamicProp) {
        const anim = this.mdl.getAnimDescription(this.blend[0][0]);
        if (!anim) {
            return null;
        }
        this.currentTime = (this.currentTime !== undefined) ? dynamicProp.frame * anim.fps / (anim.numframes - 1) : 0;
        this.currentTime = this.currentTime % 1;
        this.previousTime = (this.previousTime !== undefined) ? this.previousTime : -1;
        if (this.previousTime > this.currentTime) {
            this.previousTime = this.currentTime;
        }
        const previousTime = this.previousTime;
        const currentTime = this.currentTime;
        const seqEvents = this.events;
        for (let eventIndex = 0; eventIndex < seqEvents.length; ++eventIndex) {
            const event = seqEvents[eventIndex];
            if (event.cycle > previousTime && event.cycle <= currentTime) {
                this.processEvent(event, dynamicProp); //TODOv3
            }
        }
        this.previousTime = this.currentTime;
    }
    processEvent(event, dynamicProp) {
        let options;
        switch (true) {
            case event.event == 5004 || (event.event === 0 && event.name == 'AE_CL_PLAYSOUND'):
                Source1SoundManager.playSound(this.mdl?.repository, event.options);
                break;
            case (event.event === 0 && event.name == 'AE_CL_BODYGROUP_SET_VALUE'):
                options = event.options.split(' ');
                //dynamicProp.bodyGroups[options[0]] = options[1];
                dynamicProp.setBodyPartModel(options[0], options[1]);
                break;
            case (event.event === 0 && event.name == 'AE_WPN_HIDE'):
                //TODOV2
                //dynamicProp.setVisibility(false);
                //console.error('AE_WPN_HIDE' + dynamicProp.name);
                break;
            case (event.event === 0 && event.name == 'AE_WPN_UNHIDE'):
                //TODOV2
                //dynamicProp.setVisibility(true);
                //console.error('AE_WPN_UNHIDE' + dynamicProp.name);
                break;
            case (event.event === 0 && event.name == 'AE_CL_CREATE_PARTICLE_EFFECT'):
                options = event.options.split(' ');
                //TODOV2
                let f = async () => {
                    let sys = await Source1ParticleControler.createSystem(dynamicProp.sourceModel.repository, options[0]);
                    sys.autoKill = true;
                    sys.start();
                    //console.log(options[0], options[1], options[2]);
                    switch (options[1]) {
                        case 'follow_attachment':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                        case 'start_at_attachment':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                        case 'start_at_origin':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                    }
                };
                f();
                /*TODOv2
                        'start_at_origin',		// PATTACH_ABSORIGIN = 0,
                        'follow_origin',		// PATTACH_ABSORIGIN_FOLLOW,
                        'start_at_customorigin',// PATTACH_CUSTOMORIGIN,
                        'start_at_attachment',	// PATTACH_POINT,
                        'follow_attachment',	// PATTACH_POINT_FOLLOW,
                */
                break;
            case (event.event === 0 && event.name == 'AE_TAUNT_ADD_ATTRIBUTE'):
                //{ event AE_TAUNT_ADD_ATTRIBUTE 1 'taunt_attr_player_invis_percent 1 5.215' }
                options = event.options.split(' ');
                switch (options[0]) {
                    case 'taunt_attr_player_invis_percent':
                        dynamicProp.visible = false;
                        setTimeout(function () { dynamicProp.visible = true; }, options[2] * 1000);
                        break;
                }
                break;
        }
        //'AE_CL_BODYGROUP_SET_VALUE'
    }
}
class MdlStudioAutoLayer {
    iSequence;
    iPose;
    flags;
    start;
    peak;
    tail;
    end;
}
class MdlStudioEvent {
    cycle;
    event;
    type;
    options;
    name;
}

const STUDIO_ANIM_RAWPOS = 0x01; // Vector48
const STUDIO_ANIM_RAWROT = 0x02; // Quaternion48
const STUDIO_ANIM_ANIMPOS = 0x04; // mstudioanim_valueptr_t
const STUDIO_ANIM_ANIMROT = 0x08; // mstudioanim_valueptr_t
const STUDIO_ANIM_DELTA = 0x10;
const STUDIO_ANIM_RAWROT2 = 0x20; // Quaternion64
const tempMat4$1 = create$5();
const tempQuat$5 = create$2();
class MdlStudioAnim {
    animValuePtrRot;
    animValuePtrPos;
    rawpos;
    rawrot;
    rawrot2;
    flags;
    bone;
    nextOffset;
    getRotValue() {
        return this.animValuePtrRot;
    }
    getPosValue() {
        return this.animValuePtrPos;
    }
    getQuaternion48() {
        return this.rawrot;
    }
    getQuaternion64() {
        return this.rawrot2;
    }
    /**
     * TODO
     */
    getRot(rot, mdl, bone, frame) {
        let fromEuler5 = function (out, q, i, j, k, h, parity, repeat, frame) {
            var M = tempMat4$1; //Dim M(,) As Double = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
            var Nq;
            var s;
            var xs;
            var ys;
            var zs;
            var wx;
            var wy;
            var wz;
            var xx;
            var xy;
            var xz;
            var yy;
            var yz;
            var zz;
            Nq = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
            if (Nq > 0) {
                s = 2.0 / Nq;
            }
            else {
                s = 0;
            }
            xs = q[0] * s;
            ys = q[1] * s;
            zs = q[2] * s;
            wx = q[3] * xs;
            wy = q[3] * ys;
            wz = q[3] * zs;
            xx = q[0] * xs;
            xy = q[0] * ys;
            xz = q[0] * zs;
            yy = q[1] * ys;
            yz = q[1] * zs;
            zz = q[2] * zs;
            M[0] = 1.0 - (yy + zz);
            M[1] = xy - wz;
            M[2] = xz + wy;
            M[4] = xy + wz;
            M[5] = 1.0 - (xx + zz);
            M[6] = yz - wx;
            M[8] = xz - wy;
            M[9] = yz + wx;
            M[10] = 1.0 - (xx + yy);
            M[14] = 1.0;
            return Eul_FromHMatrix(out, M, i, j, k, h, parity, repeat, frame);
        };
        let fromEuler4 = function (out, a) {
            fromEuler5(out, a, 0, 1, 2, 0, 'even', 'no', 'S');
            var a = out[0];
            var b = out[1];
            var c = out[2];
            out[0] = c;
            out[1] = b;
            out[2] = a;
            return out;
        };
        var Eul_FromHMatrix = function (out, M, i, j, k, h, parity, repeat, frame) {
            var ea = tempQuat$5;
            if (repeat == 'yes') {
                var sy = Math.sqrt(M[i * 4 + j] * M[i * 4 + j] + M[i * 4 + k] * M[i * 4 + k]);
                if (sy > 16 * FLT_EPSILON) {
                    ea[0] = Math.atan2(M[i * 4 + j], M[i * 4 + k]);
                    ea[1] = Math.atan2(sy, M[i * 4 + i]);
                    ea[2] = Math.atan2(M[j * 4 + i], -M[k * 4 + i]);
                }
                else {
                    ea[0] = Math.atan2(-M[j * 4 + k], M[j * 4 + j]);
                    ea[1] = Math.atan2(sy, M[i * 4 + i]);
                    ea[2] = 0;
                }
            }
            else {
                var cy = Math.sqrt(M[i * 4 + i] * M[i * 4 + i] + M[j * 4 + i] * M[j * 4 + i]);
                if (cy > 16 * FLT_EPSILON) {
                    ea[0] = Math.atan2(M[k * 4 + j], M[k * 4 + k]);
                    ea[1] = Math.atan2(-M[k * 4 + i], cy);
                    ea[2] = Math.atan2(M[j * 4 + i], M[i * 4 + i]);
                }
                else {
                    ea[0] = Math.atan2(-M[j * 4 + k], M[j * 4 + j]);
                    ea[1] = Math.atan2(-M[k * 4 + i], cy);
                    ea[2] = 0;
                }
            }
            if (parity == 'odd') {
                ea[0] = -ea[0];
                ea[1] = -ea[1];
                ea[2] = -ea[2];
            }
            if (frame == 'R') {
                var t = ea[0];
                ea[0] = ea[2];
                ea[2] = t;
            }
            copy$2(out, ea);
            return out;
        };
        const flag = this.flags;
        let offset;
        if ((flag & STUDIO_ANIM_RAWROT) == STUDIO_ANIM_RAWROT) {
            rot = add$5(rot, rot, this.rawrot);
        }
        if ((flag & STUDIO_ANIM_RAWROT2) == STUDIO_ANIM_RAWROT2) {
            rot = fromEuler4(rot, this.rawrot2); //TODO: fix the from euler function
            return rot;
        }
        if ((flag & STUDIO_ANIM_ANIMROT) == STUDIO_ANIM_ANIMROT) {
            for (let i = 0; i < 3; ++i) {
                offset = this.animValuePtrRot.offset[i];
                if (offset) {
                    rot[i] = this.readValue(mdl, frame, this.animValuePtrRot.base + offset, bone.boneId, i) * bone.rotscale[i];
                }
            }
        }
        if ((flag & STUDIO_ANIM_DELTA) != STUDIO_ANIM_DELTA) {
            add$5(rot, rot, bone.rot);
        }
        return rot;
    }
    getPos(pos, mdl, bone, frame) {
        const flag = this.flags;
        let offset;
        pos[0] = 0;
        pos[1] = 0;
        pos[2] = 0;
        if ((flag & STUDIO_ANIM_RAWPOS) == STUDIO_ANIM_RAWPOS) {
            pos = add$5(pos, pos, this.rawpos);
            return pos;
        }
        else if ((flag & STUDIO_ANIM_ANIMPOS) != STUDIO_ANIM_ANIMPOS) {
            if ((flag & STUDIO_ANIM_DELTA) == STUDIO_ANIM_DELTA) {
                //vec3.add(pos, pos, bone.position);
                pos[0] = 0;
                pos[1] = 0;
                pos[2] = 0;
            }
            else {
                add$5(pos, pos, bone.position);
            }
            return pos;
        }
        if ((flag & STUDIO_ANIM_ANIMPOS) == STUDIO_ANIM_ANIMPOS) {
            for (let i = 0; i < 3; ++i) {
                offset = this.animValuePtrPos.offset[i];
                if (offset) {
                    pos[i] = this.readValue(mdl, frame, this.animValuePtrPos.base + offset, bone.boneId, i) * bone.posscale[i];
                }
            }
        }
        if ((flag & STUDIO_ANIM_DELTA) != STUDIO_ANIM_DELTA) {
            add$5(pos, pos, bone.position);
        }
        return pos;
    }
    readValue(mdl, frame, offset, boneid, memberid) {
        const reader = mdl.reader;
        reader.seek(offset);
        let valid = 0;
        let total = 0;
        let k = frame;
        let count = 0;
        do {
            count++;
            if (count > 1) {
                const nextOffset = reader.tell() + valid * 2;
                /*if (!mdl.hasChunk(nextOffset, 2)) {//TODOv3
                    return 0;
                }*/
                reader.seek(nextOffset);
            }
            k -= total;
            valid = reader.getInt8();
            total = reader.getInt8();
        } while ((total <= k) && count < 30); //TODO: change 30
        if (k >= valid) {
            k = valid - 1;
        }
        const nextOffset = reader.tell() + k * 2;
        reader.seek(nextOffset);
        return reader.getInt16();
    }
}

//-----------------------------------------------------------------------------
// Purpose: returns array of animations and weightings for a sequence based on current pose parameters
//-----------------------------------------------------------------------------
//void Studio_SeqAnims(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameter[], mstudioanimdesc_t *panim[4], float *weight)
function Studio_SeqAnims(pStudioHdr, seqdesc, iSequence, poseParameter, panim, weight) {
    /*if (!pStudioHdr || iSequence >= pStudioHdr.GetNumSeq())
    {
        weight[0] = weight[1] = weight[2] = weight[3] = 0.0;
        return;
    }*/
    const i0 = 0, i1 = 0;
    const s0 = 0, s1 = 0;
    //Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, iSequence, 0, s0, i0);TODOV2
    //	Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, iSequence, 1, s1, i1);
    //panim[0] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1)));
    panim[0] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1));
    weight[0] = (1 - s0) * (1 - s1);
    //panim[1] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1)));
    panim[1] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1));
    weight[1] = (s0) * (1 - s1);
    //panim[2] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1+1)));
    panim[2] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1 + 1));
    weight[2] = (1 - s0) * (s1);
    //panim[3] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1+1)));
    panim[3] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1 + 1));
    weight[3] = (s0) * (s1);
}
//-----------------------------------------------------------------------------
// Purpose: returns cycles per second of a sequence (cycles/second)
//-----------------------------------------------------------------------------
//float Studio_CPS(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameter[])
function Studio_CPS(pStudioHdr, seqdesc, iSequence, poseParameter) {
    const panim = [];
    const weight = [];
    Studio_SeqAnims(pStudioHdr, seqdesc, iSequence, poseParameter, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        if (panim[i] && weight[i] > 0 && panim[i].numframes > 1) {
            t += (panim[i].fps / (panim[i].numframes - 1)) * weight[i];
            //setAnimLength(panim[i].numframes);//TODOv3
        }
    }
    return t;
}
//-----------------------------------------------------------------------------
// Purpose: returns length (in seconds) of a sequence (seconds/cycle)
//-----------------------------------------------------------------------------
//float Studio_Duration(const CStudioHdr *pStudioHdr, int iSequence, const float poseParameter[])
function Studio_Duration(pStudioHdr, iSequence, poseParameter) {
    const seqdesc = pStudioHdr.getSequenceById(iSequence); //pStudioHdr.pSeqdesc(iSequence);
    const cps = Studio_CPS(pStudioHdr, seqdesc, iSequence, poseParameter);
    if (cps == 0)
        return 0.0;
    return 1.0 / cps;
}
const SOURCE_MODEL_MAX_BONES$1 = 256;
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
function InitPose(dynamicProp, pStudioHdr, pos, q, boneMask) {
    if (pStudioHdr.pLinearBones === undefined) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            {
                const pbone = pStudioHdr.getBone(i);
                pos[i] = pos[i] || create$4(); //removeme
                q[i] = q[i] || create$2(); //removeme
                copy$4(pos[i], pbone.position);
                copy$2(q[i], pbone.quaternion);
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
//function CalcPose(pStudioHdr, pIKContext, pos, q, sequence, cycle, poseParameter, boneMask, flWeight = 1.0, flTime = 0.0) {
function CalcPose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    cycle = cycle % 1; //TODOv2
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc) {
        //Assert(flWeight >= 0.0f && flWeight <= 1.0f);
        // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
        flWeight = clamp(flWeight, 0.0, 1.0);
        // add any IK locks to prevent numautolayers from moving extremities
        //CIKContext seq_ik;TODOv2
        /*
        if (false && seqdesc.numiklocks) {//TODOV2
            seq_ik.Init(pStudioHdr, vec3_angle, vec3_origin, 0.0, 0, boneMask); // local space relative so absolute position doesn't mater
            seq_ik.AddSequenceLocks(seqdesc, pos, q);
        }
            */
        CalcPoseSingle(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime);
        if (pIKContext) {
            pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameter, flWeight);
        }
        AddSequenceLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight, flTime);
        /*
                if (false && seqdesc.numiklocks) {//TODOV2
                    seq_ik.SolveSequenceLocks(seqdesc, pos, q);
                }
                    */
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
//TODOv2: put somewhere else
const STUDIO_LOOPING$1 = 0x0001; // ending frame should be the same as the starting frame
const STUDIO_DELTA$1 = 0x0004; // this sequence 'adds' to the base sequences, not slerp blends
const STUDIO_POST = 0x0010; //
const STUDIO_ALLZEROS$1 = 0x0020; // this animation/sequence has no real animation data
//						0x0040
const STUDIO_CYCLEPOSE$1 = 0x0080; // cycle index is taken from a pose parameter index
const STUDIO_REALTIME$1 = 0x0100; // cycle index is taken from a real-time clock, not the animations cycle index
const STUDIO_LOCAL$1 = 0x0200; // sequence has a local context sequence
const STUDIO_WORLD = 0x4000; // sequence blends in worldspace
const CalcPoseSingle_pos2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_q2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_pos3$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_q3$1 = Array(SOURCE_MODEL_MAX_BONES$1);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; i++) {
    CalcPoseSingle_pos2$1[i] = create$4();
    CalcPoseSingle_q2$1[i] = create$2();
    CalcPoseSingle_pos3$1[i] = create$4();
    CalcPoseSingle_q3$1[i] = create$2();
}
function CalcPoseSingle(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime) {
    let bResult = true;
    const pos2 = CalcPoseSingle_pos2$1; //[];//vec3.create();//TODOv2: optimize (see source)
    const q2 = CalcPoseSingle_q2$1; //[];//quat.create();//TODOv2: optimize (see source)
    const pos3 = CalcPoseSingle_pos3$1; //[];//vec3.create();//TODOv2: optimize (see source)
    const q3 = CalcPoseSingle_q3$1;
    for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; ++i) {
        zero$4(pos2[i]);
        identity$1(q2[i]);
        zero$4(pos3[i]);
        identity$1(q3[i]);
    }
    /*	if (sequence >= pStudioHdr->GetNumSeq())TODOv2
        {
            sequence = 0;
            seqdesc = pStudioHdr->pSeqdesc(sequence);
        }*/
    let i0 = 0, i1 = 0;
    let s0 = 0, s1 = 0;
    const r0 = Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, sequence, 0 /*, s0, i0 */); //TODOv2
    const r1 = Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, sequence, 1 /*, s1, i1 */);
    s0 = r0.s;
    i0 = r0.i;
    s1 = r1.s;
    i1 = r1.i;
    if (seqdesc.flags & STUDIO_REALTIME$1) {
        const cps = Studio_CPS(pStudioHdr, seqdesc, sequence, poseParameter);
        cycle = flTime * cps;
        cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
    }
    else if (seqdesc.flags & STUDIO_CYCLEPOSE$1) {
        const iPose = pStudioHdr.GetSharedPoseParameter(sequence, seqdesc.cycleposeindex);
        if (iPose != -1) {
            cycle = poseParameter[iPose];
        }
        else {
            cycle = 0.0;
        }
    }
    else if (cycle < 0 || cycle >= 1) {
        if (seqdesc.flags & STUDIO_LOOPING$1) {
            cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
            if (cycle < 0) {
                cycle += 1;
            }
        }
        else {
            cycle = clamp(cycle, 0.0, 1.0);
        }
    }
    if (s0 < 0.001) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else if (s0 > 0.999) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                ScaleBones(pStudioHdr, q, pos, sequence, 1.0 - s0, boneMask);
            }
            else if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1)) {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                ScaleBones(pStudioHdr, q, pos, sequence, s0, boneMask);
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
        }
        //else if (!anim_3wayblend.GetBool())
        else {
            const iAnimIndices = [];
            const weight = [];
            Calc3WayBlendIndices(i0, i1, s0, s1, seqdesc, iAnimIndices, weight);
            if (weight[1] < 0.001) {
                // on diagonal
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[2] / (weight[0] + weight[2]), boneMask);
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[1], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[1] / (weight[0] + weight[1]), boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos3, q3, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q3, pos3, weight[2], boneMask);
            }
        }
    }
    //g_VectorPool.Free(pos2);
    //g_QaternionPool.Free(q2);
    //g_VectorPool.Free(pos3);
    //g_QaternionPool.Free(q3);
    return bResult;
}
//-----------------------------------------------------------------------------
// Purpose: Find and decode a sub-frame of animation
//-----------------------------------------------------------------------------
function CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, animation, cycle, boneMask) {
    /*virtualmodel_t *pVModel = pStudioHdr->GetVirtualModel();TODOV2
    if (pVModel)
    {
        CalcVirtualAnimation(pVModel, pStudioHdr, pos, q, seqdesc, sequence, animation, cycle, boneMask);
        return;
    }*/
    const animdesc = pStudioHdr.getAnimDescription(animation);
    if (!animdesc) {
        return;
    }
    pStudioHdr.getBone(0);
    //const mstudiolinearbone_t *pLinearBones = pStudioHdr->pLinearBones();TODOV2
    let pLinearBones;
    const fFrame = cycle * (animdesc.numframes - 1);
    const iFrame = Math.floor(fFrame);
    const s = (fFrame - iFrame);
    //iFrame = 0;
    //console.log(pStudioHdr.getAnimFrame(animdesc, iFrame));
    pStudioHdr.getAnimFrame(dynamicProp, animdesc, iFrame);
    //console.log(iFrame);
    let iLocalFrame = iFrame;
    let flStall;
    const panims = animdesc.pAnim(iLocalFrame, flStall);
    //animdesc.mdl.getAnimFrame(animdesc, 31);
    //const pweight = seqdesc.pBoneweight(0);
    // if the animation isn't available, look for the zero frame cache
    if (!panims) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            const pbone = pStudioHdr.getBone(i);
            const pweight = seqdesc.pBoneweight(i);
            if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
                if (animdesc.flags & STUDIO_DELTA$1) {
                    q[i] = create$2(); //TODOV2
                    pos[i] = create$4(); //TODOV2
                }
                else {
                    //q[i] = pbone.rot;TODOv2
                    q[i] = q[i] || create$2();
                    pos[i] = pos[i] || create$4();
                    q[i] = create$2();
                    pos[i] = create$4();
                    //quat.fromMat3(q[i], mat3.fromEuler(SourceEngineTempMat3, pbone.rot));
                    quatFromEulerRad(q[i], pbone.rot[0], pbone.rot[1], pbone.rot[2]);
                    copy$4(pos[i], pbone.position);
                }
            }
        }
        //CalcZeroframeData(pStudioHdr, pStudioHdr->GetRenderHdr(), NULL, pStudioHdr->pBone(0), animdesc, fFrame, pos, q, boneMask, 1.0);
        CalcZeroframeData(pStudioHdr, pStudioHdr, null, pStudioHdr.getBone(0));
        return;
    }
    // BUGBUG: the sequence, the anim, and the model can have all different bone mappings.
    //for (i = 0; i < pStudioHdr->numbones(); i++, pbone++, pweight++)
    let panim = panims[0];
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(), animIndex = 0; i < boneCount; ++i) {
        const pbone = pStudioHdr.getBone(i);
        const pweight = seqdesc.pBoneweight(i);
        q[i] = q[i] || create$2(); //TODOV2
        pos[i] = pos[i] || create$4(); //TODOV2
        q[i] = create$2();
        pos[i] = create$4();
        if (panim && panim.bone == i) {
            boneFlags[i] = panim.flags;
            //if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask))
            if (pweight > 0) //TODOv2
             {
                if (animdesc.sectionframes != 0) {
                    iLocalFrame = iLocalFrame % animdesc.sectionframes;
                }
                CalcBoneQuaternion(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, q[i]);
                CalcBonePosition(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, pos[i]); //TODOV2
                //quat.copy(q[i], pbone.quaternion);
                //vec3.copy(pos[i], pbone.position);
            }
            //panim = panim->pNext();//TODOv2
            panim = panims[++animIndex];
            //} else if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
        }
        else if (pweight > 0) {
            if (animdesc.flags & STUDIO_DELTA$1) {
                boneFlags[i] = STUDIO_ANIM_DELTA;
                q[i] = create$2(); //TODOV2
                pos[i] = create$4(); //TODOV2
            }
            else {
                boneFlags[i] = 0;
                copy$2(q[i], pbone.quaternion);
                copy$4(pos[i], pbone.position);
            }
        }
        else {
            boneFlags[i] = STUDIO_ANIM_DELTA;
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: return a sub frame rotation for a single bone
//-----------------------------------------------------------------------------
/*void CalcBoneQuaternion(int frame, float s,
                        const Quaternion &baseQuat, const RadianEuler &baseRot, const Vector &baseRotScale,
                        int iBaseFlags, const Quaternion &baseAlignment,
                        const mstudioanim_t *panim, Quaternion &q)*/
function _CalcBoneQuaternion(pStudioHdr, frame, s, baseQuat, baseRot, baseRotScale, iBaseFlags, baseAlignment, panim, q) {
    if (panim.flags & STUDIO_ANIM_RAWROT) {
        //q = panim.pQuat48();
        copy$2(q, panim.rawrot); //TODOv2
        return;
    }
    if (panim.flags & STUDIO_ANIM_RAWROT2) {
        //q = panim.pQuat64();
        copy$2(q, panim.rawrot2); //TODOv2
        q[0] = panim.rawrot2[2];
        q[1] = panim.rawrot2[1];
        q[2] = panim.rawrot2[0];
        q[3] = panim.rawrot2[3];
        return;
    }
    if (!(panim.flags & STUDIO_ANIM_ANIMROT)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            identity$1(q);
        }
        else {
            copy$2(q, baseQuat); //TODOv2
        }
        return;
    }
    panim.animValuePtrRot;
    if (s > 0.001) {
        const angle1 = create$4(), angle2 = create$4(); // TODO: optimize
        const q1 = create$2();
        const q2 = create$2();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle1[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset, panim.bone, i) * baseRotScale[i];
                angle2[i] = angle1[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle1[0] = angle1[0] + baseRot[0];
            angle1[1] = angle1[1] + baseRot[1];
            angle1[2] = angle1[2] + baseRot[2];
            angle2[0] = angle2[0] + baseRot[0];
            angle2[1] = angle2[1] + baseRot[1];
            angle2[2] = angle2[2] + baseRot[2];
        }
        if (angle1[0] !== angle2[0] || angle1[1] !== angle2[1] || angle1[2] !== angle2[2]) {
            //_AngleQuaternion(angle1, q1);//TODOv2
            //_AngleQuaternion(angle2, q2);//TODOv2
            quatFromEulerRad(q1, angle1[0], angle1[1], angle1[2]);
            quatFromEulerRad(q2, angle2[0], angle2[1], angle2[2]);
            QuaternionBlend(q1, q2, s, q);
        }
        else {
            //_AngleQuaternion(angle1, q);//TODOv2
            //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle1));
            quatFromEulerRad(q, angle1[0], angle1[1], angle1[2]);
        }
    }
    else {
        const angle = create$4();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset, panim.bone, i) * baseRotScale[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle[0] = angle[0] + baseRot[0];
            angle[1] = angle[1] + baseRot[1];
            angle[2] = angle[2] + baseRot[2];
        }
        //_AngleQuaternion(angle, q);//TODOv2
        //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle));
        quatFromEulerRad(q, angle[0], angle[1], angle[2]);
    }
    // align to unified bone
    if (!(panim.flags & STUDIO_ANIM_DELTA) && (iBaseFlags & BONE_FIXED_ALIGNMENT)) {
        QuaternionAlign(baseAlignment, q, q);
    }
}
function CalcBoneQuaternion(pStudioHdr, frame, s, pBone, pLinearBones, panim, q) {
    {
        _CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quaternion, pBone.rot, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
        //_CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quat, [0, 0, 0]/*pBone.rot*//*TODOV2*/, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
    }
}
function _CalcBonePosition(pStudioHdr, frame, s, basePos, baseBoneScale, panim, pos) {
    if (panim.flags & STUDIO_ANIM_RAWPOS) {
        copy$4(pos, panim.rawpos);
        return;
    }
    else if (!(panim.flags & STUDIO_ANIM_ANIMPOS)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            zero$4(pos);
        }
        else {
            copy$4(pos, basePos);
        }
        return;
    }
    panim.animValuePtrPos;
    /*
        mstudioanim_valueptr_t *pPosV = panim.pPosV();
        int					j;
    */
    if (s > 0.001) {
        let v1, v2; // TODO: optimize
        for (let i = 0; i < 3; i++) {
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                v1 = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset, panim.bone, i) * baseBoneScale[i];
                v2 = v1;
                pos[i] = v1 * (1.0 - s) + v2 * s;
            }
        }
    }
    else {
        for (let i = 0; i < 3; i++) {
            //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], pos[i]);
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                pos[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset, panim.bone, i) * baseBoneScale[i];
            }
        }
    }
    if (!(panim.flags & STUDIO_ANIM_DELTA)) {
        pos[0] = pos[0] + basePos[0];
        pos[1] = pos[1] + basePos[1];
        pos[2] = pos[2] + basePos[2];
    }
}
function CalcBonePosition(pStudioHdr, frame, s, pBone, pLinearBones, panim, pos) {
    {
        _CalcBonePosition(pStudioHdr, frame, s, pBone.position, pBone.posscale, panim, pos);
    }
}
//-----------------------------------------------------------------------------
// Do a piecewise addition of the quaternion elements. This actually makes little
// mathematical sense, but it's a cheap way to simulate a slerp.
//-----------------------------------------------------------------------------
//void QuaternionBlend(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlend(p, q, t, qt) {
    // decide if one of the quaternions is backwards
    const q2 = create$2();
    QuaternionAlign(p, q, q2);
    QuaternionBlendNoAlign(p, q2, t, qt);
}
//void QuaternionBlendNoAlign(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlendNoAlign(p, q, t, qt) {
    // 0.0 returns p, 1.0 return q.
    const sclp = 1.0 - t;
    const sclq = t;
    for (let i = 0; i < 4; ++i) {
        qt[i] = sclp * p[i] + sclq * q[i];
    }
    normalize$3(qt, qt);
}
//-----------------------------------------------------------------------------
// make sure quaternions are within 180 degrees of one another, if not, reverse q
//-----------------------------------------------------------------------------
//void QuaternionAlign(const Quaternion &p, const Quaternion &q, Quaternion &qt)
function QuaternionAlign(p, q, qt) {
    // FIXME: can this be done with a quat dot product?
    // decide if one of the quaternions is backwards
    let a = 0;
    let b = 0;
    for (let i = 0; i < 4; ++i) {
        a += (p[i] - q[i]) * (p[i] - q[i]);
        b += (p[i] + q[i]) * (p[i] + q[i]);
    }
    if (a > b) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = -q[i];
        }
    }
    else if (qt != q) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = q[i];
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: Calc Zeroframe Data
//-----------------------------------------------------------------------------
function CalcZeroframeData(pStudioHdr, pAnimStudioHdr, pAnimGroup, pAnimbone, animdesc, fFrame, pos, q, boneMask, flWeight) {
    /* TODO
        let pData = animdesc.pZeroFrameData();

        if (!pData) {
            return;
        }

        // Msg('zeroframe %s\n', animdesc.pszName());
        let i;
        if (animdesc.zeroframecount == 1) {
            for (let j = 0, boneCount = pStudioHdr.getBoneCount(); j < boneCount; ++j) {
                if (pAnimGroup)
                    i = pAnimGroup.masterBone[j];
                else
                    i = j;

                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_POS) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const p = vec3.create();//TODOv2
                        console.error('const p = *(Vector48 *)pData;//TODOv2');
                        pos[i] = pos[i] * (1.0 - flWeight) + p * flWeight;
                    }
                    pData += 6;//sizeof(Vector48);//TODOv2
                }
                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_ROT) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const q0 = quat.create();//*(Quaternion64 *)pData;
                        console.error('const q0 = quat.create();//*(Quaternion64 *)pData;');
                        QuaternionBlend(q[i], q0, flWeight, q[i]);
                        //Assert(q[i].IsValid());
                    }
                    pData += 8;//sizeof(Quaternion64);
                }
            }
        }
        else {
            let s1;
            let index = fFrame / animdesc.zeroframespan;
            if (index >= animdesc.zeroframecount - 1) {
                index = animdesc.zeroframecount - 2;
                s1 = 1.0;
            } else {
                s1 = clamp((fFrame - index * animdesc.zeroframespan) / animdesc.zeroframespan, 0.0, 1.0);
            }
            let i0 = Math.max(index - 1, 0);
            let i1 = index;
            let i2 = Math.min(index + 1, animdesc.zeroframecount - 1);
            for (let j = 0, boneCount = pStudioHdr.getBoneCount(); j < boneCount; ++j) {
                if (pAnimGroup)
                    i = pAnimGroup.masterBone[j];
                else
                    i = j;

                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_POS) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const p0 = vec3.create();//*(((Vector48 *)pData) + i0);//optimize
                        const p1 = vec3.create();//*(((Vector48 *)pData) + i1);
                        const p2 = vec3.create();//*(((Vector48 *)pData) + i2);
                        console.error('Vector p2 = *(((Vector48 *)pData) + i2);');
                        let p3;
                        Hermite_Spline(p0, p1, p2, s1, p3);
                        pos[i] = pos[i] * (1.0 - flWeight) + p3 * flWeight;
                    }
                    pData += sizeof(Vector48) * animdesc.zeroframecount;
                }
                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_ROT) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const q0 = quat.create();//*(((Quaternion64 *)pData) + i0);
                        const q1 = quat.create();//*(((Quaternion64 *)pData) + i1);
                        const q2 = quat.create();//*(((Quaternion64 *)pData) + i2);
                        console.error('Quaternion q0 = *(((Quaternion64 *)pData) + i0);');
                        if (flWeight == 1.0) {
                            Hermite_Spline(q0, q1, q2, s1, q[i]);
                        }
                        else {
                            let q3;
                            Hermite_Spline(q0, q1, q2, s1, q3);
                            QuaternionBlend(q[i], q3, flWeight, q[i]);
                        }
                    }
                    pData += sizeof(Quaternion64) * animdesc.zeroframecount;
                }
            }
        }
    */
}
function PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1) {
    // remove 'zero' positional blends
    //const baseanim = pStudioHdr.iRelativeAnim(sequence, seqdesc.getBlend(i0 , i1));//TODOv2
    const baseanim = seqdesc.getBlend(i0, i1);
    const anim = pStudioHdr.getAnimDescription(baseanim);
    if (!anim) {
        return false;
    }
    return (anim.flags & STUDIO_ALLZEROS$1) != 0;
}
//-----------------------------------------------------------------------------
// Purpose: turn a 2x2 blend into a 3 way triangle blend
// Returns: returns the animination indices and barycentric coordinates of a triangle
//			the triangle is a right triangle, and the diagonal is between elements [0] and [2]
//-----------------------------------------------------------------------------
//void Calc3WayBlendIndices(int i0, int i1, float s0, float s1, const mstudioseqdesc_t &seqdesc, int *pAnimIndices, float *pWeight)
function Calc3WayBlendIndices(i0, i1, s0, s1, seqdesc, pAnimIndices, pWeight) {
    // Figure out which bi-section direction we are using to make triangles.
    const bEven = (((i0 + i1) & 0x1) == 0);
    let x1, y1;
    let x2, y2;
    let x3, y3;
    // diagonal is between elements 1 & 3
    // TL to BR
    if (bEven) {
        if (s0 > s1) {
            // B
            x1 = 0;
            y1 = 0;
            x2 = 1;
            y2 = 0;
            x3 = 1;
            y3 = 1;
            pWeight[0] = (1.0 - s0);
            pWeight[1] = s0 - s1;
        }
        else {
            // C
            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 1;
            x3 = 0;
            y3 = 0;
            pWeight[0] = s0;
            pWeight[1] = s1 - s0;
        }
    }
    // BL to TR
    else {
        const flTotal = s0 + s1;
        if (flTotal > 1.0) {
            // D
            x1 = 1;
            y1 = 0;
            x2 = 1;
            y2 = 1;
            x3 = 0;
            y3 = 1;
            pWeight[0] = (1.0 - s1);
            pWeight[1] = s0 - 1.0 + s1;
        }
        else {
            // A
            x1 = 0;
            y1 = 1;
            x2 = 0;
            y2 = 0;
            x3 = 1;
            y3 = 0;
            pWeight[0] = s1;
            pWeight[1] = 1.0 - s0 - s1;
        }
    }
    pAnimIndices[0] = seqdesc.getBlend(i0 + x1, i1 + y1);
    pAnimIndices[1] = seqdesc.getBlend(i0 + x2, i1 + y2);
    pAnimIndices[2] = seqdesc.getBlend(i0 + x3, i1 + y3);
    // clamp the diagonal
    if (pWeight[1] < 0.001)
        pWeight[1] = 0.0;
    pWeight[2] = 1.0 - pWeight[0] - pWeight[1];
    //Assert(pWeight[0] >= 0.0 && pWeight[0] <= 1.0);
    //Assert(pWeight[1] >= 0.0 && pWeight[1] <= 1.0);
    //Assert(pWeight[2] >= 0.0 && pWeight[2] <= 1.0);
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence //TODOv2
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AddSequenceLayers = function (dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    //return;
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.getAutoLayer(i);
        if (pLayer.flags & STUDIO_AL_LOCAL) {
            continue;
        }
        let layerCycle = cycle;
        let layerWeight = flWeight;
        if (pLayer.start != pLayer.end) {
            let s = 1.0;
            let index;
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                index = cycle;
            }
            else {
                //TODOv2
                pLayer.iSequence; //int iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
                //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, pLayer.iPose);
                const iPose = pLayer.iPose;
                if (iPose != -1) {
                    //const Pose = pStudioHdr.pPoseParameter(iPose);
                    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
                    if (Pose) {
                        index = poseParameter[iPose] * (Pose.end - Pose.start) + Pose.start;
                    }
                    else {
                        index = 0;
                    }
                }
                else {
                    index = 0;
                }
            }
            if (index < pLayer.start) {
                continue;
            }
            if (index >= pLayer.end) {
                continue;
            }
            if (index < pLayer.peak && pLayer.start != pLayer.peak) {
                s = (index - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (index > pLayer.tail && pLayer.end != pLayer.tail) {
                s = (pLayer.end - index) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) {
                s = SimpleSpline(s);
            }
            if ((pLayer.flags & STUDIO_AL_XFADE) && (index > pLayer.tail)) {
                layerWeight = (s * flWeight) / (1 - flWeight + s * flWeight);
            }
            else if (pLayer.flags & STUDIO_AL_NOBLEND) {
                layerWeight = s;
            }
            else {
                layerWeight = flWeight * s;
            }
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
            }
        }
        //const iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);//TODOV2
        const iSequence = pLayer.iSequence; //pStudioHdr.getSequenceById(pLayer.iSequence);
        AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameter, boneMask, layerWeight, flTime);
    }
};
//-----------------------------------------------------------------------------
// Purpose: accumulate a pose for a single sequence on top of existing animation
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AccumulatePose_pos2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const AccumulatePose_q2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; i++) {
    AccumulatePose_pos2$1[i] = create$4();
    AccumulatePose_q2$1[i] = create$2();
}
function AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    //const pos2 = [];
    //const q2 = [];
    const pos2 = AccumulatePose_pos2$1;
    const q2 = AccumulatePose_q2$1;
    // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
    flWeight = clamp(flWeight, 0.0, 1.0);
    if (sequence < 0) {
        return;
    }
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc.flags & STUDIO_LOCAL$1) {
        InitPose(dynamicProp, pStudioHdr, pos2, q2);
    }
    if (CalcPoseSingle(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime)) {
        // this weight is wrong, the IK rules won't composite at the correct intensity
        AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, 1.0, flTime);
        SlerpBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, flWeight);
    }
    if (pIKContext) {
        pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameter, flWeight);
    }
    AddSequenceLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight, flTime);
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
function AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    if (!(seqdesc.flags & STUDIO_LOCAL$1)) {
        return;
    }
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.pAutolayer(i);
        if (!(pLayer.flags & STUDIO_AL_LOCAL))
            continue;
        let layerCycle = cycle;
        let layerWeight = flWeight;
        if (pLayer.start != pLayer.end) {
            let s = 1.0;
            if (cycle < pLayer.start)
                continue;
            if (cycle >= pLayer.end)
                continue;
            if (cycle < pLayer.peak && pLayer.start != pLayer.peak) {
                s = (cycle - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (cycle > pLayer.tail && pLayer.end != pLayer.tail) {
                s = (pLayer.end - cycle) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) {
                s = SimpleSpline(s);
            }
            if ((pLayer.flags & STUDIO_AL_XFADE) && (cycle > pLayer.tail)) {
                layerWeight = (s * flWeight) / (1 - flWeight + s * flWeight);
            }
            else if (pLayer.flags & STUDIO_AL_NOBLEND) {
                layerWeight = s;
            }
            else {
                layerWeight = flWeight * s;
            }
            layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
        }
        const iSequence = pLayer.iSequence; //pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
        AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameter, boneMask, layerWeight, flTime);
    }
}
//-----------------------------------------------------------------------------
// Purpose: blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
function SlerpBones(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    if (s <= 0.0)
        return;
    if (s > 1.0) {
        s = 1.0;
    }
    if (seqdesc.flags & STUDIO_WORLD) {
        //WorldSpaceSlerp(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask);
        return;
    }
    // Build weightlist for all bones
    const nBoneCount = pStudioHdr.getBoneCount();
    //const *pS2 = (float*)stackalloc(nBoneCount * sizeof(float));TODOv2
    const pS2 = [];
    for (let i = 0; i < nBoneCount; ++i) {
        q1[i] = q1[i] || q2[i] || create$2(); //TODOV2
        pos1[i] = pos1[i] || pos2[i] || create$4();
        q2[i] = q2[i] || create$2(); //TODOV2
        pos2[i] = pos2[i] || create$4();
        {
            pS2[i] = s * seqdesc.pBoneweight(i); // blend in based on this bones weight
            continue;
        }
    }
    let s1, s2;
    if (seqdesc.flags & STUDIO_DELTA$1) {
        for (let i = 0; i < nBoneCount; ++i) {
            s2 = pS2[i];
            if (s2 <= 0.0)
                continue;
            if (seqdesc.flags & STUDIO_POST) {
                QuaternionMA(q1[i], s2, q2[i], q1[i]);
                // FIXME: are these correct?
                pos1[i][0] = pos1[i][0] + pos2[i][0] * s2;
                pos1[i][1] = pos1[i][1] + pos2[i][1] * s2;
                pos1[i][2] = pos1[i][2] + pos2[i][2] * s2;
            }
            else {
                QuaternionSM(s2, q2[i], q1[i], q1[i]);
                // FIXME: are these correct?
                pos1[i][0] = pos1[i][0] + pos2[i][0] * s2;
                pos1[i][1] = pos1[i][1] + pos2[i][1] * s2;
                pos1[i][2] = pos1[i][2] + pos2[i][2] * s2;
            }
        }
        return;
    }
    const q3 = create$2();
    for (let i = 0; i < nBoneCount; ++i) {
        s2 = pS2[i];
        if (s2 <= 0.0)
            continue;
        s1 = 1.0 - s2;
        if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
            QuaternionSlerpNoAlign(q2[i], q1[i], s1, q3);
        }
        else {
            QuaternionSlerp(q2[i], q1[i], s1, q3);
        }
        q1[i][0] = q3[0];
        q1[i][1] = q3[1];
        q1[i][2] = q3[2];
        q1[i][3] = q3[3];
        pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
        pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
        pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
    }
}
//-----------------------------------------------------------------------------
// Purpose: qt = p * (s * q)
//-----------------------------------------------------------------------------
//void QuaternionMA(const Quaternion &p, float s, const Quaternion &q, Quaternion &qt)
function QuaternionMA(p, s, q, qt) {
    const p1 = create$2();
    const q1 = create$2();
    QuaternionScale(q, s, q1);
    mul$2(p1, p, q1);
    normalize$3(p1, p1);
    qt[0] = p1[0];
    qt[1] = p1[1];
    qt[2] = p1[2];
    qt[3] = p1[3];
}
//-----------------------------------------------------------------------------
// Purpose: qt = (s * p) * q
//-----------------------------------------------------------------------------
//void QuaternionSM(float s, const Quaternion &p, const Quaternion &q, Quaternion &qt)
function QuaternionSM(s, p, q, qt) {
    const p1 = create$2();
    const q1 = create$2();
    QuaternionScale(p, s, p1);
    mul$2(q1, p1, q);
    normalize$3(q1, q1); //QuaternionNormalize(q1);
    qt[0] = q1[0];
    qt[1] = q1[1];
    qt[2] = q1[2];
    qt[3] = q1[3];
}
//void QuaternionScale(const Quaternion &p, float t, Quaternion &q);
function QuaternionScale(p, t, q) {
    let r;
    // FIXME: nick, this isn't overly sensitive to accuracy, and it may be faster to
    // use the cos part (w) of the quaternion (sin(omega)*N,cos(omega)) to figure the new scale.
    let sinom = Math.sqrt(dot$4(p, p));
    sinom = Math.min(sinom, 1.0);
    const sinsom = Math.sin(Math.asin(sinom) * t);
    t = sinsom / (sinom + FLT_EPSILON);
    scale$5(q, p, t);
    // rescale rotation
    r = 1.0 - sinsom * sinsom;
    // Assert(r >= 0);
    if (r < 0.0) {
        r = 0.0;
    }
    r = Math.sqrt(r);
    // keep sign of rotation
    if (p.w < 0) {
        q.w = -r;
    }
    else {
        q.w = r;
    }
    return;
}
//-----------------------------------------------------------------------------
// Purpose: Inter-animation blend.	Assumes both types are identical.
//			blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
/*void BlendBones(
    const CStudioHdr *pStudioHdr,
    Quaternion q1[MAXSTUDIOBONES],
    Vector pos1[MAXSTUDIOBONES],
    mstudioseqdesc_t &seqdesc,
    int sequence,
    const Quaternion q2[MAXSTUDIOBONES],
    const Vector pos2[MAXSTUDIOBONES],
    float s,
    int boneMask)*/
function BlendBones(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    const q3 = create$2();
    /*virtualmodel_t *pVModel = pStudioHdr.GetVirtualModel();TODO
    const virtualgroup_t *pSeqGroup = NULL;
    if (pVModel)
    {
        pSeqGroup = pVModel.pSeqGroup(sequence);
    }*/
    if (s <= 0) {
        //Assert(0); // shouldn't have been called
        return;
    }
    else if (s >= 1.0) {
        //Assert(0); // shouldn't have been called
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            let j;
            // skip unused bones
            if (!(pStudioHdr.boneFlags(i) & boneMask)) {
                continue;
            }
            {
                j = i;
            }
            if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
                q1[i] = q2[i];
                pos1[i] = pos2[i];
            }
        }
        return;
    }
    const s2 = s;
    const s1 = 1.0 - s2;
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
        let j;
        // skip unused bones
        q1[i] = q1[i] || create$2();
        pos1[i] = pos1[i] || create$4();
        q2[i] = q2[i] || create$2();
        pos2[i] = pos2[i] || create$4();
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
            if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
                QuaternionBlendNoAlign(q2[i], q1[i], s1, q3);
            }
            else {
                QuaternionBlend(q2[i], q1[i], s1, q3);
            }
            q1[i][0] = q3[0];
            q1[i][1] = q3[1];
            q1[i][2] = q3[2];
            q1[i][3] = q3[3];
            pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
            pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
            pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
        }
    }
}
//-----------------------------------------------------------------------------
// Quaternion sphereical linear interpolation
//-----------------------------------------------------------------------------
//void QuaternionSlerp(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionSlerp(p, q, t, qt) {
    const q2 = create$2();
    // 0.0 returns p, 1.0 return q.
    // decide if one of the quaternions is backwards
    QuaternionAlign(p, q, q2);
    QuaternionSlerpNoAlign(p, q2, t, qt);
}
//void QuaternionSlerpNoAlign(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionSlerpNoAlign(p, q, t, qt) {
    //Assert(s_bMathlibInitialized);
    let omega, cosom, sinom, sclp, sclq;
    // 0.0 returns p, 1.0 return q.
    cosom = p[0] * q[0] + p[1] * q[1] + p[2] * q[2] + p[3] * q[3];
    if ((1.0 + cosom) > 0.000001) {
        if ((1.0 - cosom) > 0.000001) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            sclp = Math.sin((1.0 - t) * omega) / sinom;
            sclq = Math.sin(t * omega) / sinom;
        }
        else {
            // TODO: add short circuit for cosom == 1.0?
            sclp = 1.0 - t;
            sclq = t;
        }
        for (let i = 0; i < 4; ++i) {
            qt[i] = sclp * p[i] + sclq * q[i];
        }
    }
    else {
        //Assert(&qt != &q);
        qt[0] = -q[1];
        qt[1] = q[0];
        qt[2] = -q[3];
        qt[3] = q[2];
        sclp = Math.sin((1.0 - t) * (0.5 * Math.PI));
        sclq = Math.sin(t * (0.5 * Math.PI));
        for (let i = 0; i < 3; i++) {
            qt[i] = sclp * p[i] + sclq * qt[i];
        }
    }
    //Assert(qt.IsValid());
}
//-----------------------------------------------------------------------------
// Purpose: resolve a global pose parameter to the specific setting for this sequence
//-----------------------------------------------------------------------------
//void Studio_LocalPoseParameter(const CStudioHdr *pStudioHdr, const float poseParameter[], mstudioseqdesc_t &seqdesc, int iSequence, int iLocalIndex, float &flSetting, int &index)
function Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, iSequence, iLocalIndex /*, flSetting, index*/) {
    let flSetting = 0;
    let index = 0;
    //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, seqdesc.paramindex[iLocalIndex]);
    const iPose = seqdesc.paramindex[iLocalIndex]; //TODOV2
    if (iPose == -1) {
        flSetting = 0;
        index = 0;
        return { s: flSetting, i: index };
    }
    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
    if (!Pose) {
        flSetting = 0;
        index = 0;
        return { s: flSetting, i: index };
    }
    //const flValue = poseParameter[iPose];
    let flValue = Pose.midpoint;
    if (poseParameter[Pose.name] !== undefined) {
        flValue = poseParameter[Pose.name];
    }
    if (Pose.loop) {
        const wrap = (Pose.start + Pose.end) / 2.0 + Pose.loop / 2.0;
        const shift = Pose.loop - wrap;
        flValue = flValue - Pose.loop * Math.floor((flValue + shift) / Pose.loop);
    }
    if (seqdesc.posekeyindex == 0) {
        const flLocalStart = (seqdesc.paramstart[iLocalIndex] - Pose.start) / (Pose.end - Pose.start);
        const flLocalEnd = (seqdesc.paramend[iLocalIndex] - Pose.start) / (Pose.end - Pose.start);
        // convert into local range
        flSetting = (flValue - flLocalStart) / (flLocalEnd - flLocalStart);
        // clamp.	This shouldn't ever need to happen if it's looping.
        if (flSetting < 0)
            flSetting = 0;
        if (flSetting > 1)
            flSetting = 1;
        index = 0;
        if (seqdesc.groupsize[iLocalIndex] > 2) {
            // estimate index
            index = Math.round(flSetting * (seqdesc.groupsize[iLocalIndex] - 1));
            if (index == seqdesc.groupsize[iLocalIndex] - 1)
                index = seqdesc.groupsize[iLocalIndex] - 2;
            flSetting = flSetting * (seqdesc.groupsize[iLocalIndex] - 1) - index;
        }
    }
    else {
        flValue = flValue * (Pose.end - Pose.start) + Pose.start;
        index = 0;
        // FIXME: this needs to be 2D
        // FIXME: this shouldn't be a linear search
        while (1) {
            flSetting = (flValue - seqdesc.poseKey(iLocalIndex, index)) / (seqdesc.poseKey(iLocalIndex, index + 1) - seqdesc.poseKey(iLocalIndex, index));
            //flSetting = 0;//TODOV2
            /*
            if (index > 0 && flSetting < 0.0)
            {
                index--;
                continue;
            }
            else
            */
            if (index < seqdesc.groupsize[iLocalIndex] - 2 && flSetting > 1.0) {
                index++;
                continue;
            }
            break;
        }
        // clamp.
        if (flSetting < 0.0)
            flSetting = 0.0;
        if (flSetting > 1.0)
            flSetting = 1.0;
    }
    return { s: flSetting, i: index };
}
function ScaleBones(pStudioHdr, //const CStudioHdr *pStudioHdr,
q1, //Quaternion q1[MAXSTUDIOBONES],
pos1, //Vector pos1[MAXSTUDIOBONES],
sequence, //int sequence,
s, //float s,
boneMask //int boneMask
) {
    let i, j; //int			i, j;
    let seqdesc = pStudioHdr.getSequenceById(sequence); //mstudioseqdesc_t & seqdesc = ((CStudioHdr *)pStudioHdr) -> pSeqdesc(sequence);
    /*
    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }
        */
    let s2 = s;
    let s1 = 1.0 - s2;
    for (i = 0; i < pStudioHdr.getBoneCount(); i++) {
        // skip unused bones
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
            QuaternionIdentityBlend(q1[i], s1, q1[i]);
            //VectorScale(pos1[i], s2, pos1[i]);
            scale$5(pos1[i], pos1[i], s2);
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: translate animations done in a non-standard parent space
//-----------------------------------------------------------------------------
/*
function CalcLocalHierarchyAnimation(
    pStudioHdr,//const CStudioHdr * pStudioHdr,
    boneToWorld: mat4,//matrix3x4_t * boneToWorld,
    boneComputed,//CBoneBitList & boneComputed,
    pos,//Vector * pos,
    q,//Quaternion * q,
    //const mstudioanimdesc_t &animdesc,
    pbone,//const mstudiobone_t * pbone,
    pHierarchy,//mstudiolocalhierarchy_t * pHierarchy,
    iBone: number,//int iBone,
    iNewParent: number,//int iNewParent,
    cycle: number,//float cycle,
    iFrame: number,//int iFrame,
    flFraq: number,//float flFraq,
    boneMask: number,//int boneMask
): void {

    let localPos = vec3.create();//Vector localPos;
    let localQ = quat.create();//Quaternion localQ;

    // make fake root transform
    //static ALIGN16 matrix3x4_t rootXform ALIGN16_POST(1.0f, 0, 0, 0, 0, 1.0f, 0, 0, 0, 0, 1.0f, 0);
    let rootXform = mat4.create();

    // FIXME: missing check to see if seq has a weight for this bone
    //float weight = 1.0f;
    let weight = 1;

    // check to see if there's a ramp on the influence
    if (pHierarchy -> tail - pHierarchy -> peak < 1.0f  )
    {
        float index = cycle;

        if (pHierarchy -> end > 1.0f && index < pHierarchy -> start)
        index += 1.0f;

        if (index < pHierarchy -> start)
            return;
        if (index >= pHierarchy -> end)
            return;

        if (index < pHierarchy -> peak && pHierarchy -> start != pHierarchy -> peak) {
            weight = (index - pHierarchy -> start) / (pHierarchy -> peak - pHierarchy -> start);
        }
        else if (index > pHierarchy -> tail && pHierarchy -> end != pHierarchy -> tail) {
            weight = (pHierarchy -> end - index) / (pHierarchy -> end - pHierarchy -> tail);
        }

        weight = SimpleSpline(weight);
    }

    CalcDecompressedAnimation(pHierarchy -> pLocalAnim(), iFrame - pHierarchy -> iStart, flFraq, localPos, localQ);

    BuildBoneChain(pStudioHdr, rootXform, pos, q, iBone, boneToWorld, boneComputed);

    matrix3x4_t localXform;
    AngleMatrix(localQ, localPos, localXform);

    if (iNewParent != -1) {
        BuildBoneChain(pStudioHdr, rootXform, pos, q, iNewParent, boneToWorld, boneComputed);
        ConcatTransforms(boneToWorld[iNewParent], localXform, boneToWorld[iBone]);
    }
    else {
        boneToWorld[iBone] = localXform;
    }

    // back solve
    Vector p1;
    Quaternion q1;
    int n = pbone[iBone].parent;
    if (n == -1) {
        if (weight == 1.0f)
        {
            MatrixAngles(boneToWorld[iBone], q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(boneToWorld[iBone], q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
    else {
        matrix3x4_t worldToBone;
        MatrixInvert(boneToWorld[n], worldToBone);

        matrix3x4_t local;
        ConcatTransforms(worldToBone, boneToWorld[iBone], local);
        if (weight == 1.0f)
        {
            MatrixAngles(local, q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(local, q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
}
    */
//-----------------------------------------------------------------------------
// Purpose: blend together in world space q1,pos1 with q2,pos2.  Return result in q1,pos1.
//			0 returns q1, pos1.  1 returns q2, pos2
//-----------------------------------------------------------------------------
/*
function WorldSpaceSlerp(
    pStudioHdr,//const CStudioHdr *pStudioHdr,
    q1: Array<quat>,//Quaternion q1[MAXSTUDIOBONES],
    pos1: Array<vec3>,//Vector pos1[MAXSTUDIOBONES],
    seqdesc,//mstudioseqdesc_t &seqdesc,
    sequence: number,//int sequence,
    q2: Array<quat>,//const Quaternion q2[MAXSTUDIOBONES],
    pos2: Array<vec3>,//const Vector pos2[MAXSTUDIOBONES],
    s: number,//float s,
    boneMask: number//int boneMask
): void {
    int			i, j;
    float		s1; // weight of parent for q2, pos2
    float		s2; // weight for q2, pos2

    // make fake root transform
    matrix3x4_t rootXform;
    SetIdentityMatrix(rootXform);

    // matrices for q2, pos2
    matrix3x4_t * srcBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList srcBoneComputed;

    matrix3x4_t * destBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList destBoneComputed;

    matrix3x4_t * targetBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList targetBoneComputed;

    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }

    mstudiobone_t * pbone = pStudioHdr -> pBone(0);

    for (i = 0; i < pStudioHdr -> numbones(); i++) {
        // skip unused bones
        if (!(pStudioHdr -> boneFlags(i) & boneMask)) {
            continue;
        }

        int n = pbone[i].parent;
        s1 = 0.0;
        if (pSeqGroup) {
            j = pSeqGroup -> boneMap[i];
            if (j >= 0) {
                s2 = s * seqdesc.weight(j);	// blend in based on this bones weight
                if (n != -1) {
                    s1 = s * seqdesc.weight(pSeqGroup -> boneMap[n]);
                }
            }
            else {
                s2 = 0.0;
            }
        }
        else {
            s2 = s * seqdesc.weight(i);	// blend in based on this bones weight
            if (n != -1) {
                s1 = s * seqdesc.weight(n);
            }
        }

        if (s1 == 1.0 && s2 == 1.0) {
            pos1[i] = pos2[i];
            q1[i] = q2[i];
        }
        else if (s2 > 0.0) {
            Quaternion srcQ, destQ;
            Vector srcPos, destPos;
            Quaternion targetQ;
            Vector targetPos;
            Vector tmp;

            BuildBoneChain(pStudioHdr, rootXform, pos1, q1, i, destBoneToWorld, destBoneComputed);
            BuildBoneChain(pStudioHdr, rootXform, pos2, q2, i, srcBoneToWorld, srcBoneComputed);

            MatrixAngles(destBoneToWorld[i], destQ, destPos);
            MatrixAngles(srcBoneToWorld[i], srcQ, srcPos);

            QuaternionSlerp(destQ, srcQ, s2, targetQ);
            AngleMatrix(targetQ, destPos, targetBoneToWorld[i]);

            // back solve
            if (n == -1) {
                MatrixAngles(targetBoneToWorld[i], q1[i], tmp);
            }
            else {
                matrix3x4_t worldToBone;
                MatrixInvert(targetBoneToWorld[n], worldToBone);

                matrix3x4_t local;
                ConcatTransforms(worldToBone, targetBoneToWorld[i], local);
                MatrixAngles(local, q1[i], tmp);

                // blend bone lengths (local space)
                pos1[i] = Lerp(s2, pos1[i], pos2[i]);
            }
        }
    }
    g_MatrixPool.Free(srcBoneToWorld);
    g_MatrixPool.Free(destBoneToWorld);
    g_MatrixPool.Free(targetBoneToWorld);
}
*/

class SourceAnimation {
    position = create$4();
    boneRot = create$4(); //TODO: remove me ?
    quaternion = create$2(); //TODOv2
    tempPos = create$4();
    tempRot = create$4();
    constructor(sourceModel) {
    }
    animate2(dynamicProp, poseParameters, position, orientation, sequences /*, bonesScale*/) {
        const model = dynamicProp.sourceModel;
        if (!model) {
            return;
        }
        const modelBones = model.getBones();
        if (!modelBones) {
            return;
        }
        dynamicProp.parent;
        const posRemoveMeTemp = [];
        const quatRemoveMeTemp = [];
        const modelBonesLength = modelBones.length;
        const seqlist = Object.keys(sequences);
        let posRemoveMe; // = [];//optimize
        let quatRemoveMe; // = [];//optimize
        if (seqlist.length) {
            let s;
            while (s = seqlist.shift()) {
                if (sequences[s].s) {
                    const sequenceMdl = sequences[s].s.mdl;
                    const t = Studio_Duration(sequenceMdl, sequences[s].s.id, poseParameters);
                    //InitPose(dynamicProp, sequenceMdl, posRemoveMeTemp, quatRemoveMeTemp, BONE_USED_BY_ANYTHING);
                    CalcPose(dynamicProp, sequenceMdl, undefined, posRemoveMeTemp, quatRemoveMeTemp, [], sequences[s].s.id, dynamicProp.frame / t, poseParameters, BONE_USED_BY_ANYTHING, 1.0, dynamicProp.frame / t);
                    if (sequenceMdl != model.mdl && sequenceMdl.boneNames) {
                        posRemoveMe = [];
                        quatRemoveMe = [];
                        const modelBoneArray = model.mdl.getBones();
                        for (let boneIndex = 0, l = modelBoneArray.length; boneIndex < l; ++boneIndex) {
                            const boneName = modelBoneArray[boneIndex].lowcasename;
                            const seqBoneId = sequenceMdl.boneNames[boneName];
                            posRemoveMe[boneIndex] = posRemoveMeTemp[seqBoneId];
                            quatRemoveMe[boneIndex] = quatRemoveMeTemp[seqBoneId];
                        }
                    }
                    else {
                        posRemoveMe = posRemoveMeTemp;
                        quatRemoveMe = quatRemoveMeTemp;
                    }
                }
            }
        }
        posRemoveMe = posRemoveMe || [];
        quatRemoveMe = quatRemoveMe || [];
        //const currentFrame = null;
        const seqList = Object.keys(sequences);
        const bonesRemoveMe = Object.create(null);
        for (let i = 0; i < seqList.length * 0; ++i) {
            const sequenceName = seqList[i];
            const seqContext = sequences[sequenceName];
            if (seqContext) {
                const sequence = seqContext.s;
                if (sequence) {
                    const sequenceBones = sequence.mdl.getBones();
                    if (sequenceBones) {
                        const g1 = Math.floor(sequence.groupsize1 / 2);
                        const g2 = Math.floor(sequence.groupsize2 / 2);
                        //g1 = g1RemoveMe;
                        //g2 = g2RemoveMe;
                        //g1 = 2;
                        const animIndex = sequence.getBlend(g1, g2); //TODOV2
                        sequence.mdl.getAnimDescription(animIndex);
                    }
                }
            }
        }
        Object.keys(bonesRemoveMe).forEach(function (boneName) {
            scale$5(bonesRemoveMe[boneName].pos, bonesRemoveMe[boneName].pos, 1 / bonesRemoveMe[boneName].count);
            scale$5(bonesRemoveMe[boneName].rot, bonesRemoveMe[boneName].rot, 1 / bonesRemoveMe[boneName].count);
            //vec3.scale(bonesRemoveMe[boneName].quat, bonesRemoveMe[boneName].quat, 1 / bonesRemoveMe[boneName].count);
            normalize$3(bonesRemoveMe[boneName].quat, bonesRemoveMe[boneName].quat);
        });
        for (let i = 0; i < modelBonesLength; ++i) {
            //let pbone = modelBones[i];
            //quatRemoveMeTemp[i] = quat.copy(quat.create(), pbone.quaternion);//removeme
            //posRemoveMeTemp[i] = vec3.copy(vec3.create(), pbone.position);
            let boneIndex = i;
            const bone = modelBones[i];
            zero$4(this.boneRot);
            zero$4(this.position);
            identity$1(this.quaternion);
            const bonesRemoveMeMe = bonesRemoveMe[bone.name];
            if (bonesRemoveMeMe !== undefined) ;
            else {
                copy$4(this.position, bone.position);
                //vec3.copy(this.boneRot, bone.rot);
                //quat.fromMat3(this.quaternion, mat3.fromEuler(SourceEngineTempMat3, bone.rot));
                quatFromEulerRad(this.quaternion, bone.rot[0], bone.rot[1], bone.rot[2]);
            }
            //const q = quat.fromMat3(quat.create(), mat3.fromEuler(SourceEngineTempMat3, this.boneRot));
            const posRemoveMeMe = posRemoveMe[bone.boneId];
            const quatRemoveMeMe = quatRemoveMe[bone.boneId];
            //bone.boneQuat = this.boneQuat;
            //bone.position = this.position;
            bone.parent;
            bone.lowcasename;
            //const parentMergedBone = bone.parentMergedBone;
            const dynamicPropBones = dynamicProp.skeleton._bones; //dynamicProp.bones;
            let dynamicPropBone = dynamicPropBones[boneIndex];
            if (dynamicPropBone === undefined) {
                //dynamicPropBone = {worldPos:vec3.create(), worldQuat:quat.create()};//TODO: optimize
                //dynamicPropBones[boneNameLowerCase] = dynamicPropBone;
                return;
            }
            //vec3.copy(dynamicPropBone.worldPos, bone.worldPos);
            //quat.copy(dynamicPropBone.worldQuat, bone.worldQuat);
            //dynamicProp.bones[boneNameLowerCase] = dynamicPropBones;
            /*
            if (bonesScale !== undefined) {
                const boneScale = bonesScale[bone.name];
                if (boneScale) {
                    mat4.scale(bone.boneMat, bone.boneMat, [boneScale, boneScale, boneScale]);
                }
            }
            */
            let b = dynamicPropBones[boneIndex];
            if (b) {
                if (!b.locked) {
                    b.quaternion = quatRemoveMeMe ?? b._initialQuaternion;
                    b.position = posRemoveMeMe ?? b._initialPosition;
                }
            }
            else {
                b = new MdlBone(dynamicProp.skeleton);
                dynamicProp.skeleton._bones[boneIndex] = b;
                b.boneId = bone.boneId;
                b.name = bone.name;
                b.quaternion = bone.quaternion;
                b.position = bone.position;
                b.parentBone = bone.parentBone;
                b.parent = dynamicProp.skeleton._bones[b.parentBone];
                b.poseToBone = bone.poseToBone;
                b.initPoseToBone = bone.initPoseToBone;
            }
        }
        return;
    }
}

function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

let animSpeed = 1.0;
const defaultMaterial = new MeshBasicMaterial();
class Source1ModelInstance extends Entity {
    isSource1ModelInstance = true;
    #poseParameters = {};
    #flexParameters = {};
    #flexesWeight = new Float32Array(MAX_STUDIO_FLEX_DESC);
    #materialOverride;
    #animations = new Animations();
    #skeleton;
    #skin = 0;
    #attachements = {};
    #materialsUsed = new Set();
    animable = true;
    hasAnimations = true;
    sourceModel;
    bodyParts = {};
    sequences = {};
    meshes = new Set();
    frame = 0;
    anim = new SourceAnimation(); //TODO: removeme
    animationSpeed = 1.0;
    isDynamic;
    #sheen;
    #tint;
    static useNewAnimSystem = false;
    useNewAnimSystem = false;
    #animationList = [];
    #bodyGroups = new Map();
    static {
        defaultMaterial.addUser(Source1ModelInstance);
    }
    constructor(params) {
        super(params);
        this.sourceModel = params.sourceModel;
        this.name = this.sourceModel.name;
        if (params.isDynamic) {
            this.#createSkeleton();
        }
        this.isDynamic = params.isDynamic;
        if (!params.preventInit) {
            this.#init();
        }
        if (params.isDynamic) {
            this.#initSkeleton();
            this.#initAttachements();
        }
        this.#updateMaterials();
    }
    get skeleton() {
        return this.#skeleton;
    }
    set skeleton(skeleton) {
        this.#skeleton = skeleton;
    }
    #createSkeleton() {
        this.#skeleton = new Skeleton({ name: `Skeleton ${this.name}` });
        return super.addChild(this.#skeleton);
    }
    addChild(child) {
        let ret = super.addChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(this.#skeleton);
        }
        return ret;
    }
    removeChild(child) {
        super.removeChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(null);
        }
    }
    set skin(skin) {
        this.setSkin(skin);
    }
    get skin() {
        return this.#skin;
    }
    async setSkin(skin) {
        this.#skin = skin;
        await this.#updateMaterials();
    }
    set sheen(sheen) {
        this.#sheen = sheen;
        //SHADER_PARAM( SHEENMAPMASKSCALEX, SHADER_PARAM_TYPE_FLOAT, '1', 'X Scale the size of the map mask to the size of the target' )
        //SHADER_PARAM( SHEENMAPMASKSCALEY, SHADER_PARAM_TYPE_FLOAT, '1', 'Y Scale the size of the map mask to the size of the target' )
        //SHADER_PARAM( SHEENMAPMASKOFFSETX, SHADER_PARAM_TYPE_FLOAT, '0', 'X Offset of the mask relative to model space coords of target' )
        //SHADER_PARAM( SHEENMAPMASKOFFSETY, SHADER_PARAM_TYPE_FLOAT, '0', 'Y Offset of the mask relative to model space coords of target' )
        //SHADER_PARAM( SHEENMAPMASKDIRECTION, SHADER_PARAM_TYPE_INTEGER, '0', 'The direction the sheen should move (length direction of weapon) XYZ, 0,1,2' )
        const dimensions = this.sourceModel.mdl.getDimensions(create$4());
        const dimensionsMin = this.sourceModel.mdl.getBBoxMin(create$4());
        const dimMax = Math.max(dimensions[0], dimensions[1], dimensions[2]);
        const direction = 0;
        let scaleX = 1;
        let scaleY = 1;
        let offsetX = 0;
        let offsetY = 0;
        for (let i = 0; i < 3; ++i) {
            if (dimMax == dimensions[i]) {
                //let direction = i;
                scaleX = dimMax;
                offsetX = dimensionsMin[i];
            }
        }
        this.materialsParams['SheenTintColor'] = fromValues$4(sheen[0], sheen[1], sheen[2]);
        this.materialsParams['SheenMaskScaleX'] = scaleX;
        this.materialsParams['SheenMaskScaleY'] = scaleX; //TODOv3: set y scale
        this.materialsParams['SheenMaskOffsetX'] = offsetX;
        this.materialsParams['SheenMaskOffsetY'] = offsetX; //TODOv3: set y offset
        this.materialsParams['SheenMaskDirection'] = direction;
        let min = create$4();
        let max = create$4();
        this.getBoundsModelSpace(min, max);
        //console.error(min, max);
        scaleX = max[0] - min[0];
        offsetX = min[0];
        scaleY = max[2] - min[2];
        offsetY = min[2];
        let sheenDir = 0;
        if (max[1] - min[1] > scaleX) {
            scaleX = max[1] - min[1];
            offsetX = min[1];
            scaleY = max[0] - min[0];
            offsetY = min[0];
            sheenDir = 2;
        }
        if (max[2] - min[2] > scaleX) {
            scaleX = max[2] - min[2];
            offsetX = min[2];
            scaleY = max[1] - min[1];
            offsetY = min[1];
            sheenDir = 1;
        }
        this.materialsParams['SheenMaskScaleX'] = scaleX;
        this.materialsParams['SheenMaskScaleY'] = scaleY; //TODOv3: set y scale
        this.materialsParams['SheenMaskOffsetX'] = offsetX;
        this.materialsParams['SheenMaskOffsetY'] = offsetY; //TODOv3: set y offset
        this.materialsParams['SheenMaskDirection'] = sheenDir;
    }
    set tint(tint) {
        this.#tint = tint;
        this.materialsParams['ItemTintColor'] = tint;
    }
    getTint(out) {
        if (this.#tint) {
            out = copy$3(out ?? create$3(), this.#tint);
            return out;
        }
    }
    setPoseParameter(paramName, paramValue) {
        this.#poseParameters[paramName] = paramValue;
    }
    playAnimation(name) {
        this.playSequence(name);
    }
    async setAnimation(id, name, weight) {
        //TODO: merge with addAnimation
        this.#animationList[id] = { name: name, weight: weight };
        this.#animations.clear();
        for (const [index, anim] of this.#animationList.entries()) {
            if (anim) {
                await this.addAnimation(index, anim.name, anim.weight);
            }
        }
    }
    playSequence(sequenceName) {
        sequenceName = sequenceName.toLowerCase();
        let existingSequence = this.sequences[sequenceName];
        this.sequences = Object.create(null); //TODOv2
        this.sequences[sequenceName] = existingSequence ?? {};
        /*{
            startTime : -1
        }*/
        this.frame = 0;
    }
    async addAnimation(id, animationName, weight = 1) {
        //TODO: merge with setAnimation
        animationName = animationName.toLowerCase();
        if (!this.#animations.setWeight(id, weight)) {
            //let animation = new Animation(animationName);
            //this.#fillAnimation(animation);
            this.#animations.set(id, new AnimationDescription(await this.sourceModel.getAnimation(animationName, this), weight));
        }
    }
    update(scene, camera, delta) {
        if (this.#skeleton && this.isPlaying()) {
            this._playSequences(delta * animSpeed * this.animationSpeed);
            this.#skeleton.setBonesMatrix();
        }
        for (let mesh of this.meshes) {
            if (mesh.skeleton) {
                mesh.skeleton.setBonesMatrix();
            }
        }
    }
    _playSequences(delta) {
        if (Source1ModelInstance.useNewAnimSystem || this.useNewAnimSystem) {
            this.frame += delta;
            this.#animate();
            return;
        }
        this.frame += delta;
        const now = new Date().getTime();
        const seqList = Object.keys(this.sequences);
        if (seqList.length === 0) {
            return;
        }
        for (let i = 0; i < seqList.length; ++i) {
            const sequenceName = seqList[i];
            const seqContext = this.sequences[sequenceName];
            let sequence;
            if (seqContext) {
                sequence = seqContext.s;
                if (!sequence) {
                    this.sourceModel.mdl.getSequence(sequenceName).then((sequence) => {
                        if (sequence) {
                            seqContext.s = sequence;
                            seqContext.startTime = now;
                            if (sequence.autolayer) {
                                const autoLayerList = sequence.autolayer;
                                for (let autoLayerIndex = 0; autoLayerIndex < autoLayerList.length; ++autoLayerIndex) {
                                    autoLayerList[autoLayerIndex];
                                }
                            }
                        }
                    });
                }
            }
            if (sequence) {
                sequence.play(this); //TODOv2: play autolayer ?
            }
        }
        this.anim.animate2(this, this.#poseParameters, this.position, this.quaternion, this.sequences);
    }
    #animate() {
        const skeleton = this.#skeleton;
        if (!skeleton) {
            return;
        }
        for (const bone of skeleton._bones) {
            zero$4(bone.tempPosition);
            identity$1(bone.tempQuaternion);
        }
        create$4(); //TODO:optimize
        create$2();
        for (const [_, animationDescription] of this.#animations) {
            if (!animationDescription) {
                continue;
            }
            //console.info(animation);
            const animation = animationDescription.animation;
            if (!animation) {
                continue;
            }
            /*
            if (!animation.once) {
                animation.once = true;
                const frame = animation.getFrame(10);
                const rotationData = frame.getData('rotation');

                var arr = []
                for (const data of rotationData.datas as Array<quat>) {
                    let s = '';
                    for (let i = 0; i < 4; i++) {
                        s += data[i].toFixed(2) + ' ';
                    }
                    arr.push(s);
                }
                console.info(arr);

            }
    */
            for (const bone of animation.bones) {
                const skeletonBone = skeleton.getBoneById(bone.id);
                if (!skeletonBone) {
                    continue;
                }
                //skeletonBone.poseToBone = bone.refPos;
                const frame = animation.getFrame(this.frame * 30);
                if (frame) {
                    const flagData = frame.getData('flags');
                    if (!flagData) {
                        continue;
                    }
                    const flag = flagData.datas[bone.id];
                    if (flag === undefined) {
                        copy$4(skeletonBone.tempPosition, bone.refPosition);
                        copy$2(skeletonBone.tempQuaternion, bone.refQuaternion);
                        continue;
                    }
                    const positionData = frame.getData('position');
                    if (positionData && positionData.datas[bone.id]) {
                        if (flag & STUDIO_ANIM_DELTA) {
                            add$5(skeletonBone.tempPosition, skeletonBone.tempPosition, positionData.datas[bone.id]);
                        }
                        else {
                            copy$4(skeletonBone.tempPosition, positionData.datas[bone.id]);
                        }
                    }
                    const rotationData = frame.getData('rotation');
                    if (rotationData && rotationData.datas[bone.id]) {
                        if (flag & STUDIO_ANIM_DELTA) {
                            mul$2(skeletonBone.tempQuaternion, skeletonBone.tempQuaternion, rotationData.datas[bone.id]);
                        }
                        else {
                            copy$2(skeletonBone.tempQuaternion, rotationData.datas[bone.id]);
                        }
                    }
                }
            }
            /*
            let b = dynamicPropBones[boneIndex];
            if (b) {
                if (!b.locked) {
                    b.quaternion = quatRemoveMeMe ?? b._initialQuaternion;
                    b.position = posRemoveMeMe ?? b._initialPosition;
                }
            } else {
                b = new MdlBone(dynamicProp.skeleton);
                dynamicProp.skeleton._bones[boneIndex] = b;
                b.boneId = bone.boneId;
                b.name = bone.name;
                b.quaternion = bone.quaternion;
                b.position = bone.position;
                b.parentBone = bone.parentBone;
                b.parent = dynamicProp.skeleton._bones[b.parentBone];
                b.poseToBone = bone.poseToBone;
                b.initPoseToBone = bone.initPoseToBone;
            }*/
        }
        for (const bone of skeleton._bones) {
            if (!bone.locked) {
                bone.position = bone.tempPosition;
                bone.quaternion = bone.tempQuaternion;
            }
        }
    }
    async setMaterialOverride(materialOverride) {
        this.#materialOverride = materialOverride;
        await this.#updateMaterials();
    }
    async #updateMaterials() {
        for (let mesh of this.meshes) {
            let material;
            let materialName;
            if (!material) {
                materialName = this.sourceModel.mdl.getMaterialName(this.#skin, mesh.properties.get('materialId'));
                material = await SourceEngineMaterialManager.getMaterial(this.sourceModel.repository, materialName, this.sourceModel.mdl.getTextureDir());
            }
            if (this.#materialOverride) {
                material = this.#materialOverride;
            }
            if (material) {
                this.#materialsUsed.add(material);
                material.addUser(this);
                mesh.setMaterial(material);
                mesh.properties.set('materialName', materialName);
                material.properties.set('materialType', mesh.properties.get('materialType')); //TODOv3 : setup a better material param
                material.properties.set('materialParam', mesh.properties.get('materialParam')); //TODOv3 : setup a better material param
                material.properties.set('eyeballArray', mesh.properties.get('eyeballArray')); //TODOv3 : setup a better material param
                material.properties.set('skeleton', mesh.skeleton); //TODOv3 : setup a better material param
            }
        }
    }
    #init() {
        let sourceModel = this.sourceModel;
        for (let [bodyPartName, bodyPart] of sourceModel.bodyParts) {
            //let newBodyPart = [];
            //let defaul = undefined;//TODOv3: change variable name;
            let group = new Entity({ name: bodyPartName });
            this.addChild(group);
            group.serializable = false;
            for (let modelId in bodyPart) {
                let model = bodyPart[modelId];
                if (model) {
                    let group2 = new Entity();
                    group2.properties.set('modelId', modelId);
                    group2.name = `${bodyPartName} ${modelId}`;
                    if (Number(modelId) != 0) {
                        group2.setVisible(false);
                    }
                    group.addChild(group2);
                    for (let modelMesh of model) {
                        let geometry = modelMesh.geometry;
                        let mesh;
                        if (this.#skeleton) {
                            mesh = new SkeletalMesh(geometry.clone(), defaultMaterial, this.#skeleton);
                        }
                        else {
                            mesh = new Mesh(geometry, defaultMaterial);
                        }
                        mesh.name = geometry.properties.get('name');
                        mesh.properties.set('sourceModelMesh', modelMesh.mesh);
                        if (geometry.hasAttribute('aVertexTangent')) {
                            mesh.setDefine('USE_VERTEX_TANGENT');
                        }
                        //mesh.visible = defaul;
                        mesh.properties.set('materialId', geometry.properties.get('materialId'));
                        mesh.properties.set('materialType', geometry.properties.get('materialType'));
                        mesh.properties.set('materialParam', geometry.properties.get('materialParam'));
                        mesh.properties.set('eyeballArray', geometry.properties.get('eyeballArray'));
                        mesh.materialsParams = this.materialsParams;
                        //this.addChild(mesh);
                        this.meshes.add(mesh);
                        group2.addChild(mesh);
                    }
                    //newBodyPart.push(newModel);
                }
                //defaul = false;
            }
            //this.bodyParts[bodyPartName] = newBodyPart;
            this.bodyParts[bodyPartName] = group;
        }
    }
    #initSkeleton() {
        let bones = this.sourceModel.getBones();
        if (bones) {
            for (let bone of bones) {
                let skeletonBone = this.#skeleton.addBone(bone.boneId, bone.name);
                skeletonBone._initialQuaternion = copy$2(create$2(), bone.quaternion);
                skeletonBone._initialPosition = copy$4(create$4(), bone.position);
                let parentBoneId = bone.parentBone;
                skeletonBone.poseToBone = bone.poseToBone;
                if (parentBoneId >= 0) {
                    let parentBone = this.#skeleton._bones[parentBoneId];
                    parentBone.addChild(skeletonBone);
                    //skeletonBone.parent = this.#skeleton._bones[parentBone];
                    if (!skeletonBone.parent) {
                        console.error('parent not found : ' + bone.name);
                    }
                }
                else {
                    this.#skeleton.addChild(skeletonBone);
                }
            }
        }
    }
    #initAttachements() {
        let attachements = this.sourceModel.getAttachments();
        let localMat3 = create$6(); //todo: optimize
        if (attachements) {
            for (let attachement of attachements) {
                let attachementBone = new Bone({ name: attachement.name });
                localMat3[0] = attachement.local[0];
                localMat3[3] = attachement.local[1];
                localMat3[6] = attachement.local[2];
                localMat3[1] = attachement.local[4];
                localMat3[4] = attachement.local[5];
                localMat3[7] = attachement.local[6];
                localMat3[2] = attachement.local[8];
                localMat3[5] = attachement.local[9];
                localMat3[8] = attachement.local[10];
                set$5(attachementBone._position, attachement.local[3], attachement.local[7], attachement.local[11]);
                fromMat3(attachementBone._quaternion, localMat3);
                let bone = this.#skeleton.getBoneById(attachement.localbone);
                bone.addChild(attachementBone);
                this.#attachements[attachement.lowcasename] = attachementBone;
            }
        }
    }
    getBoneById(boneId) {
        return this.#skeleton ? this.#skeleton.getBoneById(boneId) : null;
    }
    /*
    setBodyGroup(bodyPartName, bodyPartModelId) {
        let bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            for (let index = 0, l = bodyPart.length; index < l; index++) {
                let meshes = bodyPart[index];
                let visible = false;
                if (index === bodyPartModelId) {
                    visible = true;
                }
                for (let mesh of meshes) {
                    mesh.visible = visible;
                }
            }
        }
    }
    */
    renderBodyParts(render) {
        for (let bodyPartName in this.bodyParts) {
            this.renderBodyPart(bodyPartName, render);
            /*let bodyPart = this.bodyParts[bodyPartName];
            if (bodyPart) {
                for (let model of bodyPart) {
                    for (let model of bodyPart) {
                        model.visible = render ? undefined : false;
                    }
                }
            }*/
        }
    }
    renderBodyPart(bodyPartName, render) {
        let bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            bodyPart.setVisible(render ? undefined : false);
            /*for (let model of bodyPart) {
                for (let mesh of model) {
                    mesh.visible = render ? undefined : false;
                }
            }*/
        }
    }
    resetBodyPartModels() {
        for (let bodyPartName in this.bodyParts) {
            this.setBodyPartModel(bodyPartName, 0);
        }
    }
    setBodyPartIdModel(bodyPartId, modelId) {
        const bodypart = this.sourceModel.getBodyPart(bodyPartId);
        if (bodypart) {
            this.setBodyPartModel(bodypart.name, modelId);
        }
    }
    setBodyPartModel(bodyPartName, modelId) {
        let bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            //let id = 0;
            for (let bodyPartModel of bodyPart.children) {
                //let bodyPartModel = bodyPart.children.get(id);
                bodyPartModel.setVisible((bodyPartModel.properties.get('modelId') == modelId) ? undefined : false);
                //++id;
            }
        }
        //this.sourceModel.setBodyPartModel(bodyPartName, modelId);
        //this.bodyGroups[bodyPartName] = this.bodyGroups[bodyPartName] || {render : true, modelId : 0};
        //this.bodyGroups[bodyPartName].modelId = modelId;
        this.#bodyGroups.set(bodyPartName, Number(modelId));
    }
    getBodyGroups() {
        return new Map(this.#bodyGroups);
    }
    toString() {
        return 'Source1ModelInstance ' + super.toString();
    }
    attachSystem(system, attachementName = '', cpIndex = 0, offset) {
        this.addChild(system);
        let attachement = this.getAttachement(attachementName);
        if (attachement) {
            let controlPoint = system.getControlPoint(cpIndex);
            attachement.addChild(controlPoint);
        }
        else {
            this.attachSystemToBone(system, attachementName, offset);
        }
        if (offset) {
            system.getControlPoint(0).position = offset;
        }
    }
    attachSystemToBone(system, boneName, offset) {
        if (!this.#skeleton) {
            return;
        }
        this.addChild(system);
        let controlPoint = system.getControlPoint(0);
        let bone = this.#skeleton.getBoneByName(boneName);
        if (bone) {
            bone.addChild(controlPoint);
        }
        else {
            this.addChild(controlPoint);
        }
    }
    getAttachement(attachementName) {
        return this.#attachements[attachementName.toLowerCase()];
    }
    getBoneByName(boneName) {
        if (!this.#skeleton) {
            return;
        }
        return this.#skeleton.getBoneByName(boneName);
    }
    set material(material) {
        for (let bodyPartName in this.bodyParts) {
            let bodyPart = this.bodyParts[bodyPartName];
            let meshes = bodyPart.getChildList('Mesh');
            for (let mesh of meshes) {
                mesh.setMaterial(material);
            }
        }
        let subModels = this.getChildList('Source1ModelInstance');
        for (let subModel of subModels) {
            if (subModel !== this) {
                subModel.material = material;
            }
        }
    }
    buildContextMenu() {
        //console.error();
        let skins = this.sourceModel.mdl.getSkinList();
        let skinMenu = [];
        for (let skin of skins) {
            let item = Object.create(null);
            item.name = skin;
            item.f = () => this.skin = skin;
            skinMenu.push(item);
        }
        return Object.assign(super.buildContextMenu(), {
            Source1ModelInstance_1: null,
            skin: { i18n: '#skin', submenu: skinMenu },
            tint: { i18n: '#tint', f: async (entity) => new Interaction().getColor(0, 0, undefined, (tint) => { entity.tint = tint; }, (tint = entity.tint) => { entity.tint = tint; }) },
            reset_tint: { i18n: '#reset_tint', f: (entity) => entity.tint = undefined, disabled: this.#tint === undefined },
            animation: { i18n: '#animation', f: async (entity) => { let animation = await new Interaction().getString(0, 0, await entity.sourceModel.mdl.getAnimList()); if (animation) {
                    entity.playSequence(animation);
                } } },
            overrideallmaterials: { i18n: '#overrideallmaterials', f: async (entity) => { let material = await new Interaction().getString(0, 0, Object.keys(Material.materialList)); if (material) {
                    entity.material = new Material.materialList[material];
                } } },
            Source1ModelInstance_2: null,
            animate: { i18n: '#animate', selected: this.animationSpeed != 0.0, f: () => this.animationSpeed == 0 ? this.animationSpeed = 1 : this.animationSpeed = 0 },
            frame: { i18n: '#frame', f: () => { let frame = prompt('Frame', String(this.frame)); if (frame) {
                    this.animationSpeed = 0;
                    this.frame = Number(frame);
                } } },
            Source1ModelInstance_3: null,
            copy_filename: { i18n: '#copy_filename', f: () => navigator.clipboard.writeText(this?.sourceModel?.fileName) },
        });
    }
    getParentModel() {
        return this;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        let hitboxes = this.getHitboxes();
        let hitbox = hitboxes[getRandomInt(hitboxes.length)];
        let bone = hitbox.parent; //this.getBoneById(hitbox.boneId);
        if (bone) {
            bones.push([bone, 1]);
            vec3RandomBox(vec, hitbox.boundingBoxMin, hitbox.boundingBoxMax);
            //vec3.transformMat4(vec, vec, bone.boneMat);
            copy$4(initialVec, vec);
            transformMat4$2(vec, vec, fromRotationTranslationScale(create$5(), bone.worldQuat, bone.worldPos, bone.worldScale));
        }
        return vec;
    }
    set position(position) {
        super.position = position;
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    get position() {
        return clone$4(this._position);
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    get quaternion() {
        return clone$2(this._quaternion);
    }
    static set animSpeed(speed) {
        let s = Number(speed);
        animSpeed = Number.isNaN(s) ? 1 : s;
    }
    setFlexes(flexes = {}) {
        this.#flexParameters = flexes;
        this.#refreshFlexes();
    }
    resetFlexParameters() {
        this.#flexParameters = {};
        this.#refreshFlexes();
    }
    #refreshFlexes() {
        this.sourceModel.mdl.runFlexesRules(this.#flexParameters, this.#flexesWeight);
        for (let mesh of this.meshes) {
            if (mesh && mesh.geometry) {
                let attribute = mesh.geometry.getAttribute('aVertexPosition');
                let newAttribute = attribute.clone();
                mesh.geometry.setAttribute('aVertexPosition', newAttribute);
                const sourceModelMesh = mesh.properties.get('sourceModelMesh');
                this.#updateArray(newAttribute._array, sourceModelMesh.flexes, sourceModelMesh.vertexoffset);
            }
        }
    }
    #updateArray(vertexPositionArray, flexes, vertexoffset) {
        let flexesWeight = this.#flexesWeight;
        if (flexes && flexes.length) {
            for (let flexIndex = 0; flexIndex < flexes.length; ++flexIndex) {
                const flex = flexes[flexIndex];
                //const g_flexdescweight = this.mdl.g_flexdescweight;
                const w1 = flexesWeight[flex.flexdesc];
                let w3 = w1;
                if (flex.flexpair) {
                    w3 = flexesWeight[flex.flexpair];
                }
                if (w1) {
                    const vertAnims = flex.vertAnims;
                    //let good = 0;
                    //let bad = 0;
                    for (let vertAnimsIndex = 0; vertAnimsIndex < vertAnims.length; ++vertAnimsIndex) {
                        const vertAnim = vertAnims[vertAnimsIndex];
                        const b = vertAnim.side / 255.0;
                        //console.error(b);
                        const w = w1 * (1.0 - b) + b * w3;
                        const flDelta = vertAnim.flDelta;
                        vertAnim.flNDelta;
                        //const vertexIndex = vertAnim.index * 3;
                        //const vertexIndexArray = this.verticesPositionToto[vertAnim.index];
                        let vertexIndex = (vertexoffset + vertAnim.index) * 3;
                        vertexPositionArray[vertexIndex + 0] += flDelta[0] * w;
                        vertexPositionArray[vertexIndex + 1] += flDelta[1] * w;
                        vertexPositionArray[vertexIndex + 2] += flDelta[2] * w;
                        //vertexPositionArray[vertexIndex + 0] += 0;
                        //vertexPositionArray[vertexIndex + 1] += 0;
                        //vertexPositionArray[vertexIndex + 2] += 0;
                        /*
                        if (vertexIndexArray) {
                            for (let vertexIndexArrayIndex = 0; vertexIndexArrayIndex < vertexIndexArray.length; ++vertexIndexArrayIndex) {
                                let vertexIndex = vertexIndexArray[vertexIndexArrayIndex];
                                vertexPositionArray[vertexIndex + 0] += flDelta[0] * w;
                                vertexPositionArray[vertexIndex + 1] += flDelta[1] * w;
                                vertexPositionArray[vertexIndex + 2] += flDelta[2] * w;

                                /*normalArray[vertexIndex + 0] += flNDelta[0] * w;
                                normalArray[vertexIndex + 1] += flNDelta[1] * w;
                                normalArray[vertexIndex + 2] += flNDelta[2] * w;* /
                                ++good;
                            }
                        } else {
                            ++bad;
                        }*/
                    }
                }
            }
        }
    }
    async playDefaultAnim() {
        let animList = await this.sourceModel.mdl.getAnimList();
        if (animList && animList.size > 0) {
            this.playSequence(animList.keys().next().value);
        }
    }
    getHitboxes() {
        let mdlHitboxSets = this.sourceModel.mdl.hitboxSets;
        let hitboxes = [];
        if (mdlHitboxSets) {
            for (let mdlHitboxSet of mdlHitboxSets) {
                let mdlHitboxes = mdlHitboxSet.hitboxes;
                for (let mdlHitbox of mdlHitboxes) {
                    hitboxes.push(new Hitbox(mdlHitbox.name, mdlHitbox.bbmin, mdlHitbox.bbmax, this.getBoneById(mdlHitbox.boneId)));
                }
            }
        }
        return hitboxes;
    }
    replaceMaterial(material, recursive = true) {
        super.replaceMaterial(material, recursive);
        for (let mesh of this.meshes) {
            mesh.material = material;
        }
    }
    resetMaterial(recursive = true) {
        super.resetMaterial(recursive);
        this.#updateMaterials();
    }
    getAnimations() {
        return this.sourceModel.mdl.getAnimList();
    }
    toJSON() {
        let json = super.toJSON();
        json.skin = this.skin;
        json.repository = this.sourceModel.repository;
        json.filename = this.sourceModel.fileName;
        json.dynamic = this.isDynamic;
        if (this.#skeleton) {
            json.skeletonid = this.#skeleton.id;
        }
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        let entity = await Source1ModelManager.createInstance(json.repository, json.filename, false /*dynamic*/, true);
        loadedPromise.then(() => {
            if (json.dynamic) {
                if (json.skeletonid) {
                    entity.skeleton = entities.get(json.skeletonid);
                }
                if (!entity.skeleton) {
                    entity.#createSkeleton();
                    entity.#initSkeleton();
                    entity.#initAttachements();
                }
                entity.isDynamic = true;
            }
            entity.#init();
            entity.#updateMaterials();
            if (entity._parent) {
                entity._parent.addChild(entity);
            }
        });
        return entity;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.skin = json.skin ?? 0;
        //TODO
    }
    dispose() {
        super.dispose();
        this.#skeleton.dispose();
        for (const material of this.#materialsUsed) {
            material.removeUser(this);
        }
        for (const mesh of this.meshes) {
            mesh.dispose();
        }
    }
    static getEntityName() {
        return 'Source1Model';
    }
    is(s) {
        if (s == 'Source1ModelInstance') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(Source1ModelInstance);

//-----------------------------------------------------------------------------
// Purpose: returns array of animations and weightings for a sequence based on current pose parameters
//-----------------------------------------------------------------------------
//void Studio_SeqAnims(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameter[], mstudioanimdesc_t *panim[4], float *weight)
function Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameter, panim, weight) {
    /*if (!pStudioHdr || iSequence >= pStudioHdr.GetNumSeq())
    {
        weight[0] = weight[1] = weight[2] = weight[3] = 0.0;
        return;
    }*/
    const i0 = 0, i1 = 0;
    const s0 = 0, s1 = 0;
    //Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, iSequence, 0, s0, i0);TODOV2
    //	Studio_LocalPoseParameter(pStudioHdr, poseParameter, seqdesc, iSequence, 1, s1, i1);
    //panim[0] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1)));
    panim[0] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1));
    weight[0] = (1 - s0) * (1 - s1);
    //panim[1] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1)));
    panim[1] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1));
    weight[1] = (s0) * (1 - s1);
    //panim[2] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1+1)));
    panim[2] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1 + 1));
    weight[2] = (1 - s0) * (s1);
    //panim[3] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1+1)));
    panim[3] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1 + 1));
    weight[3] = (s0) * (s1);
}
//-----------------------------------------------------------------------------
// Purpose: returns cycles per second of a sequence (cycles/second)
//-----------------------------------------------------------------------------
//float Studio_CPS(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameter[])
function Studio_CPS2(pStudioHdr, seqdesc, iSequence, poseParameter) {
    const panim = [];
    const weight = [];
    Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameter, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        if (panim[i] && weight[i] > 0 && panim[i].numframes > 1) {
            t += (panim[i].fps / (panim[i].numframes - 1)) * weight[i];
            //setAnimLength(panim[i].numframes);//TODOv3
        }
    }
    return t;
}
function Studio_Frames2(pStudioHdr, seqdesc, iSequence, poseParameter) {
    const panim = [];
    const weight = [];
    Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameter, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        if (panim[i] && weight[i] > 0) {
            t = Math.max(t, panim[i].numframes);
        }
    }
    return t;
}
function StudioFrames2(pStudioHdr, iSequence, poseParameter) {
    const seqdesc = pStudioHdr.getSequenceById(iSequence); //pStudioHdr.pSeqdesc(iSequence);
    return Studio_Frames2(pStudioHdr, seqdesc, iSequence, poseParameter);
}
const SOURCE_MODEL_MAX_BONES = 256;
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
function InitPose2(dynamicProp, pStudioHdr, pos, q, boneMask) {
    if (pStudioHdr.pLinearBones === undefined) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            {
                const pbone = pStudioHdr.getBone(i);
                pos[i] = pos[i] || create$4(); //removeme
                q[i] = q[i] || create$2(); //removeme
                copy$4(pos[i], pbone.position);
                copy$2(q[i], pbone.quaternion);
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
//function CalcPose(pStudioHdr, pIKContext, pos, q, sequence, cycle, poseParameter, boneMask, flWeight = 1.0, flTime = 0.0) {
function CalcPose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    cycle = cycle % 1; //TODOv2
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc) {
        //Assert(flWeight >= 0.0f && flWeight <= 1.0f);
        // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
        flWeight = clamp(flWeight, 0.0, 1.0);
        // add any IK locks to prevent numautolayers from moving extremities
        //CIKContext seq_ik;TODOv2
        /*
        if (false && seqdesc.numiklocks) {//TODOV2
            seq_ik.Init(pStudioHdr, vec3_angle, vec3_origin, 0.0, 0, boneMask); // local space relative so absolute position doesn't mater
            seq_ik.AddSequenceLocks(seqdesc, pos, q);
        }
            */
        CalcPoseSingle2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime);
        if (pIKContext) {
            pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameter, flWeight);
        }
        AddSequenceLayers2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight);
        /*
                if (false && seqdesc.numiklocks) {//TODOV2
                    seq_ik.SolveSequenceLocks(seqdesc, pos, q);
                }
                    */
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
//TODOv2: put somewhere else
const STUDIO_LOOPING = 0x0001; // ending frame should be the same as the starting frame
const STUDIO_DELTA = 0x0004; // this sequence 'adds' to the base sequences, not slerp blends
const STUDIO_ALLZEROS = 0x0020; // this animation/sequence has no real animation data
//						0x0040
const STUDIO_CYCLEPOSE = 0x0080; // cycle index is taken from a pose parameter index
const STUDIO_REALTIME = 0x0100; // cycle index is taken from a real-time clock, not the animations cycle index
const STUDIO_LOCAL = 0x0200; // sequence has a local context sequence
const CalcPoseSingle_pos2 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_q2 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_pos3 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_q3 = Array(SOURCE_MODEL_MAX_BONES);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES; i++) {
    CalcPoseSingle_pos2[i] = create$4();
    CalcPoseSingle_q2[i] = create$2();
    CalcPoseSingle_pos3[i] = create$4();
    CalcPoseSingle_q3[i] = create$2();
}
function CalcPoseSingle2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime) {
    let bResult = true;
    const pos2 = CalcPoseSingle_pos2; //[];//vec3.create();//TODOv2: optimize (see source)
    const q2 = CalcPoseSingle_q2; //[];//quat.create();//TODOv2: optimize (see source)
    const pos3 = CalcPoseSingle_pos3; //[];//vec3.create();//TODOv2: optimize (see source)
    const q3 = CalcPoseSingle_q3;
    for (let i = 0; i < SOURCE_MODEL_MAX_BONES; ++i) {
        zero$4(pos2[i]);
        identity$1(q2[i]);
        zero$4(pos3[i]);
        identity$1(q3[i]);
    }
    /*	if (sequence >= pStudioHdr->GetNumSeq())TODOv2
        {
            sequence = 0;
            seqdesc = pStudioHdr->pSeqdesc(sequence);
        }*/
    let i0 = 0, i1 = 0;
    let s0 = 0, s1 = 0;
    const r0 = Studio_LocalPoseParameter2(pStudioHdr, poseParameter, seqdesc, sequence, 0 /*, s0, i0 */); //TODOv2
    const r1 = Studio_LocalPoseParameter2(pStudioHdr, poseParameter, seqdesc, sequence, 1 /*, s1, i1 */);
    s0 = r0.s;
    i0 = r0.i;
    s1 = r1.s;
    i1 = r1.i;
    if (seqdesc.flags & STUDIO_REALTIME) {
        const cps = Studio_CPS2(pStudioHdr, seqdesc, sequence, poseParameter);
        cycle = flTime * cps;
        cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
    }
    else if (seqdesc.flags & STUDIO_CYCLEPOSE) {
        const iPose = pStudioHdr.GetSharedPoseParameter(sequence, seqdesc.cycleposeindex);
        if (iPose != -1) {
            cycle = poseParameter[iPose];
        }
        else {
            cycle = 0.0;
        }
    }
    else if (cycle < 0 || cycle >= 1) {
        if (seqdesc.flags & STUDIO_LOOPING) {
            cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
            if (cycle < 0) {
                cycle += 1;
            }
        }
        else {
            cycle = clamp(cycle, 0.0, 1.0);
        }
    }
    if (s0 < 0.001) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else if (s0 > 0.999) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                ScaleBones2(pStudioHdr, q, pos, sequence, 1.0 - s0, boneMask);
            }
            else if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1)) {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                ScaleBones2(pStudioHdr, q, pos, sequence, s0, boneMask);
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
        }
        //else if (!anim_3wayblend.GetBool())
        else {
            const iAnimIndices = [];
            const weight = [];
            Calc3WayBlendIndices2(i0, i1, s0, s1, seqdesc, iAnimIndices, weight);
            if (weight[1] < 0.001) {
                // on diagonal
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[2] / (weight[0] + weight[2]), boneMask);
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[1], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[1] / (weight[0] + weight[1]), boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos3, q3, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q3, pos3, weight[2], boneMask);
            }
        }
    }
    //g_VectorPool.Free(pos2);
    //g_QaternionPool.Free(q2);
    //g_VectorPool.Free(pos3);
    //g_QaternionPool.Free(q3);
    return bResult;
}
//-----------------------------------------------------------------------------
// Purpose: Find and decode a sub-frame of animation
//-----------------------------------------------------------------------------
function CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, animation, cycle, boneMask) {
    /*virtualmodel_t *pVModel = pStudioHdr->GetVirtualModel();TODOV2
    if (pVModel)
    {
        CalcVirtualAnimation(pVModel, pStudioHdr, pos, q, seqdesc, sequence, animation, cycle, boneMask);
        return;
    }*/
    const animdesc = pStudioHdr.getAnimDescription(animation);
    if (!animdesc) {
        return;
    }
    pStudioHdr.getBone(0);
    //const mstudiolinearbone_t *pLinearBones = pStudioHdr->pLinearBones();TODOV2
    let pLinearBones;
    const fFrame = cycle * (animdesc.numframes - 1);
    const iFrame = Math.floor(fFrame);
    const s = (fFrame - iFrame);
    //iFrame = 0;
    //console.log(pStudioHdr.getAnimFrame(animdesc, iFrame));
    pStudioHdr.getAnimFrame(dynamicProp, animdesc, iFrame);
    //console.log(iFrame);
    let iLocalFrame = iFrame;
    let flStall;
    const panims = animdesc.pAnim(iLocalFrame, flStall);
    //animdesc.mdl.getAnimFrame(animdesc, 31);
    //const pweight = seqdesc.pBoneweight(0);
    // if the animation isn't available, look for the zero frame cache
    if (!panims) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            const pbone = pStudioHdr.getBone(i);
            const pweight = seqdesc.pBoneweight(i);
            if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
                if (animdesc.flags & STUDIO_DELTA) {
                    q[i] = create$2(); //TODOV2
                    pos[i] = create$4(); //TODOV2
                }
                else {
                    //q[i] = pbone.rot;TODOv2
                    q[i] = q[i] || create$2();
                    pos[i] = pos[i] || create$4();
                    q[i] = create$2();
                    pos[i] = create$4();
                    //quat.fromMat3(q[i], mat3.fromEuler(SourceEngineTempMat3, pbone.rot));
                    quatFromEulerRad(q[i], pbone.rot[0], pbone.rot[1], pbone.rot[2]);
                    copy$4(pos[i], pbone.position);
                }
            }
        }
        //CalcZeroframeData(pStudioHdr, pStudioHdr->GetRenderHdr(), NULL, pStudioHdr->pBone(0), animdesc, fFrame, pos, q, boneMask, 1.0);
        CalcZeroframeData2(pStudioHdr, pStudioHdr, null, pStudioHdr.getBone(0));
        return;
    }
    // BUGBUG: the sequence, the anim, and the model can have all different bone mappings.
    //for (i = 0; i < pStudioHdr->numbones(); i++, pbone++, pweight++)
    let panim = panims[0];
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(), animIndex = 0; i < boneCount; ++i) {
        const pbone = pStudioHdr.getBone(i);
        const pweight = seqdesc.pBoneweight(i);
        q[i] = q[i] || create$2(); //TODOV2
        pos[i] = pos[i] || create$4(); //TODOV2
        q[i] = create$2();
        pos[i] = create$4();
        if (panim && panim.bone == i) {
            boneFlags[i] = panim.flags;
            //if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask))
            if (pweight > 0) //TODOv2
             {
                if (animdesc.sectionframes != 0) {
                    iLocalFrame = iLocalFrame % animdesc.sectionframes;
                }
                CalcBoneQuaternion2(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, q[i]);
                CalcBonePosition2(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, pos[i]); //TODOV2
                //quat.copy(q[i], pbone.quaternion);
                //vec3.copy(pos[i], pbone.position);
            }
            //panim = panim->pNext();//TODOv2
            panim = panims[++animIndex];
            //} else if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
        }
        else if (pweight > 0) {
            if (animdesc.flags & STUDIO_DELTA) {
                boneFlags[i] = STUDIO_ANIM_DELTA;
                q[i] = create$2(); //TODOV2
                pos[i] = create$4(); //TODOV2
            }
            else {
                boneFlags[i] = 0;
                copy$2(q[i], pbone.quaternion);
                copy$4(pos[i], pbone.position);
            }
        }
        else {
            boneFlags[i] = STUDIO_ANIM_DELTA;
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: return a sub frame rotation for a single bone
//-----------------------------------------------------------------------------
/*void CalcBoneQuaternion(int frame, float s,
                        const Quaternion &baseQuat, const RadianEuler &baseRot, const Vector &baseRotScale,
                        int iBaseFlags, const Quaternion &baseAlignment,
                        const mstudioanim_t *panim, Quaternion &q)*/
function _CalcBoneQuaternion2(pStudioHdr, frame, s, baseQuat, baseRot, baseRotScale, iBaseFlags, baseAlignment, panim, q) {
    if (panim.flags & STUDIO_ANIM_RAWROT) {
        //q = panim.pQuat48();
        copy$2(q, panim.rawrot); //TODOv2
        return;
    }
    if (panim.flags & STUDIO_ANIM_RAWROT2) {
        //q = panim.pQuat64();
        copy$2(q, panim.rawrot2); //TODOv2
        q[0] = panim.rawrot2[2];
        q[1] = panim.rawrot2[1];
        q[2] = panim.rawrot2[0];
        q[3] = panim.rawrot2[3];
        return;
    }
    if (!(panim.flags & STUDIO_ANIM_ANIMROT)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            identity$1(q);
        }
        else {
            copy$2(q, baseQuat); //TODOv2
        }
        return;
    }
    panim.animValuePtrRot;
    if (s > 0.001) {
        const angle1 = create$4(), angle2 = create$4(); // TODO: optimize
        const q1 = create$2();
        const q2 = create$2();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle1[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset, panim.bone, i) * baseRotScale[i];
                angle2[i] = angle1[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle1[0] = angle1[0] + baseRot[0];
            angle1[1] = angle1[1] + baseRot[1];
            angle1[2] = angle1[2] + baseRot[2];
            angle2[0] = angle2[0] + baseRot[0];
            angle2[1] = angle2[1] + baseRot[1];
            angle2[2] = angle2[2] + baseRot[2];
        }
        if (angle1[0] !== angle2[0] || angle1[1] !== angle2[1] || angle1[2] !== angle2[2]) {
            //_AngleQuaternion(angle1, q1);//TODOv2
            //_AngleQuaternion(angle2, q2);//TODOv2
            quatFromEulerRad(q1, angle1[0], angle1[1], angle1[2]);
            quatFromEulerRad(q2, angle2[0], angle2[1], angle2[2]);
            QuaternionBlend2(q1, q2, s, q);
        }
        else {
            //_AngleQuaternion(angle1, q);//TODOv2
            //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle1));
            quatFromEulerRad(q, angle1[0], angle1[1], angle1[2]);
        }
    }
    else {
        const angle = create$4();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset, panim.bone, i) * baseRotScale[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle[0] = angle[0] + baseRot[0];
            angle[1] = angle[1] + baseRot[1];
            angle[2] = angle[2] + baseRot[2];
        }
        //_AngleQuaternion(angle, q);//TODOv2
        //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle));
        quatFromEulerRad(q, angle[0], angle[1], angle[2]);
    }
    // align to unified bone
    if (!(panim.flags & STUDIO_ANIM_DELTA) && (iBaseFlags & BONE_FIXED_ALIGNMENT)) {
        QuaternionAlign2(baseAlignment, q, q);
    }
}
function CalcBoneQuaternion2(pStudioHdr, frame, s, pBone, pLinearBones, panim, q) {
    {
        _CalcBoneQuaternion2(pStudioHdr, frame, s, pBone.quaternion, pBone.rot, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
        //_CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quat, [0, 0, 0]/*pBone.rot*//*TODOV2*/, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
    }
}
function _CalcBonePosition2(pStudioHdr, frame, s, basePos, baseBoneScale, panim, pos) {
    if (panim.flags & STUDIO_ANIM_RAWPOS) {
        copy$4(pos, panim.rawpos);
        return;
    }
    else if (!(panim.flags & STUDIO_ANIM_ANIMPOS)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            zero$4(pos);
        }
        else {
            copy$4(pos, basePos);
        }
        return;
    }
    panim.animValuePtrPos;
    /*
        mstudioanim_valueptr_t *pPosV = panim.pPosV();
        int					j;
    */
    if (s > 0.001) {
        let v1, v2; // TODO: optimize
        for (let i = 0; i < 3; i++) {
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                v1 = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset, panim.bone, i) * baseBoneScale[i];
                v2 = v1;
                pos[i] = v1 * (1.0 - s) + v2 * s;
            }
        }
    }
    else {
        for (let i = 0; i < 3; i++) {
            //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], pos[i]);
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                pos[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset, panim.bone, i) * baseBoneScale[i];
            }
        }
    }
    if (!(panim.flags & STUDIO_ANIM_DELTA)) {
        pos[0] = pos[0] + basePos[0];
        pos[1] = pos[1] + basePos[1];
        pos[2] = pos[2] + basePos[2];
    }
}
function CalcBonePosition2(pStudioHdr, frame, s, pBone, pLinearBones, panim, pos) {
    {
        _CalcBonePosition2(pStudioHdr, frame, s, pBone.position, pBone.posscale, panim, pos);
    }
}
//-----------------------------------------------------------------------------
// Do a piecewise addition of the quaternion elements. This actually makes little
// mathematical sense, but it's a cheap way to simulate a slerp.
//-----------------------------------------------------------------------------
//void QuaternionBlend(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlend2(p, q, t, qt) {
    // decide if one of the quaternions is backwards
    const q2 = create$2();
    QuaternionAlign2(p, q, q2);
    QuaternionBlendNoAlign2(p, q2, t, qt);
}
//void QuaternionBlendNoAlign(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlendNoAlign2(p, q, t, qt) {
    // 0.0 returns p, 1.0 return q.
    const sclp = 1.0 - t;
    const sclq = t;
    for (let i = 0; i < 4; ++i) {
        qt[i] = sclp * p[i] + sclq * q[i];
    }
    normalize$3(qt, qt);
}
//-----------------------------------------------------------------------------
// make sure quaternions are within 180 degrees of one another, if not, reverse q
//-----------------------------------------------------------------------------
//void QuaternionAlign(const Quaternion &p, const Quaternion &q, Quaternion &qt)
function QuaternionAlign2(p, q, qt) {
    // FIXME: can this be done with a quat dot product?
    // decide if one of the quaternions is backwards
    let a = 0;
    let b = 0;
    for (let i = 0; i < 4; ++i) {
        a += (p[i] - q[i]) * (p[i] - q[i]);
        b += (p[i] + q[i]) * (p[i] + q[i]);
    }
    if (a > b) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = -q[i];
        }
    }
    else if (qt != q) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = q[i];
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: Calc Zeroframe Data
//-----------------------------------------------------------------------------
function CalcZeroframeData2(pStudioHdr, pAnimStudioHdr, pAnimGroup, pAnimbone, animdesc, fFrame, pos, q, boneMask, flWeight) {
    /* TODO
        let pData = animdesc.pZeroFrameData();

        if (!pData) {
            return;
        }

        // Msg('zeroframe %s\n', animdesc.pszName());
        let i;
        if (animdesc.zeroframecount == 1) {
            for (let j = 0, boneCount = pStudioHdr.getBoneCount(); j < boneCount; ++j) {
                if (pAnimGroup)
                    i = pAnimGroup.masterBone[j];
                else
                    i = j;

                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_POS) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const p = vec3.create();//TODOv2
                        console.error('const p = *(Vector48 *)pData;//TODOv2');
                        pos[i] = pos[i] * (1.0 - flWeight) + p * flWeight;
                    }
                    pData += 6;//sizeof(Vector48);//TODOv2
                }
                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_ROT) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const q0 = quat.create();//*(Quaternion64 *)pData;
                        console.error('const q0 = quat.create();//*(Quaternion64 *)pData;');
                        QuaternionBlend(q[i], q0, flWeight, q[i]);
                        //Assert(q[i].IsValid());
                    }
                    pData += 8;//sizeof(Quaternion64);
                }
            }
        }
        else {
            let s1;
            let index = fFrame / animdesc.zeroframespan;
            if (index >= animdesc.zeroframecount - 1) {
                index = animdesc.zeroframecount - 2;
                s1 = 1.0;
            } else {
                s1 = clamp((fFrame - index * animdesc.zeroframespan) / animdesc.zeroframespan, 0.0, 1.0);
            }
            let i0 = Math.max(index - 1, 0);
            let i1 = index;
            let i2 = Math.min(index + 1, animdesc.zeroframecount - 1);
            for (let j = 0, boneCount = pStudioHdr.getBoneCount(); j < boneCount; ++j) {
                if (pAnimGroup)
                    i = pAnimGroup.masterBone[j];
                else
                    i = j;

                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_POS) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const p0 = vec3.create();//*(((Vector48 *)pData) + i0);//optimize
                        const p1 = vec3.create();//*(((Vector48 *)pData) + i1);
                        const p2 = vec3.create();//*(((Vector48 *)pData) + i2);
                        console.error('Vector p2 = *(((Vector48 *)pData) + i2);');
                        let p3;
                        Hermite_Spline(p0, p1, p2, s1, p3);
                        pos[i] = pos[i] * (1.0 - flWeight) + p3 * flWeight;
                    }
                    pData += sizeof(Vector48) * animdesc.zeroframecount;
                }
                if (pAnimbone[j].flags & BONE_HAS_SAVEFRAME_ROT) {
                    if ((i >= 0) && (pStudioHdr.boneFlags(i) & boneMask)) {
                        const q0 = quat.create();//*(((Quaternion64 *)pData) + i0);
                        const q1 = quat.create();//*(((Quaternion64 *)pData) + i1);
                        const q2 = quat.create();//*(((Quaternion64 *)pData) + i2);
                        console.error('Quaternion q0 = *(((Quaternion64 *)pData) + i0);');
                        if (flWeight == 1.0) {
                            Hermite_Spline(q0, q1, q2, s1, q[i]);
                        }
                        else {
                            let q3;
                            Hermite_Spline(q0, q1, q2, s1, q3);
                            QuaternionBlend(q[i], q3, flWeight, q[i]);
                        }
                    }
                    pData += sizeof(Quaternion64) * animdesc.zeroframecount;
                }
            }
        }
    */
}
function PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1) {
    // remove 'zero' positional blends
    //const baseanim = pStudioHdr.iRelativeAnim(sequence, seqdesc.getBlend(i0 , i1));//TODOv2
    const baseanim = seqdesc.getBlend(i0, i1);
    const anim = pStudioHdr.getAnimDescription(baseanim);
    if (!anim) {
        return false;
    }
    return (anim.flags & STUDIO_ALLZEROS) != 0;
}
//-----------------------------------------------------------------------------
// Purpose: turn a 2x2 blend into a 3 way triangle blend
// Returns: returns the animination indices and barycentric coordinates of a triangle
//			the triangle is a right triangle, and the diagonal is between elements [0] and [2]
//-----------------------------------------------------------------------------
//void Calc3WayBlendIndices(int i0, int i1, float s0, float s1, const mstudioseqdesc_t &seqdesc, int *pAnimIndices, float *pWeight)
function Calc3WayBlendIndices2(i0, i1, s0, s1, seqdesc, pAnimIndices, pWeight) {
    // Figure out which bi-section direction we are using to make triangles.
    const bEven = (((i0 + i1) & 0x1) == 0);
    let x1, y1;
    let x2, y2;
    let x3, y3;
    // diagonal is between elements 1 & 3
    // TL to BR
    if (bEven) {
        if (s0 > s1) {
            // B
            x1 = 0;
            y1 = 0;
            x2 = 1;
            y2 = 0;
            x3 = 1;
            y3 = 1;
            pWeight[0] = (1.0 - s0);
            pWeight[1] = s0 - s1;
        }
        else {
            // C
            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 1;
            x3 = 0;
            y3 = 0;
            pWeight[0] = s0;
            pWeight[1] = s1 - s0;
        }
    }
    // BL to TR
    else {
        const flTotal = s0 + s1;
        if (flTotal > 1.0) {
            // D
            x1 = 1;
            y1 = 0;
            x2 = 1;
            y2 = 1;
            x3 = 0;
            y3 = 1;
            pWeight[0] = (1.0 - s1);
            pWeight[1] = s0 - 1.0 + s1;
        }
        else {
            // A
            x1 = 0;
            y1 = 1;
            x2 = 0;
            y2 = 0;
            x3 = 1;
            y3 = 0;
            pWeight[0] = s1;
            pWeight[1] = 1.0 - s0 - s1;
        }
    }
    pAnimIndices[0] = seqdesc.getBlend(i0 + x1, i1 + y1);
    pAnimIndices[1] = seqdesc.getBlend(i0 + x2, i1 + y2);
    pAnimIndices[2] = seqdesc.getBlend(i0 + x3, i1 + y3);
    // clamp the diagonal
    if (pWeight[1] < 0.001)
        pWeight[1] = 0.0;
    pWeight[2] = 1.0 - pWeight[0] - pWeight[1];
    //Assert(pWeight[0] >= 0.0 && pWeight[0] <= 1.0);
    //Assert(pWeight[1] >= 0.0 && pWeight[1] <= 1.0);
    //Assert(pWeight[2] >= 0.0 && pWeight[2] <= 1.0);
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence //TODOv2
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AddSequenceLayers2 = function (dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    //return;
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.getAutoLayer(i);
        if (pLayer.flags & STUDIO_AL_LOCAL) {
            continue;
        }
        let layerCycle = cycle;
        let layerWeight = flWeight;
        if (pLayer.start != pLayer.end) {
            let s = 1.0;
            let index;
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                index = cycle;
            }
            else {
                //TODOv2
                pLayer.iSequence; //int iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
                //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, pLayer.iPose);
                const iPose = pLayer.iPose;
                if (iPose != -1) {
                    //const Pose = pStudioHdr.pPoseParameter(iPose);
                    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
                    if (Pose) {
                        index = poseParameter[iPose] * (Pose.end - Pose.start) + Pose.start;
                    }
                    else {
                        index = 0;
                    }
                }
                else {
                    index = 0;
                }
            }
            if (index < pLayer.start) {
                continue;
            }
            if (index >= pLayer.end) {
                continue;
            }
            if (index < pLayer.peak && pLayer.start != pLayer.peak) {
                s = (index - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (index > pLayer.tail && pLayer.end != pLayer.tail) {
                s = (pLayer.end - index) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) {
                s = SimpleSpline(s);
            }
            if ((pLayer.flags & STUDIO_AL_XFADE) && (index > pLayer.tail)) {
                layerWeight = (s * flWeight) / (1 - flWeight + s * flWeight);
            }
            else if (pLayer.flags & STUDIO_AL_NOBLEND) {
                layerWeight = s;
            }
            else {
                layerWeight = flWeight * s;
            }
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
            }
        }
        //const iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);//TODOV2
        const iSequence = pLayer.iSequence; //pStudioHdr.getSequenceById(pLayer.iSequence);
        AccumulatePose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameter, boneMask, layerWeight);
    }
};
//-----------------------------------------------------------------------------
// Purpose: accumulate a pose for a single sequence on top of existing animation
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AccumulatePose_pos2 = Array(SOURCE_MODEL_MAX_BONES);
const AccumulatePose_q2 = Array(SOURCE_MODEL_MAX_BONES);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES; i++) {
    AccumulatePose_pos2[i] = create$4();
    AccumulatePose_q2[i] = create$2();
}
function AccumulatePose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameter, boneMask, flWeight, flTime) {
    //const pos2 = [];
    //const q2 = [];
    const pos2 = AccumulatePose_pos2;
    const q2 = AccumulatePose_q2;
    // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
    flWeight = clamp(flWeight, 0.0, 1.0);
    if (sequence < 0) {
        return;
    }
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc.flags & STUDIO_LOCAL) {
        InitPose2(dynamicProp, pStudioHdr, pos2, q2);
    }
    /*
    if (CalcPoseSingle(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flTime)) {
        // this weight is wrong, the IK rules won't composite at the correct intensity
        AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, 1.0, flTime);
        SlerpBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, flWeight, boneMask);
    }
    */
    if (pIKContext) {
        pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameter, flWeight);
    }
    AddSequenceLayers2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameter, boneMask, flWeight);
}
//-----------------------------------------------------------------------------
// Purpose: Inter-animation blend.	Assumes both types are identical.
//			blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
/*void BlendBones(
    const CStudioHdr *pStudioHdr,
    Quaternion q1[MAXSTUDIOBONES],
    Vector pos1[MAXSTUDIOBONES],
    mstudioseqdesc_t &seqdesc,
    int sequence,
    const Quaternion q2[MAXSTUDIOBONES],
    const Vector pos2[MAXSTUDIOBONES],
    float s,
    int boneMask)*/
function BlendBones2(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    const q3 = create$2();
    /*virtualmodel_t *pVModel = pStudioHdr.GetVirtualModel();TODO
    const virtualgroup_t *pSeqGroup = NULL;
    if (pVModel)
    {
        pSeqGroup = pVModel.pSeqGroup(sequence);
    }*/
    if (s <= 0) {
        //Assert(0); // shouldn't have been called
        return;
    }
    else if (s >= 1.0) {
        //Assert(0); // shouldn't have been called
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            let j;
            // skip unused bones
            if (!(pStudioHdr.boneFlags(i) & boneMask)) {
                continue;
            }
            {
                j = i;
            }
            if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
                q1[i] = q2[i];
                pos1[i] = pos2[i];
            }
        }
        return;
    }
    const s2 = s;
    const s1 = 1.0 - s2;
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
        let j;
        // skip unused bones
        q1[i] = q1[i] || create$2();
        pos1[i] = pos1[i] || create$4();
        q2[i] = q2[i] || create$2();
        pos2[i] = pos2[i] || create$4();
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
            if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
                QuaternionBlendNoAlign2(q2[i], q1[i], s1, q3);
            }
            else {
                QuaternionBlend2(q2[i], q1[i], s1, q3);
            }
            q1[i][0] = q3[0];
            q1[i][1] = q3[1];
            q1[i][2] = q3[2];
            q1[i][3] = q3[3];
            pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
            pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
            pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: resolve a global pose parameter to the specific setting for this sequence
//-----------------------------------------------------------------------------
//void Studio_LocalPoseParameter(const CStudioHdr *pStudioHdr, const float poseParameter[], mstudioseqdesc_t &seqdesc, int iSequence, int iLocalIndex, float &flSetting, int &index)
function Studio_LocalPoseParameter2(pStudioHdr, poseParameter, seqdesc, iSequence, iLocalIndex /*, flSetting, index*/) {
    let flSetting = 0;
    let index = 0;
    //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, seqdesc.paramindex[iLocalIndex]);
    const iPose = seqdesc.paramindex[iLocalIndex]; //TODOV2
    if (iPose == -1) {
        flSetting = 0;
        index = 0;
        return { s: flSetting, i: index };
    }
    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
    if (!Pose) {
        flSetting = 0;
        index = 0;
        return { s: flSetting, i: index };
    }
    //const flValue = poseParameter[iPose];
    let flValue = Pose.midpoint;
    if (poseParameter[Pose.name] !== undefined) {
        flValue = poseParameter[Pose.name];
    }
    if (Pose.loop) {
        const wrap = (Pose.start + Pose.end) / 2.0 + Pose.loop / 2.0;
        const shift = Pose.loop - wrap;
        flValue = flValue - Pose.loop * Math.floor((flValue + shift) / Pose.loop);
    }
    if (seqdesc.posekeyindex == 0) {
        const flLocalStart = (seqdesc.paramstart[iLocalIndex] - Pose.start) / (Pose.end - Pose.start);
        const flLocalEnd = (seqdesc.paramend[iLocalIndex] - Pose.start) / (Pose.end - Pose.start);
        // convert into local range
        flSetting = (flValue - flLocalStart) / (flLocalEnd - flLocalStart);
        // clamp.	This shouldn't ever need to happen if it's looping.
        if (flSetting < 0)
            flSetting = 0;
        if (flSetting > 1)
            flSetting = 1;
        index = 0;
        if (seqdesc.groupsize[iLocalIndex] > 2) {
            // estimate index
            index = Math.round(flSetting * (seqdesc.groupsize[iLocalIndex] - 1));
            if (index == seqdesc.groupsize[iLocalIndex] - 1)
                index = seqdesc.groupsize[iLocalIndex] - 2;
            flSetting = flSetting * (seqdesc.groupsize[iLocalIndex] - 1) - index;
        }
    }
    else {
        flValue = flValue * (Pose.end - Pose.start) + Pose.start;
        index = 0;
        // FIXME: this needs to be 2D
        // FIXME: this shouldn't be a linear search
        while (1) {
            flSetting = (flValue - seqdesc.poseKey(iLocalIndex, index)) / (seqdesc.poseKey(iLocalIndex, index + 1) - seqdesc.poseKey(iLocalIndex, index));
            //flSetting = 0;//TODOV2
            /*
            if (index > 0 && flSetting < 0.0)
            {
                index--;
                continue;
            }
            else
            */
            if (index < seqdesc.groupsize[iLocalIndex] - 2 && flSetting > 1.0) {
                index++;
                continue;
            }
            break;
        }
        // clamp.
        if (flSetting < 0.0)
            flSetting = 0.0;
        if (flSetting > 1.0)
            flSetting = 1.0;
    }
    return { s: flSetting, i: index };
}
function ScaleBones2(pStudioHdr, //const CStudioHdr *pStudioHdr,
q1, //Quaternion q1[MAXSTUDIOBONES],
pos1, //Vector pos1[MAXSTUDIOBONES],
sequence, //int sequence,
s, //float s,
boneMask //int boneMask
) {
    let i, j; //int			i, j;
    let seqdesc = pStudioHdr.getSequenceById(sequence); //mstudioseqdesc_t & seqdesc = ((CStudioHdr *)pStudioHdr) -> pSeqdesc(sequence);
    /*
    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }
        */
    let s2 = s;
    let s1 = 1.0 - s2;
    for (i = 0; i < pStudioHdr.getBoneCount(); i++) {
        // skip unused bones
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && seqdesc.pBoneweight(j) > 0.0) {
            QuaternionIdentityBlend(q1[i], s1, q1[i]);
            //VectorScale(pos1[i], s2, pos1[i]);
            scale$5(pos1[i], pos1[i], s2);
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: translate animations done in a non-standard parent space
//-----------------------------------------------------------------------------
/*
function CalcLocalHierarchyAnimation(
    pStudioHdr,//const CStudioHdr * pStudioHdr,
    boneToWorld: mat4,//matrix3x4_t * boneToWorld,
    boneComputed,//CBoneBitList & boneComputed,
    pos,//Vector * pos,
    q,//Quaternion * q,
    //const mstudioanimdesc_t &animdesc,
    pbone,//const mstudiobone_t * pbone,
    pHierarchy,//mstudiolocalhierarchy_t * pHierarchy,
    iBone: number,//int iBone,
    iNewParent: number,//int iNewParent,
    cycle: number,//float cycle,
    iFrame: number,//int iFrame,
    flFraq: number,//float flFraq,
    boneMask: number,//int boneMask
): void {

    let localPos = vec3.create();//Vector localPos;
    let localQ = quat.create();//Quaternion localQ;

    // make fake root transform
    //static ALIGN16 matrix3x4_t rootXform ALIGN16_POST(1.0f, 0, 0, 0, 0, 1.0f, 0, 0, 0, 0, 1.0f, 0);
    let rootXform = mat4.create();

    // FIXME: missing check to see if seq has a weight for this bone
    //float weight = 1.0f;
    let weight = 1;

    // check to see if there's a ramp on the influence
    if (pHierarchy -> tail - pHierarchy -> peak < 1.0f  )
    {
        float index = cycle;

        if (pHierarchy -> end > 1.0f && index < pHierarchy -> start)
        index += 1.0f;

        if (index < pHierarchy -> start)
            return;
        if (index >= pHierarchy -> end)
            return;

        if (index < pHierarchy -> peak && pHierarchy -> start != pHierarchy -> peak) {
            weight = (index - pHierarchy -> start) / (pHierarchy -> peak - pHierarchy -> start);
        }
        else if (index > pHierarchy -> tail && pHierarchy -> end != pHierarchy -> tail) {
            weight = (pHierarchy -> end - index) / (pHierarchy -> end - pHierarchy -> tail);
        }

        weight = SimpleSpline(weight);
    }

    CalcDecompressedAnimation(pHierarchy -> pLocalAnim(), iFrame - pHierarchy -> iStart, flFraq, localPos, localQ);

    BuildBoneChain(pStudioHdr, rootXform, pos, q, iBone, boneToWorld, boneComputed);

    matrix3x4_t localXform;
    AngleMatrix(localQ, localPos, localXform);

    if (iNewParent != -1) {
        BuildBoneChain(pStudioHdr, rootXform, pos, q, iNewParent, boneToWorld, boneComputed);
        ConcatTransforms(boneToWorld[iNewParent], localXform, boneToWorld[iBone]);
    }
    else {
        boneToWorld[iBone] = localXform;
    }

    // back solve
    Vector p1;
    Quaternion q1;
    int n = pbone[iBone].parent;
    if (n == -1) {
        if (weight == 1.0f)
        {
            MatrixAngles(boneToWorld[iBone], q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(boneToWorld[iBone], q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
    else {
        matrix3x4_t worldToBone;
        MatrixInvert(boneToWorld[n], worldToBone);

        matrix3x4_t local;
        ConcatTransforms(worldToBone, boneToWorld[iBone], local);
        if (weight == 1.0f)
        {
            MatrixAngles(local, q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(local, q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
}
    */
//-----------------------------------------------------------------------------
// Purpose: blend together in world space q1,pos1 with q2,pos2.  Return result in q1,pos1.
//			0 returns q1, pos1.  1 returns q2, pos2
//-----------------------------------------------------------------------------
/*
function WorldSpaceSlerp(
    pStudioHdr,//const CStudioHdr *pStudioHdr,
    q1: Array<quat>,//Quaternion q1[MAXSTUDIOBONES],
    pos1: Array<vec3>,//Vector pos1[MAXSTUDIOBONES],
    seqdesc,//mstudioseqdesc_t &seqdesc,
    sequence: number,//int sequence,
    q2: Array<quat>,//const Quaternion q2[MAXSTUDIOBONES],
    pos2: Array<vec3>,//const Vector pos2[MAXSTUDIOBONES],
    s: number,//float s,
    boneMask: number//int boneMask
): void {
    int			i, j;
    float		s1; // weight of parent for q2, pos2
    float		s2; // weight for q2, pos2

    // make fake root transform
    matrix3x4_t rootXform;
    SetIdentityMatrix(rootXform);

    // matrices for q2, pos2
    matrix3x4_t * srcBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList srcBoneComputed;

    matrix3x4_t * destBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList destBoneComputed;

    matrix3x4_t * targetBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList targetBoneComputed;

    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }

    mstudiobone_t * pbone = pStudioHdr -> pBone(0);

    for (i = 0; i < pStudioHdr -> numbones(); i++) {
        // skip unused bones
        if (!(pStudioHdr -> boneFlags(i) & boneMask)) {
            continue;
        }

        int n = pbone[i].parent;
        s1 = 0.0;
        if (pSeqGroup) {
            j = pSeqGroup -> boneMap[i];
            if (j >= 0) {
                s2 = s * seqdesc.weight(j);	// blend in based on this bones weight
                if (n != -1) {
                    s1 = s * seqdesc.weight(pSeqGroup -> boneMap[n]);
                }
            }
            else {
                s2 = 0.0;
            }
        }
        else {
            s2 = s * seqdesc.weight(i);	// blend in based on this bones weight
            if (n != -1) {
                s1 = s * seqdesc.weight(n);
            }
        }

        if (s1 == 1.0 && s2 == 1.0) {
            pos1[i] = pos2[i];
            q1[i] = q2[i];
        }
        else if (s2 > 0.0) {
            Quaternion srcQ, destQ;
            Vector srcPos, destPos;
            Quaternion targetQ;
            Vector targetPos;
            Vector tmp;

            BuildBoneChain(pStudioHdr, rootXform, pos1, q1, i, destBoneToWorld, destBoneComputed);
            BuildBoneChain(pStudioHdr, rootXform, pos2, q2, i, srcBoneToWorld, srcBoneComputed);

            MatrixAngles(destBoneToWorld[i], destQ, destPos);
            MatrixAngles(srcBoneToWorld[i], srcQ, srcPos);

            QuaternionSlerp(destQ, srcQ, s2, targetQ);
            AngleMatrix(targetQ, destPos, targetBoneToWorld[i]);

            // back solve
            if (n == -1) {
                MatrixAngles(targetBoneToWorld[i], q1[i], tmp);
            }
            else {
                matrix3x4_t worldToBone;
                MatrixInvert(targetBoneToWorld[n], worldToBone);

                matrix3x4_t local;
                ConcatTransforms(worldToBone, targetBoneToWorld[i], local);
                MatrixAngles(local, q1[i], tmp);

                // blend bone lengths (local space)
                pos1[i] = Lerp(s2, pos1[i], pos2[i]);
            }
        }
    }
    g_MatrixPool.Free(srcBoneToWorld);
    g_MatrixPool.Free(destBoneToWorld);
    g_MatrixPool.Free(targetBoneToWorld);
}
*/

class Animation {
    #name;
    weight = 1;
    #frame = 0;
    #frameCount = 0;
    #looping = false;
    //#sequence;
    #fps = 30;
    #frames = [];
    #bones = [];
    #bonesByName = new Map;
    constructor(name) {
        this.#name = name;
    }
    [Symbol.iterator] = () => {
        return this.#frames.entries();
    };
    addFrame(animationFrame) {
        this.#frames.push(animationFrame);
        ++this.#frameCount;
    }
    addBone(bone) {
        this.#bones[bone.id] = bone;
        this.#bonesByName.set(bone.name, bone);
    }
    get name() {
        return this.#name;
    }
    get frameCount() {
        return this.#frameCount;
    }
    set fps(fps) {
        this.#fps = fps;
    }
    get fps() {
        return this.#fps;
    }
    get bones() {
        return this.#bones;
    }
    getFrame(id) {
        id = Math.round(id) % Math.max(this.#frameCount, 1);
        return this.#frames[id];
    }
    toSMD(header = SMD_HEADER) {
        const lines = [];
        lines.push(header);
        lines.push('version 1');
        // Start bones declaration
        lines.push('nodes');
        for (const bone of this.#bones) { // TODO: sort bones ?
            lines.push(`  ${bone.id} "${bone.name}" ${bone.getParentId()}`);
        }
        lines.push('end');
        // Start frames
        lines.push('skeleton');
        for (const frame of this.#frames) {
            lines.push(`  time ${frame.getFrameId()}`);
            const positions = frame.getData('position');
            const rotations = frame.getData('rotation');
            if (!positions || !rotations) {
                continue;
            }
            for (const bone of this.#bones) {
                const bonePos = positions.datas[bone.id] ?? create$4();
                const boneRot = quatToEuler(create$4(), rotations.datas[bone.id] ?? create$2());
                if (!bonePos || !boneRot) {
                    continue;
                }
                lines.push(`  ${bone.id} ${bonePos[0].toFixed(5)} ${bonePos[1].toFixed(5)} ${bonePos[2].toFixed(5)} ${boneRot[0].toFixed(5)} ${boneRot[1].toFixed(5)} ${boneRot[2].toFixed(5)}`);
            }
        }
        lines.push('end');
        return lines.join('\n');
    }
}

var AnimationFrameDataType;
(function (AnimationFrameDataType) {
    AnimationFrameDataType[AnimationFrameDataType["Vec3"] = 0] = "Vec3";
    AnimationFrameDataType[AnimationFrameDataType["Quat"] = 1] = "Quat";
    AnimationFrameDataType[AnimationFrameDataType["Number"] = 2] = "Number";
    AnimationFrameDataType[AnimationFrameDataType["Boolean"] = 3] = "Boolean";
})(AnimationFrameDataType || (AnimationFrameDataType = {}));
class AnimationFrameData {
    type;
    datas = [];
    constructor(type, datas) {
        this.type = type;
        if (datas) {
            for (const data of datas) {
                switch (type) {
                    case AnimationFrameDataType.Vec3:
                        this.datas.push(clone$4(data));
                        break;
                    case AnimationFrameDataType.Quat:
                        this.datas.push(clone$2(data));
                        break;
                    default:
                        this.datas.push(data);
                        break;
                }
            }
        }
    }
    pushData(data) {
        this.datas.push(data);
    }
}

class AnimationFrame {
    #frameId;
    #datas = new Map();
    constructor(frameId) {
        this.#frameId = frameId;
    }
    setDatas(name, type, datas) {
        this.#datas.set(name, new AnimationFrameData(type, datas));
    }
    pushData(name, data) {
        const frameDatas = this.#datas.get(name);
        frameDatas?.pushData(data);
    }
    getData(name) {
        return this.#datas.get(name);
    }
    getFrameId() {
        return this.#frameId;
    }
}

class AnimationBone {
    #id;
    #parentId;
    #name;
    refPosition;
    refQuaternion;
    constructor(id, parentId, name, position, quaternion) {
        this.#id = id;
        this.#parentId = parentId;
        this.#name = name.toLowerCase();
        this.refPosition = clone$4(position);
        this.refQuaternion = clone$2(quaternion);
    }
    get id() {
        return this.#id;
    }
    getParentId() {
        return this.#parentId;
    }
    get name() {
        return this.#name;
    }
}

class SourceModel {
    repository;
    fileName;
    name;
    mdl; //TODO: set private ?
    vvd;
    vtx;
    requiredLod = 0;
    drawBodyPart = {};
    currentSkin = 0;
    currentSheen = null;
    animLayers = [];
    materialRepository = null;
    dirty = true;
    bodyParts = new Map();
    constructor(repository, fileName, mdl, vvd, vtx) {
        this.repository = repository;
        this.fileName = fileName;
        this.name = FileNameFromPath(fileName);
        this.mdl = mdl;
        this.vvd = vvd;
        this.vtx = vtx;
        //this.visible = true;
        this.requiredLod = 0;
        //this.bodyParts = [];
        //this.origin = vec3.create();
        //this.orientation = vec3.create();
        //this.geometries = new Set();
    }
    addGeometry(mesh, geometry, bodyPartName, bodyPartModelId) {
        let modelMesh = new SourceModelMesh(mesh, geometry);
        if (bodyPartName !== undefined) {
            let bodyPart = this.bodyParts.get(bodyPartName);
            if (bodyPart === undefined) {
                bodyPart = [];
                this.bodyParts.set(bodyPartName, bodyPart);
            }
            if (bodyPartModelId !== undefined) {
                let meshes = bodyPart[bodyPartModelId];
                if (meshes === undefined) {
                    meshes = [];
                    bodyPart[bodyPartModelId] = meshes;
                }
                meshes.push(modelMesh);
            }
        }
        //this.geometries.add(geometry);
    }
    createInstance(isDynamic, preventInit) {
        return new Source1ModelInstance({ sourceModel: this, isDynamic: isDynamic, preventInit: preventInit });
    }
    getBodyNumber(bodygroups) {
        let bodyPartCount = 1;
        let bodyPartNumber = 0;
        for (const bodyPart of this.mdl.bodyParts) {
            if (bodyPart && bodyPart.models && (bodyPart.models.length > 1)) {
                const bodyPartModel = bodygroups.get(bodyPart.name);
                bodyPartNumber += (bodyPartModel ?? 0) * bodyPartCount;
                bodyPartCount *= (bodyPart.models.length);
            }
        }
        return bodyPartNumber;
    }
    getBones() {
        if (this.mdl) {
            return this.mdl.getBones();
        }
        return null;
    }
    getAttachments() {
        if (this.mdl) {
            return this.mdl.getAttachments();
        }
        return null;
    }
    getBone(boneIndex) {
        if (this.mdl) {
            return this.mdl.getBone(boneIndex);
        }
        return null;
    }
    getAttachementById(attachementIndex) {
        if (this.mdl) {
            return this.mdl.getAttachementById(attachementIndex);
        }
        return null;
    }
    getBoneByName(boneName) {
        if (this.mdl) {
            return this.mdl.getBoneByName(boneName);
        }
        return null;
    }
    getAttachement(attachementName) {
        if (this.mdl) {
            return this.mdl.getAttachement(attachementName);
        }
        return null;
    }
    getBodyPart(bodyPartId) {
        if (this.mdl) {
            return this.mdl.getBodyPart(bodyPartId);
        }
        return null;
    }
    getBodyParts() {
        if (this.mdl) {
            return this.mdl.getBodyParts();
        }
        return null;
    }
    async getAnimation(animationName, entity) {
        const animation = new Animation(animationName);
        const seq = await this.mdl.getSequence(animationName);
        const bones = this.mdl.getBones();
        for (const mdlBone of bones) {
            animation.addBone(new AnimationBone(mdlBone.boneId, mdlBone.parentBone, mdlBone.name, mdlBone.position, mdlBone.quaternion));
        }
        if (seq) {
            //const t = Studio_Duration(seq.mdl, seq.id, []);
            const frameCount = StudioFrames2(seq.mdl, seq.id, []);
            const posRemoveMeTemp = [];
            const quatRemoveMeTemp = [];
            const boneFlags = [];
            const poseParameters = {};
            for (const [boneId, bone] of animation.bones.entries()) {
                //posRemoveMeTemp.push(vec3.clone(bone.refPosition));
                //quatRemoveMeTemp.push(quat.clone(bone.refQuaternion));
                //posRemoveMeTemp.push(vec3.create());
                //quatRemoveMeTemp.push(quat.create());
            }
            for (let frame = 0; frame < frameCount; frame++) {
                const animationFrame = new AnimationFrame(frame);
                const cycle = frameCount > 1 ? frame / (frameCount - 1) : 0;
                CalcPose2(entity, seq.mdl, undefined, posRemoveMeTemp, quatRemoveMeTemp, boneFlags, seq.id, cycle /*entity.frame / t*/, poseParameters, BONE_USED_BY_ANYTHING, 1.0, cycle /*dynamicProp.frame / t*/);
                //console.info(posRemoveMeTemp, quatRemoveMeTemp);
                animationFrame.setDatas('position', AnimationFrameDataType.Vec3, posRemoveMeTemp);
                animationFrame.setDatas('rotation', AnimationFrameDataType.Quat, quatRemoveMeTemp);
                animationFrame.setDatas('flags', AnimationFrameDataType.Number, boneFlags);
                animation.addFrame(animationFrame);
            }
        }
        return animation;
    }
}
class SourceModelMesh {
    mesh;
    geometry;
    constructor(mesh, geometry) {
        this.mesh = mesh;
        this.geometry = geometry;
    }
}

/**
 * VTX Model
 */
class SourceVTX {
    bodyparts = [];
    getBodyparts() {
        return this.bodyparts;
    }
}

const BODYPART_HEADER_SIZE = 8; // Size in bytes of a BodyPartHeader_t
const MODEL_HEADER_SIZE = 8;
const LOD_HEADER_SIZE = 12;
const MESH_HEADER_SIZE = 9;
const STRIP_GROUP_HEADER_SIZE = 25;
const STRIP_HEADER_SIZE = 27;
function VTXBodyPart() {
    this.models = [];
}
function VTXModel() {
    this.lods = [];
}
function VTXLod() {
    this.meshes = [];
}
function VTXMesh() {
    this.stripGroups = [];
}
function MdlVertex() {
    this.boneWeightIndex = [];
    this.boneID = [];
}
function VTXStripGroupHeader() {
    this.vertices = [];
    this.indexes = [];
    this.strips = [];
}
function MdlStripHeader() {
    this.vertices = [];
    this.indexes = [];
}
class SourceEngineVTXLoader extends SourceBinaryLoader {
    #mdlVersion;
    constructor(mdlVersion) {
        super();
        this.#mdlVersion = mdlVersion;
    }
    parse(repository, fileName, arrayBuffer) {
        let vtx = new SourceVTX();
        let reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, vtx);
        this.#parseBodyParts(reader, vtx);
        return vtx;
    }
    #parseHeader(reader, vtx) {
        reader.seek(0);
        vtx.version = reader.getInt32();
        vtx.vertCacheSize = reader.getInt32();
        vtx.maxBonesPerStrip = reader.getUint16();
        vtx.maxBonesPerFace = reader.getUint16();
        vtx.maxBonesPerVert = reader.getInt32();
        vtx.checkSum = reader.getInt32();
        vtx.numLODs = reader.getInt32();
        vtx.materialReplacementListOffset = reader.getInt32();
        vtx.numBodyParts = reader.getInt32();
        vtx.bodyPartOffset = reader.getInt32();
    }
    #parseBodyParts(reader, vtx) {
        const bodyparts = vtx.bodyparts;
        for (let i = 0; i < vtx.numBodyParts; ++i) {
            // seek the start of body part
            reader.seek(vtx.bodyPartOffset + i * BODYPART_HEADER_SIZE);
            let bodypart = this.#parseBodyPartHeader(reader, vtx);
            if (bodypart) {
                bodyparts.push(bodypart);
            }
            else {
                return false; // More data awaiting
            }
        }
    }
    #parseBodyPartHeader(reader, vtx) {
        const bodypart = new VTXBodyPart();
        const baseOffset = reader.tell();
        bodypart.numModels = reader.getInt32();
        const modelOffset = reader.getInt32();
        for (let i = 0; i < bodypart.numModels; ++i) {
            reader.seek(baseOffset + modelOffset + i * MODEL_HEADER_SIZE);
            bodypart.models.push(this.#parseModelHeader(reader, vtx));
            /*const model = this.readModelHeader();
            if (model) {
                bodypart.models.push(model);
            } else {
                return false;// More data awaiting
            }*/
        }
        return bodypart;
    }
    #parseModelHeader(reader, vtx) {
        const model = new VTXModel();
        const baseOffset = reader.tell();
        model.numLODs = reader.getInt32();
        const lodOffset = reader.getInt32();
        for (let i = 0; i < model.numLODs; ++i) {
            reader.seek(baseOffset + lodOffset + i * LOD_HEADER_SIZE);
            model.lods.push(this.#parseLODHeader(reader, vtx));
            /*const lod = this.#parseLODHeader(reader, vtx);
            if (lod) {
                model.lods.push(lod);
            } else {
                return false;// More data awaiting
            }*/
        }
        return model;
    }
    #parseLODHeader(reader, vtx) {
        const lod = new VTXLod();
        const baseOffset = reader.tell();
        lod.numMeshes = reader.getInt32();
        const meshOffset = reader.getInt32();
        lod.switchPoint = reader.getFloat32();
        for (let i = 0; i < lod.numMeshes; ++i) {
            reader.seek(baseOffset + meshOffset + i * MESH_HEADER_SIZE);
            lod.meshes.push(this.#parseMeshHeader(reader, vtx));
        }
        return lod;
    }
    #parseMeshHeader(reader, vtx) {
        const mesh = new VTXMesh();
        const baseOffset = reader.tell();
        mesh.numStripGroups = reader.getInt32();
        const stripGroupHeaderOffset = reader.getInt32();
        const headerSize = STRIP_GROUP_HEADER_SIZE + Number(this.#mdlVersion >= 49) * 8;
        for (let i = 0; i < mesh.numStripGroups; ++i) {
            reader.seek(baseOffset + stripGroupHeaderOffset + i * headerSize);
            mesh.stripGroups.push(this.#parseStripGroupHeader(reader, vtx));
            /*const stripGroup = this.readStripGroupHeader();
            if (stripGroup) {
                mesh.stripGroups.push(stripGroup);
            } else {
                return false;// More data awaiting
            }*/
        }
        return mesh;
    }
    #parseStripGroupHeader(reader, vtx) {
        const stripGroup = new VTXStripGroupHeader();
        const baseOffset = reader.tell();
        stripGroup.numVerts = reader.getInt32();
        const vertOffset = reader.getInt32();
        stripGroup.numIndices = reader.getInt32();
        const indexOffset = reader.getInt32();
        stripGroup.numStrips = reader.getInt32();
        const stripOffset = reader.getInt32();
        stripGroup.flags = reader.getUint8();
        const vertexSize = vtx.maxBonesPerVert * 2 + 3;
        for (let i = 0; i < stripGroup.numVerts; ++i) {
            reader.seek(baseOffset + vertOffset + i * vertexSize);
            stripGroup.vertices.push(this.#parseVertex(reader, vtx));
        }
        for (let i = 0; i < stripGroup.numIndices; ++i) {
            reader.seek(baseOffset + indexOffset + i * 2);
            stripGroup.indexes.push(reader.getInt16());
        }
        for (let i = 0; i < stripGroup.numStrips; ++i) {
            reader.seek(baseOffset + stripOffset + i * STRIP_HEADER_SIZE);
            stripGroup.strips.push(this.#parseStripHeader(reader, vtx));
        }
        return stripGroup;
    }
    #parseStripHeader(reader, vtx) {
        const stripHeader = new MdlStripHeader();
        //const baseOffset = reader.tell();removeme
        stripHeader.numIndices = reader.getInt32();
        stripHeader.indexOffset = reader.getInt32();
        stripHeader.numVerts = reader.getInt32();
        stripHeader.vertOffset = reader.getInt32();
        stripHeader.numBones = reader.getInt16();
        stripHeader.flags = reader.getUint8();
        stripHeader.numBoneStateChanges = reader.getInt32();
        stripHeader.boneStateChangeOffset = reader.getInt32();
        return stripHeader;
    }
    #parseVertex(reader, vtx) {
        const vertex = new MdlVertex();
        for (let i = 0; i < vtx.maxBonesPerVert; ++i) {
            vertex.boneWeightIndex.push(reader.getUint8());
        }
        vertex.numBones = reader.getUint8();
        vertex.origMeshVertID = reader.getUint16();
        for (let i = 0; i < vtx.maxBonesPerVert; ++i) {
            vertex.boneID.push(reader.getInt8());
        }
        return vertex;
    }
}

/**
 * VVD Model
 */
class SourceVVD {
    vertices;
    numFixups;
    fixups;
    getVertices(lodLevel) {
        if (this.vertices) {
            if (this.numFixups == 0) {
                return this.vertices;
            }
            /*
                        if (!this.fixups) {
                            this.readFixups();
                        }
            */
            if (this.fixups) {
                const vertices1 = [];
                for (let fixupIndex = 0; fixupIndex < this.fixups.length; ++fixupIndex) {
                    const fixup = this.fixups[fixupIndex];
                    if (fixup.lod < lodLevel) {
                        continue;
                    }
                    const last = fixup.sourceVertexID + fixup.numVertexes;
                    for (let vertexIndex = fixup.sourceVertexID; vertexIndex < last; ++vertexIndex) {
                        vertices1.push(this.vertices[vertexIndex]);
                    }
                }
                return vertices1;
            }
        }
        return null;
    }
}

const MAX_NUM_LODS = 8;

const VERTEX_SIZE = 48; // size in bytes of a vertex
const TANGENT_SIZE = 16; // size in bytes of a vertex
const FIXUP_STRUCT_SIZE = 12; // size in bytes of a vertex vertexFileFixup
const MAX_NUM_BONES_PER_VERT = 3;
function StudioBoneWeight() {
    this.weight = [];
    this.bone = [];
    this.numbones = 0;
}
function StudioVertex() {
    this.m_BoneWeights = new StudioBoneWeight();
    this.m_vecPosition = create$4();
    this.m_vecNormal = create$4();
    this.m_vecTexCoord = create();
}
class SourceEngineVVDLoader extends SourceBinaryLoader {
    parse(repository, fileName, arrayBuffer) {
        let vvd = new SourceVVD();
        let reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, vvd);
        this.#parseVertices(reader, vvd);
        this.#parseFixups(reader, vvd);
        return vvd;
    }
    #parseHeader(reader, vvd) {
        reader.seek(0);
        vvd.modelFormatID = reader.getInt32();
        vvd.formatVersionID = reader.getInt32();
        vvd.checkSum = reader.getInt32();
        vvd.numLODs = reader.getInt32();
        vvd.numLODVertexes = [];
        for (let i = 0; i < MAX_NUM_LODS; ++i) {
            vvd.numLODVertexes.push(reader.getInt32());
        }
        vvd.numFixups = reader.getInt32();
        vvd.fixupTableStart = reader.getInt32();
        vvd.vertexDataStart = reader.getInt32();
        vvd.tangentDataStart = reader.getInt32();
    }
    #parseVertices(reader, vvd) {
        if (vvd.numLODVertexes) {
            if (vvd.numLODVertexes[0] === 0) { //TODO ????
                return;
            }
            vvd.vertices = [];
            for (let i = 0; i < vvd.numLODVertexes[0]; ++i) {
                // seek the start of body part
                reader.seek(vvd.vertexDataStart + i * VERTEX_SIZE);
                const vertex = this.#parseVertex(reader, vvd);
                reader.seek(vvd.tangentDataStart + i * TANGENT_SIZE);
                const m_vecTangent = reader.getVector4(); //vec4.fromValues(reader.getFloat32(), reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                // Avoid a nul vector
                if ((m_vecTangent[0] == 0.0) && (m_vecTangent[1] == 0.0) && (m_vecTangent[2] == 0.0)) {
                    m_vecTangent[0] = 1.0;
                }
                vertex.m_vecTangent = m_vecTangent;
            }
        }
    }
    #parseVertex(reader, vvd) {
        const vertex = new StudioVertex();
        for (let i = 0; i < MAX_NUM_BONES_PER_VERT; ++i) {
            vertex.m_BoneWeights.weight[i] = reader.getFloat32();
        }
        for (let i = 0; i < MAX_NUM_BONES_PER_VERT; ++i) {
            vertex.m_BoneWeights.bone[i] = reader.getInt8();
        }
        vertex.m_BoneWeights.numbones = reader.getInt8();
        vertex.m_vecPosition = reader.getVector3();
        vertex.m_vecNormal = reader.getVector3();
        vertex.m_vecTexCoord = reader.getVector2();
        vvd.vertices.push(vertex);
        return vertex;
    }
    #parseFixups(reader, vvd) {
        if (vvd.numFixups === 0) {
            return;
        }
        vvd.fixups = [];
        for (let i = 0; i < vvd.numFixups; ++i) {
            // seek the start of body part
            reader.seek(vvd.fixupTableStart + i * FIXUP_STRUCT_SIZE);
            this.#parseFixup(reader, vvd);
        }
    }
    #parseFixup(reader, vvd) {
        const fixup = Object.create(null);
        fixup.lod = reader.getInt32();
        fixup.sourceVertexID = reader.getInt32();
        fixup.numVertexes = reader.getInt32();
        vvd.fixups.push(fixup);
    }
}

class ModelLoader {
    load(repositoryName, fileName) {
        let promise = new Promise(async (resolve) => {
            fileName = fileName.toLowerCase().replace(/.mdl$/, '');
            // First load mdl. We need the mdl version to load the vtx
            let mdlLoader = getLoader('SourceEngineMDLLoader');
            const mdl = await new mdlLoader().load(repositoryName, fileName + '.mdl');
            let vvdPromise = new SourceEngineVVDLoader().load(repositoryName, fileName + '.vvd');
            let vtxPromise = new SourceEngineVTXLoader(mdl.header.formatVersionID).load(repositoryName, fileName + '.dx90.vtx');
            Promise.all([vvdPromise, vtxPromise]).then((values) => this.#fileLoaded(resolve, repositoryName, fileName, mdl, values[0], values[1]));
        });
        return promise;
    }
    #fileLoaded(resolve, repositoryName, fileName, mdl, vvd, vtx) {
        let requiredLod = 0;
        const vertices = [];
        const normals = [];
        const tangents = [];
        const uvs = [];
        const boneWeights = [];
        const boneIds = [];
        const vertexArray = vvd.getVertices(requiredLod); //vertices;
        const bodyparts = vtx.getBodyparts(); //vertices;
        if (!vertexArray || !bodyparts) {
            resolve(null);
            return;
        }
        let newSourceModel = new SourceModel(repositoryName, fileName, mdl, vvd, vtx);
        for (let i of vertexArray) {
            vertices.push(...i.m_vecPosition);
            normals.push(...i.m_vecNormal);
            tangents.push(...i.m_vecTangent);
            uvs.push(...i.m_vecTexCoord);
            boneWeights.push(...i.m_BoneWeights.weight);
            boneIds.push(...i.m_BoneWeights.bone);
        }
        let vertexPosition = new Float32BufferAttribute(vertices, 3);
        let vertexNormal = new Float32BufferAttribute(normals, 3);
        let vertexTangent = new Float32BufferAttribute(tangents, 4);
        let textureCoord = new Float32BufferAttribute(uvs, 2);
        let vertexWeights = new Float32BufferAttribute(boneWeights, 3);
        let vertexBones = new Float32BufferAttribute(boneIds, 3);
        //let material = new MeshBasicMaterial({map: 'texture'});//removeme
        //console.info('Vertex array :')
        //console.info(vertexArray);
        let bodypart = null;
        let model = null;
        let lod = null;
        let stripgroup = null;
        let cumulateVertexOffset = 0;
        let modelsname = '';
        // Iterate body parts
        for (let bodypartIndex = 0; bodypartIndex < bodyparts.length; ++bodypartIndex) {
            let bodyPart = /*bodyparts[bodypartIndex];//*/ mdl.getBodyPart(bodypartIndex);
            if (bodyPart) {
                bodypart = bodyparts[bodypartIndex];
                // iterate models
                for (let modelIndex = 0; modelIndex < bodypart.models.length; ++modelIndex) {
                    model = bodypart.models[modelIndex];
                    modelsname += bodyPart.models[modelIndex].name + ', '; //TODOV2
                    lod = model.lods[requiredLod];
                    let modelTest = bodyPart.models[modelIndex];
                    // iterate meshes
                    for (let meshIndex = 0; meshIndex < lod.meshes.length; ++meshIndex) {
                        let mesh = lod.meshes[meshIndex];
                        let msh = modelTest.meshArray[meshIndex]; //new SourceModel.MeshTest();
                        if (!msh.initialized) {
                            //msh.setMaterialId(bodyPart.models[modelIndex].meshArray[meshIndex].material);
                            let vertexOffset = cumulateVertexOffset + bodyPart.models[modelIndex].meshArray[meshIndex].vertexoffset; //TODO
                            const indices = [];
                            for (let stripgroupIndex = 0; stripgroupIndex < mesh.stripGroups.length; ++stripgroupIndex) {
                                stripgroup = mesh.stripGroups[stripgroupIndex];
                                let indexArray = stripgroup.indexes;
                                let stripVertexArray = stripgroup.vertices;
                                //if (this.drawBodyPart[bodyPartName])
                                for (let k = 0; k < indexArray.length; ++k) {
                                    const j = indexArray[k];
                                    const sva = stripVertexArray[j];
                                    if (!sva)
                                        break;
                                    const i = sva.origMeshVertID + vertexOffset; //TODO: rename variable i
                                    indices.push(i);
                                }
                            } // stripgroup
                            // reverse triangles from CW to CCW
                            for (let i = 0, l = indices.length; i < l; i += 3) { //TODOv3: optimize
                                let a = indices[i + 1];
                                indices[i + 1] = indices[i + 2];
                                indices[i + 2] = a;
                            }
                            let geometry = new BufferGeometry();
                            geometry.setIndex(new Uint32BufferAttribute(indices, 1));
                            geometry.setAttribute('aVertexPosition', vertexPosition);
                            geometry.setAttribute('aVertexNormal', vertexNormal);
                            geometry.setAttribute('aVertexTangent', vertexTangent);
                            geometry.setAttribute('aTextureCoord', textureCoord);
                            geometry.setAttribute('aBoneWeight', vertexWeights);
                            geometry.setAttribute('aBoneIndices', vertexBones);
                            geometry.properties.set('materialId', msh.material);
                            geometry.properties.set('materialType', msh.materialtype); //TODOv3 : setup a better material param
                            geometry.properties.set('materialParam', msh.materialparam); //TODOv3 : setup a better material param
                            geometry.properties.set('eyeballArray', msh.model.eyeballArray); //TODOv3 : setup a better material param
                            geometry.count = indices.length;
                            geometry.properties.set('name', modelTest.name);
                            newSourceModel.addGeometry(msh, geometry, bodyPart.name, modelIndex);
                        }
                    } // mesh
                    cumulateVertexOffset += bodyPart.models[modelIndex].numvertices;
                } // model
            }
        } // body
        resolve(newSourceModel);
    }
}
registerLoader('ModelLoader', ModelLoader);

/**
 * Light Map
 */
let lightMapNodeId = 0;
/**
 * TODO
 */
const SELightMapNode = function (x, y, width, height) {
    this.y = y;
    this.x = x;
    this.height = height;
    this.width = width;
    this.content = null;
    this.filled = false;
    this.id = ++lightMapNodeId;
};
/**
 * TODO
 */
SELightMapNode.prototype.setContent = function (content) {
    if (this.sub1)
        return false;
    this.content = content;
};
/**
 * TODO
 */
SELightMapNode.prototype.split = function (x, y) {
    if (this.content)
        return false;
    if (this.filled)
        return false;
    if (y >= this.height)
        return false;
    if (x >= this.width)
        return false;
    if (y != 0 && x != 0)
        return false;
    if (y == 0) { /* splitting vertically */
        this.sub1 = new SELightMapNode(this.x, this.y, x, this.height);
        this.sub2 = new SELightMapNode(this.x + x, this.y, this.width - x, this.height);
    }
    else { /* splitting horizontally */
        this.sub1 = new SELightMapNode(this.x, this.y, this.width, y);
        this.sub2 = new SELightMapNode(this.x, this.y + y, this.width, this.height - y);
    }
};
/**
 * TODO
 */
SELightMapNode.prototype.allocate = function (width, height) {
    if (this.filled)
        return false;
    if (this.content)
        return false;
    if (height == 0)
        return false;
    if (width == 0)
        return false;
    if (height > this.height)
        return false;
    if (width > this.width)
        return false;
    let node;
    if (this.sub1) {
        node = this.sub1.allocate(width, height);
        if (node) {
            this.checkFull();
            return node;
        }
    }
    if (this.sub2) {
        node = this.sub2.allocate(width, height);
        if (node) {
            this.checkFull();
            return node;
        }
        return false;
    }
    if (height == this.height && width == this.width) {
        this.filled = true;
        return this;
    }
    if ((height / this.height) > (width / this.width)) {
        this.split(width, 0);
    }
    else {
        this.split(0, height);
    }
    if (this.sub1) {
        node = this.sub1.allocate(width, height);
        if (node) {
            this.checkFull();
            return node;
        }
    }
    if (this.sub2) {
        node = this.sub2.allocate(width, height);
        this.checkFull();
        if (node) {
            this.checkFull();
            return node;
        }
    }
    return null;
};
/**
 * TODO
 */
SELightMapNode.prototype.toString = function () {
    return this.id;
};
/**
 * TODO
 */
SELightMapNode.prototype.checkFull = function () {
    if (this.sub1.filled && this.sub2.filled) {
        this.filled = true;
    }
};
/**
 * TODO
 */
SELightMapNode.prototype.getAllocatedSize = function () {
    let total = 0;
    if (this.sub1) {
        total += this.sub1.getAllocatedSize();
        total += this.sub2.getAllocatedSize();
        return total;
    }
    if (this.filled) {
        return this.height * this.width;
    }
    return 0;
};

/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SEBaseBspLump {
    map;
    initialized = false;
    mapOffset;
    mapLength;
    lumpOffset;
    lumpLen;
    lumpDataPromise = null;
    reader;
    lzmaReader;
    mapLen;
    lumpVersion;
    lumpData;
    lumpType;
    constructor(map, reader, offset, length) {
        this.map = map;
        //this.reader = reader;//TODOv3 remove reader
        this.mapOffset = offset;
        this.mapLength = length;
        this.lumpOffset = offset;
        this.lumpLen = length;
    }
    init() {
        throw 'remove me';
        /*
        if (this.reader.getString(4, this.lumpOffset) == 'LZMA') {
            const uncompressedSize = this.reader.getUint32();
            const compressedSize = this.reader.getUint32();
            const properties = this.reader.getBytes(5);
            const compressedDatas = this.reader.getBytes(this.lumpLen - 17);

            this.lzmaReader = new jDataView(SourceEngine.Choreographies._decompress(properties, compressedDatas, uncompressedSize), undefined, undefined, true);

            this.lumpOffset = 0;
            this.lumpLen = uncompressedSize;
        } else {
            //lumpData.str = this.reader.getString(lump.getLumpLen(), startOffset);
        }
        this.initialized = true;
        */
    }
    /**
     * Set lump offset
     * @param {Number} newLumpOffset The lump offset
     */
    /*setLumpOffset(newLumpOffset) {
        this.lumpOffset = newLumpOffset;
    }*/
    /**
     * Get lump offset
     * @return {Number} The lump offset
     */
    getLumpOffset() {
        return this.lumpOffset;
    }
    getMapOffset() {
        return this.mapOffset;
    }
    /**
     * Set lump len
     * @param {Number} newLumpLen The lump len
     */
    /*setLumpLen(newLumpLen) {
        this.lumpLen = newLumpLen;
    }*/
    /**
     * Get lump len
     * @return {Number} The lump len
     */
    getLumpLen() {
        return this.lumpLen;
    }
    getMapLen() {
        return this.mapLen;
    }
    /**
     * Set lump Version
     * @param {Number} newLumpVersion The lump Version
     */
    setLumpVersion(newLumpVersion) {
        this.lumpVersion = newLumpVersion;
    }
    /**
     * Get lump Version
     * @return {Number} The lump Version
     */
    getLumpVersion() {
        return this.lumpVersion;
    }
    /**
     * Set lump Data
     * @param {Object} newLumpData The lump data
     */
    setLumpData(newLumpData) {
        this.lumpData = newLumpData;
    }
    /**
     * Get lump data
     * @return {Object} The lump data
     */
    getLumpData() {
        const datas = this.lumpData;
        if (!datas) {
            this.initDatas();
        }
        return this.lumpData;
    }
    getReader() {
        if (!this.initialized) {
            this.init();
        }
        if (this.lzmaReader) {
            this.lzmaReader.seek(0);
            return this.lzmaReader;
        }
        else {
            this.reader.seek(this.lumpOffset);
            return this.reader;
        }
    }
    initDatas() {
    }
}
/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SourceBSPLump extends SEBaseBspLump {
    constructor(map, type, reader, offset, length) {
        super(map, reader, offset, length);
        this.lumpType = type;
    }
}
const LUMP_ENTITIES = 0;
const LUMP_PLANES = 1;
const LUMP_TEXDATA = 2;
const LUMP_VERTEXES = 3;
const LUMP_VISIBILITY = 4;
const LUMP_NODES = 5;
const LUMP_TEXINFO = 6;
const LUMP_FACES = 7;
const LUMP_LIGHTING = 8;
const LUMP_LEAFS = 10;
const LUMP_EDGES = 12;
const LUMP_SURFEDGES = 13;
const LUMP_MODELS = 14;
const LUMP_LEAFFACES = 16;
const LUMP_LEAFBRUSHES = 17;
const LUMP_BRUSHES = 18;
const LUMP_BRUSHSIDES = 19;
const LUMP_DISPINFO = 26;
const LUMP_ORIGINALFACES = 27;
const LUMP_DISP_VERTS = 33; // CDispVerts
//		 For each lightmap sample
//				 byte for index
//				 if 255; then index = next byte + 255
//				 3 bytes for barycentric coordinates
// The game lump is a method of adding game-specific lumps
// FIXME: Eventually; all lumps could use the game lump system
const LUMP_GAME_LUMP = 35;
// A pak file can be embedded in a .bsp now; and the file system will search the pak
//	file first for any referenced names; before deferring to the game directory
//	file system/pak files and finally the base directory file system/pak files.
const LUMP_PAKFILE = 40;
const LUMP_TEXDATA_STRING_DATA = 43;
const LUMP_TEXDATA_STRING_TABLE = 44;
const LUMP_OVERLAYS = 45;
const LUMP_DISP_TRIS = 48;
// optional lumps for HDR
const LUMP_LIGHTING_HDR = 53;
const LUMP_FACES_HDR = 58; // HDR maps may have different face data.
const SourceBSPLumpPlane = function () {
    this.normal = null; // normal vector
    this.dist = null; // distance from origin
    this.type = null; // plane axis identifier
};
const SourceBSPLumpEdge = function () {
    // f: first index s: second index
    this.f = null; // better than store as an array of 2 ?
    this.s = null;
};
const SourceBSPLumpFace = function () {
    this.planenum = null;
    this.side = null;
    this.onNode = null;
    this.firstedge = null;
    this.numedges = null;
    this.texinfo = null;
    this.dispinfo = null;
    this.surfaceFogVolumeID = null;
    this.styles = [];
    this.lightofs = null;
    this.area = null;
    this.LightmapTextureMinsInLuxels = null;
    this.LightmapTextureSizeInLuxels = null;
    this.origFace = null;
    this.numPrims = null;
    this.firstPrimID = null;
    this.smoothingGroups = null;
};
/*
unsigned short	planenum;		// the plane number
byte		side;			// faces opposite to the node's plane direction
byte		onNode;			// 1 of on node, 0 if in leaf
int		firstedge;		// index into surfedges
short		numedges;		// number of surfedges
short		texinfo;		// texture info
short		dispinfo;		// displacement info
short		surfaceFogVolumeID;	// ?
byte		styles[4];		// switchable lighting info
int		lightofs;		// offset into lightmap lump
float		area;			// face area in units^2
int		LightmapTextureMinsInLuxels[2];	// texture lighting info
int		LightmapTextureSizeInLuxels[2];	// texture lighting info
int		origFace;		// original face this was split from
unsigned short	numPrims;		// primitives
unsigned short	firstPrimID;
unsigned int	smoothingGroups;	// lightmap smoothing group
*/
const SourceBSPLumpTexData = function () {
    this.reflectivity = null; // RGB reflectivity
    this.nameStringTableID = null; // index into TexdataStringTable
    this.width = null;
    this.height = null; // source image
    this.view_width = null;
    this.view_height = null;
};
/*
const SourceBSPLumpGameLump = function() {
    this.id = null;		// gamelump ID
    this.flags = null;		// flags
    this.version = null;	// gamelump version
    this.fileofs = null;	// offset to this gamelump
    this.filelen = null;	// length
}*/
/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SourceBSPLumpGameLump extends SEBaseBspLump {
    id;
    flags;
    version;
    constructor(map, reader) {
        super(map, reader); //TODOv3
        /*this.lumpOffset = this.mapReader.getInt32();
        this.lumpLen = this.mapReader.getInt32();
        this.lumpVersion = this.mapReader.getInt32();
        this.fourCC = this.mapReader.getInt32();
        this.lumpData = null;*/
        //lump.setLumpOffset(this.reader.getInt32());
        //lump.setLumpLen(this.reader.getInt32());
        //lump.setLumpVersion(this.reader.getInt32());
        //this.reader.getInt32() // TODO: replace by lump fourCC
        //this.init();
    }
}
const SourceBSPLumpPropStaticDirectory = function () {
    this.name = [];
    this.leaf = [];
    this.props = [];
};
const SourceBSPLumpPropStatic = function () {
    this.position = null;
    this.angles = create$4();
    this.propType = null;
    this.firstLeaf = null;
    this.leafCount = null;
    this.solid = null;
    this.flags = null;
    this.skin = null;
    this.fadeMinDist = null;
    this.fadeMaxDist = null;
    this.lightingOrigin = null;
    this.forcedFadeScale = null;
    this.minDXLevel = null;
    this.maxDXLevel = null;
    this.minCPULevel = null;
    this.maxCPULevel = null;
    this.minGPULevel = null;
    this.maxGPULevel = null;
    this.diffuseModulation = null;
    this.disableX360 = null;
    /*// v4
    Vector		Origin;		 // origin
    QAngle		Angles;		 // orientation (pitch roll yaw)
    unsigned short	PropType;	 // index into model name dictionary
    unsigned short	FirstLeaf;	 // index into leaf array
    unsigned short	LeafCount;
    unsigned char	Solid;		 // solidity type
    unsigned char	Flags;
    int		Skin;		 // model skin numbers
    float		FadeMinDist;
    float		FadeMaxDist;
    Vector		LightingOrigin;	// for lighting
    // since v5
    float		ForcedFadeScale; // fade distance scale
    // v6 and v7 only
    unsigned short	MinDXLevel;			// minimum DirectX version to be visible
    unsigned short	MaxDXLevel;			// maximum DirectX version to be visible
    // since v8
    unsigned char	 MinCPULevel;
    unsigned char	 MaxCPULevel;
    unsigned char	 MinGPULevel;
    unsigned char	 MaxGPULevel;
    // since v7
    color32				 DiffuseModulation; // per instance color and alpha modulation
    // since v10
    float					 unknown;
    // since v9
    bool						DisableX360;		 // if true, don't show on XBox 360
    */
};
const SourceBSPLumpTexInfo = function () {
    this.textureVecs = []; // [s/t][xyz offset]
    this.lightmapVecs = []; // [s/t][xyz offset] - length is in units of texels/area
    this.flags; // miptex flags	overrides
    this.texdata;
};
const SourceBSPLumpDispInfo = function () {
    /*Vector			startPosition;		// start position used for orientation
    int			DispVertStart;		// Index into LUMP_DISP_VERTS.
    int			DispTriStart;		// Index into LUMP_DISP_TRIS.
    int			power;			// power - indicates size of surface (2^power	1)
    int			minTess;		// minimum tesselation allowed
    float			smoothingAngle;		// lighting smoothing angle
    int			contents;		// surface contents
    unsigned short		MapFace;		// Which map face this displacement comes from.
    int			LightmapAlphaStart;	// Index into ddisplightmapalpha.
    int			LightmapSamplePositionStart;	// Index into LUMP_DISP_LIGHTMAP_SAMPLE_POSITIONS.
    CDispNeighbor		EdgeNeighbors[4];	// Indexed by NEIGHBOREDGE_ defines.
    CDispCornerNeighbors	CornerNeighbors[4];	// Indexed by CORNER_ defines.
    unsigned int		AllowedVerts[10];	// active verticies*/
};
const SourceBSPLumpDispNeighbor = function () {
    //CDispSubNeighbor	m_SubNeighbors[2];
    this.subNeighbors = [];
};
const SourceBSPLumpDispSubNeighbor = function () {
    /*	unsigned short		m_iNeighbor;		// This indexes into ddispinfos.
                                                // 0xFFFF if there is no neighbor here.

        unsigned char		m_NeighborOrientation;		// (CCW) rotation of the neighbor wrt this displacement.

        // These use the NeighborSpan type.
        unsigned char		m_Span;						// Where the neighbor fits onto this side of our displacement.
        unsigned char		m_NeighborSpan;				// Where we fit onto our neighbor.								 */
};
/*TODO
const SourceBSPLumpDispSubNeighbor
{
};*/
const SourceBSPLumpDispVertex = function () {
    /*	Vector	vec;	// Vector field defining displacement volume.
        float	dist;	// Displacement distances.
        float	alpha;	// 'per vertex' alpha values.*/
};
const SourceBSPLumpColorRGBExp32 = function () {
    /*	Vector	vec;	// Vector field defining displacement volume.
        float	dist;	// Displacement distances.
        float	alpha;	// 'per vertex' alpha values.*/
};
const SourceBSPLumpBrush = function () {
    this.firstside = null;
    this.numsides = null;
    this.contents = null;
};
const SourceBSPLumpBrushSide = function () {
    this.planenum = null;
    this.texinfo = null;
    this.dispinfo = null;
    this.bevel = null;
};
const SourceBSPLumpModel = function () {
    this.mins = null;
    this.maxs = null;
    this.position = null;
    this.headnode = null;
    this.firstface = null;
    this.numfaces = null;
};
/*const SourceBSPLumpLeaf = function() {
/*

    DECLARE_BYTESWAP_DATADESC();
    int				contents;			// OR of all brushes (not needed?)

    short			cluster;

    BEGIN_BITFIELD(bf);
    short			area:9;
    short			flags:7;			// Per leaf flags.
    END_BITFIELD();

    short			mins[3];			// for frustum culling
    short			maxs[3];

    unsigned short	firstleafface;
    unsigned short	numleaffaces;

    unsigned short	firstleafbrush;
    unsigned short	numleafbrushes;
    * /
    this.contents = null;
    this.cluster = null;
    this.areaflags = null;
    this.mins = null;
    this.maxs = null;
    this.firstleafface = null;
    this.numleaffaces = null;
    this.firstleafbrush = null;
    this.numleafbrushes = null;
    this.leafWaterDataID = null;
}*/
class SourceBSPLumpLeaf {
    contents = null;
    cluster = null;
    areaflags = null;
    mins = null;
    maxs = null;
    firstleafface = null;
    numleaffaces = null;
    firstleafbrush = null;
    numleafbrushes = null;
    leafWaterDataID = null;
    contains(position) {
        const mins = this.mins;
        const maxs = this.maxs;
        if (mins[0] <= position[0]
            && mins[1] <= position[1]
            && mins[2] <= position[2]
            && maxs[0] >= position[0]
            && maxs[1] >= position[1]
            && maxs[2] >= position[2]) {
            return true;
        }
        return false;
    }
}
/*const SourceBSPLumpNode = function() {
/*
int			planenum;
int			children[2];	// negative numbers are -(leafs+1), not nodes
short		mins[3];		// for frustom culling
short		maxs[3];
unsigned short	firstface;
unsigned short	numfaces;	// counting both sides
short			area;		// If all leaves below this node are in the same area, then
                            // this is the area index. If not, this is -1.
    * /
    this.planenum = null;
    this.children = null;
    this.mins = null;
    this.maxs = null;
    this.firstface = null;
    this.numfaces = null;
    this.area = null;
}*/
class SourceBSPLumpNode {
    planenum = null;
    children = null;
    mins = null;
    maxs = null;
    firstface = null;
    numfaces = null;
    area = null;
    contains(position) {
        const mins = this.mins;
        const maxs = this.maxs;
        if (mins[0] <= position[0]
            && mins[1] <= position[1]
            && mins[2] <= position[2]
            && maxs[0] >= position[0]
            && maxs[1] >= position[1]
            && maxs[2] >= position[2]) {
            return true;
        }
        return false;
    }
}
class SourceBSPLumpOverlay {
    id;
    texInfo;
    FaceCountAndRenderOrder;
    faces;
    U;
    V;
    UVPoint0;
    UVPoint1;
    UVPoint2;
    UVPoint3;
    Origin;
    BasisNormal;
}

/**
 * BSP Tree
 */
class SourceEngineBspTree {
    map;
    visibilityClusters = undefined;
    clustersCount = 0;
    countRemoveMe = 0;
    leavesRemoveme = [];
    constructor(map) {
        this.map = map;
    }
    set clusters(clusters) {
        if (clusters) {
            this.visibilityClusters = clusters.clusterVis;
            this.clustersCount = clusters.clusterCount;
            this.countRemoveMe++;
            if (this.countRemoveMe > 5000) {
                this.countRemoveMe = 0;
                console.error('Fix me');
            }
        }
    }
    getLeafId(pos) {
        //TODO: optimize
        const map = this.map;
        const lumpModels = map.getLumpData(LUMP_MODELS);
        const lumpPlanes = map.getLumpData(LUMP_PLANES);
        const lumpNodes = map.getLumpData(LUMP_NODES);
        const lumpLeafs = map.getLumpData(LUMP_LEAFS);
        const lumpLeafFaces = map.getLumpData(LUMP_LEAFFACES);
        const lumpVisibility = map.getLumpData(LUMP_VISIBILITY);
        if (lumpModels && lumpPlanes && lumpNodes && lumpLeafs && lumpLeafFaces && lumpVisibility) {
            let model = lumpModels[0];
            let index = model.headnode;
            let node = null;
            let plane = null;
            create$4();
            let dist = 0;
            while (index >= 0) {
                node = lumpNodes[index];
                plane = lumpPlanes[node.planenum];
                //normal[0] = plane.normal.x; normal[1] = plane.normal.y; normal[2] = plane.normal.z; // TODO: Not this.
                //dist = vec3.dot(normal, pos) - plane.dist;
                dist = dot$4(plane.normal, pos) - plane.dist;
                if (dist >= 0) {
                    index = node.children[0];
                }
                else {
                    index = node.children[1];
                }
            }
            return -(index + 1);
        }
        else {
            return undefined;
        }
    }
    isLeafVisible(fromLeafId, toLeafId) {
        if (fromLeafId == toLeafId) {
            return true;
        } // Leaves are always visible from themselves
        let lumpLeafs = this.map.getLumpData(LUMP_LEAFS);
        if (lumpLeafs && this.visibilityClusters) {
            let fromLeaf = lumpLeafs[fromLeafId];
            let toLeaf = lumpLeafs[toLeafId];
            if (fromLeaf.cluster == -1 || toLeaf.cluster != -1) {
                return false;
            }
            return this.visibilityClusters[(fromLeaf.cluster * this.clustersCount) + toLeaf.cluster];
        }
        return false;
    }
    isVisLeaf(leafId) {
        let lumpLeafs = this.map.getLumpData(LUMP_LEAFS);
        if (lumpLeafs) {
            let lumpLeaf = lumpLeafs[leafId];
            if (lumpLeaf) {
                return lumpLeaf.cluster != -1;
            }
        }
        return true;
    }
    addPropToLeaf(leafId, propId) {
        const leaf = this.leavesRemoveme[leafId] || [];
        this.leavesRemoveme[leafId] = leaf;
        leaf.push(propId);
    }
}

function ParseVector(str) {
    const regex = / *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) */i;
    const result = regex.exec(str);
    if (result) {
        return fromValues$4(Number.parseFloat(result[1]), Number.parseFloat(result[3]), Number.parseFloat(result[5]));
    }
    return null;
}
function ParseVector2(out, str) {
    const regex = / *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) */i;
    const result = regex.exec(str);
    if (result) {
        return set$5(out, Number.parseFloat(result[1]), Number.parseFloat(result[3]), Number.parseFloat(result[5]));
    }
    return null;
}
function parseLightColorIntensity(value, light, intensityMultiplier = 1) {
    let colorValue = create$4();
    let arrayValue = value.split(' ');
    colorValue[0] = Math.pow(arrayValue[0] / 255.0, 2.2);
    colorValue[1] = Math.pow(arrayValue[1] / 255.0, 2.2);
    colorValue[2] = Math.pow(arrayValue[2] / 255.0, 2.2);
    light.color = colorValue;
    light.intensity = arrayValue[3] / 255.0 * intensityMultiplier;
}
function AngleQuaternion(angles, outQuat) {
    const sy = Math.sin(angles[1] * 0.5);
    const cy = Math.cos(angles[1] * 0.5);
    const sp = Math.sin(angles[0] * 0.5);
    const cp = Math.cos(angles[0] * 0.5);
    const sr = Math.sin(angles[2] * 0.5);
    const cr = Math.cos(angles[2] * 0.5);
    /*SinCos(DEG2RAD(angles[1]) * 0.5f, &sy, &cy);
    SinCos(DEG2RAD(angles[0]) * 0.5f, &sp, &cp);
    SinCos(DEG2RAD(angles[2]) * 0.5f, &sr, &cr);*/
    // NJS: for some reason VC6 wasn't recognizing the common subexpressions:
    const srXcp = sr * cp, crXsp = cr * sp;
    outQuat[0] = srXcp * cy - crXsp * sy; // X
    outQuat[1] = crXsp * cy + srXcp * sy; // Y
    const crXcp = cr * cp, srXsp = sr * sp;
    outQuat[2] = crXcp * sy - srXsp * cy; // Z
    outQuat[3] = crXcp * cy + srXsp * sy; // W (real component)
    return outQuat;
}
//angles[PITCH, YAW, ROLL]
function AngleVectors(angles, forward) {
    const sy = Math.sin(angles[1]);
    const cy = Math.cos(angles[1]);
    const sp = Math.sin(angles[0]);
    const cp = Math.cos(angles[0]);
    forward[0] = cp * cy;
    forward[1] = cp * sy;
    forward[2] = -sp;
}
function ParseAngles(str) {
    const angles = ParseVector(str);
    if (angles) {
        return scale$5(angles, angles, Math.PI / 180);
    }
    return null;
}
function ParseAngles2(out, str) {
    if (ParseVector2(out, str)) {
        return scale$5(out, out, Math.PI / 180);
    }
    return null;
}
/**
 * Map entity
 */
class MapEntity extends Entity {
    static incrementalId = 0;
    classname;
    outputs = [];
    m_vecVelocity = create$4();
    m_flMoveDoneTime = -1;
    m_flLocalTime = 0;
    f = 0;
    keys = new Map();
    targetName;
    parentName;
    m;
    constructor(classname) {
        super({ name: classname });
        this.classname = classname;
        this.id = String(++MapEntity.incrementalId);
        //this.children = Object.create(null);
    }
    setKeyValues(kvElement) {
        if (kvElement) {
            if (kvElement.spawnflags) {
                this.f = kvElement.spawnflags * 1;
            }
            let entityParams = Object.keys(kvElement);
            for (let i = 0, l = entityParams.length; i < l; i++) {
                let key = entityParams[i];
                this.setKeyValue(key, kvElement[key]);
            }
        }
    }
    setKeyValue(key, value) {
        if (key) {
            this.keys.set(key, value);
            if (key.indexOf('on') == 0) {
                this.addOutput(key.replace(/#\d+$/, ''), value);
            }
            switch (key) {
                case 'targetname':
                    this.targetName = value;
                    break;
                case 'origin':
                    this._position = ParseVector(value);
                    break;
                case 'angles':
                    AngleQuaternion(ParseAngles(value), this._quaternion);
                    break;
                case 'parentname':
                    this.parentName = value;
                    break;
            }
        }
    }
    getValue(key) {
        return this.keys.get(key);
    }
    addOutput(outputName, outputValue) {
        let output = new MapEntityConnection(outputName);
        this.m.addConnection(output);
        this.outputs.push(output);
        output.fromString(outputValue);
        //console.log(output.outputName, output.getTargetName(), output.getTargetInput(), output.getTargetParameter(), output.getDelay(), output.getFireOnlyOnce());
    }
    setInput(input, parameter) {
    }
    getFlag(position) {
        return (this.f >> position) & 1;
    }
    set map(map) {
        this.m = map;
    }
    get map() {
        return this.m;
    }
    move(delta) {
        this.position = add$5(create$4(), this._position, delta); //todo remove me
    }
    /*set position(o) {
        if (o) {
            let oo = this._position;
            if ((o[0] != oo[0]) || (o[1] != oo[1]) || (o[2] != oo[2])) {
                this._position = o;
                let delta = vec3.sub(vec3.create(), this._position, o);
                for (let i in this.children) {
                    let child = this.children[i];
                    child.move(delta, /*initiator || * /this);
                }
            }
        }
    }*/
    /*
    get position() {
        return super.position;
    }
        */
    getAbsOrigin() {
        return null;
    }
    getLocalOrigin() {
        return this._position;
    }
    getLocalVelocity() {
        return this.m_vecVelocity;
    }
    update(map, delta) {
        this.m_flLocalTime += delta;
        if (this.parentName) {
            let parent = map.getEntityByTargetName(this.parentName);
            if (parent) {
                this.setParent(parent);
                delete this.parentName;
            }
        }
        this.position = scaleAndAdd$2(create$4(), this.getLocalOrigin(), this.getLocalVelocity(), delta); //TODO removeme : optimize
    }
    setParent(parent) {
        //void CBaseEntity::SetParent(CBaseEntity *pParentEntity, int iAttachment)
        let oldParent = this.parent;
        this.parent = parent;
        if (parent == this) {
            this.parent = null;
        }
        if (oldParent) {
            oldParent.removeChild(this);
        }
        if (this.parent) {
            this.parent.addChild(this);
        }
    }
    /*addChild(child) {
        if (child) {
            this.children[child.id] = child;
        }
    }

    removeChild(child) {
        if (child) {
            delete this.children[child.id];
        }
    }*/
    setLocalVelocity(vecVelocity) {
        copy$4(this.m_vecVelocity, vecVelocity);
    }
    setMoveDoneTime(delay) {
        if (delay >= 0) {
            this.m_flMoveDoneTime = this.getLocalTime() + delay;
        }
        else {
            this.m_flMoveDoneTime = -1;
        }
    }
    getLocalTime() {
        return this.m_flLocalTime;
    }
    fireOutput(outputName) {
        let outputs = this.outputs;
        let result = [];
        for (let i = 0, l = outputs.length; i < l; i++) {
            let output = outputs[i];
            if (outputName == output.outputName) {
                //result.push(connection);
                output.fire(this.m);
            }
        }
        return result;
    }
    toString() {
        return this.classname;
    }
}
MapEntity.incrementalId = 0;
/**
 * Entity connection
 */
class MapEntityConnection {
    //'OnMapSpawn' 'tonemap_global,SetAutoExposureMax,.8,0,-1'
    n;
    p;
    constructor(name) {
        this.n = name;
        this.p = null;
    }
    fromString(stringDatas) {
        let parameters = stringDatas.split(',');
        if (parameters && parameters.length == 5) {
            this.p = parameters;
        }
    }
    get outputName() {
        return this.n;
    }
    getTargetName() {
        let parameters = this.p;
        if (parameters) {
            return parameters[0];
        }
    }
    getTargetInput() {
        let parameters = this.p;
        if (parameters) {
            return parameters[1];
        }
    }
    getTargetParameter() {
        let parameters = this.p;
        if (parameters) {
            return parameters[2];
        }
    }
    getDelay() {
        let parameters = this.p;
        if (parameters) {
            return parameters[3];
        }
    }
    getFireOnlyOnce() {
        let parameters = this.p;
        if (parameters) {
            return parameters[4];
        }
    }
    fire(map) {
        let parameters = this.p;
        if (parameters) {
            map.setTargetsInput(parameters[0], parameters[1], parameters[2]);
        }
    }
}

/**
 * Map entities
 */
const MapEntities = function () {
};
MapEntities.entities = Object.create(null);
MapEntities.registerEntity = function (className, entityClass) {
    this.entities[className] = entityClass;
};
MapEntities.createEntity = function (map, className) {
    const entityClass = this.entities[className];
    if (!entityClass) {
        return null;
    }
    const entity = new entityClass(className);
    entity.map = map;
    return entity;
};

const DISPLACEMENT_DELTA = 1.0; // max distance from start position
const LIGTH_MAP_TEXTURE_SIZE = 1024;
class SourceBSP extends World {
    repository;
    bspFileVersion = null;
    lumps = [];
    mapRevision = null;
    loaded = false;
    bufferInitialized = false;
    staticGeometry = {};
    skyBoxStaticGeometry = {};
    skyboxGeometry = {};
    overlayVerticesByTexture = {};
    mainLightMap = new SELightMapNode(0, 0, LIGTH_MAP_TEXTURE_SIZE, LIGTH_MAP_TEXTURE_SIZE);
    lightMapTexture = null;
    skyCamera = null;
    skyName = null;
    entities = [];
    connections = [];
    mapSpawn = true;
    lastLeaf = undefined;
    bspTree;
    frameCount = 0;
    mustParseHeader = true;
    funcBrushesRemoveMe = [];
    partialLoading = false;
    eventTarget = new EventTarget(); //TODOv3
    staticProps = new Group({ name: 'Static props' });
    dynamicProps = new Group({ name: 'Dynamic props' });
    mapFaces = new Group({ name: 'World geometry' });
    characterSpawn;
    #geometries;
    loader;
    constructor(params) {
        super(params);
        this.repository = params.repository;
        //this.staticProps = [];
        this.bspTree = new SourceEngineBspTree(this);
        //this.loadFile(root, fileName);
        //BspMap.defaultMaterial = BspMap.defaultMaterial ||	SourceEngine.Materials.MaterialManager._loadMaterial('', SourceEngine.Settings.Materials.defaultLightMappedMaterial).then(function(material){BspMap.defaultMaterial = material;});TODOv3
        this.addChild(this.staticProps);
        this.addChild(this.dynamicProps);
        this.addChild(this.mapFaces);
    }
    initMap() {
        this.initGeometry();
        this._createEntities();
        this._createStaticProps();
    }
    _createEntities() {
        const lumpEntities = this.getLumpData(LUMP_ENTITIES);
        if (lumpEntities) {
            this.createDynamicEntities(lumpEntities.kv);
            /*new Promise((resolve, reject) => {
                this.createDynamicEntities(entities.kv);
                this.eventTarget.dispatchEvent(new CustomEvent('entitiescreated'));//TODOv3
                resolve();
            });*/
        }
    }
    _createStaticProps() {
        const lumpGameDatas = this.getLumpData(LUMP_GAME_LUMP);
        if (lumpGameDatas && lumpGameDatas.prps && lumpGameDatas.prps.lumpData) {
            let propsStatic = lumpGameDatas.prps.lumpData;
            let propNames = propsStatic.name;
            let props = propsStatic.props;
            const tempQuaternion = create$2();
            for (let prop of props) {
                Source1ModelManager.createInstance(this.repository, propNames[prop.propType], true).then((model) => {
                    this.staticProps.addChild(model);
                    model.position = prop.position;
                    model.quaternion = AngleQuaternion(prop.angles, tempQuaternion);
                    model.skin = prop.skin;
                });
            }
        }
    }
    createDynamicEntities(kv) {
        const list = Object.keys(kv.rootElements);
        for (let i = 0; i < list.length; ++i) {
            let entity = kv.rootElements[list[i]];
            if (entity.classname) {
                let e = MapEntities.createEntity(this, entity.classname);
                if (e) {
                    e.setKeyValues(entity);
                    this.addEntity(e);
                }
                else {
                    console.error('Unknown classname : %s', entity.classname);
                }
                if (entity.classname == 'sky_camera') {
                    this.skyCamera = e;
                    //this.renderBuffer = false;
                }
                if (entity.classname == 'worldspawn' && entity.skyname) {
                    //console.log(entity.skyname);
                    this.skyName = entity.skyname;
                }
                if (entity.classname == 'info_player_teamspawn') {
                    if (!this.characterSpawn) {
                        this.characterSpawn = scale$5(create$4(), entity.origin.split(' '), 1);
                    }
                }
            }
        }
    }
    addLump(lump) {
        this.lumps.push(lump);
    }
    getLumpData(lumpType) {
        const lump = this.lumps[lumpType];
        if (lump) {
            return lump.getLumpData();
        }
        return null;
    }
    initFaceGeometry(face, position) {
        if (face.initialized) { //TODOv3
            return;
        }
        face.initialized = true;
        this.getLumpData(LUMP_FACES);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        let texInfo = lumpTexInfo[face.texinfo];
        let texData = lumpTexData[texInfo.texdata];
        let texName = lumpTexDataStringData[texData.nameStringTableID];
        //console.log(face);
        let buffer = this.#geometries[texName];
        if (!buffer) {
            buffer = {
                lastIndice: 0,
                vertices: [], indices: [], coords: [], alphas: [],
                triangleArray: [], alphaArray: [], textureCoord: [], lightMaps: [], textureVecs: lumpTexInfo.textureVecs, height: lumpTexData.height, width: lumpTexData.width
            }; //TODOv3
            this.#geometries[texName] = buffer;
        }
        let textureVecsU = texInfo.textureVecs[0];
        let textureVecsV = texInfo.textureVecs[1];
        const firstEdge = face.firstedge;
        const lastEdge = firstEdge + face.numedges;
        let firstIndice = buffer.lastIndice;
        for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; ++surfEdgeIndex) {
            const surfedge = lumpSurfEdges[surfEdgeIndex];
            const edge = lumpEdges[Math.abs(surfedge)]; //TODOv3 ? why abs
            let vertice1, vertice2;
            if (surfedge <= 0) {
                vertice1 = lumpVertices[edge.f];
                vertice2 = lumpVertices[edge.s];
            }
            else {
                vertice2 = lumpVertices[edge.f];
                vertice1 = lumpVertices[edge.s];
            }
            if (vertice1 && vertice2) {
                if (position) {
                    buffer.vertices.push(vertice1[0] + position[0]); //TODOv3: optimize
                    buffer.vertices.push(vertice1[1] + position[1]);
                    buffer.vertices.push(vertice1[2] + position[2]);
                    buffer.vertices.push(vertice2[0] + position[0]);
                    buffer.vertices.push(vertice2[1] + position[1]);
                    buffer.vertices.push(vertice2[2] + position[2]);
                }
                else {
                    buffer.vertices.push(vertice1[0]); //TODOv3: optimize
                    buffer.vertices.push(vertice1[1]);
                    buffer.vertices.push(vertice1[2]);
                    buffer.vertices.push(vertice2[0]);
                    buffer.vertices.push(vertice2[1]);
                    buffer.vertices.push(vertice2[2]);
                }
                buffer.coords.push((vertice1[0] * textureVecsU[0] + vertice1[1] * textureVecsU[1] + vertice1[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                buffer.coords.push((vertice1[0] * textureVecsV[0] + vertice1[1] * textureVecsV[1] + vertice1[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                buffer.coords.push((vertice2[0] * textureVecsU[0] + vertice2[1] * textureVecsU[1] + vertice2[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                buffer.coords.push((vertice2[0] * textureVecsV[0] + vertice2[1] * textureVecsV[1] + vertice2[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                buffer.indices.push(firstIndice); //TODOv3: optimize
                buffer.indices.push(buffer.lastIndice++); //TODOv3: optimize
                buffer.indices.push(buffer.lastIndice++); //TODOv3: optimize
            }
        }
    }
    initDispGeometry(dispInfo, face) {
        if (face.initialized) { //TODOv3
            return;
        }
        face.initialized = true;
        this.getLumpData(LUMP_FACES);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        let texInfo = lumpTexInfo[face.texinfo];
        let texData = lumpTexData[texInfo.texdata];
        let texName = lumpTexDataStringData[texData.nameStringTableID];
        //console.log(face);
        let buffer = this.#geometries[texName];
        if (!buffer) {
            buffer = {
                lastIndice: 0,
                vertices: [], indices: [], coords: [], alphas: [],
                triangleArray: [], alphaArray: [], textureCoord: [], lightMaps: [], textureVecs: lumpTexInfo.textureVecs, height: lumpTexData.height, width: lumpTexData.width
            }; //TODOv3
            this.#geometries[texName] = buffer;
        }
        let textureVecsU = texInfo.textureVecs[0];
        let textureVecsV = texInfo.textureVecs[1];
        const firstEdge = face.firstedge;
        const lastEdge = firstEdge + face.numedges;
        const origVertices = [];
        for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; ++surfEdgeIndex) {
            const surfedge = lumpSurfEdges[surfEdgeIndex];
            const edge = lumpEdges[Math.abs(surfedge)]; //TODOv3 ? why abs
            let vertice1;
            if (surfedge <= 0) {
                vertice1 = lumpVertices[edge.f];
                lumpVertices[edge.s];
            }
            else {
                lumpVertices[edge.f];
                vertice1 = lumpVertices[edge.s];
            }
            if (vertice1) {
                origVertices.push(vertice1);
            }
        }
        for (let testremoveme = 0; testremoveme < 4; testremoveme++) {
            const vvremoveme = origVertices[0];
            if (Math.abs(vvremoveme[0] - dispInfo.startPosition[0]) < DISPLACEMENT_DELTA
                && Math.abs(vvremoveme[1] - dispInfo.startPosition[1]) < DISPLACEMENT_DELTA
                && Math.abs(vvremoveme[2] - dispInfo.startPosition[2]) < DISPLACEMENT_DELTA) {
                break;
            }
            origVertices.push(origVertices.shift());
        }
        const verticesPerSide = Math.pow(2, dispInfo.power) + 1;
        const tesselateVertices = [];
        /* create tesslate array */
        for (let i = 0; i < verticesPerSide; ++i) {
            const row = [];
            tesselateVertices.push(row);
            for (let j = 0; j < verticesPerSide; ++j) {
                row[j] = null;
            }
        }
        tesselateVertices[0][0] = clone$3(origVertices[0]);
        tesselateVertices[0][verticesPerSide - 1] = clone$3(origVertices[3]);
        tesselateVertices[verticesPerSide - 1][verticesPerSide - 1] = clone$3(origVertices[2]);
        tesselateVertices[verticesPerSide - 1][0] = clone$3(origVertices[1]);
        let subdiv = Math.pow(2, dispInfo.power);
        for (let level = 0; level < dispInfo.power; ++level) {
            const squares = Math.pow(2, level);
            let subdiv2 = subdiv / 2;
            for (let i = 0; i < squares; ++i) {
                for (let j = 0; j < squares; ++j) {
                    const iMin = subdiv * i;
                    const iMax = iMin + subdiv;
                    const jMin = subdiv * j;
                    const jMax = jMin + subdiv;
                    const v1 = tesselateVertices[iMin][jMin];
                    const v2 = tesselateVertices[iMax][jMin];
                    const v3 = tesselateVertices[iMin][jMax];
                    const v4 = tesselateVertices[iMax][jMax];
                    const iMid = iMin + subdiv2;
                    const jMid = jMin + subdiv2;
                    if (v1 && v2 && v3 && v4) {
                        const s1 = Vec3Middle(create$3(), v1, v2);
                        const s2 = Vec3Middle(create$3(), v3, v4);
                        const s3 = Vec3Middle(create$3(), v1, v3);
                        const s4 = Vec3Middle(create$3(), v2, v4);
                        const s5 = Vec3Middle(create$3(), s3, s4);
                        tesselateVertices[iMid][jMin] = s1;
                        tesselateVertices[iMid][jMax] = s2;
                        tesselateVertices[iMin][jMid] = s3;
                        tesselateVertices[iMax][jMid] = s4;
                        tesselateVertices[iMid][jMid] = s5;
                    }
                }
            }
            subdiv = subdiv2;
        }
        /* displace vertices */
        const lumpDispVerts = this.lumps[LUMP_DISP_VERTS].getLumpData();
        let vertexIndex = dispInfo.dispVertStart;
        for (let i = 0; i < verticesPerSide; ++i) {
            for (let j = 0; j < verticesPerSide; ++j) {
                const dispVert = lumpDispVerts[vertexIndex];
                if (dispVert) {
                    const v = tesselateVertices[i][j];
                    if (dispVert.dist > 0) {
                        scaleAndAdd$2(v, v, dispVert.vec, dispVert.dist);
                    }
                    v[3] = dispVert.alpha;
                }
                ++vertexIndex;
            }
        }
        subdiv = Math.pow(2, dispInfo.power);
        for (let i = 0; i < subdiv; ++i) {
            for (let j = 0; j < subdiv; ++j) {
                let firstIndice = buffer.lastIndice;
                const v1 = tesselateVertices[i][j];
                const v2 = tesselateVertices[i + 1][j];
                const v3 = tesselateVertices[i + 1][j + 1];
                const v4 = tesselateVertices[i][j + 1];
                if (v1 && v2 && v3 && v4) {
                    buffer.vertices.push(v1[0], v1[1], v1[2]); //TODOv3: optimize
                    buffer.vertices.push(v2[0], v2[1], v2[2]); //TODOv3: optimize
                    buffer.vertices.push(v3[0], v3[1], v3[2]); //TODOv3: optimize
                    buffer.vertices.push(v4[0], v4[1], v4[2]); //TODOv3: optimize
                    buffer.alphas.push(v1[3] / 255.0, v2[3] / 255.0, v3[3] / 255.0, v4[3] / 255.0);
                    buffer.coords.push((v1[0] * textureVecsU[0] + v1[1] * textureVecsU[1] + v1[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v1[0] * textureVecsV[0] + v1[1] * textureVecsV[1] + v1[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v2[0] * textureVecsU[0] + v2[1] * textureVecsU[1] + v2[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v2[0] * textureVecsV[0] + v2[1] * textureVecsV[1] + v2[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v3[0] * textureVecsU[0] + v3[1] * textureVecsU[1] + v3[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v3[0] * textureVecsV[0] + v3[1] * textureVecsV[1] + v3[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v4[0] * textureVecsU[0] + v4[1] * textureVecsU[1] + v4[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v4[0] * textureVecsV[0] + v4[1] * textureVecsV[1] + v4[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    { //TODOv3
                        buffer.indices.push(firstIndice); //TODOv3: optimize
                        buffer.indices.push(firstIndice + 2);
                        buffer.indices.push(firstIndice + 1);
                        buffer.indices.push(firstIndice + 3);
                        buffer.indices.push(firstIndice + 2);
                        buffer.indices.push(firstIndice);
                    }
                    buffer.lastIndice += 4;
                }
            }
        }
    }
    initGeometry() {
        this.#geometries = {};
        const lumpFaces = this.getLumpData(LUMP_FACES);
        const lumpLeafs = this.getLumpData(LUMP_LEAFS);
        const lumpLeafFaces = this.getLumpData(LUMP_LEAFFACES);
        //const lumpNodes = this.getLumpData(LUMP_NODES);
        const lumpTexLighting = this.getLumpData(LUMP_LIGHTING);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        const lumpModels = this.getLumpData(LUMP_MODELS);
        const lumpDispInfos = this.getLumpData(LUMP_DISPINFO);
        if (lumpFaces && lumpLeafs && lumpLeafFaces && /*lumpNodes && */ lumpTexLighting && lumpTexInfo && lumpTexData && lumpTexDataStringData && lumpSurfEdges && lumpEdges && lumpVertices) {
            if (lumpModels) {
                for (let i = 0; i < this.funcBrushesRemoveMe.length; ++i) {
                    const funcBrushesRemove = this.funcBrushesRemoveMe[i];
                    const modelIndex = funcBrushesRemove.model;
                    const model = lumpModels[modelIndex];
                    if (model) {
                        const firstFace = model.firstface;
                        const lastFace = firstFace + model.numfaces;
                        for (let j = firstFace; j < lastFace; ++j) {
                            const face = lumpFaces[j];
                            //this.renderLeafFace(renderContext, face, funcBrushesRemove.position, 0/*leafId TODO*/);
                            this.initFaceGeometry(face, funcBrushesRemove.origin);
                        }
                    }
                }
            }
            /* Init displacement buffer */
            if (lumpDispInfos) {
                for (let i = 0; i < lumpDispInfos.length; ++i) { //TODO
                    let dispInfo = lumpDispInfos[i];
                    let face = lumpFaces[dispInfo.mapFace];
                    if (face) {
                        this.initDispGeometry(dispInfo, face);
                    }
                }
            }
            for (let leafIndex = 0, l = lumpLeafs.length; leafIndex < l; ++leafIndex) {
                const leaf = lumpLeafs[leafIndex];
                const firstFace = leaf.firstleafface;
                const lastFace = leaf.firstleafface + leaf.numleaffaces;
                for (let faceIndex = firstFace; faceIndex < lastFace; ++faceIndex) {
                    let face = lumpFaces[lumpLeafFaces[faceIndex]];
                    this.initFaceGeometry(face);
                }
            }
        }
        for (let textureName in this.#geometries) {
            let geometry = this.#geometries[textureName];
            if (textureName.toLowerCase().substring(0, 5) == 'tools') { //TODOV3
                continue;
                //continue;
            }
            let bufferGeometry = new BufferGeometry();
            let vertexPosition = new Float32BufferAttribute(geometry.vertices, 3);
            let vertexAlpha = new Float32BufferAttribute(geometry.alphas, 1);
            let textureCoord = new Float32BufferAttribute(geometry.coords, 2);
            bufferGeometry.setIndex(new Uint16BufferAttribute(geometry.indices, 1));
            bufferGeometry.setAttribute('aVertexPosition', vertexPosition);
            bufferGeometry.setAttribute('aVertexAlpha', vertexAlpha);
            bufferGeometry.setAttribute('aTextureCoord', textureCoord);
            bufferGeometry.count = geometry.indices.length;
            let staticMesh = new Mesh(bufferGeometry, null);
            staticMesh.name = textureName;
            SourceEngineMaterialManager.getMaterial(this.repository, textureName).then((material) => staticMesh.setMaterial(material)).catch(() => console.error('unable to find material ' + textureName));
            this.mapFaces.addChild(staticMesh);
        }
    }
    addEntity(entity) {
        if (entity) {
            this.entities.push(entity);
        }
    }
    addConnection(connection) {
        if (connection) {
            this.connections.push(connection);
        }
    }
    getOBBSize(modelIndex) {
        let lumpModels = this.getLumpData(LUMP_MODELS);
        let lumpFaces = this.getLumpData(LUMP_FACES);
        let lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        let lumpEdges = this.getLumpData(LUMP_EDGES);
        let lumpVertices = this.getLumpData(LUMP_VERTEXES);
        if (lumpModels && lumpFaces && lumpSurfEdges && lumpEdges && lumpVertices) {
            let model = lumpModels[modelIndex];
            if (model) {
                if (model.numfaces == 0) {
                    return create$4();
                }
                function compare(v) {
                    for (let i = 0; i < 3; i++) {
                        if (v[i] < min[i]) {
                            min[i] = v[i];
                        }
                        if (v[i] > max[i]) {
                            max[i] = v[i];
                        }
                    }
                }
                let min = fromValues$4(Infinity, Infinity, Infinity);
                let max = fromValues$4(-Infinity, -Infinity, -Infinity);
                let firstFace = model.firstface;
                let lastFace = firstFace + model.numfaces;
                for (let j = firstFace; j < lastFace; j++) {
                    let face = lumpFaces[j];
                    if (face) {
                        let firstEdge = face.firstedge;
                        let lastEdge = firstEdge + face.numedges;
                        for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; surfEdgeIndex++) {
                            let surfedge = lumpSurfEdges[surfEdgeIndex];
                            let edge = lumpEdges[Math.abs(surfedge)];
                            let vertice1 = lumpVertices[edge.f];
                            let vertice2 = lumpVertices[edge.s];
                            compare(vertice1);
                            compare(vertice2);
                        }
                    }
                }
                return sub$2(create$4(), max, min);
            }
        }
        return null;
    }
    static getEntityName() {
        return 'BSP Map';
    }
}

const BODYPART_STRUCT_SIZE = 16;
const MODEL_VERTEX_DATA_STRUCT_SIZE = 8; // Size in bytes of mstudio_modelvertexdata_t
const MODEL_STRUCT_SIZE = 140 + MODEL_VERTEX_DATA_STRUCT_SIZE; // Size in bytes of mstudio_modelvertexdata_t
const MESH_VERTEX_DATA_STRUCT_SIZE = 4 + 4 * MAX_NUM_LODS; // Size in bytes of mstudio_meshvertexdata_t
const MESH_STRUCT_SIZE = 80 + MESH_VERTEX_DATA_STRUCT_SIZE;
const EYEBALL_STRUCT_SIZE = 172; // Size in bytes of mstudioeyeball_t
const STUDIO_VERT_ANIM_NORMAL = 0;
const STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE = 16; // Size in bytes of mstudiovertanim_t
const TEXTURE_STRUCT_SIZE = 64;
const STUDIO_MODEL_GROUP_STRUCT_SIZE = 8;
const STUDIO_ANIM_DESC_STRUCT_SIZE = 25 * 4; // Size in bytes of mstudioanimdesc_t
const STUDIO_SEQUENCE_DESC_STRUCT_SIZE = 53 * 4; // Size in bytes of mstudioseqdesc_t
const STUDIO_EVENT_STRUCT_SIZE = 80; // Size in bytes of mstudioevent_t
const STUDIO_AUTO_LAYER_STRUCT_SIZE = 24; // Size in bytes of mstudioautolayer_t
const BONE_STRUCT_SIZE = 216;
const STUDIO_POSE_PARAMETER_STRUCT_SIZE = 20; // Size in bytes of mstudioposeparamdesc_t
const ATTACHMENT_STRUCT_SIZE = 92;
const STUDIO_FLEX_RULE_STRUCT_SIZE = 12;
const STUDIO_FLEX_OP_STRUCT_SIZE = 8;
const STUDIO_FLEX_CONTROLLER_STRUCT_SIZE = 20; // Size in bytes of mstudioflexcontroller_t
const STUDIO_FLEX_STRUCT_SIZE = 60; // Size in bytes of mstudioflex_t
const STUDIO_HITBOX_SET_STRUCT_SIZE = 12; // Size in bytes of mstudiohitboxset_t
const STUDIO_HITBOX_STRUCT_SIZE = 68; // Size in bytes of mstudiobbox_t
function ModelTest() {
    this.render = true; //removeme
}
function MeshTest() {
    this.render = true; //removeme
}
function MdlStudioFlex() {
}
function MdlStudioVertAnim() {
}
function MdlEyeball() {
}
class MdlAttachement {
    name;
    lowcasename;
    mdl;
    flags = 0;
    localbone = 0;
    local = [];
}
function MdlStudioAnimDesc() {
    this.animSections = [];
}
MdlStudioAnimDesc.prototype.pAnim = function (frameIndex /*, flStall TODOv2*/) {
    if (this.mdl) {
        return this.mdl.loader._parseAnimSection(this.mdl.reader, this, frameIndex);
    }
    return null;
};
MdlStudioAnimDesc.prototype.pZeroFrameData = function () {
    return null;
    /*
    short				zeroframespan;	// frames per span
        short				zeroframecount; // number of spans
        int					zeroframeindex;
        byte				*pZeroFrameData() const { if (zeroframeindex) return (((byte *)this) + zeroframeindex); else return NULL; };
        */
};
MdlStudioAnimDesc.prototype.getAnimBlock = function (reader, block, index) {
    if (block == -1) {
        return null;
    }
    if (block == 0) {
        return this.startOffset + index;
    }
    /* TODO
    byte *pAnimBlock = pStudiohdr()->GetAnimBlock(block);
    if (pAnimBlock)
    {
    return (mstudioanim_t *)(pAnimBlock + index);
    }
    */
    return null;
};
function MdlStudioPoseParam() {
}
function MdlStudioFlexRule() {
}
function MdlStudioFlexOp() {
}
class MdlStudioFlexController {
    localToGlobal = 0;
    min = 0;
    max = 0;
    type = '';
    name = '';
}
function MdlStudioHitboxSet() {
}
function MdlStudioHitbox() {
}
/**
 *	MdlStudioAnimValuePtr
 */
class MdlStudioAnimValuePtr {
    offset;
    base;
    constructor() {
        this.offset = [];
    }
    getAnimValue2(i) {
        return this.base + this.offset[i];
    }
}
const invQuaternion64 = (1 / 1048576.5);
const readQuaternion64 = function (reader) {
    const b = reader.getBytes(8);
    const x = ((b[7] & 0x7F) << 14) | (b[6] << 6) | ((b[5] & 0xFC) >> 2);
    const y = ((b[5] & 0x03) << 19) | (b[4] << 11) | (b[3] << 3) | ((b[2] & 0xE0) >> 5);
    const z = ((b[2] & 0x1F) << 16) | (b[1] << 8) | b[0];
    const neg = (b[7] & 0x80) >> 7;
    const tmpx = (x - 1048576) * invQuaternion64;
    const tmpy = (y - 1048576) * invQuaternion64;
    const tmpz = (z - 1048576) * invQuaternion64;
    let tmpw = Math.sqrt(1 - tmpx * tmpx - tmpy * tmpy - tmpz * tmpz);
    if (neg) {
        tmpw = -tmpw;
    }
    return fromValues$2(tmpx, tmpy, tmpz, tmpw);
};
const invQuaternion48xy = (1 / 32768.0);
const invQuaternion48z = (1 / 16384.0);
const readQuaternion48 = function (reader) {
    const x = reader.getUint16();
    const y = reader.getUint16();
    const tmp = reader.getUint16();
    const z = tmp & 0x7FFF;
    const neg = tmp & 0x8000;
    const tmpx = (x - 32768) * invQuaternion48xy;
    const tmpy = (y - 32768) * invQuaternion48xy;
    const tmpz = (z - 16384) * invQuaternion48z;
    let tmpw = Math.sqrt(1 - tmpx * tmpx - tmpy * tmpy - tmpz * tmpz);
    if (neg) {
        tmpw = -tmpw;
    }
    return fromValues$2(tmpx, tmpy, tmpz, tmpw);
};
class SourceEngineMDLLoader extends SourceBinaryLoader {
    #parseAnimSectionOnce;
    parse(repository, fileName, arrayBuffer) {
        let mdl = new SourceMDL(repository);
        let reader = new BinaryReader(arrayBuffer);
        mdl.reader = reader; //TODOv3//removeme
        mdl.loader = this; //TODOv3//removeme
        this.#parseHeader(reader, mdl);
        this.#parseBodyParts(reader, mdl);
        this.#parseSkinReferences(reader, mdl);
        this.#parseTextures(reader, mdl);
        this.#parseTextureDirs(reader, mdl);
        this.#parseModelGroups(reader, mdl);
        this.#parseAnimDescriptions(reader, mdl);
        this.#parseSequences(reader, mdl);
        this.#parseBones(reader, mdl);
        this.#parsePoseParameters(reader, mdl);
        this.#parseAttachements(reader, mdl);
        this.#parseFlexRules(reader, mdl);
        this.#parseFlexControllers(reader, mdl);
        parseHitBoxSets(reader, mdl);
        return mdl;
    }
    #parseHeader(reader, mdl) {
        mdl.header = Object.create(null);
        const header = mdl.header;
        reader.seek(0);
        header.modelFormatID = reader.getInt32();
        header.formatVersionID = reader.getInt32();
        header.checkSum = reader.getInt32();
        header.modelName = StringStrip(reader.getString(64));
        header.dataLength = reader.getInt32();
        header.eyeposition = reader.getVector3();
        header.illumposition = reader.getVector3();
        header.hull_min = reader.getVector3();
        header.hull_max = reader.getVector3();
        header.view_bbmin = reader.getVector3();
        header.view_bbmax = reader.getVector3();
        header.flags = reader.getInt32();
        mdl.boneCount = reader.getInt32();
        mdl.boneOffset = reader.getInt32();
        mdl.boneControllerCount = reader.getInt32();
        mdl.boneControllerOffset = reader.getInt32();
        mdl.hitboxCount = reader.getInt32();
        mdl.hitboxOffset = reader.getInt32();
        mdl.localAnimCount = reader.getInt32();
        mdl.localAnimOffset = reader.getInt32();
        mdl.localSeqCount = reader.getInt32();
        mdl.localSeqOffset = reader.getInt32();
        header.activitylistversion = reader.getInt32();
        header.eventsindexed = reader.getInt32();
        mdl.textureCount = reader.getInt32();
        mdl.textureOffset = reader.getInt32();
        mdl.textureDirCount = reader.getInt32();
        mdl.textureDirOffset = reader.getInt32();
        mdl.skinReferenceCount = reader.getInt32();
        mdl.skinFamilyCount = reader.getInt32();
        mdl.skinReferenceOffset = reader.getInt32();
        mdl.bodyPartCount = reader.getInt32();
        mdl.bodyPartOffset = reader.getInt32();
        mdl.attachementCount = reader.getInt32();
        mdl.attachementOffset = reader.getInt32();
        mdl.localNodeCount = reader.getInt32();
        mdl.localNodeIndex = reader.getInt32();
        mdl.localNodeNameIndex = reader.getInt32();
        header.numFlexDesc = reader.getInt32();
        mdl.flexDescIndex = reader.getInt32();
        mdl.flexControllerCount = reader.getInt32();
        mdl.flexControllerIndex = reader.getInt32();
        mdl.numFlexRules = reader.getInt32();
        mdl.flexRulesIndex = reader.getInt32();
        mdl.ikChainCount = reader.getInt32();
        mdl.ikChainIndex = reader.getInt32();
        mdl.mouthsCount = reader.getInt32();
        mdl.mouthsIndex = reader.getInt32();
        mdl.localPoseParamCount = reader.getInt32();
        mdl.localPoseParamOffset = reader.getInt32();
        mdl.surfacePropIndex = reader.getInt32();
        mdl.keyValueIndex = reader.getInt32();
        mdl.keyValueCount = reader.getInt32();
        mdl.ikLockCount = reader.getInt32();
        mdl.ikLockIndex = reader.getInt32();
        header.mass = reader.getFloat32();
        header.contents = reader.getInt32();
        mdl.includeModelCount = reader.getInt32();
        mdl.includeModelOffset = reader.getInt32();
        header.virtualModel = reader.getInt32();
        mdl.animBlocksNameIndex = reader.getInt32();
        header.animBlocksCount = reader.getInt32();
        header.animBlocksIndex = reader.getInt32();
        header.animBlockModel = reader.getInt32();
        mdl.boneTableByNameIndex = reader.getInt32();
        mdl.vertexBase = reader.getInt32();
        mdl.offsetBase = reader.getInt32();
        header.directionaldotproduct = reader.getInt8();
        header.rootLod = reader.getInt8();
        header.numAllowedRootLods = reader.getInt8();
        reader.getInt8();
        reader.getInt32();
        mdl.flexControllerUICount = reader.getInt32();
        mdl.flexControllerUIIndex = reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        mdl.studiohdr2index = reader.getInt32();
        reader.getInt32();
        if (mdl.studiohdr2index != 0) {
            //if (this.hasChunk(this.studiohdr2index, 5 * 4)) {
            // seek the start of header2
            reader.seek(mdl.studiohdr2index);
            mdl.srcbonetransform_count = reader.getInt32();
            mdl.srcbonetransform_index = reader.getInt32();
            mdl.illumpositionattachmentindex = reader.getInt32();
            mdl.flMaxEyeDeflection = reader.getFloat32();
            mdl.linearboneOffset = reader.getInt32();
            /*} else {
                return;// More data awaiting
            }*/
        }
    }
    #parseBodyParts(reader, mdl) {
        const bodyParts = [];
        for (let i = 0; i < mdl.bodyPartCount; ++i) {
            const bodyPart = this.#parseBodyPart(reader, mdl, mdl.bodyPartOffset + i * BODYPART_STRUCT_SIZE);
            if (bodyPart !== null) {
                bodyParts.push(bodyPart);
            }
            else {
                return; // More data awaiting
            }
        }
        mdl.bodyParts = bodyParts;
    }
    #parseBodyPart(reader, mdl, startOffset) {
        const nameOffset = reader.getInt32(startOffset) + startOffset;
        // Ensure we have enough data for the name
        const bodyPart = new MdlBodyPart();
        const nummodels = reader.getInt32();
        bodyPart.base = reader.getInt32();
        const modelOffset = reader.getInt32();
        bodyPart.models = [];
        for (let i = 0; i < nummodels; ++i) {
            const model = this.#parseModel(reader, mdl, startOffset + modelOffset + i * MODEL_STRUCT_SIZE);
            if (model !== null) {
                bodyPart.models.push(model);
            }
            else {
                return null; // More data awaiting
            }
            //reader.seek(baseOffset + bodypart.modelindex + i*MODEL_STRUCT_SIZE);
            //bodyPart.models.push(this.readModel());
        }
        bodyPart.name = reader.getNullString(nameOffset);
        return bodyPart;
    }
    #parseModel(reader, mdl, startOffset) {
        // Ensure we have enough data for the name
        const model = new ModelTest();
        model.name = StringStrip(reader.getString(64, startOffset));
        model.type = reader.getInt32();
        model.boundingradius = reader.getFloat32();
        const nummeshes = reader.getInt32();
        const meshOffset = reader.getInt32();
        model.meshArray = [];
        model.vertexArray = [];
        model.eyeballArray = [];
        model.numvertices = reader.getInt32();
        model.vertexindex = reader.getInt32();
        model.tangentsindex = reader.getInt32();
        model.numattachments = reader.getInt32();
        model.attachmentindex = reader.getInt32();
        model.numeyeballs = reader.getInt32();
        model.eyeballindex = reader.getInt32();
        //this.readModelVertexData();//TODO
        reader.skip(4 * 8);
        for (let i = 0; i < nummeshes; ++i) {
            const mesh = this.#parseMesh(reader, mdl, startOffset + meshOffset + i * MESH_STRUCT_SIZE);
            if (mesh !== null) {
                model.meshArray.push(mesh);
                mesh.model = model;
            }
            else {
                return null; // More data awaiting
            }
        }
        for (let i = 0; i < model.numeyeballs; ++i) {
            const eyeBall = this.#parseEyeBall(reader, startOffset + model.eyeballindex + i * EYEBALL_STRUCT_SIZE);
            if (eyeBall !== null) {
                model.eyeballArray.push(eyeBall);
            }
            else {
                return null; // More data awaiting
            }
        }
        return model;
    }
    #parseMesh(reader, mdl, startOffset) {
        // Ensure we have enough data
        //const mesh = new MdlMesh();TODO
        const mesh = new MeshTest(); //TODO
        mesh.material = reader.getInt32(startOffset);
        mesh.modelindex = reader.getInt32();
        mesh.numvertices = reader.getInt32();
        mesh.vertexoffset = reader.getInt32();
        mesh.numflexes = reader.getInt32();
        mesh.flexindex = reader.getInt32() + startOffset; //TODO: add array
        mesh.materialtype = reader.getInt32();
        mesh.materialparam = reader.getInt32();
        mesh.meshid = reader.getInt32();
        mesh.center = reader.getVector3();
        //mesh.vertexData = this.readMeshVertexData();
        reader.skip(4 + MAX_NUM_LODS * 4);
        //mesh.flexes = [];
        reader.skip(4 * 8);
        //TODO: read flexes
        mesh.flexes = this.#parseFlexes(reader, mdl, mesh.flexindex, mesh.numflexes);
        return mesh;
    }
    #parseFlexes(reader, mdl, startOffset, count) {
        const flexes = [];
        for (let i = 0; i < count; ++i) {
            flexes.push(this.#parseFlex(reader, mdl, startOffset + i * STUDIO_FLEX_STRUCT_SIZE));
        }
        return flexes;
    }
    #parseFlex(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const flex = new MdlStudioFlex();
        flex.flexdesc = reader.getInt32();
        flex.target0 = reader.getFloat32();
        flex.target1 = reader.getFloat32();
        flex.target2 = reader.getFloat32();
        flex.target3 = reader.getFloat32();
        flex.numverts = reader.getInt32();
        flex.vertindex = reader.getInt32();
        flex.flexpair = reader.getInt32();
        flex.vertanimtype = reader.getInt8();
        flex.vertAnims = [];
        const vertOffset = startOffset + flex.vertindex;
        if (flex.vertanimtype == STUDIO_VERT_ANIM_NORMAL) {
            //const size = flex.numverts * STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE;
            for (let i = 0; i < flex.numverts; ++i) {
                //reader.seek(vertOffset + i*STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE);
                const vertAnim = this.#parseVertAnim(reader, vertOffset + i * STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE);
                flex.vertAnims.push(vertAnim);
            }
        }
        return flex;
    }
    #parseVertAnim(reader, startOffset) {
        reader.seek(startOffset);
        const vert = new MdlStudioVertAnim();
        vert.index = reader.getUint16();
        vert.speed = reader.getUint8();
        vert.side = reader.getUint8();
        vert.flDelta = [];
        vert.flNDelta = [];
        vert.flDelta[0] = reader.getFloat16();
        vert.flDelta[1] = reader.getFloat16();
        vert.flDelta[2] = reader.getFloat16();
        vert.flNDelta[0] = reader.getFloat16();
        vert.flNDelta[1] = reader.getFloat16();
        vert.flNDelta[2] = reader.getFloat16();
        return vert;
    }
    #parseEyeBall(reader, startOffset) {
        const eyeball = new MdlEyeball();
        const nameOffset = startOffset + reader.getInt32(startOffset);
        eyeball.bone = reader.getInt32();
        eyeball.org = reader.getVector3();
        eyeball.zoffset = reader.getFloat32();
        eyeball.radius = reader.getFloat32();
        eyeball.up = reader.getVector3();
        eyeball.forward = reader.getVector3();
        eyeball.texture = reader.getInt32();
        reader.skip(4); //unused
        eyeball.irisScale = reader.getFloat32();
        reader.skip(4); //unused
        eyeball.upperflexdesc = [reader.getInt32(), reader.getInt32(), reader.getInt32()];
        eyeball.lowerflexdesc = [reader.getInt32(), reader.getInt32(), reader.getInt32()];
        eyeball.uppertarget = reader.getVector3();
        eyeball.lowertarget = reader.getVector3();
        eyeball.upperlidflexdesc = reader.getInt32();
        eyeball.lowerlidflexdesc = reader.getInt32();
        reader.skip(4 * 4); //unused
        eyeball.m_bNonFACS = reader.getInt8();
        reader.skip(3 * 1 + 7 * 4); //unused
        eyeball.name = reader.getNullString(nameOffset);
        //console.error(eyeball);
        return eyeball;
    }
    #parseSkinReferences(reader, mdl) {
        const skinReferences = [];
        // Ensure we have enough data
        reader.seek(mdl.skinReferenceOffset);
        for (let i = 0; i < mdl.skinFamilyCount; ++i) {
            skinReferences[i] = [];
            for (let j = 0; j < mdl.skinReferenceCount; ++j) {
                skinReferences[i].push(reader.getInt16());
            }
        }
        mdl.skinReferences = skinReferences;
    }
    #parseTextures(reader, mdl) {
        const textures = [];
        for (let i = 0; i < mdl.textureCount; ++i) {
            let texture = this.#parseTexture(reader, mdl, mdl.textureOffset + i * TEXTURE_STRUCT_SIZE);
            texture.name = texture.name;
            textures.push(texture);
        }
        mdl.textures = textures;
    }
    #parseTexture(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const nameOffset = reader.getInt32() + startOffset;
        // Ensure we have enough data for the name
        const texture = new MdlTexture();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        texture.name = reader.getNullString(nameOffset);
        texture.originalName = texture.name;
        if (!mdl.baseTexturePath) {
            const regex = /(.*(\\|\/))*/i;
            const result = regex.exec(texture.name);
            if (result) {
                mdl.baseTexturePath = result[0];
            }
        }
        return texture;
    }
    #parseTextureDirs(reader, mdl) {
        for (let i = 0; i < mdl.textureDirCount; ++i) {
            const nameOffset = reader.getInt32(mdl.textureDirOffset + i * 4);
            const textureDir = reader.getNullString(nameOffset);
            if (textureDir !== null) {
                mdl.texturesDir.push(textureDir.replace(/\\/g, '/').toLowerCase());
            }
        }
    }
    #parseModelGroups(reader, mdl) {
        const groups = [];
        for (let i = 0; i < mdl.includeModelCount; ++i) {
            groups.push(this.#parseModelGroup(reader, mdl, mdl.includeModelOffset + i * STUDIO_MODEL_GROUP_STRUCT_SIZE));
        }
        mdl.modelGroups = groups;
    }
    #parseModelGroup(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const labelOffset = reader.getInt32() + startOffset;
        const nameOffset = reader.getInt32() + startOffset;
        const modelgroup = new MdlStudioModelGroup();
        modelgroup.label = reader.getNullString(labelOffset);
        modelgroup.name = reader.getNullString(nameOffset);
        return modelgroup;
    }
    #parseAnimDescriptions(reader, mdl) {
        const animDescriptions = [];
        for (let i = 0; i < mdl.localAnimCount; ++i) {
            const animDescription = this.#parseAnimDescription(reader, mdl, mdl.localAnimOffset + i * STUDIO_ANIM_DESC_STRUCT_SIZE);
            if (animDescription) {
                animDescriptions.push(animDescription);
            }
            else {
                return; // More data awaiting
            }
        }
        mdl.animDesc = animDescriptions;
    }
    #parseAnimDescription(reader, mdl, startOffset) {
        reader.seek(startOffset + 4); //skip 4 first bytes
        const nameOffset = reader.getInt32() + startOffset;
        const animDesc = new MdlStudioAnimDesc();
        animDesc.mdl = mdl;
        animDesc.startOffset = startOffset; //TODOv2: remove?Non
        animDesc.fps = reader.getFloat32();
        animDesc.flags = reader.getInt32();
        animDesc.numframes = reader.getInt32();
        animDesc.nummovements = reader.getInt32();
        reader.getInt32();
        reader.skip(24);
        animDesc.animblock = reader.getInt32();
        animDesc.animIndex = reader.getInt32();
        animDesc.numikrules = reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        animDesc.numlocalhierarchy = reader.getInt32();
        reader.getInt32();
        animDesc.sectionOffset = reader.getInt32();
        animDesc.sectionframes = reader.getInt32();
        animDesc.zeroframespan = reader.getInt16();
        animDesc.zeroframecount = reader.getInt16();
        //console.log(animDesc.zeroframecount);
        animDesc.zeroframeOffset = reader.getInt32();
        reader.getFloat32();
        animDesc.frames = [];
        //TODO
        let numSection;
        if (animDesc.sectionframes != 0) {
            numSection = Math.ceil(animDesc.numframes / animDesc.sectionframes) + 1;
        }
        else {
            numSection = 1;
        }
        numSection = 0;
        for (let i = 0; i < numSection; i++) {
            let section = this._parseAnimSection(reader, animDesc, i); //TODOv3
            animDesc.animSections.push(section);
        }
        animDesc.name = reader.getNullString(nameOffset);
        return animDesc;
    }
    #parseSequences(reader, mdl) {
        for (let i = 0; i < mdl.localSeqCount; ++i) {
            const sequence = this.#parseSequence(reader, mdl, mdl.localSeqOffset + i * STUDIO_SEQUENCE_DESC_STRUCT_SIZE);
            sequence.id = i;
            mdl.sequences.push(sequence);
        }
    }
    #parseSequence(reader, mdl, startOffset) {
        reader.seek(startOffset + 4); //skip 4 first bytes
        const nameOffset = reader.getInt32() + startOffset;
        const activityNameOffset = reader.getInt32() + startOffset;
        const sequence = new MdlStudioSeqDesc();
        sequence.mdl = mdl;
        sequence.startOffset = startOffset; //TODO: remove me
        sequence.flags = reader.getInt32();
        sequence.activity = reader.getInt32();
        sequence.actweight = reader.getInt32();
        sequence.numevents = reader.getInt32();
        sequence.eventindex = reader.getInt32();
        // Bounding box
        sequence.bbmin = reader.getVector3();
        sequence.bbmax = reader.getVector3();
        sequence.numblends = reader.getInt32();
        sequence.animindexindex = reader.getInt32() + startOffset;
        sequence.movementindex = reader.getInt32();
        sequence.groupsize[0] = reader.getInt32();
        sequence.groupsize[1] = reader.getInt32();
        sequence.paramindex.push(reader.getInt32());
        sequence.paramindex.push(reader.getInt32());
        sequence.paramstart.push(reader.getFloat32());
        sequence.paramstart.push(reader.getFloat32());
        sequence.paramend.push(reader.getFloat32());
        sequence.paramend.push(reader.getFloat32());
        sequence.paramparent = reader.getInt32();
        sequence.fadeintime = reader.getFloat32();
        sequence.fadeouttime = reader.getFloat32();
        sequence.localentrynode = reader.getInt32();
        sequence.localexitnode = reader.getInt32();
        sequence.nodeflags = reader.getInt32();
        sequence.entryphase = reader.getFloat32();
        sequence.exitphase = reader.getFloat32();
        sequence.lastframe = reader.getFloat32();
        sequence.nextseq = reader.getInt32();
        sequence.pose = reader.getInt32();
        sequence.numikrules = reader.getInt32();
        sequence.numautolayers = reader.getInt32();
        sequence.autolayerindex = reader.getInt32() + startOffset;
        sequence.weightlistindex = reader.getInt32();
        sequence.posekeyindex = reader.getInt32() + startOffset;
        sequence.numiklocks = reader.getInt32();
        sequence.iklockindex = reader.getInt32();
        sequence.keyvalueindex = reader.getInt32();
        sequence.keyvaluesize = reader.getInt32();
        sequence.cycleposeindex = reader.getInt32();
        //TODO: check size
        reader.seek(sequence.animindexindex);
        for (let i = 0; i < sequence.groupsize[1]; ++i) {
            sequence.blend.push([]);
            for (let j = 0; j < sequence.groupsize[0]; ++j) {
                sequence.blend[i][j] = reader.getInt16();
            }
        }
        if (sequence.numautolayers && sequence.autolayerindex) {
            //const size = sequence.numautolayers * STUDIO_AUTO_LAYER_STRUCT_SIZE;
            for (let i = 0; i < sequence.numautolayers; ++i) {
                reader.seek(sequence.autolayerindex + i * STUDIO_AUTO_LAYER_STRUCT_SIZE);
                //this.readAutoLayer();
                const autoLayer = new MdlStudioAutoLayer();
                autoLayer.iSequence = reader.getInt16();
                autoLayer.iPose = reader.getInt16();
                autoLayer.flags = reader.getInt32();
                autoLayer.start = reader.getFloat32();
                autoLayer.peak = reader.getFloat32();
                autoLayer.tail = reader.getFloat32();
                autoLayer.end = reader.getFloat32();
                sequence.autolayer.push(autoLayer);
            }
        }
        sequence.name = reader.getNullString(nameOffset).toLowerCase();
        //console.log(sequence.name);
        sequence.activityName = reader.getNullString(activityNameOffset);
        // TODO: check size
        for (let boneIndex = 0; boneIndex < mdl.boneCount; ++boneIndex) {
            reader.seek(startOffset + sequence.weightlistindex + boneIndex * 4);
            sequence.weightlist.push(reader.getFloat32());
        }
        for (let eventIndex = 0; eventIndex < sequence.numevents; ++eventIndex) {
            reader.seek(startOffset + sequence.eventindex + STUDIO_EVENT_STRUCT_SIZE * eventIndex);
            const event = this.#parseStudioEvent(reader, mdl, startOffset + sequence.eventindex + STUDIO_EVENT_STRUCT_SIZE * eventIndex);
            sequence.events.push(event);
            /*if (sequence.name.toLowerCase().indexOf('taunt07') != -1) {
                console.log(sequence.name, event);
            }*/
        }
        return sequence;
    }
    #parseStudioEvent(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const studioEvent = new MdlStudioEvent();
        studioEvent.cycle = reader.getFloat32();
        studioEvent.event = reader.getInt32();
        studioEvent.type = reader.getInt32();
        studioEvent.options = reader.getString(64).replace(/\u0000/g, '');
        const nameOffset = reader.getInt32() + startOffset;
        studioEvent.name = reader.getNullString(nameOffset);
        return studioEvent;
    }
    #parseBones(reader, mdl) {
        const bones = [];
        const boneNames = Object.create(null);
        for (let i = 0; i < mdl.boneCount; ++i) {
            const bone = this.#parseBone(reader, mdl.boneOffset + i * BONE_STRUCT_SIZE);
            if (bone !== null) {
                if (bone.parentBone != -1) {
                    //bone.setParent(bones[bone.parentBone]);
                    bone.parent = bones[bone.parentBone];
                    //bone.worldPos = vec3.create();
                    //bone.worldQuat = quat.create();
                }
                bones.push(bone);
                bone.boneId = bones.length - 1;
                boneNames[bone.lowcasename] = bones.length - 1;
            }
            else {
                return; // More data awaiting
            }
        }
        mdl.bones = bones;
        mdl.boneNames = boneNames;
    }
    #parseBone(reader, startOffset) {
        reader.seek(startOffset);
        const nameOffset = reader.getInt32() + startOffset;
        const bone = new MdlBone();
        bone.parentBone = reader.getInt32();
        bone.bonecontroller = new Array();
        for (let i = 0; i < 6; ++i) {
            bone.bonecontroller.push(reader.getInt32());
        }
        bone.position = reader.getVector3();
        bone.quaternion = reader.getVector4();
        reader.getVector3(undefined, undefined, bone.rot);
        reader.getVector3(undefined, undefined, bone.posscale);
        reader.getVector3(undefined, undefined, bone.rotscale);
        let poseToBone = readMatrix3x4(reader);
        bone.poseToBone = poseToBone;
        bone.initPoseToBone = poseToBone;
        //bone.invPoseToBone = mat4.invert(mat4.create(), bone.poseToBone);
        reader.getVector4(undefined, undefined, bone.qAlignment);
        bone.flags = reader.getInt32();
        bone.proctype = reader.getInt32();
        bone.procindex = reader.getInt32();
        bone.physicsbone = reader.getInt32();
        bone.surfacepropidx = reader.getInt32();
        bone.contents = reader.getInt32();
        reader.skip(8 * 4);
        if (bone.procindex && (bone.proctype == 5)) {
            reader.seek(startOffset + bone.procindex);
            //this.readJiggleBone();//TODO
        }
        bone.name = reader.getNullString(nameOffset);
        bone.lowcasename = bone.name.toLowerCase();
        return bone;
    }
    _parseAnimSection(reader, animDesc, frameIndex) {
        //_parseAnimSection(reader, animDesc, sectionIndex) {
        if (animDesc.sectionframes != 0) {
            const sectionIndex = Math.floor(frameIndex / animDesc.sectionframes); //TODOv3
            const sectionOffset1 = animDesc.startOffset + animDesc.sectionOffset + sectionIndex * 8; //TODOv2: name
            reader.seek(sectionOffset1);
            let block = reader.getInt32(); //block;//TODOv2
            let sectionOffset = reader.getInt32();
            if (block == 0) {
                const section = [];
                let blockOffset = 0;
                let anim;
                do {
                    anim = this.#parseAnimBlock(reader, animDesc.startOffset + sectionOffset + blockOffset);
                    if (!anim) {
                        return null;
                    }
                    section.push(anim);
                    blockOffset += anim.nextOffset;
                } while (anim.nextOffset);
                return section;
            }
        }
        else { // animDesc.sectionframes == 0
            const section = [];
            if (animDesc.animblock == 0) {
                if (animDesc.animIndex) {
                    let blockOffset = 0;
                    let anim;
                    do {
                        anim = this.#parseAnimBlock(reader, animDesc.startOffset + animDesc.animIndex + blockOffset);
                        if (!anim) {
                            return null;
                        }
                        section.push(anim);
                        blockOffset += anim.nextOffset;
                    } while (anim.nextOffset);
                }
            }
            //animDesc.animSections.push(section);
            return section;
        }
        return null;
    }
    #parseAnimBlock(reader, startOffset) {
        reader.seek(startOffset);
        const anim = new MdlStudioAnim();
        //anim.baseOffset = reader.tell();TODOv2
        anim.bone = reader.getUint8();
        anim.flags = reader.getUint8();
        anim.nextOffset = reader.getInt16();
        //anim.values = [];TODOv2
        // valid if animation unvaring over timeline
        if ((anim.flags & STUDIO_ANIM_RAWROT) == STUDIO_ANIM_RAWROT) { // 1: STUDIO_ANIM_RAWROT
            //reader.getString(6); //TODO: read Quaternion48
            anim.rawrot = readQuaternion48(reader);
        }
        if ((anim.flags & STUDIO_ANIM_RAWROT2) == STUDIO_ANIM_RAWROT2) { // 2: STUDIO_ANIM_RAWROT2
            anim.rawrot2 = readQuaternion64(reader);
        }
        if ((anim.flags & STUDIO_ANIM_RAWPOS) == STUDIO_ANIM_RAWPOS) { // 3: STUDIO_ANIM_RAWROT
            anim.rawpos = reader.getVector48();
        }
        if ((anim.flags & STUDIO_ANIM_ANIMROT) == STUDIO_ANIM_ANIMROT) { // 1: STUDIO_ANIM_ANIMROT
            anim.animValuePtrRot = this.#parseAnimValuePtr(reader);
        }
        if ((anim.flags & STUDIO_ANIM_ANIMPOS) == STUDIO_ANIM_ANIMPOS) { // 2: STUDIO_ANIM_ANIMPOS
            anim.animValuePtrPos = this.#parseAnimValuePtr(reader);
        }
        return anim;
    }
    #parseAnimValuePtr(reader) {
        const animValuePtr = new MdlStudioAnimValuePtr();
        animValuePtr.base = reader.tell();
        for (let i = 0; i < 3; ++i) {
            animValuePtr.offset.push(reader.getInt16());
        }
        return animValuePtr;
    }
    #parsePoseParameters(reader, mdl) {
        const poseParameters = [];
        for (let i = 0; i < mdl.localPoseParamCount; ++i) {
            const poseParameter = this.#parsePoseParameter(reader, mdl, mdl.localPoseParamOffset + i * STUDIO_POSE_PARAMETER_STRUCT_SIZE);
            if (poseParameter) {
                poseParameters.push(poseParameter);
            }
            else {
                return; // More data awaiting
            }
        }
        mdl.poseParameters = poseParameters;
    }
    #parsePoseParameter(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const nameOffset = reader.getInt32() + startOffset;
        const poseParameter = new MdlStudioPoseParam();
        poseParameter.flags = reader.getInt32();
        poseParameter.start = reader.getFloat32();
        poseParameter.end = reader.getFloat32();
        poseParameter.loop = reader.getFloat32();
        poseParameter.midpoint = RemapValClamped(0.5, poseParameter.start, poseParameter.end, 0, 1);
        reader.seek(nameOffset);
        poseParameter.name = reader.getNullString();
        return poseParameter;
    }
    #parseAttachements(reader, mdl) {
        const attachements = [];
        const attachementNames = {};
        mdl.attachements = attachements;
        mdl.attachementNames = attachementNames;
        if (mdl.attachementCount && mdl.attachementOffset) {
            //const size = mdl.attachementCount * ATTACHMENT_STRUCT_SIZE;
            for (let i = 0; i < mdl.attachementCount; ++i) {
                const attachement = this.#parseAttachement(reader, mdl, mdl.attachementOffset + i * ATTACHMENT_STRUCT_SIZE);
                if (attachement !== null) {
                    attachements.push(attachement);
                    attachementNames[attachement.name.toLowerCase()] = attachement;
                }
                else {
                    return; // More data awaiting
                }
            }
        }
    }
    #parseAttachement(reader, mdl, startOffset) {
        const nameOffset = reader.getInt32(startOffset) + startOffset;
        const attachement = new MdlAttachement();
        attachement.mdl = mdl;
        attachement.flags = reader.getInt32();
        attachement.localbone = reader.getInt32();
        attachement.local = [];
        for (let i = 0; i < 12; ++i) { //local
            attachement.local.push(reader.getFloat32());
        }
        attachement.name = reader.getNullString(nameOffset);
        attachement.lowcasename = attachement.name.toLowerCase();
        return attachement;
    }
    #parseFlexRules(reader, mdl) {
        if (mdl.numFlexRules && mdl.flexRulesIndex) {
            //const size = mdl.numFlexRules * STUDIO_FLEX_RULE_STRUCT_SIZE;
            for (let i = 0; i < mdl.numFlexRules; ++i) {
                mdl.flexRules.push(this.#parseFlexRule(reader, mdl.flexRulesIndex + i * STUDIO_FLEX_RULE_STRUCT_SIZE));
            }
        }
    }
    #parseFlexRule(reader, startOffset) {
        reader.seek(startOffset);
        const rule = new MdlStudioFlexRule();
        rule.flex = reader.getInt32();
        rule.ops = [];
        const numops = reader.getInt32();
        const opindex = startOffset + reader.getInt32();
        for (let i = 0; i < numops; ++i) {
            reader.seek(opindex + i * STUDIO_FLEX_OP_STRUCT_SIZE);
            const op = new MdlStudioFlexOp();
            op.op = reader.getInt32();
            const unionOffset = reader.tell();
            op.index = reader.getInt32();
            op.value = reader.getFloat32(unionOffset);
            rule.ops.push(op);
        }
        return rule;
    }
    #parseFlexControllers(reader, mdl) {
        if (mdl.flexControllerCount && mdl.flexControllerIndex) {
            for (let i = 0; i < mdl.flexControllerCount; ++i) {
                mdl.flexControllers.push(this.#parseFlexController(reader, mdl, mdl.flexControllerIndex + i * STUDIO_FLEX_CONTROLLER_STRUCT_SIZE));
            }
        }
    }
    #parseFlexController(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const typeOffset = reader.getInt32() + startOffset;
        const nameOffset = reader.getInt32() + startOffset;
        const flexController = new MdlStudioFlexController();
        flexController.localToGlobal = reader.getInt32();
        flexController.min = reader.getFloat32();
        flexController.max = reader.getFloat32();
        reader.seek(typeOffset);
        flexController.type = reader.getNullString();
        reader.seek(nameOffset);
        flexController.name = reader.getNullString().toLowerCase();
        // TODO: hack; fix this
        if (flexController.localToGlobal == -1) {
            flexController.localToGlobal = mdl.flexController.getController(flexController.name, flexController.min, flexController.max);
            //TODOv3
            //TODOv4
        }
        return flexController;
    }
}
registerLoader('SourceEngineMDLLoader', SourceEngineMDLLoader);
function readMatrix3x4(reader) {
    let matrix = create$5();
    matrix[0] = reader.getFloat32();
    matrix[4] = reader.getFloat32();
    matrix[8] = reader.getFloat32();
    matrix[12] = reader.getFloat32();
    matrix[1] = reader.getFloat32();
    matrix[5] = reader.getFloat32();
    matrix[9] = reader.getFloat32();
    matrix[13] = reader.getFloat32();
    matrix[2] = reader.getFloat32();
    matrix[6] = reader.getFloat32();
    matrix[10] = reader.getFloat32();
    matrix[14] = reader.getFloat32();
    return matrix;
}
function parseHitBoxSets(reader, mdl) {
    let hitboxSetCount = mdl.hitboxCount;
    let hitboxSetOffset = mdl.hitboxOffset;
    if (hitboxSetCount && hitboxSetOffset) {
        mdl.hitboxSets = [];
        for (let i = 0; i < hitboxSetCount; ++i) {
            mdl.hitboxSets.push(parseHitboxSet(reader, mdl, hitboxSetOffset));
            hitboxSetOffset += STUDIO_HITBOX_SET_STRUCT_SIZE;
        }
        //mdl.hitboxSets = hitboxSets;
    }
}
function parseHitboxSet(reader, mdl, startOffset) {
    const hitboxSet = new MdlStudioHitboxSet();
    const nameOffset = reader.getInt32(startOffset) + startOffset;
    let hitboxCount = reader.getInt32();
    let hitboxOffset = reader.getInt32() + startOffset;
    hitboxSet.name = reader.getNullString(nameOffset);
    const hitboxes = [];
    for (let i = 0; i < hitboxCount; ++i) {
        hitboxes.push(parseHitbox(reader, mdl, hitboxOffset));
        hitboxOffset += STUDIO_HITBOX_STRUCT_SIZE;
    }
    hitboxSet.hitboxes = hitboxes;
    return hitboxSet;
}
function parseHitbox(reader, mdl, startOffset) {
    reader.seek(startOffset);
    const hitbox = new MdlStudioHitbox();
    hitbox.boneId = reader.getInt32();
    hitbox.groupId = reader.getInt32();
    hitbox.bbmin = reader.getVector3();
    hitbox.bbmax = reader.getVector3();
    hitbox.name = reader.getNullString(reader.getInt32() + startOffset);
    return hitbox;
}

class SourceEngineVMTLoaderClass {
    #materials = new Map();
    #extraMaterials = new Map();
    load(repositoryName, fileName) {
        //let fullPathName = repository + fileName;
        /*
        const repository = new Repositories().getRepository(repositoryName);
        if (!repository) {
            console.error(`Unknown repository ${repositoryName} in SourceEngineVMTLoader.load`);
            return null;
        }
            */
        let promise = new Promise(async (resolve, reject) => {
            /*
            const requestCallback = async response => {
                if (response.ok) {
                    this.parse(resolve, repositoryName, fileName, await response.text());
                } else {
                    reject();
                }
            }
            const requestReject = () => {
                let fileContent = this.#extraMaterials.get(fileName);
                if (fileContent) {
                    this.parse(resolve, repositoryName, fileName, fileContent);
                } else {
                    reject();
                }
                ///() =>
            }
                */
            //let req = customFetch(new URL(fileName, repository.base)).then(requestCallback, requestReject);
            const response = await new Repositories().getFileAsText(repositoryName, fileName);
            if (!response.error) {
                this.parse(resolve, repositoryName, fileName, response.text);
            }
            else {
                const fileContent = this.#extraMaterials.get(fileName);
                if (fileContent) {
                    this.parse(resolve, repositoryName, fileName, fileContent);
                }
                else {
                    reject();
                }
            }
        });
        return promise;
    }
    parse(resolve, repositoryName, fileName, fileContent) {
        this.#loadMaterial(repositoryName, fileName, fileContent).then((value) => resolve(value));
    }
    #loadMaterial(repositoryName, fileName, file /*, repository, texturesDir*/) {
        let loadMaterialPromise = new Promise((resolve, reject) => {
            fileName = fileName.replace(/\\/g, '/').toLowerCase().replace(/.vmt$/g, '');
            fileName = fileName.replace(/\\/g, '/').toLowerCase();
            const kv = new KvReader();
            kv.readText(file);
            const vmt = kv.getRootElement();
            if (!vmt) {
                return null;
            }
            const shaderName = kv.getRootName().toLowerCase();
            let material;
            if (shaderName === 'patch') {
                let include = vmt['include'];
                let insert = vmt['insert'];
                let patchResolve = function (material) {
                    for (let insertIndex in insert) {
                        material.variables.set(insertIndex, insert[insertIndex]);
                        material.parameters[insertIndex] = insert[insertIndex];
                    }
                    //materialList[fileNameRemoveMe] = material;removeme
                    resolve(material);
                };
                let patchReject = function () {
                };
                let promise = SourceEngineMaterialManager.getMaterial(repositoryName, include);
                promise.then(patchResolve, patchReject);
            }
            else {
                let materialClass = this.#materials.get(shaderName);
                if (materialClass !== undefined) {
                    vmt.repository = repositoryName;
                    vmt.filename = fileName;
                    material = new materialClass(/*repositoryName, fileName, */ vmt);
                }
                else {
                    console.error('Unknown material : ' + shaderName);
                }
            }
            if (material) {
                resolve(material);
            }
        });
        return loadMaterialPromise;
    }
    setMaterial(fileName, fileContent) {
        this.#extraMaterials.set(fileName, fileContent);
    }
    registerMaterial(materialName, materialClass) {
        this.#materials.set(materialName.toLowerCase(), materialClass);
    }
}
const SourceEngineVMTLoader = new SourceEngineVMTLoaderClass();
registerLoader('SourceEngineVMTLoader', SourceEngineVMTLoader);

const PARAM_TYPE_INT = 'int';
const PARAM_TYPE_FLOAT = 'float';
const PARAM_TYPE_VECTOR = 'vector3';
const PARAM_TYPE_VECTOR3 = 'vector3';
const PARAM_TYPE_COLOR = 'color';
const PARAM_TYPE_BOOL = 'bool';
const PARAM_TYPE_STRING = 'string';
const PARAM_TYPE_ID = 'elementid';
const PARAM_TYPE_UNKNOWN = 'unknown';
const ELEMENT_TYPES = [
    PARAM_TYPE_UNKNOWN,
    PARAM_TYPE_ID,
    PARAM_TYPE_INT,
    PARAM_TYPE_FLOAT,
    PARAM_TYPE_BOOL,
    PARAM_TYPE_STRING,
    '', //TODO	time
    '', //TODO color
    '', //TODO verctor2
    PARAM_TYPE_VECTOR,
    '', //TODO verctor4
];

class Color {
    r;
    g;
    b;
    a;
    constructor(r = 0, g = 0, b = 0, a = 255) {
        // TODO: move / 255 in caller
        this.r = r / 255.0;
        this.g = g / 255.0;
        this.b = b / 255.0;
        this.a = a / 255.0;
    }
    randomize(color1, color2) {
        const f = Math.random();
        this.r = (color2.r - color1.r) * f + color1.r;
        this.g = (color2.g - color1.g) * f + color1.g;
        this.b = (color2.b - color1.b) * f + color1.b;
    }
    setColor(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    setColorAlpha(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        this.a = color.a;
        return this;
    }
    fromVec3(v) {
        this.r = v[0];
        this.g = v[1];
        this.b = v[2];
        return this;
    }
    fromVec4(v) {
        this.r = v[0];
        this.g = v[1];
        this.b = v[2];
        this.a = v[3];
        return this;
    }
    getRed() {
        return Math.round(this.r * 255.0);
    }
    getGreen() {
        return Math.round(this.g * 255.0);
    }
    getBlue() {
        return Math.round(this.b * 255.0);
    }
    getAlpha() {
        return Math.round(this.a * 255.0);
    }
    setRed = function (r) {
        this.r = r / 255.0;
    };
    setGreen = function (g) {
        this.g = g / 255.0;
    };
    setBlue = function (b) {
        this.b = b / 255.0;
    };
    toString() {
        return '' + this.getRed() + ' ' + this.getGreen() + ' ' + this.getBlue() + ' ' + this.getAlpha();
    }
    setWhite() {
        this.r = 1.0;
        this.g = 1.0;
        this.b = 1.0;
        this.a = 1.0;
    }
}
const BLACK = new Color();
const WHITE = new Color(255, 255, 255, 255);

/**
 * TODO
 */
class SourceEngineParticle {
    currentTime = 0;
    previousElapsedTime = 0;
    name;
    id;
    isAlive = false;
    position = create$4();
    prevPosition = create$4();
    cpPosition = create$4();
    cpOrientation = create$2(); //TODO: rename this var
    cpOrientationInvert = create$2();
    velocity = create$4();
    color = new Color(255, 255, 255);
    initialColor = new Color(255, 255, 255);
    uMin = 0;
    uMax = 1;
    vMin = 0;
    vMax = 1;
    system;
    cTime = 0;
    timeToLive;
    initialTimeToLive;
    proportionOfLife;
    u = 0;
    v = 0;
    radius = 1;
    initialRadius = 1;
    rotationRoll = 0;
    initialRoll = 0;
    rotationSpeedRoll = 0;
    rotationYaw = 0;
    startAlpha = 175 / 255;
    alpha = 175 / 255;
    alpha2 = 1.0;
    sequence = 0;
    initialSequence = 0;
    frame = 0;
    PositionFromParentParticles = false;
    posLockedToCP = false;
    rotLockedToCP = false;
    trailLength = 0.1;
    initialCPPosition = null;
    initialCPQuaternion = null;
    renderScreenVelocityRotate = false;
    constructor(id, system) {
        this.name = 'Particle ' + id;
        this.id = id;
        //this.offsetPosition = vec3.create();
        this.system = system;
        this.reset();
        /*
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PREV_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_LIFE_DURATION, 1.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_RADIUS, pDef->m_flConstantRadius);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION, pDef->m_flConstantRotation);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION_SPEED, pDef->m_flConstantRotationSpeed);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TINT_RGB,
                pDef->m_ConstantColor.r() / 255.0f, pDef->m_ConstantColor.g() / 255.0f,
                pDef->m_ConstantColor.g() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ALPHA, pDef->m_ConstantColor.a() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_CREATION_TIME, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER, pDef->m_nConstantSequenceNumber);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER1, pDef->m_nConstantSequenceNumber1);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TRAIL_LENGTH, 0.1f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PARTICLE_ID, 0);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_YAW, 0);*/
    }
    step(elapsedTime) {
        this.currentTime += elapsedTime;
        if (this.timeToLive) {
            this.proportionOfLife = this.currentTime / this.timeToLive;
        }
    }
    start() {
        this.isAlive = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        //this.trail = new Array();
    }
    die() {
        this.isAlive = false;
    }
    reset() {
        //this.firstRender = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.timeToLive = 1;
        zero$4(this.position);
        zero$4(this.prevPosition);
        zero$4(this.cpPosition);
        zero$3(this.cpOrientation);
        //vec3.zero(this.offsetPosition);
        zero$4(this.velocity);
        this.color.setWhite();
        this.initialColor.setWhite();
        this.u = 0;
        this.v = 0;
        this.radius = 1;
        this.initialRadius = 1;
        this.rotationRoll = 0;
        this.initialRoll = 0;
        this.rotationSpeedRoll = 0;
        this.rotationYaw = 0;
        this.startAlpha = 175 / 255;
        this.alpha = this.startAlpha;
        this.alpha2 = 1.0;
        // sequence number for animated textures
        this.sequence = 0;
        this.frame = 0;
        this.PositionFromParentParticles = false;
        this.posLockedToCP = false;
        this.rotLockedToCP = false;
        this.trailLength = 0.1;
        this.initialCPPosition = null;
        this.initialCPQuaternion = null;
        this.renderScreenVelocityRotate = false;
    }
    setInitialField(field, value, mulInitial) {
        this.setField(field, value, mulInitial, true);
    }
    setField(field = 0, value, mulInitial = false, setInitial = false) {
        if (isNaN(field)) {
            return;
        }
        //console.log('Field ' + field + ' ' + value);
        switch (field) {
            case 0: // Position
                copy$4(this.position, value);
                break;
            case 1: // Time to live
                //if (mulInitial) {value*=this.initialSequence;}
                //this.sequence = Math.round(value);
                if (mulInitial) {
                    value += this.initialTimeToLive;
                }
                this.timeToLive = value;
                //console.log(value);
                break;
            case 2: // Previous position
                copy$4(this.prevPosition, value);
                break;
            case 3:
                if (mulInitial) {
                    value += this.initialRadius;
                }
                this.radius = value;
                if (setInitial) {
                    this.initialRadius = value;
                }
                break;
            case 4: //roll
                //value*=57.3;
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                if (mulInitial) {
                    value += this.initialRoll;
                }
                this.rotationRoll = value; //TODO
                break;
            case 5:
                this.rotationSpeedRoll = value;
                break;
            case 6: // Color
                if (mulInitial) {
                    value[0] += this.initialColor.r;
                    value[1] += this.initialColor.g;
                    value[2] += this.initialColor.b;
                }
                value[0] = clamp(value[0], 0.0, 1.0);
                value[1] = clamp(value[1], 0.0, 1.0);
                value[2] = clamp(value[2], 0.0, 1.0);
                this.color.fromVec3(value);
                if (setInitial) {
                    this.initialColor.fromVec3(value);
                }
                break;
            case 7: // Alpha
                if (mulInitial) {
                    value *= this.startAlpha;
                }
                if (setInitial) {
                    this.startAlpha = value;
                }
                this.alpha = value;
                break;
            //case 8: // creation time
            //case 9: // sequence#
            //case 10: // trail length
            case 12: // yaw
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                this.rotationYaw = value; //TODO
                break;
            case 16: // Alpha2
                this.alpha2 = value;
                break;
        }
    }
    /**
    * TODO
    */
    /*
    // required
    DEFPARTICLE_ATTRIBUTE(XYZ, 0);

    // particle lifetime (duration) of particle as a float.
    DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

    // prev coordinates for verlet integration
    DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

    // radius of particle
    DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

    // rotation angle of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

    // rotation speed of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

    // tint of particle
    DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

    // alpha tint of particle
    DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

    // creation time stamp (relative to particle system creation)
    DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

    // sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

    // length of the trail
    DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

    // unique particle identifier
    DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

    // unique rotation around up vector
    DEFPARTICLE_ATTRIBUTE(YAW, 12);

    // second sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

    // hit box index
    DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

    DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

    DEFPARTICLE_ATTRIBUTE( ALPHA2, 16 );
    */
    getField(field = 0, initial = false) {
        switch (field) {
            case 1: // Time to live
                return initial ? this.initialTimeToLive : this.timeToLive;
            case 3:
                return this.radius;
            case 4:
                return this.rotationRoll;
            case 5:
                return this.rotationSpeedRoll;
            case 7:
                return this.alpha;
            case 8: //creation time
                return this.cTime;
            case 12: //yaw
                return this.rotationYaw;
            case 16: //alpha2
                return this.alpha2;
        }
        return 0;
    }
    /**
    * TODO
    */
    setInitialSequence(sequence) {
        this.sequence = sequence;
        this.initialSequence = sequence;
    }
    /**
    * TODO
    */
    setInitialRadius(radius) {
        this.radius = radius;
        this.initialRadius = radius;
    }
    /**
    * TODO
    */
    setInitialTTL(timeToLive) {
        this.timeToLive = timeToLive;
        this.initialTimeToLive = timeToLive;
    }
    /**
    * TODO
    */
    setInitialColor(color) {
        this.color = color;
        this.initialColor = color;
    }
    /**
    * Set particle initial rotation roll.
    * @param {Number} roll Initial rotation roll.
    */
    setInitialRoll(roll) {
        this.rotationRoll = roll;
        this.initialRoll = roll;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getWorldPos(worldPos) {
        worldPos = worldPos || create$4();
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.transformQuat(worldPos, this.position, this.system.currentOrientation);
        transformQuat$1(worldPos, this.position, this.cpOrientation);
        if (this.initialCPPosition) ;
        copy$4(worldPos, this.position);
        return worldPos;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getLocalPos(worldPos) {
        worldPos = worldPos || create$4();
        transformQuat$1(worldPos, this.position, this.cpOrientation);
        transformQuat$1(worldPos, this.position, create$2());
        //vec3.add(worldPos, worldPos, this.cpPosition);
        return worldPos;
    }
}
/* FIELDS
0:velocity ??
1: TTL
3:radius
4:roll
5:roll speed ??
6: color
7: alpha
8:current time
10:scale
12:yaw???
//-----------------------------------------------------------------------------
// Particle attributes
//-----------------------------------------------------------------------------
#define MAX_PARTICLE_ATTRIBUTES 32

#define DEFPARTICLE_ATTRIBUTE(name, bit)						\
    const int PARTICLE_ATTRIBUTE_##name##_MASK = (1 << bit);	\
    const int PARTICLE_ATTRIBUTE_##name = bit;

// required
DEFPARTICLE_ATTRIBUTE(XYZ, 0);

// particle lifetime (duration) of particle as a float.
DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

// prev coordinates for verlet integration
DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

// radius of particle
DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

// rotation angle of particle
DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

// rotation speed of particle
DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

// tint of particle
DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

// alpha tint of particle
DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

// creation time stamp (relative to particle system creation)
DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

// sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

// length of the trail
DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

// unique particle identifier
DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

// unique rotation around up vector
DEFPARTICLE_ATTRIBUTE(YAW, 12);

// second sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

// hit box index
DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

*/
/**
 * TODO
 */

const DEFAULT_MAX_PARTICLES = 1000;
const HARD_MAX_PARTICLES = 5000;
const PARTICLE_ORIENTATION_SCREEN_ALIGNED = 0; //Point towards camera
const PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED = 1; //parallel to camera axis
const PARTICLE_ORIENTATION_WORLD_Z_ALIGNED = 2;
const PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL = 3;
const PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL = 4;
const PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION = 5;

var _a;
const MAX_PARTICLE_CONTROL_POINTS = 64;
let systemNumber = 0;
class ParamType {
    param;
    type;
    constructor(param, type) {
        this.param = param;
        this.type = type;
    }
}
class SourceEngineParticleSystem extends Entity {
    isParticleSystem = true;
    repository;
    #autoKill = false;
    #looping = false;
    isLoopable = true;
    #sequenceNumber = 0;
    #materialPromiseResolve;
    #materialPromise;
    #renderers = new Map();
    #particleCount = 0;
    #randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
    #maximumTimeStep = 0.1;
    animable = true;
    resetable = true;
    paramList = [];
    parameters = {};
    minimumTickRate = 0;
    maximumTickRate = 1;
    // particle to emit when the system starts
    initialParticles = 0;
    currentParticles = 0;
    currentTime = 0;
    // elapsed time since last ste
    elapsedTime = 0.05;
    previousElapsedTime = 0.05;
    speed = 1;
    isRunning = false;
    radius = 1;
    attachementBone = null;
    // List of living particles
    livingParticles = new Array();
    // List of dead but reusable particles
    poolParticles = new Array();
    currentOrientation = create$2();
    prevOrientation = create$2();
    emitters = {}; //new Array();//todo transform to map
    initializers = {}; // = new Array();//todo transform to map
    operators = {}; //new Array();//todo transform to map
    forces = new Map(); //new Array();//todo transform to map
    constraints = {}; //new Array();//todo transform to map
    controlPoints = [];
    childrenSystems = []; //todo transform to map
    tempChildren = {}; //new Array();//todo transform to map
    operatorRandomSampleOffset = 0;
    parentSystem;
    firstStep = false;
    pcf;
    material;
    materialName;
    maxParticles = DEFAULT_MAX_PARTICLES;
    resetDelay = 0;
    snapshot;
    static #speed = 1.0;
    static #simulationSteps = 1;
    //constructor(repository, parameters, id) {
    constructor(params) {
        params.name = params.name ?? `System ${systemNumber++}`;
        super(params);
        this.repository = params.repository;
        this.addParam('max_particles', PARAM_TYPE_INT, 50);
        this.addParam('initial_particles', PARAM_TYPE_INT, 0);
        this.addParam('material', PARAM_TYPE_STRING, '');
        this.addParam('snapshot', PARAM_TYPE_STRING, '');
        this.addParam('color', PARAM_TYPE_COLOR, new Color(255, 255, 255, 255));
        this.addParam('radius', PARAM_TYPE_FLOAT, 1);
        this.addParam('name', PARAM_TYPE_STRING, params.name);
        this.addParam('id', PARAM_TYPE_ID, params.id);
        this.addParam('minimum sim tick rate', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum sim tick rate', PARAM_TYPE_FLOAT, 1);
        this.addParam('maximum time step', PARAM_TYPE_FLOAT, 0.1);
        //this.maxParticles = null;
        //this.getControlPoint(0);
        /*for (let i = 0; i < MAX_PARTICLE_CONTROL_POINTS; ++i) {
            let cp = new ControlPoint();
            cp.name = i;
            this.addChild(cp);
            this.controlPoints.push(cp);

            vec3.set(cp.fVector, 0, 1, 0);
            vec3.set(cp.uVector, 0, 0, 1);
            vec3.set(cp.rVector, 1, 0, 0);
        }*/
    }
    start() {
        if (this.isRunning)
            return;
        Source1ParticleControler.setActive(this);
        this.firstStep = true;
        this.updateChilds();
        this.#reset();
        this.#startChildren();
        //		this.emitInitialParticles();
        this.isRunning = true;
    }
    #startChildren() {
        for (let i = 0; i < this.childrenSystems.length; ++i) {
            this.childrenSystems[i].start();
        }
    }
    stop() {
        this.stopChildren();
        this.isRunning = false;
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            this.poolParticles.push(particle);
            this.livingParticles.splice(i, 1);
            --i;
        }
    }
    stopChildren() {
        for (let i = 0; i < this.childrenSystems.length; ++i) {
            this.childrenSystems[i].stop();
        }
    }
    do(action, params) {
        switch (action) {
            case 'reset':
                this.reset();
                break;
        }
    }
    reset() {
        this.stop();
        this.start();
    }
    #reset() {
        //console.log('Reset PS');
        this.currentTime = 0;
        this.elapsedTime = 0.05;
        this.previousElapsedTime = 0.05;
        this.#resetChilds();
        this.#resetEmitters();
        this.#resetInitializers();
    }
    #resetChilds() {
        for (let i = 0; i < this.childrenSystems.length; ++i) {
            this.childrenSystems[i].#reset();
        }
    }
    #resetEmitters() {
        for (let i in this.emitters) { //TODOv3
            const emitter = this.emitters[i];
            emitter.reset();
        }
    }
    #resetInitializers() {
        for (let i in this.initializers) {
            this.initializers[i].reset();
        }
    }
    updateChilds() {
        for (let i in this.tempChildren) {
            const ps = this.pcf?.getSystem(this.tempChildren[i]);
            if (ps) {
                this.addChildSystem(ps);
                delete this.tempChildren[i];
            }
        }
    }
    step(elapsedTime) {
        if (!this.isPlaying()) {
            elapsedTime = 0.0000001;
        }
        for (let i = 0; i < _a.#simulationSteps; i++) {
            this.#step(elapsedTime / _a.#simulationSteps);
        }
    }
    #step(elapsedTime) {
        if (!this.isRunning || _a.#speed == 0) {
            return;
        }
        elapsedTime = Math.min(elapsedTime, this.#maximumTimeStep);
        this.previousElapsedTime = this.elapsedTime;
        this.elapsedTime = elapsedTime;
        //elapsedTime = clamp(elapsedTime, this.minimumTickRate, this.maximumTickRate);
        this.stepControlPoint();
        if (this.firstStep) {
            this.firstStep = false;
            elapsedTime = 0.05;
            this.#emitInitialParticles(elapsedTime);
        }
        this.elapsedTime = elapsedTime * this.speed * _a.#speed;
        this.#stepOperators1();
        this.stepControlPoint();
        this.#stepEmitters();
        this.currentTime += this.elapsedTime;
        //this.stepForces();
        if (!this.parentSystem) {
            this.setCpOrientation();
        }
        else {
            this.setCpOrientation();
        }
        this.#stepOperators();
        //this.stepConstraints();
        /*if (this.livingParticles.length == 0 && this.allowReset) {
            this.resetDelay+=this.elapsedTime;
            if (this.resetDelay>RESET_DELAY) this.reset();
        };*/
        if (this.material) {
            this.#stepRenderers(elapsedTime);
        }
        this.#stepChildren(elapsedTime);
    }
    #emitInitialParticles(elapsedTime) {
        for (let i = 0; i < this.initialParticles; ++i) {
            this.createParticle(0, elapsedTime);
        }
    }
    #stepEmitters() {
        for (let i in this.emitters) {
            const emitter = this.emitters[i];
            emitter.doEmit(this.elapsedTime);
        }
    }
    /**
     * Step operators for each particle, killing it if necessary.
     */
    #stepOperators() {
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            particle.step(this.elapsedTime);
            this.operatorRandomSampleOffset = 0;
            for (let j in this.operators) {
                const operator = this.operators[j];
                operator.operateParticle(particle, this.elapsedTime);
                // break the loop if the particle is dead
                if (!particle.isAlive)
                    break;
                this.operatorRandomSampleOffset += 17;
            }
            //particle.step(this.elapsedTime);
            if (!particle.isAlive) {
                this.poolParticles.push(particle);
                this.livingParticles.splice(i, 1);
                --i;
            }
        }
        if (this.livingParticles.length == 0) {
            for (let j in this.operators) {
                const operator = this.operators[j];
                switch (operator.functionName) {
                    case 'set control point positions':
                        operator.operateParticle(null, this.elapsedTime);
                        break;
                }
            }
            this.#checkFinished();
        }
    }
    #checkFinished() {
        if (this.#finished()) {
            if (this.#autoKill) {
                this.stop();
                this.remove();
                return;
            }
            if (this.#looping) {
                //TODO: add delay
                this.#reset();
            }
        }
    }
    #finished() {
        if (Object.keys(this.tempChildren).length) {
            return false;
        }
        for (let i in this.emitters) {
            const emitter = this.emitters[i];
            if (!emitter.finished()) {
                return false;
            }
        }
        for (let child of this.childrenSystems) {
            if ((child.livingParticles.length > 0) || !child.#finished()) {
                return false;
            }
        }
        return true;
    }
    #stepOperators1() {
        if (this.livingParticles.length == 0) {
            for (let j in this.operators) {
                const operator = this.operators[j];
                switch (operator.functionName) {
                    case 'set control point positions':
                        operator.operateParticle(null, this.elapsedTime);
                        break;
                }
            }
        }
    }
    /**
     * Step forces for each particle.
     */
    stepForces() {
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            for (let force of this.forces.values()) {
                //const force = this.forces[j];
                force.forceParticle(particle, this.elapsedTime);
            }
        }
    }
    stepConstraints(particle) {
        //TODOv3: multiple passes
        for (let j in this.constraints) {
            const constraint = this.constraints[j];
            constraint.constraintParticle(particle);
        }
    }
    #stepRenderers(elapsedTime) {
        for (const [_, renderer] of this.#renderers) {
            renderer.updateParticles(this, this.livingParticles, elapsedTime);
        }
    }
    #stepChildren(elapsedTime) {
        for (let j in this.childrenSystems) { //TODOv3
            const child = this.childrenSystems[j];
            child.#step(elapsedTime);
        }
    }
    createParticle(creationTime, elapsedTime) {
        if (this.livingParticles.length < this.maxParticles) {
            // first try to get one from the pool
            if (this.poolParticles.length > 0) {
                const particle = this.poolParticles.pop();
                //init the particle to its initial state;
                particle.reset();
                particle.cTime = creationTime;
                this.#initControlPoint(particle);
                this.#startParticle(particle, elapsedTime);
                return particle;
            }
            const particle = new SourceEngineParticle(/*'Particle ' + */ (this.#randomSeed + this.#particleCount++) % MAX_FLOATS, this);
            particle.cTime = creationTime;
            this.#initControlPoint(particle);
            this.#startParticle(particle, elapsedTime);
            ++this.currentParticles;
            return particle;
        }
        //console.error('No particle has been emitted. Try to raise max particles');
        return null;
    }
    #startParticle(particle, elapsedTime) {
        this.resetDelay = 0;
        this.livingParticles.push(particle);
        this.#preInitParticle(particle);
        particle.previousElapsedTime = elapsedTime;
        particle.start();
        // Init modifiers in a 2nd loop
        for (let i in this.initializers) {
            const initializer = this.initializers[i];
            if (!initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
        for (let i in this.initializers) {
            const initializer = this.initializers[i];
            if (initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
    }
    #preInitParticle(particle) {
        const radius = this.getParameter('radius') || 1;
        const color = this.getParameter('color') ?? WHITE;
        particle.setInitialRadius(radius);
        particle.setInitialSequence(this.#sequenceNumber);
        particle.color.setColorAlpha(color); //TODO: remove alpha
        particle.startAlpha = color.a;
        particle.alpha = color.a;
        //particle.creationTime = this.currentTime;
    }
    #initControlPoint(particle) {
        this.getWorldPosition(particle.cpPosition);
    }
    getWorldPosition(vec = create$4()) {
        return zero$4(vec);
    }
    stepControlPoint() {
        for (let i = 0; i < this.controlPoints.length; i++) {
            const cp = this.controlPoints[i];
            if (!cp) {
                continue;
            }
            cp.step();
        }
        if (this.parentSystem) {
            this.setOrientation(this.parentSystem.getWorldQuaternion());
        }
    }
    setParam(element) {
        if (!element) {
            return null;
        }
        const parameter = element.typeName;
        const type = element.type;
        const value = element.value;
        return this.setParameter(parameter, type, value);
    }
    addParam(param, type, value) {
        this.paramList.push(new ParamType(param, type));
        this.setParameter(param, type, value);
    }
    setParameter(parameter, type /*TODO: create an enum*/, value) {
        if (parameter == '')
            return;
        if (this.parameters[parameter] === undefined) {
            this.parameters[parameter] = {};
        }
        this.parameters[parameter].type = type;
        this.parameters[parameter].value = value;
        this.propertyChanged(parameter);
        return this;
    }
    propertyChanged(name) {
        const value = this.getParameter(name);
        switch (name) {
            case 'material':
                this.setMaterialName(value);
                break;
            case 'max_particles':
                this.setMaxParticles(value);
                break;
            case 'snapshot':
                this.setSnapshot(value);
                break;
            /*
        case 'snapshot_control_point':
            this.setSnapshotCP(value);
            break;
            */
            case 'radius':
                this.setRadius(value);
                break;
            case 'initial_particles':
                this.setInitialParticles(value);
                break;
            case 'minimum sim tick rate':
                this.setMinimumTickRate(value);
                break;
            case 'maximum sim tick rate':
                this.setMaximumTickRate(value);
                break;
            case 'maximum time step':
                this.#maximumTimeStep = value;
                break;
            case 'sequence_number':
                this.#sequenceNumber = value;
                break;
        }
    }
    getParameter(parameterName) {
        const parameter = this.parameters[parameterName];
        if (parameter === undefined) {
            return null;
        }
        return parameter.value;
    }
    setMaxParticles(max) {
        this.maxParticles = Math.max(Math.min(max, HARD_MAX_PARTICLES), 1);
    }
    setRadius(radius) {
        this.radius = radius;
    }
    setInitialParticles(initial) {
        this.initialParticles = initial;
    }
    setMinimumTickRate(minimum) {
        this.minimumTickRate = minimum;
    }
    setMaximumTickRate(maximum) {
        this.maximumTickRate = maximum;
    }
    setMaterialName(materialName) {
        if (!materialName || materialName === '') {
            return;
        }
        this.materialName = materialName;
        SourceEngineMaterialManager.getMaterial(this.repository, materialName).then((material) => {
            this.material = material;
            material.addUser(this);
            if (this.#materialPromiseResolve) {
                this.#materialPromiseResolve(material);
            }
        });
    }
    #getMaterial() {
        this.#materialPromise = this.#materialPromise ?? new Promise((resolve, reject) => {
            this.#materialPromiseResolve = resolve;
        });
        return this.#materialPromise;
    }
    setSnapshot(snapshot /*TODO: better type*/) {
        if (!snapshot || snapshot === '') {
            return;
        }
        if (snapshot !== this.snapshot) {
            this.snapshot = snapshot;
            //this.loadSnapshot();//TODOv3
        }
    }
    addSub(type, object, id) {
        switch (type) {
            case 'operator':
            case 'operators':
                this.addOperator(object, id);
                break;
            case 'force':
            case 'forces':
                this.addForce(object, id);
                break;
            case 'constraint':
            case 'constraints':
                this.addConstraint(object, id);
                break;
            case 'emitter':
            case 'emitters':
                this.addEmitter(object, id);
                break;
            case 'initializer':
            case 'initializers':
                this.addInitializer(object, id);
                break;
            case 'renderer':
            case 'renderers':
                this.addRenderer(object, id);
                break;
        }
    }
    addEmitter(emitter, id) {
        this.emitters[id] = emitter;
        emitter.setParticleSystem(this);
    }
    addInitializer(initializer, id) {
        this.initializers[id] = initializer;
        initializer.setParticleSystem(this);
    }
    addOperator(operator, id) {
        this.operators[id] = operator;
        operator.setParticleSystem(this);
    }
    removeOperator(id) {
        delete this.emitters[id];
        delete this.initializers[id];
        delete this.operators[id];
        this.forces.delete(id);
        delete this.constraints[id];
        this.#renderers.delete(id);
        //delete this.childrenSystems[id];
        //this.removeChild(id);
    }
    addForce(force, id) {
        this.forces.set(id, force);
        force.setParticleSystem(this);
    }
    addConstraint(constraint, id) {
        this.constraints[id] = constraint;
        constraint.setParticleSystem(this);
    }
    addRenderer(renderer, id) {
        this.#renderers.set(id, renderer);
        renderer.setParticleSystem(this);
        this.#getMaterial().then((material) => renderer.initRenderer(this));
    }
    getControlPoint(controlPointId) {
        if (controlPointId < 0 || controlPointId >= MAX_PARTICLE_CONTROL_POINTS) {
            return null;
        }
        let parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            return this.controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId);
        }
        let controlPoint = this.controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
        }
        return controlPoint;
    }
    getOwnControlPoint(controlPointId) {
        return this.controlPoints[controlPointId] ?? this.#createControlPoint(controlPointId);
    }
    #createControlPoint(controlPointId) {
        let controlPoint = new ControlPoint();
        controlPoint.name = String(controlPointId);
        if (controlPointId == 0) {
            this.addChild(controlPoint);
        }
        else {
            //Attach to first control point
            //this.getControlPoint(0).addChild(controlPoint);
            this.addChild(controlPoint);
        }
        this.controlPoints[controlPointId] = controlPoint;
        set$5(controlPoint.fVector, 0, 1, 0);
        set$5(controlPoint.uVector, 0, 0, 1);
        set$5(controlPoint.rVector, 1, 0, 0);
        let parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            let parentControlPoint = parentSystem.getControlPoint(controlPointId);
            if (parentControlPoint) {
                controlPoint.parentControlPoint = parentControlPoint;
            }
        }
        return controlPoint;
    }
    addTempChild(name, id) {
        this.tempChildren[id] = name;
    }
    addChildSystem(particleSystem) {
        this.childrenSystems.push(particleSystem);
        particleSystem.setParent(this);
        this.addChild(particleSystem);
        particleSystem.serializable = false;
        /*let parentControlPoint = this.getControlPoint(0);
        let childControlPoint = particleSystem.getControlPoint(0);
        parentControlPoint.addChild(childControlPoint);*/
        /*for (let i = 0; i < MAX_PARTICLE_CONTROL_POINTS; ++i) {
            let parentCp = this.controlPoints[i];
            let childCp = particleSystem.controlPoints[i];
            parentCp.addChild(childCp);
        }*/
        //particleSystem.setSkyBox(this.skybox);TODOv3
    }
    setParent(parentSystem) {
        return this.parentSystem = parentSystem;
    }
    /**
     * Orient all particles relative to control point #0.
     */
    setCpOrientation() {
        return; //TODOV3
        /*
        const cp = this.getControlPoint(0);
        if (cp) {
            const orientation = cp.getWorldQuaternion();
            for (let i = 0; i < this.livingParticles.length; ++i) {
                const particle = this.livingParticles[i];
                quat.copy(particle.cpOrientation, orientation);
                quat.copy(particle.cpOrientation, this.getWorldQuaternion());
            }
        }*/
    }
    /**
     * Set control point orientation
     * @param (Object quat) orientation New orientation
     */
    setOrientation(orientation) {
        copy$2(this.prevOrientation, this.currentOrientation);
        copy$2(this.currentOrientation, orientation);
    }
    setChildControlPointPosition(first, last, position) {
        for (let i = 0; i < this.childrenSystems.length; ++i) {
            const child = this.childrenSystems[i];
            for (let cpId = first; cpId <= last; ++cpId) {
                const cp = child.getOwnControlPoint(cpId);
                if (cp) {
                    cp.position = position;
                    //The control point is now world positioned
                    //Therefore we remove it from the hierarchy
                    //cp.remove();
                }
            }
        }
    }
    getParticle(index) {
        if (index == undefined) {
            index = Math.floor(Math.random() * this.livingParticles.length);
        }
        /*if (index >= this.livingParticles.length) {
            index = Math.floor(Math.random() * this.poolParticles.length);
            return this.poolParticles[index];
        }*/
        return this.livingParticles[index];
    }
    getControlPointPosition(cpId) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            return cp.getWorldPosition();
        }
        return create$4();
    }
    setControlPointPosition(cpId, position) {
        const cp = this.getOwnControlPoint(cpId);
        if (cp) {
            cp.position = position;
        }
    }
    setControlPointParent(controlPointId, parentControlPointId) {
        this.getControlPoint(controlPointId);
        this.parentSystem;
        /*
                if (cp && cpParent) {
                    cp.setParent(cpParent);
                }*/
        // Not sure it should be done resursively ?
        // This function is only used in 'set control point positions'
        /*for (let child of this.childrenSystems) {
            child.setControlPointParent(controlPointId, parentControlPointId);
        }*/
    }
    getWorldQuaternion(q = create$2()) {
        copy$2(q, this._quaternion);
        return q;
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
    set autoKill(autoKill) {
        this.#autoKill = autoKill;
    }
    get autoKill() {
        return this.#autoKill;
    }
    setLooping(looping) {
        this.#looping = looping;
    }
    getLooping() {
        return this.#looping;
    }
    dispose() {
        super.dispose();
        this.controlPoints.forEach(element => element.dispose());
        this.controlPoints.length = 0;
        this.material?.removeUser(this);
        for (const [_, renderer] of this.#renderers) {
            renderer.dispose();
        }
        for (const child of this.childrenSystems) {
            child.dispose();
        }
    }
    getBounds(min = create$4(), max = create$4()) {
        if (!this.livingParticles.length) {
            set$5(min, -1, -1, -1);
            set$5(max, 1, 1, 1);
        }
        else {
            set$5(min, Infinity, Infinity, Infinity);
            set$5(max, -Infinity, -Infinity, -Infinity);
            for (let particle of this.livingParticles) {
                min$3(min, min, particle.position);
                max$3(max, max, particle.position);
            }
        }
    }
    static setSpeed(speed) {
        _a.#speed = speed;
    }
    static setSimulationSteps(simulationSteps) {
        simulationSteps = Math.round(simulationSteps);
        if (simulationSteps > 0 && simulationSteps <= 10) {
            _a.#simulationSteps = simulationSteps;
        }
    }
    buildContextMenu() {
        let startStop = this.isRunning ? { i18n: '#stop', f: () => this.stop() } : { i18n: '#start', f: () => this.start() };
        return Object.assign(super.buildContextMenu(), {
            SourceEngineParticleSystem_1: null,
            startStop: startStop,
            reset: { i18n: '#reset', f: () => this.reset() },
        });
    }
    toJSON() {
        let json = super.toJSON();
        json.repository = this.repository;
        if (!this.isRunning) {
            json.isrunning = false;
        }
        let jControlPoint = [];
        this.controlPoints.forEach((element, index) => jControlPoint[index] = element.id);
        json.controlpoints = jControlPoint;
        return json;
    }
    static async constructFromJSON(json /*TODO: better type*/, entities, loadedPromise) {
        let entity = await Source1ParticleControler.createSystem(json.repository, json.name);
        if (entity) {
            loadedPromise.then(() => {
                console.error(entities);
                let jControlPoint = json.controlpoints;
                if (jControlPoint) {
                    for (let i = 0; i < jControlPoint.length; ++i) {
                        let cpEntity = entities.get(jControlPoint[i]);
                        if (cpEntity) {
                            entity.controlPoints[i] = cpEntity;
                        }
                    }
                }
                if (json.isrunning !== false) {
                    entity.start();
                }
            });
        }
        return entity;
    }
    static getEntityName() {
        return 'Source1ParticleSystem';
    }
}
_a = SourceEngineParticleSystem;
SourceEngineParticleSystem.prototype.isParticleSystem = true;
registerEntity(SourceEngineParticleSystem);
Source1ParticleControler.setParticleConstructor(SourceEngineParticleSystem);

class SourceEngineParticleOperators {
    static #functions = {};
    static #functionsType = {};
    static getOperator(name) {
        const n = name.replace(/\_/g, ' ').toLowerCase();
        if (!this.#functions[n]) {
            return null;
        }
        return new this.#functions[n]();
    }
    static #register(type, name, className) {
        this.#functions[name.replace(/\_/g, ' ').toLowerCase()] = className;
        this.#functionsType[type] = this.#functionsType[type] ?? [];
        this.#functionsType[type].push(name);
    }
    static getOperators(type) {
        return this.#functionsType[type] ?? [];
    }
    static registerOperator(name, className) {
        if (className) {
            this.#register('Operators', name, className);
        }
        else {
            this.#register('Operators', name.functionName, name);
        }
    }
}

class SourcePCF {
    repository;
    stringDict = [];
    elementsDict = [];
    systems = {};
    systems2 = {};
    binaryVersion;
    repositoryName;
    constructor(repository) {
        this.repository = repository;
    }
    getSystemElement(systemName) {
        return this.systems[systemName];
    }
    addSystem(element) {
        this.systems[element.name] = element;
        this.systems2[element.guid2] = element;
    }
    getSystem(systemName) {
        const element = this.systems[systemName];
        if (!element) {
            return null;
        }
        const attributes = element.attributes;
        const ps = new SourceEngineParticleSystem({ repository: this.repository, name: systemName });
        ps.pcf = this; // Store PCF to load children
        ps.repository = this.repository;
        for (let attributeIndex = 0; attributeIndex < attributes.length; ++attributeIndex) {
            let attribute = attributes[attributeIndex];
            switch (attribute.typeName) {
                case 'renderers':
                case 'operators':
                case 'initializers':
                case 'emitters':
                case 'forces':
                case 'constraints':
                    this.addOperators(ps, attribute.value, attribute.typeName);
                    break;
                case 'children':
                    this.addOperators(ps, attribute.value, attribute.typeName);
                    break;
                default:
                    ps.setParam(attribute);
            }
        }
        return ps;
    }
    initSystem(system) {
        const element = this.systems[system.name];
        if (!element) {
            return null;
        }
        const attributes = element.attributes;
        system.pcf = this; // Store PCF to load children
        system.repository = this.repository;
        for (let attributeIndex = 0; attributeIndex < attributes.length; ++attributeIndex) {
            let attribute = attributes[attributeIndex];
            switch (attribute.typeName) {
                case 'renderers':
                case 'operators':
                case 'initializers':
                case 'emitters':
                case 'forces':
                case 'constraints':
                    this.addOperators(system, attribute.value, attribute.typeName);
                    break;
                case 'children':
                    this.addOperators(system, attribute.value, attribute.typeName);
                    break;
                default:
                    system.setParam(attribute);
            }
        }
        return system;
    }
    addOperators(system, list, listType) {
        for (let i = 0; i < list.length; ++i) {
            const ope = list[i];
            if (ope.type == 'DmeParticleOperator') {
                const operator = SourceEngineParticleOperators.getOperator(ope.name);
                if (operator) {
                    system.addSub(listType, operator, generateRandomUUID());
                    this.addAttributes(operator, ope.attributes);
                }
            }
            else {
                if (ope.type == 'DmeParticleChild') {
                    const attribs = ope.attributes;
                    for (let attribIndex = 0; attribIndex < attribs.length; ++attribIndex) {
                        const attrib = attribs[attribIndex];
                        if (attrib.typeName == 'child' && attrib.value) {
                            system.addTempChild(attrib.value.name, ope.guid2);
                        }
                    }
                }
            }
        }
    }
    addAttributes(operator, list) {
        for (let i = 0; i < list.length; ++i) {
            let attrib = list[i];
            operator.setParameter(attrib.typeName, ELEMENT_TYPES[attrib.type], attrib.value);
        }
    }
}
const DmeParticleSystemDefinition = 'DmeParticleSystemDefinition';

const data_size = [
    0, 4, 4, 4, 1, 0, 0, 4, 4, 8, 12, 16, 12, 16, 64,
    4, 4, 4, 1, 0, 0, 4, 4, 8, 12, 16, 12, 16, 64,
];
const BINARY_FORMAT_POS = 25;
class SourceEnginePCFLoader extends SourceBinaryLoader {
    parse(repositoryName, fileName, arrayBuffer) {
        let pcf = new SourcePCF(repositoryName);
        let reader = new BinaryReader(arrayBuffer);
        let str = reader.getString(Math.min(1000, arrayBuffer.byteLength));
        let startOffset = str.indexOf('-->');
        if (startOffset === 0) {
            return null;
        }
        startOffset += 5;
        pcf.binaryVersion = Number(str.substring(BINARY_FORMAT_POS, BINARY_FORMAT_POS + 1));
        if (pcf.binaryVersion !== 2 && pcf.binaryVersion !== 5) {
            console.log('Binary version unknown. Loading of file may be unaccurate.');
        }
        this.#parseHeader(reader, pcf, startOffset);
        return pcf;
    }
    #parseHeader(reader, pcf, startOffset) {
        reader.seek(startOffset);
        let nStrings = 0;
        let nElements = 0;
        if (pcf.binaryVersion < 5) {
            nStrings = reader.getUint16();
        }
        else {
            nStrings = reader.getUint32();
        }
        for (let i = 0; i < nStrings; ++i) {
            pcf.stringDict.push(reader.getNullString());
        }
        if (pcf.binaryVersion < 5) {
            nElements = reader.getUint32();
        }
        else {
            nElements = reader.getUint32();
        }
        for (let i = 0; i < nElements; ++i) {
            pcf.elementsDict.push(this.#parseElement(reader, pcf));
        }
        for (let i = 0; i < nElements; i++) {
            pcf.elementsDict[i].attributes = this.#parseAttributes(reader, pcf);
        }
    }
    #parseElement(reader, pcf) {
        const element = new CDmxElement();
        if (pcf.binaryVersion < 5) {
            element.type = this.getString(pcf, reader.getUint16());
        }
        else {
            element.type = this.getString(pcf, reader.getUint32());
        }
        if (pcf.binaryVersion < 5) {
            element.name = reader.getNullString();
        }
        else {
            element.name = this.getString(pcf, reader.getUint32());
        }
        element.guid = reader.getBytes(16);
        element.guid2 = '';
        for (let i = 0; i < 16; ++i) {
            element.guid2 += String.fromCharCode(element.guid[i]);
        }
        if (element.type == DmeParticleSystemDefinition) {
            pcf.addSystem(element);
        }
        return element;
    }
    #parseAttributes(reader, pcf) {
        const attributes = [];
        const nAttributes = reader.getUint32();
        for (let i = 0; i < nAttributes; ++i) {
            attributes.push(this.#parseAttribute(reader, pcf));
        }
        return attributes;
    }
    #parseAttribute(reader, pcf) {
        const attribute = new CDmxAttribute();
        if (pcf.binaryVersion < 5) {
            attribute.typeName = this.getString(pcf, reader.getUint16());
        }
        else {
            attribute.typeName = this.getString(pcf, reader.getUint32());
        }
        attribute.type = reader.getUint8();
        attribute.value = null;
        if (attribute.type > 14) {
            attribute.value = this.#parseArray(reader, pcf, attribute.type);
        }
        else {
            attribute.value = this.#parseValue(reader, pcf, attribute.type);
        }
        return attribute;
    }
    #parseArray(reader, pcf, type) {
        const valuesCount = reader.getUint32();
        const value = [];
        for (let i = 0; i < valuesCount; ++i) {
            value.push(this.#parseValue(reader, pcf, type));
        }
        return value;
    }
    #parseValue(reader, pcf, type) {
        let size = data_size[type];
        let value = undefined;
        switch (type % 14) {
            case 1: // Element
                value = this.getElement(pcf, reader.getInt32());
                break;
            case 2: // Integer
                value = reader.getInt32();
                break;
            case 3: // Float
                value = reader.getFloat32();
                break;
            case 4: // Bool
                value = reader.getInt8();
                break;
            case 7: // Time
                value = reader.getInt32() / 10000.0;
                break;
            case 8: // Color
                //value = {r:reader.getUint8(), g:reader.getUint8(), b:reader.getUint8(), a:reader.getUint8()};
                value = new Color(reader.getUint8(), reader.getUint8(), reader.getUint8(), reader.getUint8());
                //value = [reader.getUint8(), reader.getUint8(), reader.getUint8(), reader.getUint8()];
                break;
            case 9: // vec2
                value = fromValues(reader.getFloat32(), reader.getFloat32());
                break;
            case 10: // vec3
                value = fromValues$4(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                break;
            case 11: // vec4
                value = fromValues$3(reader.getFloat32(), reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                break;
            case 5:
                if (pcf.binaryVersion < 5) {
                    value = reader.getNullString();
                }
                else {
                    value = this.getString(pcf, reader.getInt32());
                }
                break;
            case 6:
                size = reader.getInt32();
                reader.seek(reader.tell() + size);
                break;
            default:
                reader.seek(reader.tell() + size);
                break;
        }
        return value;
    }
    getString(pcf, index) {
        if (pcf) {
            const s = pcf.stringDict[index];
            if (s) {
                return s;
            }
            else {
                return '';
            }
        }
        return '';
    }
    getElement(pcf, index) {
        if (pcf) {
            const e = pcf.elementsDict[index];
            if (e) {
                return e;
            }
            else {
                return null;
            }
        }
        return null;
    }
}
registerLoader('SourceEnginePCFLoader', SourceEnginePCFLoader);
class CDmxElement {
    type;
    name;
    guid;
    guid2;
}
class CDmxAttribute {
    typeName;
    type;
    value;
}

const BSP_HEADER_LUMPS_COUNT = 64;
function InitLZMALump(reader, lump) {
    if (reader.getString(4, lump.lumpOffset) === 'LZMA') {
        const uncompressedSize = reader.getUint32();
        const compressedSize = reader.getUint32();
        const properties = reader.getBytes(5);
        const compressedDatas = reader.getBytes(compressedSize); // 4 + 4 + 4 + 5
        reader = new BinaryReader(DecompressLZMA(properties, compressedDatas, uncompressedSize));
        lump.lumpOffset = 0;
        lump.lumpLen = uncompressedSize;
    }
    return reader;
}
class SourceEngineBSPLoader extends SourceBinaryLoader {
    parse(repository, fileName, arrayBuffer) {
        let bsp = new SourceBSP({ repository: repository, name: fileName });
        bsp.loader = this;
        let reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, bsp);
        this.#parseLumps(reader, bsp);
        return bsp;
    }
    #parseHeader(reader, bsp) {
        reader.seek(4); //skip first 4 char TODO: check == 'VBSP' ?
        bsp.bspFileVersion = reader.getInt32();
        this._parseLumpDirectory(reader, bsp);
        bsp.mapRevision = reader.getInt32();
    }
    _parseLumpDirectory(reader, bsp) {
        const startOffset = reader.tell();
        for (let lumpIndex = 0; lumpIndex < BSP_HEADER_LUMPS_COUNT; ++lumpIndex) {
            reader.seek(startOffset + lumpIndex * 16);
            const lumpOffset = reader.getInt32();
            const lumpLen = reader.getInt32();
            const lump = new SourceBSPLump(bsp, lumpIndex, reader, lumpOffset, lumpLen); //lump type is the index in lump directory
            //lump.setLumpOffset(reader.getInt32());
            //lump.setLumpLen(reader.getInt32());
            lump.setLumpVersion(reader.getInt32());
            //reader.getInt32() // TODO: replace by lump fourCC
            //lump.init();
            bsp.addLump(lump);
        }
    }
    #parseLumps(reader, bsp) {
        const lumps = bsp.lumps;
        for (let i = 0, l = lumps.length; i < l; i++) {
            let lump = bsp.lumps[i];
            this.#parseLump(reader, lump, bsp); //TODOv3: lzma
            //console.error(lump);
        }
    }
    #parseLump(reader, lump, bsp) {
        if (lump.lumpLen === 0) {
            lump.lumpData = Object.create(null);
        }
        else {
            /*if (reader.getString(4, lump.lumpOffset) === 'LZMA') {
                const uncompressedSize = reader.getUint32();
                const compressedSize = reader.getUint32();
                const properties = reader.getBytes(5);
                const compressedDatas = reader.getBytes(lump.lumpLen - 17);// 4 + 4 + 4 + 5

                reader = new BinaryReader(DecompressLZMA(properties, compressedDatas, uncompressedSize));

                lump.lumpOffset = 0;
                lump.lumpLen = uncompressedSize;
            }*/
            reader = InitLZMALump(reader, lump);
            switch (lump.lumpType) {
                case LUMP_ENTITIES:
                    this.#parseLumpEntities(reader, lump);
                    break;
                case LUMP_PLANES:
                    this.#parseLumpPlanes(reader, lump);
                    break;
                case LUMP_VERTEXES:
                    this.#parseLumpVertices(reader, lump);
                    break;
                case LUMP_VISIBILITY:
                    this.#parseLumpVisibility(reader, lump);
                    break;
                case LUMP_EDGES:
                    this.#parseLumpEdges(reader, lump);
                    break;
                case LUMP_SURFEDGES:
                    this.#parseLumpSurfEdges(reader, lump);
                    break;
                case LUMP_FACES:
                case LUMP_ORIGINALFACES: //TODO: remove if useless
                case LUMP_FACES_HDR:
                    this.#parseLumpFaces(reader, lump);
                    break;
                case LUMP_TEXDATA:
                    this.#parseLumpTexdata(reader, lump);
                    break;
                case LUMP_TEXDATA_STRING_DATA:
                    this.#parseLumpTexdataStringData(reader, lump);
                    break;
                case LUMP_TEXDATA_STRING_TABLE:
                    this.#parseLumpTexdataStringTable(reader, lump);
                    break;
                case LUMP_GAME_LUMP:
                    this.#parseLumpGameDirectory(reader, lump, bsp);
                    break;
                case LUMP_TEXINFO:
                    this.#parseLumpTexInfo(reader, lump);
                    break;
                case LUMP_DISPINFO:
                    this.#parseLumpDispInfo(reader, lump);
                    break;
                case LUMP_DISP_VERTS:
                    this.#parseLumpDispVerts(reader, lump);
                    break;
                case LUMP_DISP_TRIS:
                    //this._parseLumpDispTris(reader, lump);//TODOv3
                    break;
                case LUMP_LIGHTING:
                case LUMP_LIGHTING_HDR:
                    this.#parseLumpLighting(reader, lump);
                    break;
                case LUMP_BRUSHES:
                    this.#parseLumpBrushes(reader, lump);
                    break;
                case LUMP_BRUSHSIDES:
                    this.#parseLumpBrushSides(reader, lump);
                    break;
                case LUMP_MODELS:
                    this.#parseLumpModels(reader, lump);
                    break;
                case LUMP_LEAFS:
                    this.#parseLumpLeafs(reader, lump);
                    break;
                case LUMP_LEAFFACES:
                    this.#parseLumpLeafFaces(reader, lump);
                    break;
                case LUMP_LEAFBRUSHES:
                    this.#parseLumpLeafbrushes(reader, lump);
                    break;
                case LUMP_NODES:
                    this.#parseLumpNodes(reader, lump);
                    break;
                case LUMP_PAKFILE:
                    this.#parseLumpPakFile(reader, lump);
                    break;
                case LUMP_OVERLAYS:
                    this.#parseLumpOverlays(reader, lump);
                    break;
            }
        }
    }
    #parseLumpEntities(reader, lump) {
        const lumpData = Object.create(null); //TODOv3
        lumpData.str = reader.getString(lump.getLumpLen(), lump.lumpOffset);
        const kv = new KvReader();
        kv.readText(lumpData.str);
        lumpData.kv = kv;
        lump.setLumpData(lumpData);
    }
    #parseLumpPlanes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_PLANE = 20;
        const planesCount = lump.getLumpLen() / BYTES_PER_PLANE;
        const lumpData = [];
        for (let planeIndex = 0; planeIndex < planesCount; planeIndex++) {
            let plane = new SourceBSPLumpPlane();
            plane.normal = reader.getVector3();
            plane.dist = reader.getFloat32();
            plane.type = reader.getInt32();
            lumpData.push(plane);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexdata(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_TEXDATA = 32;
        const texdataCount = lump.getLumpLen() / BYTES_PER_TEXDATA;
        const lumpData = [];
        for (let texdataIndex = 0; texdataIndex < texdataCount; ++texdataIndex) {
            let texdata = new SourceBSPLumpTexData();
            texdata.reflectivity = reader.getVector3();
            texdata.nameStringTableID = reader.getInt32();
            texdata.width = reader.getInt32();
            texdata.height = reader.getInt32();
            texdata.view_width = reader.getInt32();
            texdata.view_height = reader.getInt32();
            lumpData.push(texdata);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpVertices(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_VERTEX = 12;
        const verticesCount = lump.getLumpLen() / BYTES_PER_VERTEX;
        const lumpData = [];
        for (let vertexIndex = 0; vertexIndex < verticesCount; ++vertexIndex) {
            lumpData.push(reader.getVector3());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpVisibility(reader, lump) {
        reader.seek(lump.lumpOffset);
        let offset = reader.tell();
        let clusterCount = reader.getInt32();
        let visOffsets = [];
        for (let clusterIndex = 0; clusterIndex < clusterCount; clusterIndex++) {
            visOffsets.push([reader.getInt32(), reader.getInt32()]);
        }
        let numBytes = Math.ceil(clusterCount / 8);
        let clusterVis = new Uint8Array(clusterCount * clusterCount);
        for (let i = 0; i < clusterCount; ++i) {
            let rleVis = new Uint8Array(reader.buffer, offset + visOffsets[i][0], numBytes); //TODOv3 ???
            let clusterOfs = i * clusterCount;
            let v = 0;
            // Unpack the RLE visibility bitfield
            // See code at: http://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml
            for (let c = 0; c < clusterCount; v++) {
                if (rleVis[v] == 0) {
                    v++;
                    c += 8 * rleVis[v];
                }
                else {
                    for (let bit = 1; bit < 256; bit *= 2, c++) {
                        if (rleVis[v] & bit) {
                            clusterVis[clusterOfs + c] = 1;
                        }
                    }
                }
            }
        }
        let lumpData = { clusterCount: clusterCount, clusterVis: clusterVis };
        lump.setLumpData(lumpData);
    }
    #parseLumpNodes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_NODE = 32;
        const nodeCount = lump.getLumpLen() / BYTES_PER_NODE;
        const lumpData = [];
        for (let nodeIndex = 0; nodeIndex < nodeCount; ++nodeIndex) {
            let node = new SourceBSPLumpNode();
            node.planenum = reader.getInt32();
            node.children = [reader.getInt32(), reader.getInt32()];
            node.mins = [reader.getInt16(), reader.getInt16(), reader.getInt16()];
            node.maxs = [reader.getInt16(), reader.getInt16(), reader.getInt16()];
            node.firstface = reader.getUint16();
            node.numfaces = reader.getUint16();
            node.area = reader.getInt16();
            reader.getInt16();
            //console.log(node);
            lumpData.push(node);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexInfo(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_TEXINFO = 72;
        const texInfoCount = lump.getLumpLen() / BYTES_PER_TEXINFO;
        const lumpData = [];
        for (let texinfoIndex = 0; texinfoIndex < texInfoCount; ++texinfoIndex) {
            let texinfo = new SourceBSPLumpTexInfo();
            texinfo.textureVecs.push(reader.getVector4());
            texinfo.textureVecs.push(reader.getVector4());
            texinfo.lightmapVecs.push(reader.getVector4());
            texinfo.lightmapVecs.push(reader.getVector4());
            texinfo.flags = reader.getInt32();
            texinfo.texdata = reader.getInt32();
            lumpData.push(texinfo);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpFaces(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_FACE = 56;
        const faceCount = lump.getLumpLen() / BYTES_PER_FACE;
        const lumpData = [];
        for (let faceIndex = 0; faceIndex < faceCount; ++faceIndex) {
            let face = new SourceBSPLumpFace();
            face.planenum = reader.getInt16();
            face.side = reader.getInt8();
            face.onNode = reader.getInt8();
            face.firstedge = reader.getInt32();
            face.numedges = reader.getInt16();
            face.texinfo = reader.getInt16();
            face.dispinfo = reader.getInt16();
            face.surfaceFogVolumeID = reader.getInt16();
            for (let styleIndex = 0; styleIndex < 4; ++styleIndex) {
                const style = reader.getUint8();
                face.styles.push(style);
                if (style != 255) {
                    face.styleCount = styleIndex + 1;
                }
            }
            face.lightofs = reader.getInt32() / 4;
            face.area = reader.getFloat32();
            face.LightmapTextureMinsInLuxels = [reader.getInt32(), reader.getInt32()];
            face.LightmapTextureSizeInLuxels = [reader.getInt32(), reader.getInt32()];
            //face.LightmapTextureSizeInLuxels = (face.LightmapTextureSizeInLuxels[0] + 1) * (face.LightmapTextureSizeInLuxels[1] + 1);
            face.origFace = reader.getInt32();
            face.numPrims = reader.getUint16();
            face.firstPrimID = reader.getUint16();
            face.smoothingGroups = reader.getInt32();
            lumpData.push(face);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLighting(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LIGHTING = 4;
        const lightingCount = lump.getLumpLen() / BYTES_PER_LIGHTING;
        let lumpData = [];
        for (let lightingIndex = 0; lightingIndex < lightingCount; ++lightingIndex) {
            let lighting = new SourceBSPLumpColorRGBExp32();
            lighting.r = reader.getUint8();
            lighting.g = reader.getUint8();
            lighting.b = reader.getUint8();
            lighting.exp = reader.getInt8();
            lumpData.push(lighting);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafs(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAF = 32;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAF;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            let brushSide = new SourceBSPLumpLeaf();
            brushSide.contents = reader.getInt32();
            brushSide.cluster = reader.getInt16();
            brushSide.areaflags = reader.getInt16();
            brushSide.mins = [reader.getInt16(), reader.getInt16(), reader.getInt16()];
            brushSide.maxs = [reader.getInt16(), reader.getInt16(), reader.getInt16()];
            brushSide.firstleafface = reader.getUint16();
            brushSide.numleaffaces = reader.getUint16();
            brushSide.firstleafbrush = reader.getUint16();
            brushSide.numleafbrushes = reader.getUint16();
            brushSide.leafWaterDataID = reader.getInt16();
            reader.getInt16();
            lumpData.push(brushSide);
        }
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            let leaf = lumpData[brushSideIndex];
            if (leaf.numleaffaces) ;
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpEdges(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_EDGE = 4;
        const edgesCount = lump.getLumpLen() / BYTES_PER_EDGE;
        const lumpData = [];
        for (let edgeIndex = 0; edgeIndex < edgesCount; ++edgeIndex) {
            let edge = new SourceBSPLumpEdge();
            edge.f = reader.getUint16();
            edge.s = reader.getUint16();
            lumpData.push(edge);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpSurfEdges(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_SURFEDGE = 4;
        const surfedgesCount = lump.getLumpLen() / BYTES_PER_SURFEDGE;
        const lumpData = [];
        for (let surfedgeIndex = 0; surfedgeIndex < surfedgesCount; ++surfedgeIndex) {
            lumpData.push(reader.getInt32());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpModels(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_MODEL = 48;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_MODEL;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            const brushSide = new SourceBSPLumpModel();
            //brushSide.planenum = reader.getUint16();
            //brushSide.texinfo = reader.getInt16();
            //brushSide.dispinfo = reader.getInt16();
            reader.skip(24);
            brushSide.position = reader.getVector3();
            brushSide.headnode = reader.getInt32();
            brushSide.firstface = reader.getInt32();
            brushSide.numfaces = reader.getInt32();
            lumpData.push(brushSide);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafFaces(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAFFACE = 2;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAFFACE;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            lumpData.push(reader.getUint16());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafbrushes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAFBRUSH = 2;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAFBRUSH;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            lumpData.push(reader.getUint16());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpBrushes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_BRUSH = 12;
        const brushesCount = lump.getLumpLen() / BYTES_PER_BRUSH;
        const lumpData = [];
        for (let brushIndex = 0; brushIndex < brushesCount; ++brushIndex) {
            let brush = new SourceBSPLumpBrush();
            brush.firstside = reader.getInt32();
            brush.numsides = reader.getInt32();
            brush.contents = reader.getInt32();
            lumpData.push(brush);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpBrushSides(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_BRUSH_SIDE = 8;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_BRUSH_SIDE;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            let brushSide = new SourceBSPLumpBrushSide();
            brushSide.planenum = reader.getUint16();
            brushSide.texinfo = reader.getInt16();
            brushSide.dispinfo = reader.getInt16();
            brushSide.bevel = reader.getInt16();
            lumpData.push(brushSide);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpGameDirectory(reader, lump, bsp) {
        reader.seek(lump.lumpOffset);
        const gameCount = reader.getInt32();
        const lumpData = Object.create(null);
        for (let gameIndex = 0; gameIndex < gameCount; ++gameIndex) {
            const gamelump = new SourceBSPLumpGameLump(bsp, reader);
            gamelump.id = reader.getString(4); //Four CC
            gamelump.flags = reader.getUint16();
            gamelump.version = reader.getUint16();
            gamelump.lumpOffset = reader.getInt32();
            gamelump.lumpLen = reader.getInt32();
            lumpData[gamelump.id] = gamelump;
        }
        for (let gameIndex in lumpData) {
            let lump = lumpData[gameIndex];
            let lumpReader = InitLZMALump(reader, lump);
            this.#parseLumpGame(lumpReader, lump);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpGame(reader, lump) {
        reader.seek(lump.lumpOffset);
        switch (lump.id) {
            case 'prps':
                this.#parseLumpGamePropStatic(reader, lump);
                break;
        }
    }
    #parseLumpGamePropStatic(reader, lump) {
        reader.seek(lump.lumpOffset);
        const STATIC_PROP_NAME_LENGTH = 128;
        const staticDir = new SourceBSPLumpPropStaticDirectory();
        //lump.map.map.staticDirRemoveMe = staticDir;//TODOv3 removeme
        const lumpVersion = lump.version;
        const nameCount = reader.getInt32();
        for (let nameIndex = 0; nameIndex < nameCount; ++nameIndex) {
            let name = StringStrip(reader.getString(STATIC_PROP_NAME_LENGTH));
            staticDir.name.push(name);
        }
        const leafCount = reader.getInt32();
        for (let leafIndex = 0; leafIndex < leafCount; ++leafIndex) {
            staticDir.leaf.push(reader.getUint16());
        }
        const propCount = reader.getInt32();
        // This is bullshit, but the structure size is not sturdy
        const propsStartOffset = reader.tell();
        const propsTotalLength = lump.getLumpLen() - (propsStartOffset - lump.getLumpOffset());
        const byteSizePerProp = Math.floor(propsTotalLength / propCount); // Should be int anyway
        for (let propIndex = 0; propIndex < propCount; ++propIndex) {
            reader.seek(propsStartOffset + propIndex * byteSizePerProp);
            const prop = new SourceBSPLumpPropStatic();
            prop.position = reader.getVector3();
            const angles = reader.getVector3(); //TODO: memory
            prop.propType = reader.getUint16();
            if (angles[0] != 0) ;
            prop.angles[0] = DEG_TO_RAD * angles[0];
            prop.angles[1] = DEG_TO_RAD * angles[1];
            prop.angles[2] = DEG_TO_RAD * angles[2];
            prop.firstLeaf = reader.getUint16();
            prop.leafCount = reader.getUint16();
            prop.solid = reader.getUint8();
            prop.flags = reader.getUint8();
            prop.skin = reader.getInt32();
            prop.fadeMinDist = reader.getFloat32();
            prop.fadeMaxDist = reader.getFloat32();
            prop.lightingOrigin = reader.getVector3();
            if (lumpVersion >= 5) {
                prop.forcedFadeScale = reader.getFloat32();
            }
            if (lumpVersion == 6 || lumpVersion == 7) {
                prop.minDXLevel = reader.getUint16();
                prop.maxDXLevel = reader.getUint16();
            }
            //TODO
            if (lumpVersion >= 7) {
                reader.skip(4);
            }
            if (lumpVersion >= 8) {
                reader.skip(4);
            }
            if (lumpVersion >= 9) {
                reader.skip(4);
            }
            staticDir.props.push(prop);
        }
        create$2();
        lump.lumpData = staticDir;
    }
    #parseLumpPakFile(reader, lump) {
        reader.seek(lump.lumpOffset);
        const startOffset = lump.lumpOffset;
        let offset = reader.byteLength - 22; //sizeof ZIP_EndOfCentralDirRecord
        for (let sO = offset; (offset >= 0) && (offset <= sO); --offset) {
            reader.seek(offset);
            if (reader.getUint32() == 101010256) { //PK56
                break;
            }
        }
        if (offset <= 0) {
            lump.setLumpData(Object.create(null));
            return;
        }
        reader.seek(offset);
        reader.skip(4); //signature
        reader.skip(2); //numberOfThisDisk
        reader.skip(2); //numberOfTheDiskWithStartOfCentralDirectory
        reader.skip(2); //nCentralDirectoryEntries_ThisDisk
        const nCentralDirectoryEntries_Total = reader.getUint16();
        reader.getUint32();
        const startOfCentralDirOffset = reader.getUint32();
        const lumpData = new Map();
        reader.seek(startOffset + startOfCentralDirOffset);
        for (let i = 0; i < nCentralDirectoryEntries_Total; ++i) {
            reader.skip(4); //signature
            reader.skip(2); //versionMadeBy
            reader.skip(2); //versionNeededToExtract
            reader.skip(2); //flags
            const compressionMethod = reader.getUint16();
            reader.skip(2); //lastModifiedTime
            reader.skip(2); //lastModifiedDate
            reader.skip(4); //crc32
            const compressedSize = reader.getUint32();
            const uncompressedSize = reader.getUint32();
            const fileNameLength = reader.getUint16();
            const extraFieldLength = reader.getUint16();
            const fileCommentLength = reader.getUint16();
            reader.getUint16();
            reader.getUint16();
            reader.getUint32();
            const relativeOffsetOfLocalHeader = reader.getUint32();
            const fileName = reader.getString(fileNameLength);
            const filepos = startOffset + relativeOffsetOfLocalHeader + fileNameLength + extraFieldLength + 30; //sizeof ZIP_LocalFileHeader
            reader.skip(extraFieldLength + fileCommentLength);
            const file = { cs: compressedSize, fp: filepos, cm: compressionMethod, us: uncompressedSize };
            lumpData.set(fileName, file);
        }
        for (let [fileName, file] of lumpData) {
            if (fileName.match(/^materials\/.*\.vmt$/)) {
                let fileContent = this.#getFileData(reader, file);
                SourceEngineVMTLoader.setMaterial(fileName, fileContent);
            }
        }
        lump.setLumpData(lumpData);
    }
    #getFileData(reader, file) {
        if (file) {
            if (file.cm == 14) { //LZMA
                const lzmaProperties = reader.getBytes(5, file.fp + 4);
                const compressedDatas = reader.getBytes(file.cs, file.fp + 9);
                let lzmaReader = new BinaryReader(DecompressLZMA(lzmaProperties, compressedDatas, file.us));
                return lzmaReader.getString(file.us);
            }
            return reader.getString(file.cs, file.fp);
        }
    }
    #parseLumpTexdataStringData(reader, lump) {
        reader.seek(lump.lumpOffset);
        const startOffset = lump.getLumpOffset();
        const endOffset = startOffset + lump.getLumpLen();
        const lumpData = [];
        while (reader.tell() < endOffset) {
            lumpData.push(reader.getNullString());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexdataStringTable(reader, lump) {
        reader.seek(lump.lumpOffset);
        const texdataCount = lump.getLumpLen() / 4; /* size of int */
        const lumpData = [];
        for (let texdataIndex = 0; texdataIndex < texdataCount; ++texdataIndex) {
            lumpData.push(reader.getInt32());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpOverlays(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_OVERLAY = 352;
        const overlayCount = lump.getLumpLen() / BYTES_PER_OVERLAY;
        const lumpData = [];
        for (let overlayIndex = 0; overlayIndex < overlayCount; ++overlayIndex) {
            const overlay = new SourceBSPLumpOverlay();
            overlay.id = reader.getInt32();
            overlay.texInfo = reader.getInt16();
            overlay.FaceCountAndRenderOrder = reader.getUint16();
            const OVERLAY_BSP_FACE_COUNT = 64;
            overlay.faces = new Int32Array(OVERLAY_BSP_FACE_COUNT);
            for (let i = 0; i < OVERLAY_BSP_FACE_COUNT; ++i) {
                overlay.faces[i] = reader.getInt32();
            }
            overlay.U = [reader.getFloat32(), reader.getFloat32()];
            overlay.V = [reader.getFloat32(), reader.getFloat32()];
            overlay.UVPoint0 = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            overlay.UVPoint1 = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            overlay.UVPoint2 = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            overlay.UVPoint3 = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            overlay.Origin = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            overlay.BasisNormal = [reader.getFloat32(), reader.getFloat32(), reader.getFloat32()];
            normalize$5(overlay.BasisNormal, overlay.BasisNormal);
            lumpData.push(overlay);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpDispInfo(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_DISPINFO = 176;
        const dispInfoCount = lump.getLumpLen() / BYTES_PER_DISPINFO;
        const lumpData = [];
        for (let dispinfoIndex = 0; dispinfoIndex < dispInfoCount; ++dispinfoIndex) {
            let dispinfo = new SourceBSPLumpDispInfo();
            dispinfo.startPosition = reader.getVector3();
            dispinfo.dispVertStart = reader.getInt32();
            dispinfo.dispTriStart = reader.getInt32();
            dispinfo.power = reader.getInt32();
            dispinfo.minTess = reader.getInt32();
            dispinfo.smoothingAngle = reader.getFloat32();
            dispinfo.contents = reader.getInt32();
            dispinfo.mapFace = reader.getUint16();
            dispinfo.LightmapAlphaStart = reader.getInt32();
            dispinfo.LightmapSamplePositionStart = reader.getInt32();
            reader.getUint16(); // Spare bytes
            this.#parseEdgeNeighbors(reader);
            reader.skip(40); //skip CornerNeighbors
            dispinfo.AllowedVerts = [];
            for (let i = 0; i < 10; ++i) { //TODO : variable
                dispinfo.AllowedVerts.push(reader.getInt32());
            }
            lumpData.push(dispinfo);
        }
        lump.setLumpData(lumpData);
    }
    #parseEdgeNeighbors(reader) {
        for (let edgeIndex = 0; edgeIndex < 4; ++edgeIndex) {
            const neighbor = new SourceBSPLumpDispNeighbor();
            for (let neighborIndex = 0; neighborIndex < 2; ++neighborIndex) {
                const subneighbor = new SourceBSPLumpDispSubNeighbor();
                neighbor.subNeighbors.push(subneighbor);
                subneighbor.iNeighbor = reader.getUint16();
                subneighbor.orientation = reader.getUint8();
                subneighbor.span = reader.getUint8();
                subneighbor.neighSpan = reader.getUint8();
                reader.skip(1); // read spare byte;
            }
        }
    }
    #parseLumpDispVerts(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_DISPVERT = 20;
        const dispVertCount = lump.getLumpLen() / BYTES_PER_DISPVERT;
        const lumpData = [];
        for (let dispvertIndex = 0; dispvertIndex < dispVertCount; ++dispvertIndex) {
            let dispvert = new SourceBSPLumpDispVertex();
            dispvert.vec = reader.getVector3();
            dispvert.dist = reader.getFloat32();
            dispvert.alpha = reader.getFloat32();
            lumpData.push(dispvert);
        }
        lump.setLumpData(lumpData);
    }
}

/**
 * DummyEntity
 */
class DummyEntity extends MapEntity {
    constructor(classname) {
        super(classname);
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement.model);
        if (result) {
            this.map.funcBrushesRemoveMe.push({ model: result[1], origin: kvElement.origin ? ParseVector(kvElement.origin) : null });
        }
    }
}
MapEntities.registerEntity('env_sprite', DummyEntity);
//MapEntities.registerEntity('light_spot', DummyEntity);
MapEntities.registerEntity('worldspawn', DummyEntity);
MapEntities.registerEntity('info_player_teamspawn', DummyEntity);
MapEntities.registerEntity('team_round_timer', DummyEntity);
MapEntities.registerEntity('team_control_point_master', DummyEntity);
MapEntities.registerEntity('tf_gamerules', DummyEntity);
MapEntities.registerEntity('filter_activator_tfteam', DummyEntity);
MapEntities.registerEntity('env_lightglow', DummyEntity);
//MapEntities.registerEntity('light', DummyEntity);
MapEntities.registerEntity('point_spotlight', DummyEntity);
MapEntities.registerEntity('func_nobuild', DummyEntity);
MapEntities.registerEntity('keyframe_rope', DummyEntity);
MapEntities.registerEntity('move_rope', DummyEntity);
MapEntities.registerEntity('func_regenerate', DummyEntity);
MapEntities.registerEntity('env_soundscape', DummyEntity);
MapEntities.registerEntity('env_soundscape_proxy', DummyEntity);
MapEntities.registerEntity('func_areaportal', DummyEntity);
MapEntities.registerEntity('func_illusionary', DummyEntity);
MapEntities.registerEntity('func_respawnroomvisualizer', DummyEntity);
MapEntities.registerEntity('func_respawnroom', DummyEntity);
MapEntities.registerEntity('trigger_capture_area', DummyEntity);
MapEntities.registerEntity('info_player_start', DummyEntity);
MapEntities.registerEntity('env_tonemap_controller', DummyEntity);
MapEntities.registerEntity('prop_physics_multiplayer', DummyEntity);
MapEntities.registerEntity('ambient_generic', DummyEntity);
//MapEntities.registerEntity('info_particle_system', DummyEntity);
//MapEntities.registerEntity('light_environment', DummyEntity);
MapEntities.registerEntity('shadow_control', DummyEntity);
MapEntities.registerEntity('env_sun', DummyEntity);
MapEntities.registerEntity('water_lod_control', DummyEntity);
MapEntities.registerEntity('env_fog_controller', DummyEntity);
MapEntities.registerEntity('item_grenadepack', DummyEntity);
MapEntities.registerEntity('env_smokestack', DummyEntity);
MapEntities.registerEntity('func_rotating', DummyEntity);
MapEntities.registerEntity('logic_relay', DummyEntity);
MapEntities.registerEntity('game_round_win', DummyEntity);
MapEntities.registerEntity('game_intro_viewpoint', DummyEntity);
MapEntities.registerEntity('func_occluder', DummyEntity);
MapEntities.registerEntity('sunlight_shadow_control', DummyEntity);
//MapEntities.registerEntity('prop_dynamic_override', DummyEntity);
MapEntities.registerEntity('prop_ragdoll', DummyEntity);
MapEntities.registerEntity('info_target', DummyEntity);
MapEntities.registerEntity('math_counter', DummyEntity);

class FuncBrush extends MapEntity {
    constructor(classname) {
        super(classname);
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement.model);
        if (result) {
            if (kvElement.rendermode && kvElement.rendermode != 10) {
                this.map.funcBrushesRemoveMe.push({ model: result[1], origin: ParseVector(kvElement.origin) });
                console.error(kvElement.origin, kvElement);
            }
        }
    }
}
MapEntities.registerEntity('func_brush', FuncBrush);

/**
 * func_detail
 */
class FuncDetail extends MapEntity {
    constructor(classname) {
        super(classname);
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement.model);
        if (result) {
            this.map.funcBrushesRemoveMe.push({ model: result[1], origin: kvElement.origin ? ParseVector(kvElement.origin) : null });
        }
    }
}
MapEntities.registerEntity('func_detail', FuncDetail);
MapEntities.registerEntity('func_detail_blocker', FuncDetail);
MapEntities.registerEntity('func_lod', FuncDetail);

/**
 * Output Event
 */
class OutputEvent {
    outputName;
    constructor(outputName) {
        this.outputName = outputName.toLowerCase();
    }
    fireOutput(activator, caller) {
        caller.fireOutput(this.outputName);
    }
}

/**
 * Map entity
 */
class FuncDoor extends MapEntity {
    onFullyOpen = new OutputEvent('OnFullyOpen');
    onFullyClosed = new OutputEvent('OnFullyClosed');
    model = null;
    speed = 0;
    moveDir = create$4();
    pos1 = create$4();
    pos2 = create$4();
    finalDest = create$4();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement.model);
        if (result) {
            this.model = { model: result[1], origin: ParseVector(kvElement.origin) };
            //if (kvElement.rendermode && kvElement.rendermode != 10) {
            this.map.funcBrushesRemoveMe.push(this.model);
            //}
        }
        if (kvElement) {
            kvElement.movedistance;
            this.speed = kvElement.speed;
            zero$4(this.moveDir);
            AngleVectors(ParseAngles(kvElement.movedir), this.moveDir);
            let vecOBB = this.m.getOBBSize(this.model.model);
            this.pos1 = this.getAbsOrigin(); //vec3.scaleAndAdd(vec3.create(), this.getAbsOrigin(), this.moveDir, -movedistance * kvElement.startposition);
            let a = this.moveDir;
            let b = vecOBB;
            let dotProductAbs = Math.abs(a[0] * b[0]) + Math.abs(a[1] * b[1]) + Math.abs(a[2] * b[2]); //vec3.dot(vec3.create(), this.moveDir, vecOBB);
            this.pos2 = scaleAndAdd$2(this.pos2, this.pos1, this.moveDir, dotProductAbs); //todo : lip
            copy$4(this.finalDest, this.getAbsOrigin());
        }
    }
    setInput(inputName, parameter) {
        switch (inputName.toLowerCase()) {
            case 'open':
                this.inputOpen();
                break;
            case 'close':
                this.inputClose();
                break;
            /*
            DEFINE_INPUTFUNC(FIELD_VOID,	'Open', InputOpen),
            DEFINE_INPUTFUNC(FIELD_VOID,	'Close', InputClose),
            DEFINE_INPUTFUNC(FIELD_FLOAT, 'SetPosition', InputSetPosition),
            DEFINE_INPUTFUNC(FIELD_FLOAT, 'SetSpeed', InputSetSpeed),
            */
        }
    }
    update(map, delta) {
        super.update(map, delta);
        if (this.model) {
            if ((this._position[0] != this.model.origin[0]) || (this._position[1] != this.model.origin[1]) || (this._position[2] != this.model.origin[2])) {
                //vec3.copy(this.model.origin, this._position);
                this.model.position = this._position;
                this.model.dirty = true; //removeme ?
            }
        }
        if (this.m_flMoveDoneTime <= this.m_flLocalTime && this.m_flMoveDoneTime > 0) {
            this.setMoveDoneTime(-1);
            //vec3.copy(this.origin, this.finalDest);
            this.position = this.finalDest;
            set$5(this.m_vecVelocity, 0, 0, 0);
            this.moveDone();
        }
    }
    inputOpen() {
        if (squaredDistance$2(this.getAbsOrigin(), this.pos2) != 0) {
            this.moveTo(this.pos2, this.speed);
        }
    }
    inputClose() {
        if (squaredDistance$2(this.getAbsOrigin(), this.pos1) != 0) {
            this.moveTo(this.pos1, this.speed);
        }
    }
    moveTo(position, speed) {
        if (speed) {
            this.linearMove(position, speed);
        }
    }
    linearMove(destination, speed) {
        this.finalDest = clone$4(destination);
        const origin = this.getLocalOrigin();
        if (squaredDistance$2(origin, destination) < 0.001) {
            this.moveDone();
            return;
        }
        const vecDelta = sub$2(create$4(), destination, origin);
        const travelTime = length$5(vecDelta) / speed;
        this.setMoveDoneTime(travelTime);
        this.setLocalVelocity(scale$5(vecDelta, vecDelta, 1.0 / travelTime));
    }
    moveDone() {
        if (squaredDistance$2(this.getAbsOrigin(), this.pos2) == 0) {
            this.onFullyOpen.fireOutput(this, this);
        }
        else if (squaredDistance$2(this.getAbsOrigin(), this.pos1) == 0) {
            this.onFullyClosed.fireOutput(this, this);
        }
    }
    getAbsOrigin() {
        return this._position;
    }
}
MapEntities.registerEntity('func_door', FuncDoor);

class MapEntityAmbientLight extends MapEntity {
    #ambientLight = new AmbientLight();
    constructor(classname) {
        super(classname);
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.m.addChild(this.#ambientLight);
        this.#ambientLight.position = this._position;
    }
    setKeyValue(key, value) {
        let ambientLight = this.#ambientLight;
        //pointLight.range = 1000;
        switch (key) {
            case '_ambient':
                parseLightColorIntensity(value, ambientLight, 0.1);
                break;
            //TODO: other parameters
            default:
                super.setKeyValue(key, value);
        }
    }
    update(map, delta) {
        super.update(map, delta);
        this.#ambientLight.position = this._position;
    }
}
MapEntities.registerEntity('light_environment', MapEntityAmbientLight);
/*
{
"origin" "216 -632 -48.4408"
"SunSpreadAngle" "0"
"pitch" "-45"
"angles" "-45 204 0"
"_lightscaleHDR" "1"
"_lightHDR" "-1 -1 -1 1"
"_light" "253 243 208 500"
"_AmbientScaleHDR" "1"
"_ambientHDR" "-1 -1 -1 1"
"_ambient" "124 138 203 500"
"classname" "light_environment"
"hammerid" "1351"
}
*/

//const colorIntensity = vec4.create();
class MapEntityLight extends MapEntity {
    pointLight = new PointLight();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.m.addChild(this.pointLight);
        this.pointLight.position = this._position;
    }
    setKeyValue(key, value) {
        let pointLight = this.pointLight;
        pointLight.range = 1000;
        switch (key) {
            case '_zero_percent_distance':
                pointLight.range = Number(value);
                break;
            case '_light':
                parseLightColorIntensity(value, pointLight, 1.0);
                break;
            //TODO: other parameters
            default:
                super.setKeyValue(key, value);
        }
    }
    update(map, delta) {
        super.update(map, delta);
        this.pointLight.position = this._position;
    }
}
MapEntities.registerEntity('light', MapEntityLight);

class PropDynamic extends MapEntity {
    model;
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.setupModel(kvElement);
    }
    async setupModel(kvElement) {
        const entity = kvElement;
        if (entity && entity.model) {
            let model = await this.setModel(entity.model);
            const skin = entity.skin || 0;
            if (model) {
                model.skin = skin;
                if (model) {
                    model.position = this._position;
                    model.quaternion = this._quaternion;
                }
                if (entity.defaultanim) {
                    model.playSequence(entity.defaultanim);
                }
                else {
                    model.playDefaultAnim();
                } //TODO: RandomAnimation, StartDisabled, SetBodyGroup
                if (entity.startdisabled == 1) {
                    this.model.visible = false;
                }
            }
        }
    }
    /*
        setKeyValue(key, value) {
            await super.setKeyValue(key, value);
            let model;
            switch (key) {
                case 'model':
                    await this.setModel(value);
                    break;
                case 'origin':
                    model = this.model;
                    if (model) {
                        model.position = this._position;
                    }
                    break;
                case 'angles':
                    model = this.model;
                    if (model) {
                        model.quaternion = this._quaternion;
                    }
                    break;
            }
        }*/
    async setModel(modelName) {
        modelName = modelName.replace(/.mdl$/g, '');
        let model = await Source1ModelManager.createInstance(this.map.repository, modelName, true);
        /*model.position = this.position;
        model.quaternion = this._quaternion;*/
        this.model = model;
        this.m.dynamicProps.addChild(model);
        /*.then(
            (model) => {
                this.map.dynamicProps.addChild(model);
                model.position = this.position;
                model.quaternion = this._quaternion;
                //TODOv3: animate
            }
        );*/
        return model;
    }
    setInput(inputName, parameter) {
        switch (inputName.toLowerCase()) {
            case 'skin':
                this.model.setSkin(parameter);
                break;
        }
    }
    update(map, delta) {
        super.update(map, delta);
        const model = this.model; //fixme this
        if (model) {
            model.position = this._position;
            model.quaternion = this._quaternion;
        }
    }
}
MapEntities.registerEntity('prop_dynamic', PropDynamic);
MapEntities.registerEntity('prop_dynamic_override', PropDynamic);
//SEMapEntities.registerEntity('prop_static', SEEntityPropDynamic);
MapEntities.registerEntity('prop_scalable', PropDynamic);
MapEntities.registerEntity('prop_physics_override', PropDynamic);

const tempQuaternion = create$2();
const tempVec3$j = create$4();
const SPOTLIGHT_DEFAULT_QUATERNION = fromValues$2(0, -1, 0, 1);
class PropLightSpot extends MapEntity {
    spotLight = new SpotLight();
    //this.spotLight.visible = false;
    _angles = fromValues$4(-90, 0, 0);
    constructor(classname) {
        super(classname);
        this.quaternion = SPOTLIGHT_DEFAULT_QUATERNION;
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.m.addChild(this.spotLight);
        this.spotLight.position = this._position;
        this.spotLight.quaternion = this._quaternion;
    }
    setKeyValue(key, value) {
        let spotLight = this.spotLight;
        spotLight.range = 1000;
        switch (key) {
            case '_zero_percent_distance':
                spotLight.range = Number(value);
                break;
            case '_cone':
                spotLight.angle = value * DEG_TO_RAD;
                break;
            case '_inner_cone':
                spotLight.innerAngle = value * DEG_TO_RAD;
                break;
            case '_light':
                parseLightColorIntensity(value, spotLight, 0.1);
                break;
            case 'pitch':
                //angles should suffice
                this._angles[0] = -value * DEG_TO_RAD;
                this.setAngles();
                break;
            case 'angles':
                ParseAngles2(tempVec3$j, value);
                this._angles[1] = tempVec3$j[1];
                this._angles[2] = tempVec3$j[1];
                this.setAngles();
                break;
            case '_quadratic_attn':
                //TODO
                break;
            case '_linear_attn':
                //TODO
                break;
            case '_lightscalehdr':
                //TODO
                break;
            case '_lighthdr':
                //TODO
                break;
            default:
                super.setKeyValue(key, value);
        }
    }
    setAngles() {
        AngleQuaternion(this._angles, tempQuaternion);
        mul$2(this._quaternion, SPOTLIGHT_DEFAULT_QUATERNION, tempQuaternion);
    }
    setInput(inputName, parameter) {
        throw 'code me';
        /*
        switch (inputName.toLowerCase()) {
            case 'skin':
                this.model.setSkin(parameter);
                break;
        }*/
    }
    update(map, delta) {
        super.update(map, delta);
        this.spotLight.position = this._position;
        this.spotLight.quaternion = this._quaternion;
    }
}
MapEntities.registerEntity('light_spot', PropLightSpot);
MapEntities.registerEntity('light_glspot', PropLightSpot);

class SkyCamera extends MapEntity {
    camera = new Camera();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.camera.scale = fromValues$4(kvElement.scale, kvElement.scale, kvElement.scale);
        this.camera.position = this._position;
    }
}
MapEntities.registerEntity('sky_camera', SkyCamera);

/**
 * Proxy manager
 */
class ProxyManager {
    static #proxyList = {};
    static getProxy(proxyName) {
        if (!proxyName) {
            return;
        }
        proxyName = proxyName.toLowerCase();
        const proxy = this.#proxyList[proxyName];
        if (!proxy) {
            return null;
        }
        return new proxy();
    }
    static registerProxy(proxyName, proxyClass) {
        if (!proxyClass) {
            return;
        }
        const name = proxyName.toLowerCase();
        this.#proxyList[name] = proxyClass;
    }
}

/*export setResult(variables, value) {
    let resultVarName = this.getData('resultvar');
    if (resultVarName) {
        resultVarName = resultVarName.toLowerCase();
        if (resultVarName.indexOf('[') != -1) {
            let result = (/([^\[]*)\[(\d*)\]/g).exec(resultVarName);
            if (result && result.length == 3) {
                const v = variables.get(result[1].toLowerCase());
                if (v) {
                    v[result[2]] = value;
                }
            }
        } else {
            variables.set(resultVarName, value);
        }
    }
}
*/
/**
 * Source engine material interface
 */
class Proxy {
    datas = null;
    /**
     * TODO
     */
    setParams(datas, variables) {
        this.datas = datas;
        this.init(variables);
    }
    /**
     * TODO
     */
    getData(name) {
        const result = this.datas[name];
        if (typeof result == 'string') {
            return result.toLowerCase();
        }
        return result;
    }
    /**
     * Dummy function
     */
    init(variables) {
    }
    /**
     * Dummy function
     */
    execute(variables, proxyParams, time) {
    }
    setResult(variables, value) {
        let resultVarName = this.getData('resultvar');
        if (resultVarName) {
            resultVarName = resultVarName.toLowerCase();
            if (resultVarName.indexOf('[') != -1) {
                let result = (/([^\[]*)\[(\d*)\]/g).exec(resultVarName);
                if (result && result.length == 3) {
                    const v = variables.get(result[1].toLowerCase());
                    if (v) {
                        if (typeof value == 'number') {
                            v[result[2]] = value;
                        }
                        else { //array
                            v[result[2]] = value[result[2]];
                        }
                    }
                }
            }
            else {
                let v = variables.get(resultVarName);
                if ((v === undefined) && (value instanceof Array || value instanceof Float32Array)) {
                    v = new Float32Array(value.length);
                    variables.set(resultVarName, v);
                }
                if (v instanceof Array || v instanceof Float32Array) {
                    v[0] = value?.[0] ?? value;
                    v[1] = value?.[1] ?? value;
                    v[2] = value?.[2] ?? value;
                }
                else {
                    variables.set(resultVarName, value);
                }
            }
        }
    }
    getVariable(variables, name) {
        const result = this.datas[name];
        if (typeof result == 'string') {
            if (result.startsWith('$')) {
                const varName = result.toLowerCase();
                return variables.get(varName);
            }
            else {
                return result.toLowerCase();
            }
        }
        return result;
    }
}

/**
 * Add proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Add extends Proxy {
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                super.setResult(variables, v1 + v2);
            }
            else { //array
                super.setResult(variables, fromValues$4(v1 + v2[0], v1 + v2[1], v1 + v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                super.setResult(variables, fromValues$4(v1[0] + v2, v1[1] + v2, v1[2] + v2));
            }
            else { //array
                super.setResult(variables, fromValues$4(v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]));
            }
        }
    }
}
ProxyManager.registerProxy('Add', Add);

class AnimatedTextureProxy extends Proxy {
    #animatedtexturevar;
    #animatedtextureframenumvar;
    #animatedtextureframerate;
    init() {
        this.#animatedtexturevar = this.datas['animatedtexturevar'];
        this.#animatedtextureframenumvar = this.datas['animatedtextureframenumvar'];
        this.#animatedtextureframerate = this.datas['animatedtextureframerate'];
    }
    execute(variables, proxyParams, time) {
        variables.set(this.#animatedtextureframenumvar, time * this.#animatedtextureframerate);
    }
}
ProxyManager.registerProxy('AnimatedTexture', AnimatedTextureProxy);
/*AnimatedTexture
 Increments the current frame of an animated VTF.

animatedtexturevar
Texture to increment frame for (i.e. $basetexture, $bumpmap, $normalmap (both $bumpmap and $normalmap use $bumpframe))
animatedtextureframenumvar
Frame variable to increment (i.e. $frame, $bumpframe)
animatedtextureframerate
Framerate in frames per second. Fixed; cannot be changed once set.



            'animatedtextureframenumvar' '$frame'
            'animatedtextureframenumvar' '$detailframe'
*/

class AnimatedWeaponSheen extends Proxy {
    #animatedtexturevar;
    #animatedtextureframenumvar;
    #animatedtextureframerate;
    init() {
        this.#animatedtexturevar = this.datas['animatedtexturevar'];
        this.#animatedtextureframenumvar = this.datas['animatedtextureframenumvar'];
        this.#animatedtextureframerate = this.datas['animatedtextureframerate'];
    }
    execute(variables, proxyParams, time) {
        if (proxyParams['SheenTintColor']) {
            variables.set(this.#animatedtextureframenumvar, time * this.#animatedtextureframerate);
        }
        else {
            variables.set(this.#animatedtextureframenumvar, 0);
        }
        if (proxyParams['SheenMaskScaleX']) {
            variables.set('$SheenMaskScaleX', proxyParams['SheenMaskScaleX']);
            variables.set('$SheenMaskScaleY', proxyParams['SheenMaskScaleY']);
            variables.set('$SheenMaskOffsetX', proxyParams['SheenMaskOffsetX']);
            variables.set('$SheenMaskOffsetY', proxyParams['SheenMaskOffsetY']);
            variables.set('$SheenMaskDirection', proxyParams['SheenMaskDirection']);
        }
    }
}
ProxyManager.registerProxy('AnimatedWeaponSheen', AnimatedWeaponSheen);
/*AnimatedWeaponSheen
 Increments the current frame of an animated VTF.

animatedtexturevar
Texture to increment frame for (i.e. $basetexture, $bumpmap, $normalmap (both $bumpmap and $normalmap use $bumpframe))
animatedtextureframenumvar
Frame variable to increment (i.e. $frame, $bumpframe)
animatedtextureframerate
Framerate in frames per second. Fixed; cannot be changed once set.



            'animatedtextureframenumvar' '$frame'
            'animatedtextureframenumvar' '$detailframe'
*/

const minValue = 5.0;
const maxValue = 1.0;
class BenefactorLevel extends Proxy {
    #datas;
    #resultVar;
    setParams(datas) {
        this.#datas = datas;
        this.init();
    }
    init() {
        this.#resultVar = this.#datas['resultvar'];
    }
    execute(variables) {
        let value = 1.0;
        variables.set(this.#resultVar, minValue + (maxValue - minValue) * value);
    }
}
ProxyManager.registerProxy('BenefactorLevel', BenefactorLevel);

class BuildingInvis extends Proxy {
}
ProxyManager.registerProxy('building_invis', BuildingInvis);

class TextureTransform extends Proxy {
    centerVar;
    translateVar;
    rotateVar;
    scaleVar;
    resultVar;
    init(variables) {
        this.centerVar = this.getData('centervar');
        this.translateVar = this.getData('translatevar');
        this.rotateVar = this.getData('rotatevar');
        this.scaleVar = this.getData('scalevar');
        this.resultVar = this.getData('resultvar');
        variables.set(this.resultVar, create$5()); //TODO: fixme
    }
    execute(variables, proxyParams, time) {
        let center = fromValues(0.5, 0.5);
        const mat = create$5(); //TODOv3 optimize
        const temp = create$5(); //TODOv3 optimize
        if (this.centerVar) {
            center = variables.get(this.centerVar) || center;
        }
        MatrixBuildTranslation(mat, -center[0], -center[1], 0.0);
        if (this.scaleVar) { //mat4.identity(out);
            const scale = variables.get(this.scaleVar);
            if (scale) {
                if (typeof scale == 'number') {
                    MatrixBuildScale(temp, scale, scale, 1.0);
                }
                else {
                    MatrixBuildScale(temp, scale[0], scale[1], 1.0);
                }
                mul$5(mat, temp, mat);
            }
        }
        if (this.rotateVar) {
            const rotate = variables.get(this.rotateVar);
            identity$2(temp);
            rotateZ$3(temp, temp, DEG_TO_RAD * (rotate));
            //MatrixBuildRotateZ(temp, angle);
            //MatrixMultiply(temp, mat, mat);
            mul$5(mat, temp, mat);
        }
        MatrixBuildTranslation(temp, center[0], center[1], 0.0);
        mul$5(mat, temp, mat);
        //mat[12] += center[0];
        //mat[13] += center[1];
        if (this.translateVar) {
            const translation = variables.get(this.translateVar);
            MatrixBuildTranslation(temp, translation[0], translation[1], 0.0);
            //MatrixMultiply(temp, mat, mat);
            mul$5(mat, temp, mat);
        }
        const v = variables.get(this.resultVar);
        if (v) {
            copy$5(v, mat);
        }
        else {
            variables.set(this.resultVar, clone$5(mat));
        }
    }
}
ProxyManager.registerProxy('TextureTransform', TextureTransform);
function MatrixBuildTranslation(dst, x, y, z) {
    identity$2(dst);
    dst[12] = x;
    dst[13] = y;
    dst[14] = z;
}
// Builds a scale matrix
function MatrixBuildScale(dst, x, y, z) {
    dst[0] = x;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = y;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = z;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
}
/*TextureTransform
 Generates a texture transform matrix for use with $basetexturetransform etc.

centerVar
scaleVar
rotateVar
translateVar
Optional input variables for the matrix. Each one can be a float or a 2D vector.
resultVar


        'TextureTransform'
        {
            'translateVar' '$temp'
            'resultVar' '$basetexturetransform'
        }
*/

const TEMP_MAT4 = create$5();
class BuildingRescueLevel extends Proxy {
    #datas;
    #r;
    setParams(datas) {
        this.#datas = datas;
        this.init();
    }
    init() {
        this.#r = this.#datas['resultvar'];
    }
    execute(variables) {
        const v = variables.get(this.#r);
        if (v) {
            let iAmmo = 200;
            let maxAmmo = 200;
            let iIncreasedRangeCost = 100;
            let scale = 1.0;
            {
                scale = (3.0 - ((iAmmo - iIncreasedRangeCost) / (maxAmmo - iIncreasedRangeCost) * 3.0) + 1.0);
            }
            MatrixBuildTranslation(v, -0.5, -0.5, 0.0);
            // scale
            {
                MatrixBuildScale(TEMP_MAT4, 1.0, scale, 1.0);
                mul$5(v, TEMP_MAT4, v);
            }
            MatrixBuildTranslation(TEMP_MAT4, 0.5, 0.5, 0.0);
            mul$5(v, TEMP_MAT4, v);
        }
    }
}
ProxyManager.registerProxy('BuildingRescueLevel', BuildingRescueLevel);

/**
 * BurnLevel proxy.
 * @comment ouput variable name: resultVar
 */
class BurnLevel extends Proxy {
    #r;
    init() {
        this.#r = this.datas['resultvar'];
    }
    execute(variables, proxyParams) {
        variables.set(this.#r, proxyParams.burnlevel ?? 0);
    }
}
ProxyManager.registerProxy('BurnLevel', BurnLevel);

class Clamp extends Proxy {
    #srcvar1;
    #resultvar;
    #minVal;
    #maxVal;
    init(variables) {
        //TODO : removeme
        this.#srcvar1 = this.datas['srcvar1'];
        this.#resultvar = this.datas['resultvar'];
        this.#minVal = this.datas['min'] ?? 0;
        this.#maxVal = this.datas['max'] ?? 1;
    }
    execute(variables) {
        const v1 = variables.get(this.getData('srcvar1'));
        if ((v1 === null) || (v1 === undefined)) {
            variables.set(this.#resultvar, null);
            return;
        }
        if (typeof v1 == 'number') {
            super.setResult(variables, Math.min(Math.max(v1, this.#minVal), this.#maxVal));
        }
        else { //array
            let clampedArray = [];
            for (let i in v1) {
                clampedArray[i] = Math.min(Math.max(v1[i], this.#minVal), this.#maxVal);
            }
            super.setResult(variables, clampedArray);
            /*if (typeof v2=='number') {
                //variables.set(this.r, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
                super.setResult(variables, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
            } else {//array
                //variables.set(this.r, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
                super.setResult(variables, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
            }*/
        }
    }
}
ProxyManager.registerProxy('Clamp', Clamp);

class CommunityWeapon extends Proxy {
}
ProxyManager.registerProxy('communityweapon', CommunityWeapon);

/**
 * CustomSteamImageOnModel proxy.
 * @comment ouput variable name: resultVar
 */
class CustomSteamImageOnModel extends Proxy {
    #defaultTexture;
    setParams(datas) {
    }
    init() {
    }
    execute(variables, proxyParams) {
        if (!this.#defaultTexture) {
            this.#defaultTexture = variables.get('$basetexture');
        }
        if (proxyParams['customtexture']) {
            variables.set('$basetexture', proxyParams['customtexture']);
        }
        else {
            variables.set('$basetexture', this.#defaultTexture);
        }
    }
}
ProxyManager.registerProxy('customsteamimageonmodel', CustomSteamImageOnModel);

/**
 * Divide proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Divide extends Proxy {
    init(variables) {
        //this.s1 = this.datas['srcvar1'];
        //this.s2 = this.datas['srcvar2'];
        //this.r = this.datas['resultvar'];
    }
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                //variables.get(this.r, v1*v2);
                super.setResult(variables, v1 / v2);
            }
            else { //array
                //variables.get(this.r, vec3.fromValues(v1*v2[0], v1*v2[1], v1*v2[2]));
                super.setResult(variables, fromValues$4(v1 / v2[0], v1 / v2[1], v1 / v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                //variables.get(this.r, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
                super.setResult(variables, fromValues$4(v1[0] / v2, v1[1] / v2, v1[2] / v2));
            }
            else { //array
                //variables.get(this.r, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
                super.setResult(variables, fromValues$4(v2[0] ? (v1[0] / v2[0]) : 0, v2[1] ? (v1[1] / v2[1]) : 0, v2[2] ? (v1[2] / v2[2]) : 0));
            }
        }
    }
}
ProxyManager.registerProxy('Divide', Divide);

/**
 * Equals proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment ouput variable name: resultVar
 */
class Equals extends Proxy {
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
    }
}
ProxyManager.registerProxy('Equals', Equals);

const scale = 0.6;
const loBeat = 1.0 * scale;
const hiBeat = 0.8 * scale;
class HeartbeatScale extends Proxy {
    #datas;
    #sineperiod;
    #resultVar;
    #delta;
    #mid;
    #p;
    setParams(datas) {
        this.#datas = datas;
        this.init();
    }
    init() {
        this.#sineperiod = 1;
        this.#resultVar = this.#datas['resultvar'];
        this.#delta = 0.2;
        this.#mid = 1.0;
        this.#p = 2 * Math.PI / this.#sineperiod;
    }
    execute(variables, proxyParams, time) {
        let s1 = Math.sin(time * TWO_PI);
        s1 = clamp(s1, 0.0, 1.0);
        s1 *= s1;
        s1 *= s1;
        s1 = clamp(s1, 0.5, 1.0);
        s1 -= 0.5;
        s1 *= 2.0;
        let s2 = Math.sin((time + 0.25) * TWO_PI);
        s2 = clamp(s2, 0.0, 1.0);
        s2 *= s2;
        s2 *= s2;
        s2 = clamp(s2, 0.5, 1.0);
        s2 -= 0.5;
        s2 *= 2.0;
        let beat = Math.max(s1, s2);
        let scaledBeat = loBeat + (hiBeat - loBeat) * beat;
        variables.set(this.#resultVar, scaledBeat);
    }
}
ProxyManager.registerProxy('HeartbeatScale', HeartbeatScale);

class IntProxy extends Proxy {
    init() {
    }
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        //const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v1 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            super.setResult(variables, Math.round(v1));
        }
        else {
            super.setResult(variables, fromValues$4(Math.round(v1[0]), Math.round(v1[1]), Math.round(v1[2])));
        }
    }
}
ProxyManager.registerProxy('Int', IntProxy);

/**
 * Invis proxy.
 * @comment ouput variable name: resultVar
 */
class Invis extends Proxy {
}
ProxyManager.registerProxy('Invis', Invis);

/**
 * ItemTintColor Proxy
 */
class ItemTintColor extends Proxy {
    #resultvar;
    init() {
        this.#resultvar = this.datas['resultvar'];
    }
    execute(variables, proxyParams) {
        variables.set(this.#resultvar, proxyParams.ItemTintColor);
    }
}
ProxyManager.registerProxy('ItemTintColor', ItemTintColor);

class LessOrEqualProxy extends Proxy {
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const srcVar1 = variables.get(this.getData('srcvar1'));
        const srcVar2 = variables.get(this.getData('srcvar2'));
        if (typeof srcVar1 == 'number' && typeof srcVar2 == 'number') {
            if (srcVar1 <= srcVar2) {
                super.setResult(variables, variables.get(this.getData('lessequalvar')));
            }
            else {
                super.setResult(variables, variables.get(this.getData('greatervar')));
            }
        }
        else {
            super.setResult(variables, srcVar1);
        }
    }
}
ProxyManager.registerProxy('LessOrEqual', LessOrEqualProxy);
/*
        "LessOrEqual"
        {
            "srcVar1"		"$glowSineFlashGap"
            "srcVar2"		"$flashMin"
            "resultVar"		"$glowSineFlash"
            "greaterVar"		"$glowSineFlash"
            "LessEqualVar"		"$flashOff"
        }
*/

class LinearRamp extends Proxy {
    #rate;
    init() {
        this.#rate = Number(this.datas['rate'] ?? 1);
    }
    execute(variables, proxyParams, time) {
        const initialValue = Number(this.getVariable(variables, 'initialvalue') ?? 0);
        super.setResult(variables, initialValue + time * this.#rate);
    }
}
ProxyManager.registerProxy('LinearRamp', LinearRamp);

/**
 * ModelGlowColor proxy.
 * @comment ouput variable name: resultVar
 */
class ModelGlowColor extends Proxy {
    #resultVar;
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams) {
        variables.set(this.#resultVar, proxyParams.ModelGlowColor ?? [1, 1, 1]);
    }
}
ProxyManager.registerProxy('ModelGlowColor', ModelGlowColor);

/**
 * Multiply proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Multiply extends Proxy {
    init() {
    }
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                super.setResult(variables, v1 * v2);
            }
            else { //array
                super.setResult(variables, fromValues$4(v1 * v2[0], v1 * v2[1], v1 * v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                super.setResult(variables, fromValues$4(v1[0] * v2, v1[1] * v2, v1[2] * v2));
            }
            else { //array
                super.setResult(variables, fromValues$4(v1[0] * v2[0], v1[1] * v2[1], v1[2] * v2[2]));
            }
        }
    }
}
ProxyManager.registerProxy('Multiply', Multiply);

/**
 * SelectFirstIfNonZero Proxy
 */
class SelectFirstIfNonZero extends Proxy {
    #srcVar1;
    #srcVar2;
    init() {
        this.#srcVar1 = (this.datas['srcvar1'] ?? '').toLowerCase();
        this.#srcVar2 = (this.datas['srcvar2'] ?? '').toLowerCase();
    }
    execute(variables) {
        super.setResult(variables, this.isNonZero(variables.get(this.#srcVar1)) ? variables.get(this.#srcVar1) : variables.get(this.#srcVar2));
    }
    isNonZero(value) {
        if (!value)
            return false;
        if (value instanceof Array || value instanceof Float32Array) {
            for (let i = 0; i < value.length; ++i) {
                if (value[i]) {
                    return true;
                }
            }
        }
        return false;
    }
}
ProxyManager.registerProxy('SelectFirstIfNonZero', SelectFirstIfNonZero);

class Sine extends Proxy {
    //#delta;
    //#mid;
    #period;
    #sineperiod;
    #timeoffset;
    init() {
        this.#sineperiod = Number(this.datas['sineperiod'] ?? 1);
        //this.sinemin = this.datas['sinemin']*1; //TODO: check number
        //this.sinemax = this.datas['sinemax']*1;
        this.#timeoffset = Number(this.datas['timeoffset'] ?? 0);
        //this.#delta = (this.sinemax - this.sinemin)/2;
        //this.#mid = this.sinemin + this.#delta;
        this.#period = 2 * Math.PI / this.#sineperiod;
        //this.#delta = 1.0;
    }
    execute(variables, proxyParams, time) {
        const sineMin = this.getVariable(variables, 'sinemin') * 1;
        const sineMax = this.getVariable(variables, 'sinemax') * 1;
        const delta = (sineMax - sineMin) * 0.5;
        const mid = sineMin + delta;
        const value = mid + delta * Math.sin(time * this.#period);
        super.setResult(variables, value);
    }
}
ProxyManager.registerProxy('Sine', Sine);
/*Sine
Sine
 A sine wave.

sineperiod
Period between wave peaks, in seconds.
sinemin
sinemax
Values at the top and bottom of the wave
timeoffset
Used to offset the starting position of the wave
resultVar

resultVar $selfillumtint // The shader parameter to be manipulated
*/

/**
 * SpyInvis proxy.
 * @comment ouput variable name: resultVar
 */
class SpyInvis extends Proxy {
}
ProxyManager.registerProxy('Spy_Invis', SpyInvis);

/**
 * StatTrakDigit Proxy
 */
class StatTrakDigit extends Proxy {
    #displayDigit = 0;
    #resultVar;
    #trimZeros;
    init() {
        this.#trimZeros = this.datas['trimzeros'];
        this.#resultVar = this.datas['resultvar'];
        this.#displayDigit = this.datas['displaydigit'] ?? 0;
    }
    execute(variables, proxyParams, time) {
        const number = proxyParams.StatTrakNumber || 0;
        const numberasstring = String(number);
        let digit = Math.floor(number / (Math.pow(10, this.#displayDigit)) % 10);
        // Trim zeroes
        if (this.#trimZeros && digit == 0 && (this.#displayDigit >= numberasstring.length)) {
            digit = 10; // Blank frame
        }
        variables.set(this.#resultVar, digit);
    }
}
ProxyManager.registerProxy('StatTrakDigit', StatTrakDigit);

class StatTrakIllum extends Proxy {
    #resultVar;
    #minVal;
    #maxVal;
    init() {
        this.#resultVar = this.datas['resultvar'];
        this.#minVal = Number(this.datas['minval'] ?? 0);
        this.#maxVal = Number(this.datas['maxval'] ?? 1);
    }
    execute(variables, proxyParams) {
        const glowMultiplier = proxyParams.GlowMultiplier ?? 0.5;
        let value = lerp(this.#minVal, this.#maxVal, glowMultiplier);
        variables.set(this.#resultVar, fromValues$4(value, value, value));
    }
}
ProxyManager.registerProxy('StatTrakIllum', StatTrakIllum);

class StickybombGlowColor extends Proxy {
    #resultVar;
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams) {
        variables.set(this.#resultVar, [1, 1, 1]);
    }
}
ProxyManager.registerProxy('StickybombGlowColor', StickybombGlowColor);

function toNumber(string) {
    let num = Number(string);
    if (!Number.isNaN(num)) {
        return num;
    }
}
class TextureScroll extends Proxy {
    #textureScrollVar;
    #textureScrollRate;
    #textureScrollAngle;
    #textureScale;
    init(variables) {
        this.#textureScrollVar = (this.datas['texturescrollvar'] ?? '').toLowerCase();
        this.#textureScrollRate = toNumber(this.datas['texturescrollrate']) ?? 1;
        this.#textureScrollAngle = toNumber(DEG_TO_RAD * (this.datas['texturescrollangle'])) ?? 0;
        this.#textureScale = toNumber(this.datas['texturescale']) ?? 1;
        variables.set(this.#textureScrollVar, create$5()); //TODO: fixme
    }
    execute(variables, proxyParams, time) {
        const rate = this.#textureScrollRate;
        const angle = this.#textureScrollAngle;
        const scale = this.#textureScale;
        const sOffset = time * Math.cos(angle) * rate;
        const tOffset = time * Math.sin(angle) * rate;
        // make sure that we are positive
        /*if(sOffset < 0.0) {
            sOffset += 1.0 + -(int)sOffset;
        }
        if(tOffset < 0.0) {
            tOffset += 1.0 + -(int)tOffset;
        }*/
        // make sure that we are in a [0,1] range
        //sOffset = sOffset - (int)sOffset;
        //tOffset = tOffset - (int)tOffset;
        const v = variables.get(this.#textureScrollVar);
        if (v) {
            v[0] = scale;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            v[4] = 0;
            v[5] = scale;
            v[6] = 0;
            v[7] = 0;
            v[8] = 0;
            v[9] = 0;
            v[10] = 1;
            v[11] = 0;
            v[12] = sOffset;
            v[13] = tOffset;
            v[14] = 0;
            v[15] = 1;
        }
        /*
            if (m_pTextureScrollVar->GetType() == MATERIAL_VAR_TYPE_MATRIX)
            {
                VMatrix mat(scale, 0.0f, 0.0f, sOffset,
                    0.0f, scale, 0.0f, tOffset,
                    0.0f, 0.0f, 1.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, 1.0f);
                m_pTextureScrollVar->SetMatrixValue(mat);
            }
            else
            {
                m_pTextureScrollVar->SetVecValue(sOffset, tOffset, 0.0f);
            }*/
    }
}
ProxyManager.registerProxy('TextureScroll', TextureScroll);
/*TextureScroll
 Returns a transform matrix or vector that will translate a texture at a given angle at a given rate.

textureScrollVar
Destination for the resulting transformation.
textureScrollRate
Rate of scroll in units per second.
textureScrollAngle
Angle of rotation to move along. (90 = up, 180 = left, etc)

        'TextureScroll'
        {
            'texturescrollvar'	'$BUMPTRANSFORM'
            'texturescrollrate'	.45
            'texturescrollangle'	85
        }
*/

class UniformNoiseProxy extends Proxy {
    execute(variables) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const minVal = (this.getData('minval') ?? 0) * 1;
        const maxVal = (this.getData('maxval') ?? 1) * 1;
        super.setResult(variables, Math.random() * (maxVal - minVal) + minVal);
    }
}
ProxyManager.registerProxy('UniformNoise', UniformNoiseProxy);
/*
        "UniformNoise"
        {
            "minVal"		"-0.001000"
            "maxVal"		"0.001000"
            "resultVar"		"$noise_alpha"
        }
*/

class WaterLod extends Proxy {
}
ProxyManager.registerProxy('WaterLod', WaterLod);

class WeaponInvis extends Proxy {
}
ProxyManager.registerProxy('weapon_invis', WeaponInvis);

const RESULT_VAR = '$basetexturetransform';
class WeaponLabelText extends Proxy {
    #displayDigit;
    init() {
        this.#displayDigit = this.datas['displaydigit'] ?? 0;
    }
    execute(variables, proxyParams, time) {
        const text = proxyParams.WeaponLabelText || '';
        const car = text.charCodeAt(this.#displayDigit);
        const mat = create$5(); //TODOv3 optimize
        // 96 ASCII characters starting from 0x20 (space)
        let x, y;
        if ((car >= 32) && (car < 128)) {
            const i = car - 32;
            x = i % 12;
            y = Math.floor(i / 12);
        }
        else {
            x = 0;
            y = 0;
        }
        // Texture is 12*8 characters
        //const btt = variables.get('$basetexturetransform') || vec2.create();
        //btt[0]=x/12;
        // /btt[1]=y/8;
        //variables.set('$basetexturetransform', btt);
        MatrixBuildTranslation(mat, x / 12, y / 8, 0.0);
        const v = variables.get(RESULT_VAR);
        if (v) {
            copy$5(v, mat);
        }
        else {
            variables.set(RESULT_VAR, clone$5(mat));
        }
    }
}
ProxyManager.registerProxy('WeaponLabelText', WeaponLabelText);
ProxyManager.registerProxy('WeaponLabelTextPreview', WeaponLabelText);

class WeaponSkin extends Proxy {
    #defaultTexture = null;
    execute(variables, proxyParams) {
        if (!this.#defaultTexture) {
            this.#defaultTexture = variables.get('$basetexture');
        }
        if (proxyParams['WeaponSkin']) {
            variables.set('$basetexture', proxyParams['WeaponSkin']);
        }
        else {
            variables.set('$basetexture', this.#defaultTexture);
        }
    }
}
ProxyManager.registerProxy('WeaponSkin', WeaponSkin);

/**
 * YellowLevel proxy.
 * @comment ouput variable name: resultVar
 */
const URINE_RED = fromValues$4(6, 9, 2);
const URINE_BLU = fromValues$4(7, 5, 1);
class YellowLevel extends Proxy {
    #resultVar;
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams) {
        if (!proxyParams.jarate) {
            variables.set(this.#resultVar, fromValues$4(1, 1, 1));
        }
        else {
            if (proxyParams.team == 0) {
                variables.set(this.#resultVar, scale$5(create$4(), URINE_RED, proxyParams.jarate));
            }
            else {
                variables.set(this.#resultVar, scale$5(create$4(), URINE_BLU, proxyParams.jarate));
            }
        }
    }
}
ProxyManager.registerProxy('YellowLevel', YellowLevel);

function detex(imports){return _loadWasmModule(0, null, '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IgAQBCIBEA0hAkH00wAgADYCAEHw0wAgATYCACADQSBqJAAgAguFAQECfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAoAgAiBEH//wNxQf8BbEGB/QFqQf//A24gBEEQdkH/AWxBgf0BakH//wNuQQh0ciAALwEEQf8BbEGB/QFqQf//A25BEHRyQYCAgHhyNgIAIANBAWohAyACQQRqIQIgAEEIaiEADAELCwuCAQEDfyABQQAgAUEAShshAQNAIAEgA0cEQCAALwEAIQQgAC8BAiEFIAIgAC8BBEH/AWxBgf0BakH//wNuOgACIAIgBUH/AWxBgf0BakH//wNuOgABIAIgBEH/AWxBgf0BakH//wNuOgAAIANBAWohAyACQQNqIQIgAEEGaiEADAELCwtoAQJ/IAFBACABQQBKGyEBA0AgASADRwRAIAIgACgCACIEQRB2Qf8BbEGB/QFqQf//A25BCHQgBEH//wNxQf8BbEGB/QFqQf//A25yOwEAIANBAWohAyACQQJqIQIgAEEEaiEADAELCwtKAQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC8BAEH/AWxBgf0BakH//wNuOgAAIANBAWohAyACQQFqIQIgAEECaiEADAELCwtCAQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC8BAEGAgIB4cjYCACADQQFqIQMgAkEEaiECIABBAmohAAwBCwsLQgEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAtAABBgICAeHI2AgAgA0EBaiEDIAJBBGohAiAAQQFqIQAMAQsLCzwBAX8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAALwAAOwAAIANBAWohAyACQQJqIQIgAEEDaiEADAELCws8AQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC0AADoAACADQQFqIQMgAkEBaiECIABBA2ohAAwBCwsLPAEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAoAgA7AQAgA0EBaiEDIAJBAmohAiAAQQRqIQAMAQsLCzwBAX8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAAKAIAOgAAIANBAWohAyACQQFqIQIgAEEEaiEADAELCwsGACAAEBILBgAgACQACxAAIwAgAGtBcHEiACQAIAALBAAjAAsjACAAPwBBEHRrQf//A2pBEHZAAEF/RgRAQQAPC0EAEABBAQs7AQF/IAIEQANAIAAgASACQfwDIAJB/ANJGyIDEAUhACABQfwDaiEBIABB/ANqIQAgAiADayICDQALCwtjAQN/QfDDACEBA0AgASIAQQRqIQEgACgCACICQX9zIAJB//37d2pxQYCBgoR4cUUNAAsgAkH/AXFFBEAgAEHwwwBrDwsDQCAALQABIQIgAEEBaiIBIQAgAg0ACyABQfDDAGsLqQEBA38CQCACKAIQIgQEfyAEBSACEIQBDQEgAigCEAsgAigCFCIFayABSQRAIAIgACABIAIoAiQRAgAaDwsCQCACLABLQQBIDQAgASEEA0AgBCIDRQ0BIAAgA0F/aiIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIANJDQEgASADayEBIAAgA2ohACACKAIUIQULIAUgACABEAUaIAIgAigCFCABajYCFAsLWQEBfyAAIAAtAEoiAUF/aiABcjoASiAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALVAEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAtAAIgAC0AAEEQdHIgAC0AAUEIdHJBgICAeHI2AgAgA0EBaiEDIAJBBGohAiAAQQNqIQAMAQsLC5oBAAJAIAFBgAFOBEAgAEMAAAB/lCEAIAFB/wFIBEAgAUGBf2ohAQwCCyAAQwAAAH+UIQAgAUH9AiABQf0CSBtBgn5qIQEMAQsgAUGBf0oNACAAQwAAgACUIQAgAUGDfkoEQCABQf4AaiEBDAELIABDAACAAJQhACABQYZ9IAFBhn1KG0H8AWohAQsgACABQRd0QYCAgPwDar6UC9kDAgJ/An4jAEEgayICJAACQCABQv///////////wCDIgVCgICAgICAwP9DfCAFQoCAgICAgMCAvH98VARAIAFCBIYgAEI8iIQhBCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCEEDAILIARCgICAgICAgIBAfSEEIABCgICAgICAgIAIhUIAUg0BIARCAYMgBHwhBAwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQQMAQtCgICAgICAgPj/ACEEIAVC////////v//DAFYNAEIAIQQgBUIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qEIkBIAIgACAEQYH4ACADaxCIASACKQMIQgSGIAIpAwAiAEI8iIQhBCACKQMQIAIpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIARCAXwhBAwBCyAAQoCAgICAgICACIVCAFINACAEQgGDIAR8IQQLIAJBIGokACAEIAFCgICAgICAgICAf4OEvwtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAu8AQEBfyABQQBHIQICQAJAAkACQCABRSAAQQNxRXINAANAIAAtAABFDQIgAEEBaiEAIAFBf2oiAUEARyECIAFFDQEgAEEDcQ0ACwsgAkUNAQsgAC0AAEUNAQJAIAFBBE8EQANAIAAoAgAiAkF/cyACQf/9+3dqcUGAgYKEeHENAiAAQQRqIQAgAUF8aiIBQQNLDQALCyABRQ0BCwNAIAAtAABFDQIgAEEBaiEAIAFBf2oiAQ0ACwtBAA8LIAALXgEBfkEAIQIgAUEAIAFBAEobIQEDQCABIAJHBEAgACAAKQMAIgNCgID8/4+AQIMgA0IgiEL//wODhCADQiCGQoCAgIDw/z+DhDcDACACQQFqIQIgAEEIaiEADAELCwszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQBRogACAAKAIUIAFqNgIUIAILNQAgAFBFBEADQCABQX9qIgEgAKdBD3FBoMkAai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABC1cBAX9BACECIAFBACABQQBKGyEDA0AgAiADRwRAIAAgACgCACIBQYD+g3hxIAFBEHZB/wFxciABQRB0QYCA/AdxcjYCACACQQFqIQIgAEEEaiEADAELCwvrAgEDfyMAQdABayIDJAAgAyACNgLMAUEAIQIgA0GgAWpBAEEoEBsgAyADKALMATYCyAECQEEAIAEgA0HIAWogA0HQAGogA0GgAWoQHEEASARAQX8hAQwBCyAAKAJMQQBOBEBBASECCyAAKAIAIQQgACwASkEATARAIAAgBEFfcTYCAAsgBEEgcSEFAn8gACgCMARAIAAgASADQcgBaiADQdAAaiADQaABahAcDAELIABB0AA2AjAgACADQdAAajYCECAAIAM2AhwgACADNgIUIAAoAiwhBCAAIAM2AiwgACABIANByAFqIANB0ABqIANBoAFqEBwiASAERQ0AGiAAQQBBACAAKAIkEQIAGiAAQQA2AjAgACAENgIsIABBADYCHCAAQQA2AhAgACgCFCEEIABBADYCFCABQX8gBBsLIQEgACAAKAIAIgAgBXI2AgBBfyABIABBIHEbIQEgAkUNAAsgA0HQAWokACABC4sCAAJAIAAEfyABQf8ATQ0BAkBBsNMAKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQcDUAEEZNgIAQX8FQQELDwsgACABOgAAQQELYAECfyMAQRBrIgMkACADIAI2AgwgAyACNgIIQX8hBAJAQQBBACABIAIQLCICQQBIDQAgACACQQFqIgIQBCIANgIAIABFDQAgACACIAEgAygCDBAsIQQLIANBEGokACAECwMAAQtlAQF/IwBBkAJrIgMkAAJ/IABBf0EAIANBEGogAUEWdkH8B3FBoMQAaigCABEBAEUEQCADIAE2AgBB8MQAIAMQE0EADAELIANBEGpBECABQf//A3EgAhAiCyEAIANBkAJqJAAgAAuXAQID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AQEAAAEAQaYOC4oJAQAAAQEBAAABAAAAAAAAAQAAAQEBAAABAAAAAQEAAQEAAAEAAAEAAAEBAAABAQABAQABAQAAAQAAAQABAQAAAAEBAQAAAQEBAAAAAAEBAQAAAQEBAAAAAQEAAAEBAAEBAAABAQAAAQAAAQABAQAAAAEBAAABAQEAAAEAAQEBAQEBAAEAAAAAAAABAAAAAQEAAAABAQEAAAEBAQAAAAABAQEBAAABAQAAAQEAAAEBAAABAQEBAQEAAAAAAAABAAAAAQABAQEAAQEBAAABAAAAAQAAAAEBAQABAQEAAAEBAAABAQACAgECAgICAAAAAQAAAQECAgEBAgICAQAAAAACAAABAgIBAQICAQEAAgICAAACAgAAAQEAAQEBAAAAAAAAAAABAQICAQECAgAAAQEAAAEBAAACAgAAAgIAAAICAAACAgEBAQEBAQEBAAABAQAAAQECAgEBAgIBAQAAAAAAAAAAAQEBAQICAgIAAAAAAQEBAQEBAQECAgICAAAAAAEBAQECAgICAgICAgAAAQIAAAECAAABAgAAAQIAAQECAAEBAgABAQIAAQECAAECAgABAgIAAQICAAECAgAAAQEAAQECAQECAgECAgIAAAEBAgAAAQICAAACAgIAAAAAAQAAAQEAAQECAQECAgABAQEAAAEBAgAAAQICAAAAAAAAAQECAgEBAgIBAQICAAACAgAAAgIAAAICAQEBAQABAQEAAQEBAAICAgACAgIAAAABAAAAAQICAgECAgIBAAAAAAAAAQEAAQICAAECAgAAAAABAQAAAgIBAAICAQAAAQICAAECAgAAAQEAAAAAAAABAgAAAQIBAQICAgICAgABAQABAgIBAQICAQABAQAAAAAAAAEBAAECAgEBAgIBAAACAgEBAAIBAQACAAACAgABAQAAAQEAAgAAAgICAgIAAAEBAAECAgABAgIAAAEBAAAAAAIAAAACAgEBAgICAQAAAAAAAAACAQECAgECAgIAAgICAAACAgAAAQIAAAEBAAABAQAAAQIAAAICAAICAgABAgAAAQIAAAECAAABAgAAAAAAAQEBAQICAgIAAAAAAAECAAECAAECAAECAAECAAABAgACAAECAQIAAQABAgAAAAEBAgIAAAEBAgIAAAEBAAABAQEBAgICAgAAAAABAQABAAEAAQABAgICAgICAgIAAAAAAAAAAAIBAgECAQIBAAACAgEBAgIAAAICAQECAgAAAgIAAAEBAAACAgAAAQEAAgIAAQICAQACAgABAgIBAAEAAQICAgICAgICAAEAAQAAAAACAQIBAgECAQIBAgEAAQABAAEAAQABAAECAgICAAICAgABAQEAAgICAAEBAQAAAAIBAQECAAAAAgEBAQIAAAAAAgEBAgIBAQICAQECAAICAgABAQEAAQEBAAICAgAAAAIBAQECAQEBAgAAAAIAAQEAAAEBAAABAQACAgICAAAAAAAAAAACAQECAgEBAgABAQAAAQEAAgICAgICAgIAAAICAAABAQAAAQEAAAICAAACAgEBAgIBAQICAAACAgBBvBcLiwICAQECAAAAAgAAAAEAAAACAAAAAQACAgIBAgICAAICAgECAgIAAQABAgICAgICAgICAgICAAEBAQIAAQECAgABAgICAA8PDw8PDw8PDw8PDw8PDw8PAggCAggIDwIIAgIICAICDw8GCAIIDw8CCAICAg8PBgYCBggPDwICDw8PDw8CAg8DAw8PCAMPDwgIBgYGBQMDAwMIDwMDBgoFCAgGCAUPDwgPAwUGCggPDwMPBQ8PDw8DDwUFBQgFCgUKCA0PDAMDDwgIAw8PAwgPDw8PDw8PCA8IDwMPCA8IAw8GCg8PCggPAw8KCggJCgYPCA8DBgYIDwMPDw8PDw8PDw8PAw8PCAAAFQArAEAAQdIZCy0JABIAGwAlAC4ANwBAAAAABAAJAA0AEQAVABoAHgAiACYAKwAvADMANwA8AEAAQYAcC5EqAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2RldGV4Q29udmVydFBpeGVsczogVW5hYmxlIHRvIGZpbmQgY29udmVyc2lvbiBwYXRoAFVuYWJsZSB0byBmaW5kIGluLXBsYWNlIGNvbnZlcnNpb24gcGF0aABkZXRleENvbnZlcnRQaXhlbHM6IFRvbyBtYW55IHRlbXBvcmFyeSBidWZmZXJzIG5lZWRlZAAKBwsLCwkICAgGCgsMEAAAAAECCv//Awv//wQM//8FDf//Bv///wf///8I////Cf8AAAAAAwIAAAMCAwIBAQECBAYGBgAAAAYAAAAAAgIAAAMDAgIDAgQCAwMCAgICBAIC/wEBAwMDAgQGBQcFBwcFAAAAAAYIBwUFBwUIBQcIBgAAAAAGCAgGAAAAAAAAAAD9+vfxAgUIDv359vMCBgkM/vv48wEEBwz+/PrzAQMFDP36+PQCBQcL/fn39QIGCAr8+fj1AwYHCv37+PUCBAcK/vr49gEFBwn++/j2AQQHCf78+PYBAwcJ/vv59gEEBgn9/Pn2AgMGCf/+/fYAAQIJ/Pr49wMFBwj9+/n3AgQGCAAAAAAIAAAAEAAAABgAAADg////6P////D////4////AgAAAAgAAAD+////+P///wUAAAARAAAA+////+////8JAAAAHQAAAPf////j////DQAAACoAAADz////1v///xIAAAA8AAAA7v///8T///8YAAAAUAAAAOj///+w////IQAAAGoAAADf////lv///y8AAAC3AAAA0f///0n///8DAAAABgAAAAsAAAAQAAAAFwAAACAAAAApAAAAQAAAAAAAAAAIAAAAAAAAAPj///8AAAAAEQAAAAAAAADv////AAAAAB0AAAAAAAAA4////wAAAAAqAAAAAAAAANb///8AAAAAPAAAAAAA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', imports)}

class Detex {
    static #webAssembly;
    static #HEAPU8;
    static async decode(format, width, height, input, output) {
        switch (format) {
            case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1:
                return this.decodeBC1(width, height, input, output);
            case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3:
                return this.decodeBC2(width, height, input, output);
            case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5:
                return this.decodeBC3(width, height, input, output);
            default:
                console.error('bad texture format in Detex.decode: ' + format);
        }
    }
    static async decodeBC1(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 0.5);
        this.#HEAPU8.set(input, p);
        api.decode_BC1(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC2(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC2(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC3(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC3(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC4(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 0.5);
        this.#HEAPU8.set(input, p);
        api.decode_BC4(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        //console.error('decodeBC7', width, height, resultSize);
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        //const result = new Uint8ClampedArray(resultView);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC7(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC7(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        //console.error('decodeBC7', width, height, resultSize);
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        //const result = new Uint8ClampedArray(resultView);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async getWebAssembly() {
        if (this.#webAssembly) {
            return this.#webAssembly;
        }
        const env = {
            'abortStackOverflow': (_) => { throw new Error('overflow'); },
            'emscripten_notify_memory_growth': (_) => { /*console.error('growth ', this.#webAssembly.instance.exports.memory.buffer.byteLength);*/ this.#initHeap(); },
            'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
            'tableBase': 0,
            'memoryBase': 1024,
            'STACKTOP': 0,
        };
        this.#webAssembly = await detex({ env }); //WebAssembly.instantiateStreaming(fetch('detex.wasm'), {env});
        this.#initHeap();
        return this.#webAssembly;
    }
    static #initHeap() {
        this.#HEAPU8 = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
    }
}

class SourceEngineVTF {
    repository;
    fileName;
    versionMaj = null;
    versionMin = null;
    width = null;
    height = null;
    flags = null;
    frames = null;
    faceCount = 1;
    firstFrame = null;
    reflectivity = null;
    bumpmapScale = null;
    highResImageFormat = null;
    mipmapCount = null;
    lowResImageFormat = null;
    lowResImageWidth = null;
    lowResImageHeight = null;
    depth = null;
    resEntries = [];
    currentFrame = 0;
    filled = false;
    numResources;
    headerSize;
    constructor(repository, fileName) {
        this.repository = repository;
        this.fileName = fileName;
    }
    setVerionMin(value) {
        this.versionMin = value;
    }
    /**
     * TODO
     */
    setFlags(flags) {
        this.flags = flags;
        if (flags & TEXTUREFLAGS_ENVMAP) {
            if (this.isHigherThan74()) {
                this.faceCount = 6;
            }
            else {
                this.faceCount = 7; // WTF ?
            }
        }
    }
    getAlphaBits() {
        if ((this.flags & TEXTUREFLAGS_ONEBITALPHA) == TEXTUREFLAGS_ONEBITALPHA) {
            return 1;
        }
        if ((this.flags & TEXTUREFLAGS_EIGHTBITALPHA) == TEXTUREFLAGS_EIGHTBITALPHA) {
            return 8;
        }
        return 0;
    }
    /**
     * TODO
     */
    setVerionMaj(value) {
        this.versionMaj = value;
    }
    /**
     * TODO
     */
    isHigherThan71() {
        if (this.versionMaj >= 7 && this.versionMin > 1) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan72() {
        if (this.versionMaj >= 7 && this.versionMin > 2) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan73() {
        if (this.versionMaj >= 7 && this.versionMin > 3) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan74() {
        if (this.versionMaj >= 7 && this.versionMin > 4) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    getResource(type) {
        for (let i = 0; i < this.resEntries.length; ++i) {
            let entry = this.resEntries[i];
            if (entry.type == type) {
                return entry;
            }
        }
        return null;
    }
    /**
     * TODO
     */
    getImageDatas(mipmapLvl) {
        let entry = this.getResource(48);
        if (!entry) {
            entry = this.getResource(1);
            if (entry) {
                return entry.imageData;
            }
            else {
                return null;
            }
        }
        return entry.mipMaps[mipmapLvl];
    }
    fillTexture(graphics, glContext, texture, mipmapLvl, frame1 = 0, srgb = true) {
        if (this.flags & TEXTUREFLAGS_ENVMAP) {
            this.#fillCubeMapTexture(graphics, glContext, texture.texture, mipmapLvl, srgb);
        }
        else {
            this.#fillTexture(graphics, glContext, texture, mipmapLvl, frame1, srgb);
        }
    }
    #fillTexture(graphics, glContext, texture, mipmapLvl, frame1 = 0, srgb) {
        if (this.filled && (this.frames == 1)) {
            return;
        }
        if (this.filled) ;
        if (mipmapLvl == undefined) {
            mipmapLvl = this.mipmapCount - 1;
        }
        else {
            mipmapLvl = Math.min(mipmapLvl, this.mipmapCount - 1);
        }
        const face = 0;
        let frame;
        if (isNaN(frame1)) ;
        else {
            this.currentFrame = frame1;
            frame = Math.round(frame1) % this.frames;
            this.currentFrame = frame;
        }
        const res48 = this.getResource(48);
        if (!res48) {
            //TODO: show error
            return;
        }
        const mipmap = res48.mipMaps[mipmapLvl];
        if (!mipmap) {
            //TODO: show error
            return;
        }
        let webGLTexture = texture.texture;
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        glContext.bindTexture(GL_TEXTURE_2D, webGLTexture);
        const clampS = this.flags & TEXTUREFLAGS_CLAMPS;
        const clampT = this.flags & TEXTUREFLAGS_CLAMPT;
        texture.width = mipmap.width;
        texture.height = mipmap.height;
        if (this.isDxtCompressed()) {
            fillTextureDxt(graphics, glContext, webGLTexture, GL_TEXTURE_2D, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][face], clampS, clampT, srgb && this.isSRGB());
        }
        else {
            glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            glContext.texImage2D(GL_TEXTURE_2D, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][face]);
        }
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_2D, null);
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        this.filled = true;
    }
    /**
     * TODO
     */
    #fillCubeMapTexture(graphics, glContext, texture, mipmapLvl, srgb) {
        if (mipmapLvl == undefined) {
            mipmapLvl = this.mipmapCount - 1;
        }
        else {
            mipmapLvl = Math.min(mipmapLvl, this.mipmapCount - 1);
        }
        let frame = 0;
        //TODOv3: removeme
        /*if (delta!=undefined) {
            this.currentFrame += delta / 100.0;
            frame = Math.min(Math.round(this.currentFrame), this.frames-1);
            if (this.currentFrame>this.frames) { // TODO: loop
                this.currentFrame =0;
            }
        }*/
        const res48 = this.getResource(48);
        if (!res48) {
            //TODO: show error
            return;
        }
        const mipmap = res48.mipMaps[mipmapLvl];
        if (!mipmap) {
            //TODO: show error
            return;
        }
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture);
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        const clampS = this.flags & TEXTUREFLAGS_CLAMPS;
        const clampT = this.flags & TEXTUREFLAGS_CLAMPT;
        if (this.isDxtCompressed()) {
            let isSRGB = srgb && this.isSRGB();
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_X, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][0], clampS, clampT, isSRGB);
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][1], clampS, clampT, isSRGB);
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][2], clampS, clampT, isSRGB);
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][3], clampS, clampT, isSRGB);
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][4], clampS, clampT, isSRGB);
            fillTextureDxt(graphics, glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, mipmap.width, mipmap.height, this.highResImageFormat - 12, mipmap.frames[frame][5], clampS, clampT, isSRGB);
        }
        else {
            glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][0]);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][1]);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][2]);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][3]);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][4]);
            glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(glContext), this.getType(glContext), mipmap.frames[frame][5]);
        }
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        this.filled = true;
    }
    /**
     * TODO
     */
    getDxtFormat(s3tc) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_DXT1:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            case IMAGE_FORMAT_DXT3:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            case IMAGE_FORMAT_DXT5:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            /* TODO: check format */
            /*case IMAGE_FORMAT_DXT1_ONEBITALPHA:
                return s3tc.COMPRESSED_RGB_S3TC_DXT1_EXT;*/
        }
        return 0;
    }
    /**
     * TODO
     */
    getFormat(glContext) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGB888:
            case IMAGE_FORMAT_BGR888: // Note: format has been inverted at load time
                return GL_RGB;
            case IMAGE_FORMAT_RGBA8888:
            case IMAGE_FORMAT_BGRA8888: // Note: format has been inverted at load time
            case IMAGE_FORMAT_ABGR8888: // Note: format has been inverted at load time
            case IMAGE_FORMAT_RGBA16161616F: // Note: format has been inverted at load time
                return GL_RGBA;
        }
        return 0;
    }
    /**
     * TODO
     */
    #getInternalFormat(allowSrgb = true) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGB888:
            case IMAGE_FORMAT_BGR888:
                return this.isSRGB() && allowSrgb ? GL_SRGB8 : GL_RGB;
            case IMAGE_FORMAT_RGBA8888:
            case IMAGE_FORMAT_BGRA8888:
            case IMAGE_FORMAT_ABGR8888:
                return this.isSRGB() && allowSrgb ? GL_SRGB8_ALPHA8 : GL_RGBA;
            case IMAGE_FORMAT_RGBA16161616F: // Note: format has been inverted at load time
                return GL_RGBA16F;
        }
        return 0;
    }
    /**
     * TODO
     */
    getType(glContext) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGBA16161616F:
                return GL_FLOAT;
            default:
                return GL_UNSIGNED_BYTE;
        }
    }
    /**
     * Return whether the texture is compressed or not
     * @return {bool} true if texture is dxt compressed
     */
    isDxtCompressed() {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_DXT1:
            case IMAGE_FORMAT_DXT3:
            case IMAGE_FORMAT_DXT5:
                return true;
        }
        return false;
    }
    isSRGB() {
        return ((this.flags & TEXTUREFLAGS_SRGB) == TEXTUREFLAGS_SRGB);
    }
}
const IMAGE_FORMAT_RGBA8888 = 0;
const IMAGE_FORMAT_ABGR8888 = 1;
const IMAGE_FORMAT_RGB888 = 2;
const IMAGE_FORMAT_BGR888 = 3;
const IMAGE_FORMAT_RGB888_BLUESCREEN = 9;
const IMAGE_FORMAT_BGR888_BLUESCREEN = 10;
const IMAGE_FORMAT_BGRA8888 = 12;
const IMAGE_FORMAT_DXT1 = 13;
const IMAGE_FORMAT_DXT3 = 14;
const IMAGE_FORMAT_DXT5 = 15;
const IMAGE_FORMAT_RGBA16161616F = 24;
function fillTextureDxt(graphics, glContext, texture, target, width, height, dxtLevel, datas, clampS, clampT, srgb) {
    const s3tc = graphics.getExtension('WEBGL_compressed_texture_s3tc');
    const s3tcSRGB = graphics.getExtension('WEBGL_compressed_texture_s3tc_srgb');
    glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    //glContext.bindTexture(target, texture);
    if (s3tc) {
        let dxtFormat = 0;
        switch (dxtLevel) {
            case 1:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                break;
            case 2:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                break;
            case 3:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                break;
        }
        glContext.compressedTexImage2D(target, 0, dxtFormat, width, height, 0, datas);
    }
    else {
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        let uncompressedData = new Uint8Array(width * height * 4);
        let decompressFunc = null;
        switch (dxtLevel) {
            case 1:
                decompressFunc = 'decodeBC1';
                break;
            case 2:
                decompressFunc = 'decodeBC2';
                break;
            case 3:
                decompressFunc = 'decodeBC3';
                break;
        }
        if (decompressFunc) {
            Detex[decompressFunc](width, height, datas, uncompressedData).then(() => {
                glContext.bindTexture(GL_TEXTURE_2D, texture);
                glContext.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                glContext.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        /*const dxtflag = dxtLevel == 1 ? (1 << 0) : (1 << 2);
        let uncompressedData;
        if (datas.uncompressedData) {
            uncompressedData = datas.uncompressedData;
        } else {
            uncompressedData = decompress(datas, width, height, dxtflag);
            datas.uncompressedData = uncompressedData;
        }
        glContext.texImage2D(target, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData);//TODO: params*/
    }
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, clampS ? glContext.CLAMP_TO_EDGE : glContext.REPEAT);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, clampT ? glContext.CLAMP_TO_EDGE : glContext.REPEAT);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
    //glContext.bindTexture(glContext.TEXTURE_2D, null);
    glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
}

const MAX_IMAGES_PER_FRAME_ON_DISK = 4;
const MAX_IMAGES_PER_FRAME_IN_MEMORY = 2;
const SEQUENCE_SAMPLE_COUNT = 1024;
class SequenceSampleTextureCoords_t {
    m_fLeft_U0 = 0;
    m_fTop_V0 = 0;
    m_fRight_U0 = 0;
    m_fBottom_V0 = 0;
    m_fLeft_U1 = 0;
    m_fTop_V1 = 0;
    m_fRight_U1 = 0;
    m_fBottom_V1 = 0;
}
class SheetSequenceSample_t {
    m_fBlendFactor = 0;
    m_TextureCoordData = [];
    constructor() {
        for (let i = 0; i < MAX_IMAGES_PER_FRAME_IN_MEMORY; ++i) {
            this.m_TextureCoordData[i] = new SequenceSampleTextureCoords_t();
        }
    }
}
function GetInterpolationData(pKnotPositions, pKnotValues, nNumValuesinList, nInterpolationRange, flPositionToInterpolateAt, bWrap) {
    // first, find the bracketting knots by looking for the first knot >= our index
    let result = Object.create(null);
    let idx;
    for (idx = 0; idx < nNumValuesinList; idx++) {
        if (pKnotPositions[idx] >= flPositionToInterpolateAt) {
            break;
        }
    }
    let nKnot1, nKnot2;
    let flOffsetFromStartOfGap, flSizeOfGap;
    if (idx == 0) {
        if (bWrap) {
            nKnot1 = Math.max(nNumValuesinList - 1, 0);
            nKnot2 = 0;
            flSizeOfGap =
                (pKnotPositions[nKnot2] + (nInterpolationRange - pKnotPositions[nKnot1]));
            flOffsetFromStartOfGap =
                flPositionToInterpolateAt + (nInterpolationRange - pKnotPositions[nKnot1]);
        }
        else {
            result.pValueA = result.pValueB = pKnotValues[0];
            result.pInterpolationValue = 1.0;
            return result;
        }
    }
    else if (idx == nNumValuesinList) { // ran out of values
        if (bWrap) {
            nKnot1 = nNumValuesinList - 1;
            nKnot2 = 0;
            flSizeOfGap = (pKnotPositions[nKnot2] +
                (nInterpolationRange - pKnotPositions[nKnot1]));
            flOffsetFromStartOfGap = flPositionToInterpolateAt - pKnotPositions[nKnot1];
        }
        else {
            result.pValueA = result.pValueB = pKnotValues[nNumValuesinList - 1];
            result.pInterpolationValue = 1.0;
            return result;
        }
    }
    else {
        nKnot1 = idx - 1;
        nKnot2 = idx;
        flSizeOfGap = pKnotPositions[nKnot2] - pKnotPositions[nKnot1];
        flOffsetFromStartOfGap = flPositionToInterpolateAt - pKnotPositions[nKnot1];
    }
    function FLerp(f1, f2, i1, i2, x) {
        return f1 + (f2 - f1) * (x - i1) / (i2 - i1);
    }
    result.pValueA = pKnotValues[nKnot1];
    result.pValueB = pKnotValues[nKnot2];
    result.pInterpolationValue = FLerp(0, 1, 0, flSizeOfGap, flOffsetFromStartOfGap);
    return result;
}

class SourceEngineVTFLoader extends SourceBinaryLoader {
    parse(repository, fileName, arrayBuffer) {
        let vtf = new SourceEngineVTF(repository, fileName);
        try {
            let reader = new BinaryReader(arrayBuffer);
            this.#parseHeader(reader, vtf);
            if (vtf.isHigherThan72()) {
                for (let i = 0; i < vtf.numResources; ++i) {
                    vtf.resEntries.push({ type: reader.getUint32(), resData: reader.getUint32() });
                }
            }
            else {
                if (vtf.lowResImageFormat == -1) {
                    vtf.resEntries.push({ type: 48, resData: vtf.headerSize });
                }
                else {
                    vtf.resEntries.push({ type: 1, resData: vtf.headerSize });
                    if (vtf.lowResImageWidth == 0 && vtf.lowResImageHeight == 0) {
                        vtf.resEntries.push({ type: 48, resData: vtf.headerSize });
                    }
                    else {
                        vtf.resEntries.push({ type: 48, resData: vtf.headerSize + Math.max(2, vtf.lowResImageWidth * vtf.lowResImageHeight * 0.5) }); // 0.5 bytes per pixel
                    }
                }
            }
            if (vtf.isHigherThan72()) {
                reader.seek(vtf.headerSize);
            }
            this.#parseResEntries(reader, vtf);
        }
        catch (err) {
            return null;
        }
        return vtf;
    }
    #parseHeader(reader, vtf) {
        reader.seek(4); //skip first 4 char TODO: check == 'VTF\0' ?
        vtf.setVerionMaj(reader.getUint32());
        vtf.setVerionMin(reader.getUint32());
        vtf.headerSize = reader.getUint32();
        vtf.width = reader.getUint16();
        vtf.height = reader.getUint16();
        vtf.setFlags(reader.getUint32());
        vtf.frames = reader.getUint16();
        vtf.firstFrame = reader.getUint16();
        reader.seek(reader.tell() + 4); //padding
        vtf.reflectivity = reader.getVector3();
        reader.seek(reader.tell() + 4); //padding
        vtf.bumpmapScale = reader.getFloat32();
        vtf.highResImageFormat = reader.getInt32();
        vtf.mipmapCount = reader.getUint8();
        vtf.lowResImageFormat = reader.getInt32();
        vtf.lowResImageWidth = reader.getUint8();
        vtf.lowResImageHeight = reader.getUint8();
        if (vtf.isHigherThan71()) {
            vtf.depth = reader.getUint16();
        }
        if (vtf.isHigherThan72()) {
            reader.seek(reader.tell() + 3); //padding
            vtf.numResources = reader.getUint32();
            reader.seek(reader.tell() + 8); //padding
        }
    }
    #parseResEntries(reader, vtf) {
        reader.tell();
        for (let resIndex = 0; resIndex < vtf.resEntries.length; ++resIndex) {
            this.#parseResEntry(reader, vtf, vtf.resEntries[resIndex]);
        }
    }
    #parseResEntry(reader, vtf, entry) {
        switch (entry.type) {
            case 1: // Low-res image data
                //TODO
                break;
            case 48: // Image data
                //TODO
                if (vtf.mipmapCount > 0) {
                    this.#parseImageData(reader, vtf, entry);
                }
                else {
                    console.error('vtf.mipmapCount == 0');
                }
                break;
            case 16: // sheet
                this.#parseSheet(reader, vtf, entry);
                break;
        }
    }
    #parseImageData(reader, vtf, entry) {
        reader.seek(entry.resData);
        let mipmapWidth = vtf.width * Math.pow(0.5, vtf.mipmapCount - 1);
        let mipmapHeight = vtf.height * Math.pow(0.5, vtf.mipmapCount - 1);
        entry.mipMaps = [];
        for (let mipmapIndex = 0; mipmapIndex < vtf.mipmapCount; ++mipmapIndex) {
            this.#parseMipMap(reader, vtf, entry, mipmapIndex, mipmapWidth, mipmapHeight);
            mipmapWidth *= 2;
            mipmapHeight *= 2;
        }
    }
    #parseSheet(reader, vtf, entry) {
        reader.seek(entry.resData);
        const sheet = Object.create(null);
        vtf.sheet = sheet;
        sheet.length = reader.getUint32();
        let nVersion = reader.getUint32();
        let nNumCoordsPerFrame = (nVersion) ? MAX_IMAGES_PER_FRAME_ON_DISK : 1;
        let nNumSequences = reader.getUint32();
        sheet.sequences = [];
        if (sheet.format == 0) ;
        //for (let groupIndex=0; groupIndex < sheet.groupsCount; ++groupIndex) {
        while (nNumSequences--) {
            const group = Object.create(null);
            group.duration = 0;
            group.m_pSamples = [];
            group.m_pSamples2 = [];
            sheet.sequences.push(group);
            reader.getUint32();
            group.clamp = reader.getUint32() != 0;
            group.frameCount = reader.getUint32();
            let bSingleFrameSequence = (group.frameCount == 1);
            let nTimeSamples = bSingleFrameSequence ? 1 : SEQUENCE_SAMPLE_COUNT;
            //let m_pSample = [];
            //sheet.m_pSamples[nSequenceNumber] = m_pSample;
            for (let i = 0; i < nTimeSamples; i++) {
                group.m_pSamples[i] = new SheetSequenceSample_t();
            }
            let Samples = [];
            for (let i = 0; i < SEQUENCE_SAMPLE_COUNT; i++) {
                Samples[i] = new SheetSequenceSample_t();
            }
            //group.frames = [];
            let fTotalSequenceTime = reader.getFloat32();
            let InterpKnot = new Float32Array(SEQUENCE_SAMPLE_COUNT);
            let InterpValue = new Float32Array(SEQUENCE_SAMPLE_COUNT);
            let fCurTime = 0.;
            for (let frameIndex = 0; frameIndex < group.frameCount; ++frameIndex) {
                const frameSample = new SheetSequenceSample_t();
                group.m_pSamples2.push(frameSample);
                //const frame = Object.create(null);
                //group.frames.push(frame);
                //frame.values = [];
                //frame.duration = reader.getFloat32();
                let fThisDuration = reader.getFloat32();
                InterpValue[frameIndex] = frameIndex;
                InterpKnot[frameIndex] = SEQUENCE_SAMPLE_COUNT * (fCurTime / fTotalSequenceTime);
                fCurTime += fThisDuration;
                group.duration += fThisDuration; //frame.duration;
                /*for (let i = 0; i < valuesCount; ++i) {
                    frame.values.push(reader.getFloat32());
                }*/
                let seq = Samples[frameIndex];
                for (let nImage = 0; nImage < nNumCoordsPerFrame; nImage++) {
                    let s = seq.m_TextureCoordData[nImage];
                    let s2 = frameSample.m_TextureCoordData[nImage];
                    if (s) {
                        s.m_fLeft_U0 = reader.getFloat32();
                        s.m_fTop_V0 = reader.getFloat32();
                        s.m_fRight_U0 = reader.getFloat32();
                        s.m_fBottom_V0 = reader.getFloat32();
                        if (s2) {
                            s2.m_fLeft_U0 = s.m_fLeft_U0;
                            s2.m_fTop_V0 = s.m_fTop_V0;
                            s2.m_fRight_U0 = s.m_fRight_U0;
                            s2.m_fBottom_V0 = s.m_fBottom_V0;
                        }
                    }
                    else {
                        //drop it ?
                        reader.getFloat32();
                        reader.getFloat32();
                        reader.getFloat32();
                        reader.getFloat32();
                    }
                }
            }
            group.duration += fCurTime;
            // now, fill in the whole table
            for (let nIdx = 0; nIdx < nTimeSamples; ++nIdx) {
                //float flIdxA, flIdxB, flInterp;
                let result = GetInterpolationData(InterpKnot, InterpValue, group.frameCount, SEQUENCE_SAMPLE_COUNT, nIdx, !group.clamp /*,
                                &flIdxA, &flIdxB, &flInterp */);
                let sA = Samples[result.pValueA];
                let sB = Samples[result.pValueB];
                let oseq = group.m_pSamples[nIdx];
                oseq.m_fBlendFactor = result.pInterpolationValue;
                for (let nImage = 0; nImage < MAX_IMAGES_PER_FRAME_IN_MEMORY; nImage++) {
                    let src0 = sA.m_TextureCoordData[nImage];
                    let src1 = sB.m_TextureCoordData[nImage];
                    let o = oseq.m_TextureCoordData[nImage];
                    o.m_fLeft_U0 = src0.m_fLeft_U0;
                    o.m_fTop_V0 = src0.m_fTop_V0;
                    o.m_fRight_U0 = src0.m_fRight_U0;
                    o.m_fBottom_V0 = src0.m_fBottom_V0;
                    o.m_fLeft_U1 = src1.m_fLeft_U0;
                    o.m_fTop_V1 = src1.m_fTop_V0;
                    o.m_fRight_U1 = src1.m_fRight_U0;
                    o.m_fBottom_V1 = src1.m_fBottom_V0;
                }
            }
        }
    }
    #parseMipMap(reader, vtf, entry, mipmaplvl, mipmapWidth, mipmapHeight) {
        //TODO: frame face, zlice
        let startingByte = reader.tell();
        // Mipmap minimum size is 1*1 px
        mipmapWidth = Math.max(1.0, vtf.width * Math.pow(0.5, vtf.mipmapCount - mipmaplvl - 1));
        mipmapHeight = Math.max(1.0, vtf.height * Math.pow(0.5, vtf.mipmapCount - mipmaplvl - 1));
        const mipmap = { width: mipmapWidth, height: mipmapHeight, frames: [] };
        entry.mipMaps.push(mipmap);
        let faceIndex;
        let face;
        for (let frameIndex = 0; frameIndex < vtf.frames; ++frameIndex) {
            let frame = [];
            mipmap.frames.push(frame);
            for (faceIndex = 0; faceIndex < vtf.faceCount; faceIndex++) {
                if (vtf.faceCount == 1) {
                    face = [];
                }
                else {
                    face = [];
                }
                face = frame;
                let entrySize;
                let s;
                switch (vtf.highResImageFormat) {
                    case IMAGE_FORMAT_ABGR8888: //1
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        face.push(str2abABGR(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGB888_BLUESCREEN:
                    case IMAGE_FORMAT_BGR888_BLUESCREEN:
                        entrySize = mipmapWidth * mipmapHeight * 2; // 2 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGB888:
                        entrySize = mipmapWidth * mipmapHeight * 3; // 3 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_BGR888:
                        entrySize = mipmapWidth * mipmapHeight * 3; // 3 byte per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abBGR(s));
                        break;
                    case IMAGE_FORMAT_RGBA8888:
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_BGRA8888:
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abBGRA(s));
                        break;
                    case IMAGE_FORMAT_DXT1:
                        entrySize = Math.max(mipmapWidth * mipmapHeight * 0.5, 8); // 0.5 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_DXT3:
                        entrySize = Math.max(mipmapWidth * mipmapHeight, 16); // 1 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_DXT5:
                        entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGBA16161616F:
                        entrySize = mipmapWidth * mipmapHeight * 8; // 8 bytes per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abRGBA16F(s));
                        break;
                }
            }
        }
    }
}
function str2abRGBA16F(str) {
    let len = str.length / 2;
    const buf = new ArrayBuffer(str.length * 2);
    const bufView = new Float32Array(buf);
    let j;
    for (let i = 0; i < len; ++i) {
        j = i * 2;
        bufView[i] = float16(str.charCodeAt(j + 0), str.charCodeAt(j + 1)); //(str.charCodeAt(i+0) + str.charCodeAt(i+1)*256);
    }
    return bufView;
}
function float16(byte1, byte2) {
    const b = new Uint8Array([byte1, byte2]);
    let sign = b[1] >> 7;
    let exponent = ((b[1] & 0x7C) >> 2);
    let mantissa = ((b[1] & 0x03) << 8) | b[0];
    if (exponent == 0) {
        return (sign ? -1 : 1) * TWO_POW_MINUS_14 * (mantissa / TWO_POW_10);
    }
    else if (exponent == 0x1F) {
        return mantissa ? NaN : ((sign ? -1 : 1) * Infinity);
    }
    return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + (mantissa / TWO_POW_10));
}
function str2ab(reader, start, length) {
    return new Uint8Array(reader.buffer.slice(start, start + length));
}
function str2abBGR(str) {
    // assume str.length is divisible by 3
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 3) {
        bufView[i] = str.charCodeAt(i + 2);
        bufView[i + 1] = str.charCodeAt(i + 1);
        bufView[i + 2] = str.charCodeAt(i);
    }
    return bufView;
}
function str2abBGRA(str) {
    // assume str.length is divisible by 4
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 4) {
        bufView[i] = str.charCodeAt(i + 2);
        bufView[i + 1] = str.charCodeAt(i + 1);
        bufView[i + 2] = str.charCodeAt(i);
        bufView[i + 3] = str.charCodeAt(i + 3);
    }
    return bufView;
}
/*
function str2abABGR(reader, start, length) {
// assume str.length is divisible by 4
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 4) {
        bufView[i	] = str.charCodeAt(i+3);
        bufView[i+1] = str.charCodeAt(i+2);
        bufView[i+2] = str.charCodeAt(i+1);
        bufView[i+3] = str.charCodeAt(i	);
    }
    return bufView;
}*/
function str2abABGR(reader, start, length) {
    let arr = new Uint8Array(reader.buffer.slice(start, start + length));
    for (let i = 0; i < length; i += 4) {
        let a = arr[i];
        arr[i] = arr[i + 3];
        arr[i + 1] = arr[i + 2];
        arr[i + 2] = arr[i + 1];
        arr[i + 3] = a;
    }
    return arr;
}

class AnimatedTexture extends Texture {
    frames = [];
    addFrame(frame, texture) {
        this.frames[frame] = texture;
        texture.addUser(this);
    }
    getFrame(frame) {
        frame = frame % this.frames.length;
        return this.frames[frame]; //TODOv3 handle missing textures
    }
    hasOnlyUser(user) {
        if (!super.hasOnlyUser(user)) {
            return false;
        }
        for (const frame of this.frames) {
            if (!frame.hasOnlyUser(this)) {
                return false;
            }
        }
        return true;
    }
    dispose() {
        if (this.hasNoUser()) {
            // Check if frames have other users
            for (const frame of this.frames) {
                if (!frame.hasOnlyUser(this)) {
                    return;
                }
            }
            super.dispose();
            this.frames.forEach(frame => frame.removeUser(this));
        }
    }
}

let internalTextureId = 0;
class Source1TextureManagerClass extends EventTarget {
    #texturesList = new Map();
    #defaultTexture;
    #defaultTextureCube;
    fallbackRepository;
    constructor() {
        super();
        new Graphics().ready.then(() => {
            this.#defaultTexture = TextureManager.createCheckerTexture([127, 190, 255]);
            this.#defaultTextureCube = TextureManager.createCheckerTexture([127, 190, 255], undefined, undefined, true);
            this.#defaultTexture.addUser(this);
            this.#defaultTextureCube.addUser(this);
        });
        setInterval(() => this.#cleanup(), TEXTURE_CLEANUP_DELAY);
    }
    getTexture(repository, path, frame, needCubeMap = false, srgb = true) {
        frame = Math.floor(frame);
        let animatedTexture = this.#getTexture(repository, path, needCubeMap, srgb);
        return (animatedTexture.getFrame ? animatedTexture.getFrame(frame) : animatedTexture) ?? (needCubeMap ? this.#defaultTextureCube : this.#defaultTexture);
    }
    #getTexture(repository, path, needCubeMap, srgb = true) {
        path = path.replace(/.vtf$/, '');
        path = path.replace(/.psd/, '');
        path = path.toLowerCase();
        if (this.#texturesList.has(path)) { //Internal texture
            return this.#texturesList.get(path);
        }
        let pathWithMaterials = 'materials/' + path + '.vtf'; //TODOv3
        let fullPath = repository + pathWithMaterials;
        if (!this.#texturesList.has(fullPath)) {
            let animatedTexture = new AnimatedTexture(); //TODOv3: merge with TextureManager.createTexture(); below
            this.setTexture(fullPath, animatedTexture);
            new SourceEngineVTFLoader().load(repository, pathWithMaterials).then((vtf) => vtfToTexture(vtf, animatedTexture, srgb)).catch(() => {
                let fallbackTexture = this.#getTexture(this.fallbackRepository, path, needCubeMap);
                if (fallbackTexture) {
                    //TODO: dispose of  the previous animatedTexture
                    this.setTexture(fullPath, fallbackTexture);
                }
            });
        }
        return this.#texturesList.get(fullPath);
    }
    async getTextureAsync(repository, path, frame, needCubeMap, defaultTexture, srgb = true) {
        frame = Math.floor(frame);
        path = path.replace(/.vtf$/, '');
        path = path.replace(/.psd/, '');
        path = path.toLowerCase();
        if (this.#texturesList.has(path)) { //Internal texture
            return this.#texturesList.get(path); //.getFrame(frame);//TODOv3: add frame back
        }
        let pathWithMaterials = 'materials/' + path + '.vtf'; //TODOv3
        let fullPath = repository + pathWithMaterials;
        if (!this.#texturesList.has(fullPath)) {
            let animatedTexture = new AnimatedTexture(); //TODOv3: merge with TextureManager.createTexture(); below
            this.setTexture(fullPath, animatedTexture);
            let vtf = await new SourceEngineVTFLoader().load(repository, pathWithMaterials);
            if (vtf) {
                vtfToTexture(vtf, animatedTexture, srgb);
            }
            else {
                this.removeTexture(fullPath);
                return null;
            }
        }
        return this.#texturesList.get(fullPath)?.getFrame(frame) ?? defaultTexture ?? (needCubeMap ? this.#defaultTextureCube : this.#defaultTexture); //TODOv3
    }
    getInternalTextureName() {
        return 'source1texturemanager_' + (++internalTextureId);
    }
    addInternalTexture(texture) {
        let textureName = this.getInternalTextureName();
        texture = texture ?? TextureManager.createTexture(); //TODOv3: add params + create animated texture
        this.setTexture(textureName, texture);
        return { name: textureName, texture: texture };
    }
    setTexture(path, texture) {
        texture.addUser(this);
        this.#texturesList.set(path, texture);
    }
    removeTexture(path) {
        if (this.#texturesList.has(path)) {
            this.#texturesList.get(path).removeUser(this);
            this.#texturesList.delete(path);
        }
    }
    #cleanup() {
        for (const [texturePath, texture] of this.#texturesList) {
            if (texture.hasOnlyUser(this)) {
                texture.removeUser(this);
                this.#texturesList.delete(texturePath);
            }
        }
    }
}
const Source1TextureManager = new Source1TextureManagerClass();
function vtfToTexture(vtf, animatedTexture, srgb) {
    const alphaBits = vtf.getAlphaBits();
    animatedTexture.vtf = vtf;
    animatedTexture.setAlphaBits(alphaBits);
    let glContext = new Graphics().glContext;
    for (let frameIndex = 0; frameIndex < vtf.frames; frameIndex++) {
        let texture = TextureManager.createTexture(); //TODOv3: add params
        texture.properties.set('vtf', vtf);
        texture.setAlphaBits(alphaBits);
        const currentMipMap = vtf.mipmapCount; //TODOv3: choose mipmap
        vtf.fillTexture(new Graphics(), glContext, texture, currentMipMap, frameIndex, srgb);
        animatedTexture.addFrame(frameIndex, texture);
    }
}

const IDENTITY_MAT4$3 = create$5();
function GetTextureTransform(str, mat = create$5()) {
    const center = fromValues(0.5, 0.5);
    //const mat = mat4.create();
    const temp = create$5();
    const centerResult = /center *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    const scaleResult = /scale *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    const rotateResult = /rotate *(\d*(?:\.\d)?)/.exec(str);
    const translateResult = /translate *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    if (centerResult) {
        set$1(center, Number(centerResult[1]), Number(centerResult[2]));
        MatrixBuildTranslation(mat, -center[0], -center[1], 0.0);
    }
    if (scaleResult) {
        MatrixBuildScale(temp, scaleResult[1], scaleResult[2], 1.0);
        mul$5(mat, temp, mat);
    }
    if (rotateResult) {
        identity$2(temp);
        rotateZ$3(temp, temp, DEG_TO_RAD * Number(rotateResult[1]));
        mul$5(mat, temp, mat);
    }
    MatrixBuildTranslation(temp, center[0], center[1], 0.0);
    mul$5(mat, temp, mat);
    if (translateResult) {
        MatrixBuildTranslation(temp, translateResult[1], translateResult[2], 0.0);
        mul$5(mat, temp, mat);
    }
    return mat;
}
const SHADER_PARAM_TYPE_INTEGER = 1;
const SHADER_PARAM_TYPE_COLOR = 2;
const SHADER_PARAM_TYPE_VEC2 = 3;
const SHADER_PARAM_TYPE_FLOAT = 7;
const SHADER_PARAM_TYPE_BOOL = 8;
const SHADER_PARAM_TYPE_STRING = 12;
const VMT_PARAMETERS = {
    $alpha: [SHADER_PARAM_TYPE_FLOAT, 1.0],
    $color: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $color2: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $envmaptint: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $phong: [SHADER_PARAM_TYPE_BOOL, 0],
    $phongalbedotint: [SHADER_PARAM_TYPE_BOOL, false],
    $phongexponent: [SHADER_PARAM_TYPE_FLOAT, 5.0],
    $phongexponentfactor: [SHADER_PARAM_TYPE_FLOAT, 0.0],
    $phongexponenttexture: [SHADER_PARAM_TYPE_STRING, ''],
    $phongboost: [SHADER_PARAM_TYPE_FLOAT, 1.0],
    $lightwarptexture: [SHADER_PARAM_TYPE_STRING, ''],
    $selfillumtint: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $detailscale: [SHADER_PARAM_TYPE_VEC2, [1, 1]],
    $detailblendmode: [SHADER_PARAM_TYPE_INTEGER, 0],
    $no_draw: [SHADER_PARAM_TYPE_BOOL, false],
};
function initDefaultParameters(defaultParameters, parameters, variables) {
    if (defaultParameters) {
        for (let parameterName in defaultParameters) {
            if (parameters[parameterName] === undefined) {
                let defaultParam = defaultParameters[parameterName];
                //variables.set(parameterName, defaultParam[1]);
                switch (defaultParam[0]) {
                    case SHADER_PARAM_TYPE_COLOR:
                        variables.set(parameterName, clone$4(defaultParam[1]));
                        break;
                    default:
                        variables.set(parameterName, defaultParam[1]);
                        break;
                }
            }
        }
    }
}
let defaultTexture;
function getDefaultTexture() {
    if (!defaultTexture) {
        defaultTexture = TextureManager.createCheckerTexture();
        defaultTexture.addUser(SourceEngineMaterial);
    }
    return defaultTexture;
}
class SourceEngineMaterial extends Material {
    #detailTextureTransform = create$5();
    //static #defaultTexture;
    repository;
    fileName;
    proxyParams;
    proxies;
    variables;
    numFrames;
    frameX;
    frameY;
    sequenceLength;
    constructor(params = {} /*repository, fileName, parameters = Object.create(null)*/) {
        super(params);
        this.repository = params.repository;
        this.fileName = params.filename;
        this.proxyParams = {};
        this.proxies = [];
        this.variables = new Map();
        this.#initUniforms();
        let variables = this.variables;
        initDefaultParameters(VMT_PARAMETERS, params, variables);
        initDefaultParameters(this.getDefaultParameters(), params, variables);
        let readParameters = (parameters) => {
            for (let parameterName in parameters) {
                const value = parameters[parameterName];
                let sanitized = this.sanitizeValue(parameterName, value);
                if (sanitized) {
                    this.variables.set(parameterName, sanitized);
                }
                else if ((typeof value) == 'string') {
                    //try a single number
                    let n = Number(value);
                    if (!Number.isNaN(n)) {
                        this.variables.set(parameterName, n);
                    }
                    else {
                        const color = readColor(value);
                        if (color) {
                            this.variables.set(parameterName, color);
                        }
                        else {
                            const v2 = readVec2(value);
                            if (v2) {
                                this.variables.set(parameterName, v2);
                            }
                            else {
                                if (isNaN(Number(value))) {
                                    this.variables.set(parameterName, value);
                                }
                                else {
                                    this.variables.set(parameterName, Number(value));
                                }
                            }
                        }
                    }
                }
                else {
                    this.variables.set(parameterName, value);
                }
            }
        };
        readParameters(params);
        if (params['>=dx90']) {
            readParameters(params['>=dx90']);
        }
        let baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            this.setColorMap(Source1TextureManager.getTexture(this.repository, baseTexture, params['$frame'] || 0, false, params.useSrgb ?? true));
        }
        else {
            this.setColorMap(getDefaultTexture());
        }
        if (params['$bumpmap']) {
            this.setNormalMap(Source1TextureManager.getTexture(this.repository, params['$bumpmap'], 0, false, false));
        }
        else {
            this.setNormalMap(null);
        }
        let translucent = false;
        if (params['$alpha']) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
        }
        if (params['$vertexalpha'] == 1) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
            //TODOv3 activate proper define in shader
            //also add vertexcolor
        }
        if (params['$translucent'] == 1) {
            this.setBlending(MATERIAL_BLENDING_NORMAL);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
        }
        if (params['$additive'] == 1) {
            if (translucent) {
                this.setBlending(MATERIAL_BLENDING_ADDITIVE);
            }
            else {
                this.setBlending(MATERIAL_BLENDING_ADDITIVE, true);
            }
            this.setDefine('IS_ADDITIVE');
        }
        if (params['$alphatest'] == 1) {
            this.alphaTest = true;
            this.alphaTestReference = Number.parseFloat(params['$alphatestreference'] ?? 0.5);
        }
        if (params['$vertexalpha'] == 1) {
            this.setDefine('VERTEX_ALPHA');
        }
        if (params['$vertexcolor'] == 1) {
            this.setDefine('VERTEX_COLOR');
        }
        let envmaptint = variables.get('$envmaptint');
        if (envmaptint) {
            this.uniforms['uCubeMapTint'] = envmaptint;
        }
        else {
            this.uniforms['uCubeMapTint'] = fromValues$4(1.0, 1.0, 1.0);
        }
        if (variables.get('$normalmapalphaenvmapmask') == 1) {
            this.setDefine('USE_NORMAL_ALPHA_AS_ENVMAP_MASK');
        }
        if (variables.get('$no_draw')) {
            this.setDefine('NO_DRAW');
        }
        this.uniforms['uTextureTransform'] = IDENTITY_MAT4$3;
        if (params['$basetexturetransform']) {
            let textureTransform = GetTextureTransform(params['$basetexturetransform']);
            if (textureTransform) {
                this.variables.set('$basetexturetransform', textureTransform);
                this.uniforms['uTextureTransform'] = textureTransform;
            }
        }
        if (params['$nocull'] == 1) {
            this.renderFace(RenderFace.Both);
        }
        let lightWarpTexture = params['$lightwarptexture'];
        this.setTexture('lightWarpMap', lightWarpTexture ? Source1TextureManager.getTexture(this.repository, lightWarpTexture, 0) : null, 'USE_LIGHT_WARP_MAP');
        if (params['$phong'] == 1) {
            this.setDefine('USE_PHONG_SHADING');
            // The $phongexponenttexture is overrided by $phongexponent
            let phongExponentTexture = params['$phongexponenttexture'];
            this.setTexture('phongExponentMap', phongExponentTexture ? Source1TextureManager.getTexture(this.repository, phongExponentTexture, 0) : null, 'USE_PHONG_EXPONENT_MAP');
            if (phongExponentTexture) {
                this.uniforms['uPhongExponentFactor'] = variables.get('$phongexponentfactor');
            }
            this.uniforms['uPhongExponent'] = variables.get('$phongexponent');
            this.uniforms['uPhongBoost'] = variables.get('$phongboost');
            if (params['$basemapalphaphongmask'] == 1) {
                this.setDefine('USE_COLOR_ALPHA_AS_PHONG_MASK');
            }
            if (params['$phongalbedotint'] == 1) {
                this.setDefine('USE_PHONG_ALBEDO_TINT');
            }
            /*VertexLitGeneric
            {
                $phong 1

                $bumpmap				[texture]
                $phongexponent			5			// either/or
                $phongexponenttexture	[texture]	// either/or
                $phongboost				1.0
                $phongfresnelranges		"[0 0.5 1]"
                basemapalphaphongmask
            }*/
        }
        if (variables.get('$selfillum') == 1) {
            this.setDefine('USE_SELF_ILLUM');
            if (variables.get('$selfillum_envmapmask_alpha') == 1) {
                this.setDefine('USE_SELF_ILLUM_ENVMAPMASK_ALPHA');
            }
            let selfIllumTint = variables.get('$selfillumtint');
            if (selfIllumTint) {
                this.uniforms['uSelfIllumTint'] = selfIllumTint;
            }
            else {
                this.uniforms['uSelfIllumTint'] = fromValues$4(1.0, 1.0, 1.0);
            }
            let selfIllumMask = variables.get('$selfillummask');
            this.setTexture('uSelfIllumMaskMap', selfIllumMask ? Source1TextureManager.getTexture(this.repository, selfIllumMask, 0) : null, 'USE_SELF_ILLUM_MASK_MAP');
            if (variables.get('$selfillumfresnel') == 1) {
                this.setDefine('USE_SELF_ILLUM_FRESNEL');
                let selfIllumFresnelMinMaxExp = variables.get('$selfillumfresnelminmaxexp') ?? fromValues$4(0.0, 1.0, 1.0);
                let constScaleBiasExp = fromValues$3(1.0, 0.0, 1.0, 0.0);
                let flMin = selfIllumFresnelMinMaxExp[0];
                let flMax = selfIllumFresnelMinMaxExp[1];
                let flExp = selfIllumFresnelMinMaxExp[2];
                constScaleBiasExp[1] = (flMax != 0.0) ? (flMin / flMax) : 0.0; // Bias
                constScaleBiasExp[0] = 1.0 - constScaleBiasExp[1]; // Scale
                constScaleBiasExp[2] = flExp; // Exp
                constScaleBiasExp[3] = flMax; // Brightness
                this.uniforms['uSelfIllumScaleBiasExpBrightness'] = constScaleBiasExp;
            }
            /*
                        $selfillum
                        selfIllumFresnelMinMaxExp
                        selfillumtint
                        selfIllumFresnel
                        selfillummask
                        selfillum_envmapmask_alpha
                        selfillumtexture
                        selfillummaskscale
                        */
        }
        const ssbump = this.variables.get('$ssbump');
        if (ssbump == 1) {
            this.setDefine('USE_SSBUMP');
        }
        else {
            this.removeDefine('USE_SSBUMP');
        }
        const proxies = params['proxies'];
        if (proxies) {
            this.initProxies(proxies);
        }
        //this.blend = true;
        //this.blendFuncSource = GL_SRC_ALPHA;
        //this.blendFuncDestination = GL_ONE_MINUS_SRC_ALPHA;
        //this.blendFuncDestination = GL_ONE;
        //TODO: $ignorez
    }
    #initUniforms() {
        this.uniforms['uDetailTextureTransform'] = this.#detailTextureTransform;
    }
    setNumFrames(frames, frameX, frameY, sequenceLength) {
        this.numFrames = frames;
        this.frameX = frameX;
        this.frameY = frameY;
        this.sequenceLength = sequenceLength;
    }
    getTexCoords(flCreationTime, flCurTime, flAgeScale, nSequence) {
        const texture = this.uniforms['colorMap'];
        if (!texture) {
            return;
        }
        const vtf = texture.properties.get('vtf');
        const sheet = vtf?.sheet;
        if (sheet) {
            //SETextureControler.getAnimSheet('materials/' + this.baseTexture);
            if (sheet) {
                let group = sheet.sequences[nSequence];
                if (!group) { // In case sequence # is outside VTF range
                    group = sheet.sequences[0];
                }
                if (group) {
                    if (group.frameCount == 1) {
                        return group.m_pSamples[0];
                    }
                    let flAge = flCurTime - flCreationTime;
                    flAge *= flAgeScale;
                    let nFrame = Math.abs(Math.round(flAge));
                    if (group.clamp) {
                        nFrame = Math.min(nFrame, SEQUENCE_SAMPLE_COUNT - 1);
                    }
                    else {
                        nFrame &= SEQUENCE_SAMPLE_COUNT - 1;
                    }
                    return group.m_pSamples[nFrame];
                }
            }
        }
        return null;
    }
    getFrameSpan(sequence) {
        const texture = this.uniforms['colorMap'];
        if (!texture) {
            return;
        }
        const vtf = texture.properties.get('vtf');
        const sheet = vtf?.sheet;
        if (sheet) {
            //const sheet = texture.vtf.sheet;//SETextureControler.getAnimSheet('materials/' + this.baseTexture);
            if (sheet) {
                let group = sheet.sequences[sequence];
                if (!group) {
                    group = sheet.sequences[0];
                }
                if (group) {
                    return group.duration;
                }
            }
        }
        return null;
    }
    /**
     * Init proxies
     * @param proxies {Array} List of proxies
     */
    initProxies(proxies) {
        if (!proxies) {
            return;
        }
        for (let proxyIndex in proxies) {
            if (proxies.hasOwnProperty(proxyIndex)) {
                const proxyName = proxyIndex.replace(/#\d+$/, '');
                const proxy = ProxyManager.getProxy(proxyName);
                if (proxy) {
                    proxy.setParams(proxies[proxyIndex], this.variables);
                    this.proxies.push(proxy);
                }
            }
        }
    }
    updateMaterial(time, mesh) {
        this.processProxies(time, mesh.materialsParams);
    }
    /**
     * Process proxies
     * @param proxyParams {Object} Param passed to proxies
     */
    processProxies(time, proxyParams = {}) {
        let proxies = this.proxies;
        for (let proxyIndex = 0, l = proxies.length; proxyIndex < l; ++proxyIndex) {
            proxies[proxyIndex].execute(this.variables, proxyParams, time);
        }
        this._afterProcessProxies(proxyParams);
        this.afterProcessProxies(proxyParams);
    }
    _afterProcessProxies(proxyParams) {
        let variables = this.variables;
        let parameters = this.parameters;
        let baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            const texture = Source1TextureManager.getTexture(this.repository, baseTexture, parameters['$frame'] || variables.get('$frame') || 0);
            this.setColorMap(texture);
            // Disable self illum if texture doesn't have alpha channel (fix for D-eye-monds)
            this.setDefine('COLOR_MAP_ALPHA_BITS', texture?.getAlphaBits() ?? 0);
        }
        let normalMap = variables.get('$bumpmap') ?? variables.get('$normalmap');
        if (normalMap) {
            this.setNormalMap(Source1TextureManager.getTexture(this.repository, normalMap, 0));
        }
        else {
            this.setNormalMap(null);
        }
        let envmap = variables.get('$envmap');
        if (envmap) {
            if (envmap == 'env_cubemap') {
                envmap = 'editor/cubemap'; //TODO: set default cubmap as a constant
            }
            this.setCubeMap(Source1TextureManager.getTexture(this.repository, envmap, 0, true));
        }
        let baseTextureTransform = variables.get('$basetexturetransform');
        if (baseTextureTransform) {
            this.uniforms['uTextureTransform'] = baseTextureTransform;
            this.setDefine('USE_TEXTURE_TRANSFORM');
        }
        //TODO: remove this
        let phongExponentTexture = variables.get('$phongexponenttexture');
        if (phongExponentTexture) {
            this.setTexture('phongExponentMap', Source1TextureManager.getTexture(this.repository, phongExponentTexture, 0), 'USE_PHONG_EXPONENT_MAP');
        }
        let lightWarpTexture = parameters['$lightwarptexture'];
        this.setTexture('lightWarpMap', lightWarpTexture ? Source1TextureManager.getTexture(this.repository, lightWarpTexture, 0) : null, 'USE_LIGHT_WARP_MAP');
        if (variables.get('$selfillum') == 1) {
            let selfIllumTint = variables.get('$selfillumtint');
            if (selfIllumTint) {
                this.uniforms['uSelfIllumTint'] = selfIllumTint;
            }
            let selfIllumMask = variables.get('$selfillummask');
            if (selfIllumMask) {
                this.setTexture('uSelfIllumMaskMap', Source1TextureManager.getTexture(this.repository, selfIllumMask, 0));
            }
        }
        const detailTexture = variables.get('$detail');
        if (detailTexture) {
            this.setDetailMap(Source1TextureManager.getTexture(this.repository, detailTexture, variables.get('$detailframe') ?? 0));
            const detailTextureTransform = variables.get('$detailtexturetransform');
            if (detailTextureTransform) {
                let textureTransform = GetTextureTransform(detailTextureTransform, this.#detailTextureTransform);
                if (textureTransform) {
                    this.variables.set('$detailtexturetransform', textureTransform);
                }
            }
            else {
                const detailScale = variables.get('$detailscale');
                if (detailScale) {
                    MatrixBuildScale(this.#detailTextureTransform, detailScale[0], detailScale[1], 1.0);
                    this.setDefine('USE_DETAIL_TEXTURE_TRANSFORM');
                    /*let textureTransform = GetTextureTransform(parameters['$basetexturetransform']);
                    if (textureTransform) {
                        this.variables.set('$basetexturetransform', textureTransform);
                        this.uniforms['uTextureTransform'] = textureTransform;
                    }*/
                }
                else {
                    this.removeDefine('USE_DETAIL_TEXTURE_TRANSFORM');
                }
            }
            this.setDefine('DETAIL_BLEND_MODE', variables.get('$detailblendmode') ?? 0);
            this.uniforms['uDetailBlendFactor'] = variables.get('$detailblendfactor') ?? 0;
        }
    }
    afterProcessProxies(proxyParams) {
    }
    getAlpha() {
        return clamp(this.variables.get('$alpha'), 0.0, 1.0);
    }
    computeModulationColor(out) {
        let color = this.variables.get('$color'); //TODOv3: check variable type
        let color2 = this.variables.get('$color2'); //TODOv3: check variable type
        if (color2) {
            out[0] = color[0] * color2[0];
            out[1] = color[1] * color2[1];
            out[2] = color[2] * color2[2];
            out[3] = this.getAlpha();
        }
        else {
            out[0] = color[0];
            out[1] = color[1];
            out[2] = color[2];
            out[3] = this.getAlpha();
        }
        return out;
    }
    getDefaultParameters() {
        return {};
    }
    sanitizeValue(parameterName, value) {
        let param = VMT_PARAMETERS[parameterName] ?? this.getDefaultParameters()[parameterName];
        if (param) {
            switch (param[0]) {
                case SHADER_PARAM_TYPE_COLOR:
                    return readColor(value);
                case SHADER_PARAM_TYPE_FLOAT:
                    let fl = Number(value);
                    if (!Number.isNaN(fl)) {
                        return fl;
                    }
                    const c = readColor(value);
                    if (c) {
                        return c[0];
                    }
                    return param[1];
                case SHADER_PARAM_TYPE_INTEGER:
                    return Number(value) << 0;
                case SHADER_PARAM_TYPE_BOOL:
                    return Number(value);
                case SHADER_PARAM_TYPE_STRING:
                    return value;
                case SHADER_PARAM_TYPE_VEC2:
                    return readVec2(value);
            }
        }
        return null;
    }
    setKeyValue(key, value) {
        let sanitized = this.sanitizeValue(key, value);
        if (sanitized) {
            this.variables.set(key, sanitized);
        }
        else {
            this.variables.set(key, value);
        }
    }
}
//TODO: store regexes
function readColor(value, color) {
    color = color || create$4();
    // With { } : color values in 0-255 range
    value = value.trim();
    let regex = /\{ *(\d*) *(\d*) *(\d*) *(\d*)* *\}/i;
    let result = regex.exec(value);
    if (result) {
        set$5(color, Number(result[1]) / 255.0, Number(result[2]) / 255.0, Number(result[3]) / 255.0);
        return color;
    }
    // With [] : color values in 0.0-1.0 range
    regex = /\[ *(\d*(\.\d*)?) *(\d*(\.\d*)?) *(\d*(\.\d*)?) *\]/i;
    result = regex.exec(value);
    if (result) {
        set$5(color, Number(result[1]), Number(result[3]), Number(result[5]));
        return color;
    }
    // With nothing : color values in 0.0-1.0 range
    regex = /^ *(\d*(\.\d*)?) *(\d*(\.\d*)?) *(\d*(\.\d*)?) *$/i;
    result = regex.exec(value);
    if (result) {
        set$5(color, Number(result[1]), Number(result[3]), Number(result[5]));
        return color;
    }
    //try a single number
    let n = Number(value);
    if (!Number.isNaN(n)) {
        set$5(color, n, n, n);
        return color;
    }
    return null;
}
function readVec2(value, vec) {
    vec = vec || create();
    let regex = /\[ *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *\]/i;
    let result = regex.exec(value);
    if (result) {
        return set$1(vec, Number(result[1]), Number(result[3]));
    }
    const f = Number.parseFloat(value);
    if (Number.isNaN(f)) {
        return;
    }
    return set$1(vec, f, f);
}
/*

enum MaterialVarFlags_t
{
    MATERIAL_VAR_DEBUG					  = (1 << 0),
    MATERIAL_VAR_NO_DEBUG_OVERRIDE		  = (1 << 1),
    MATERIAL_VAR_NO_DRAW				  = (1 << 2),
    MATERIAL_VAR_USE_IN_FILLRATE_MODE	  = (1 << 3),

    MATERIAL_VAR_VERTEXCOLOR			  = (1 << 4),
    MATERIAL_VAR_VERTEXALPHA			  = (1 << 5),
    MATERIAL_VAR_SELFILLUM				  = (1 << 6),
    MATERIAL_VAR_ADDITIVE				  = (1 << 7),
    MATERIAL_VAR_ALPHATEST				  = (1 << 8),
    MATERIAL_VAR_MULTIPASS				  = (1 << 9),
    MATERIAL_VAR_ZNEARER				  = (1 << 10),
    MATERIAL_VAR_MODEL					  = (1 << 11),
    MATERIAL_VAR_FLAT					  = (1 << 12),
    MATERIAL_VAR_NOCULL					  = (1 << 13),
    MATERIAL_VAR_NOFOG					  = (1 << 14),
    MATERIAL_VAR_IGNOREZ				  = (1 << 15),
    MATERIAL_VAR_DECAL					  = (1 << 16),
    MATERIAL_VAR_ENVMAPSPHERE			  = (1 << 17),
    MATERIAL_VAR_NOALPHAMOD				  = (1 << 18),
    MATERIAL_VAR_ENVMAPCAMERASPACE	      = (1 << 19),
    MATERIAL_VAR_BASEALPHAENVMAPMASK	  = (1 << 20),
    MATERIAL_VAR_TRANSLUCENT              = (1 << 21),
    MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
    MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING  = (1 << 23),
    MATERIAL_VAR_OPAQUETEXTURE			  = (1 << 24),
    MATERIAL_VAR_ENVMAPMODE				  = (1 << 25),
    MATERIAL_VAR_SUPPRESS_DECALS		  = (1 << 26),
    MATERIAL_VAR_HALFLAMBERT			  = (1 << 27),
    MATERIAL_VAR_WIREFRAME                = (1 << 28),
    MATERIAL_VAR_ALLOWALPHATOCOVERAGE     = (1 << 29),
    MATERIAL_VAR_IGNORE_ALPHA_MODULATION  = (1 << 30),

    // NOTE: Only add flags here that either should be read from
    // .vmts or can be set directly from client code. Other, internal
    // flags should to into the flag enum in imaterialinternal.h
};
*/
/*
static const char* s_pShaderStateString[] =
{
    "$debug",
    "$no_fullbright",
    "$no_draw",
    "$use_in_fillrate_mode",

    "$vertexcolor",
    "$vertexalpha",
    "$selfillum",
    "$additive",
    "$alphatest",
    "$multipass",
    "$znearer",
    "$model",
    "$flat",
    "$nocull",
    "$nofog",
    "$ignorez",
    "$decal",
    "$envmapsphere",
    "$noalphamod",
    "$envmapcameraspace",
    "$basealphaenvmapmask",
    "$translucent",
    "$normalmapalphaenvmapmask",
    "$softwareskin",
    "$opaquetexture",
    "$envmapmode",
    "$nodecal",
    "$halflambert",
    "$wireframe",
    "$allowalphatocoverage",

    ""			// last one must be null
};
*/

//TODO: deprecate
class CharacterMaterial extends SourceEngineMaterial {
    diffuseModulation = fromValues$3(1.0, 1.0, 1.0, 1.0);
    constructor(params = {}) {
        super(params);
        this.setValues(params);
        let variables = this.variables;
        //"$masks1"                   models/weapons/v_models/arms/glove_bloodhound/glove_bloodhound_masks1
        //"$masks2"                   models/weapons/v_models/arms/glove_bloodhound/glove_bloodhound_masks2
        let masks1Texture = variables.get('$masks1');
        if (masks1Texture) {
            this.uniforms['mask1Map'] = Source1TextureManager.getTexture(this.repository, masks1Texture, 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        else {
            this.removeDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        let masks2Texture = variables.get('$masks2');
        if (masks2Texture) {
            this.uniforms['mask2Map'] = Source1TextureManager.getTexture(this.repository, masks2Texture, 0);
            this.setDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        else {
            this.removeDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        //this.uniforms['phongfresnelranges'] = SourceEngineMaterial.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = fromValues$3(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba && btbba == 1) {
            this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
            this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = create$4();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams) {
        let variables = this.variables;
        let parameters = this.parameters;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = fromValues$3(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = fromValues$3(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            let sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        let masks1Texture = variables.get('$masks1');
        if (masks1Texture) {
            this.uniforms['mask1Map'] = Source1TextureManager.getTexture(this.repository, masks1Texture, 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        let masks2Texture = variables.get('$masks2');
        if (masks2Texture) {
            this.uniforms['mask2Map'] = Source1TextureManager.getTexture(this.repository, masks2Texture, 0);
            this.setDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.diffuseModulation);
    }
    clone() {
        return new CharacterMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_character'; //TODO: setup proper shader
    }
}
SourceEngineVMTLoader.registerMaterial('character', CharacterMaterial);

const DEFAULT_WEAR_PROGRESS = 0.0; //0.45;
//TODO: deprecate
class CustomWeaponMaterial extends SourceEngineMaterial {
    diffuseModulation = fromValues$3(1.0, 1.0, 1.0, 1.0);
    constructor(params = {}) {
        super(params);
        this.setValues(params);
        //this.uniforms['phongfresnelranges'] = SourceEngineMaterial.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = fromValues$3(1, 0, 1, 0); //TODOv3
        this.uniforms['g_PreviewPhongBoosts'] = fromValues$3(1, 1, 1, 1);
        this.uniforms['g_DiffuseModulation'] = this.diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba && btbba == 1) {
            this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
            this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = create$4();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams) {
        let variables = this.variables;
        let parameters = this.parameters;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = fromValues$3(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = fromValues$3(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$maskstexture']) {
            this.uniforms['mask1Map'] = Source1TextureManager.getTexture(this.repository, parameters['$maskstexture'], 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$pattern']) {
            this.uniforms['patternMap'] = Source1TextureManager.getTexture(this.repository, parameters['$pattern'], 0);
            this.setDefine('USE_PATTERN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$aotexture']) {
            this.uniforms['aoMap'] = Source1TextureManager.getTexture(this.repository, parameters['$aotexture'], 0);
            this.setDefine('USE_AO_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$weartexture']) {
            this.uniforms['scratchesMap'] = Source1TextureManager.getTexture(this.repository, parameters['$weartexture'], 0);
            this.setDefine('USE_SCRATCHES_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$grungetexture']) {
            this.uniforms['grungeMap'] = Source1TextureManager.getTexture(this.repository, parameters['$grungetexture'], 0);
            this.setDefine('USE_GRUNGE_MAP'); //TODOv3: set this automaticaly
        }
        let expTexture = parameters['$exptexture'];
        if (expTexture) {
            this.uniforms['exponentMap'] = Source1TextureManager.getTexture(this.repository, expTexture, 0);
            this.setDefine('USE_EXPONENT_MAP'); //TODOv3: set this automaticaly
        }
        let surfaceTexture = parameters['$surfacetexture'];
        if (surfaceTexture) {
            this.uniforms['surfaceMap'] = Source1TextureManager.getTexture(this.repository, surfaceTexture, 0);
            this.setDefine('USE_SURFACE_MAP'); //TODOv3: set this automaticaly
        }
        let posTexture = parameters['$postexture'];
        if (posTexture) {
            this.uniforms['posMap'] = Source1TextureManager.getTexture(this.repository, posTexture, 0);
            this.setDefine('USE_POS_MAP'); //TODOv3: set this automaticaly
        }
        /*

                    if( bAOTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER0, true );		// [sRGB] Ambient Occlusion
                    }
                    if( bWearTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER1, true );		// Scratches
                    }
                    if( bExpTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER2, true );		// Exponent
                    }
                    if ( bBaseTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER3, true );		// [sRGB] Base
                    }
                    if( bMasksTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER4, true );		// Masks
                    }
                    if( bGrungeTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER5, true );		// [sRGB] Grunge
                    }
                    if( bSurfaceTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER6, true );		// Obj-space normal and cavity
                    }
                    if( bPosTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER7, true );		// High-precision Position
                    }
                    if( bPaintTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER8, true );		// Paint
                    }	*/
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            let sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        let wearProgress = proxyParams['WearProgress'] ?? 0;
        if (wearProgress !== undefined) {
            this.uniforms['uWearProgress'] = wearProgress;
        }
        else {
            this.uniforms['uWearProgress'] = DEFAULT_WEAR_PROGRESS;
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.diffuseModulation);
    }
    set style(style) {
        this.setDefine('PAINT_STYLE', style);
    }
    setColorUniform(uniformName, value) {
        let color = readColor(value);
        if (color) {
            //vec3.scale(color, color, 1 / 255.0);
            this.uniforms[uniformName] = color;
        }
    }
    set color0(color) {
        this.setColorUniform('uCamoColor0', color);
    }
    set color1(color) {
        this.setColorUniform('uCamoColor1', color);
    }
    set color2(color) {
        this.setColorUniform('uCamoColor2', color);
    }
    set color3(color) {
        this.setColorUniform('uCamoColor3', color);
    }
    /*
        setUniformTransform(uniformName, scale, translation, rotation) {
            let transformMatrix = this.getTexCoordTransform(scale, translation, rotation);
            this.uniforms[uniformName] = new Float32Array([
                                                            transformMatrix[0], transformMatrix[4], transformMatrix[8], transformMatrix[12],
                                                            transformMatrix[1], transformMatrix[5], transformMatrix[9], transformMatrix[13]
                                                            ]);
        }

        setPatternTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_patternTexCoordTransform[0]', scale, translation, rotation);
        }

        setWearTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_wearTexCoordTransform[0]', scale, translation, rotation);
        }

        setGrungeTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_grungeTexCoordTransform[0]', scale, translation, rotation);
        }
    */
    setPatternScale(scale) {
        this.uniforms['g_PreviewPhongBoosts'][2] = scale;
    }
    /*

        "name": "aa_vertigo",
        "desc": "#PaintKit_aa_vertigo",
        "rarity": "mythical",
        "pattern": "vertigo",
        "wear_default": "0.150000",
        "style": "6",
        "color0": "102 92 85",
        "color1": "16 16 16",
        "color2": "16 16 16",
        "color3": "16 16 16",
        "pattern_scale": "1.400000",
        "pattern_offset_x_start": "0.040000",
        "pattern_offset_x_end": "0.140000",
        "pattern_offset_y_start": "-0.440000",
        "pattern_offset_y_end": "-0.180000",
        "pattern_rotate_start": "7",
        "pattern_rotate_end": "25",
        "wear_remap_min": "0.000000",
        "wear_remap_max": "0.080000",
        "phongexponent": "32",
        "phongalbedoboost": "80"
        */
    clone() {
        return new CustomWeaponMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_customweapon';
    }
}
SourceEngineVMTLoader.registerMaterial('customweapon', CustomWeaponMaterial);

create$4();
class EyeRefractMaterial extends SourceEngineMaterial {
    #eyeOrigin = create$4();
    #eyeForward = create$4();
    #eyeUp = create$4();
    #eyeRight = create$4();
    #irisProjectionU = create$3();
    #irisProjectionV = create$3();
    constructor(params = {}) {
        params.useSrgb = false;
        super(params);
        this.setValues(params);
        //this.uniforms['phongfresnelranges'] = SourceEngineMaterial.readColor(parameters['$phongfresnelranges']);
        if (params['$iris']) {
            this.setColorMap(Source1TextureManager.getTexture(this.repository, params['$iris'], params['$frame'] || 0));
        }
        else {
            this.setColorMap(TextureManager.createCheckerTexture());
        }
    }
    afterProcessProxies() {
        this.variables;
        let parameters = this.parameters;
        if (parameters['$iris']) {
            this.setColorMap(Source1TextureManager.getTexture(this.repository, parameters['$iris'], parameters['$frame'] || 0));
        }
        if (parameters['$corneatexture']) {
            this.setTexture('corneaMap', Source1TextureManager.getTexture(this.repository, parameters['$corneatexture'], 0));
        }
        /*
        const eyeballArray = this.properties.get('eyeballArray');
        const skeleton = this.properties.get('skeleton');
        if (eyeballArray && skeleton) {//TODOv3: do this only once
            let eyeBall = eyeballArray[this.properties.get('materialParam')];
            if (eyeBall) {
                let bone = skeleton._bones[eyeBall.bone];
                if (bone) {
                    bone.getWorldPosOffset(eyeBall.org, this.#eyeOrigin);
                    this.uniforms['u#eyeOrigin'] = this.#eyeOrigin;
                }
            }
        }
        */
    }
    beforeRender(camera) {
        const eyeballArray = this.properties.get('eyeballArray');
        const skeleton = this.properties.get('skeleton');
        if (eyeballArray && skeleton) { //TODOv3: do this only once
            let eyeBall = eyeballArray[this.properties.get('materialParam')];
            if (eyeBall) {
                let bone = skeleton._bones[eyeBall.bone];
                if (bone) {
                    bone.getWorldPosOffset(eyeBall.org, this.#eyeOrigin);
                    transformQuat$1(this.#eyeUp, eyeBall.up, bone.worldQuat);
                    sub$2(this.#eyeForward, camera.position, this.#eyeOrigin);
                    cross$2(this.#eyeRight, this.#eyeForward, this.#eyeUp);
                    normalize$5(this.#eyeRight, this.#eyeRight);
                    scaleAndAdd$2(this.#eyeForward, this.#eyeForward, this.#eyeRight, eyeBall.zoffset);
                    normalize$5(this.#eyeForward, this.#eyeForward);
                    cross$2(this.#eyeRight, this.#eyeForward, this.#eyeUp); //TODOv3: fix this bullshit
                    normalize$5(this.#eyeRight, this.#eyeRight);
                    cross$2(this.#eyeUp, this.#eyeRight, this.#eyeForward); //TODOv3: fix this bullshit
                    normalize$5(this.#eyeUp, this.#eyeUp);
                    let scale = eyeBall.irisScale; //(1 / eyeBall.irisScale);TODOv3
                    scale$5(this.#irisProjectionU, this.#eyeRight, -scale);
                    scale$5(this.#irisProjectionV, this.#eyeUp, -scale);
                    this.#irisProjectionU[3] = -dot$4(this.#eyeOrigin, this.#irisProjectionU) + 0.5;
                    this.#irisProjectionV[3] = -dot$4(this.#eyeOrigin, this.#irisProjectionV) + 0.5;
                    this.uniforms['uIrisProjectionU'] = this.#irisProjectionU;
                    this.uniforms['uIrisProjectionV'] = this.#irisProjectionV;
                    this.uniforms['uEyeOrigin'] = this.#eyeOrigin;
                }
            }
        }
    }
    clone() {
        return new EyeRefractMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_eyerefract';
    }
}
SourceEngineVMTLoader.registerMaterial('eyerefract', EyeRefractMaterial);

class LightMappedGenericMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
        this.setValues(params);
    }
    clone() {
        return new LightMappedGenericMaterial(this.parameters);
    }
    getShaderSource() {
        return 'source1_lightmappedgeneric';
    }
}
SourceEngineVMTLoader.registerMaterial('lightmappedgeneric', LightMappedGenericMaterial);

class RefractMaterial extends SourceEngineMaterial {
    clone() {
        return new RefractMaterial(this.parameters);
    }
    getShaderSource() {
        return 'source1_refract';
    }
}
SourceEngineVMTLoader.registerMaterial('refract', RefractMaterial);

class SpriteCardMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        if (params['$color']) {
            params.useSrgb = false;
        }
        super(params);
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.colorMask[3] = 0.0;
        this.setDefine('IS_TRANSLUCENT');
        this.setDefine('IS_SPRITE_CARD_MATERIAL');
        this.setDefine('USE_PARTICLE_YAW', '0'); //This material never yaw
        if ( /*bAdditive2ndTexture || bAddOverBlend || */params['$addself'] !== undefined) {
            this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        else {
            if (params['$additive'] == 1) {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            }
            else {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            }
        }
        // this material always has blending
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        if (params['$additive'] == 1) ;
        /*if (parameters['$addself']) {
            this.setDefine('ALPHA_TEST', false);
        } else {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = Number.parseFloat(parameters['$alphatestreference'] || 0.5);
        }*/
        if (params['$addself'] !== undefined) {
            this.uniforms['uAddSelf'] = Number.parseFloat(params['$addself']);
            this.setDefine('ADD_SELF');
            //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        let overbrightFactor = this.variables.get('$overbrightfactor') ?? this.variables.get('srgb?$overbrightfactor'); //TODO: improve this
        this.uniforms['uOverbrightFactor'] = overbrightFactor ?? 1.0;
        //this.modeRGB = GL_MAX;
        this.modeAlpha = GL_MAX;
    }
    clone() {
        return new SpriteCardMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_spritecard';
    }
}
SourceEngineVMTLoader.registerMaterial('spritecard', SpriteCardMaterial);

var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["Normal"] = 0] = "Normal";
    RenderMode[RenderMode["TransColor"] = 1] = "TransColor";
    RenderMode[RenderMode["TransTexture"] = 2] = "TransTexture";
    RenderMode[RenderMode["Glow"] = 3] = "Glow";
    RenderMode[RenderMode["TransAlpha"] = 4] = "TransAlpha";
    RenderMode[RenderMode["TransAdd"] = 5] = "TransAdd";
    RenderMode[RenderMode["Environmental"] = 6] = "Environmental";
    RenderMode[RenderMode["TransAddFrameBlend"] = 7] = "TransAddFrameBlend";
    RenderMode[RenderMode["TransAlphaAdd"] = 8] = "TransAlphaAdd";
    RenderMode[RenderMode["WorldGlow"] = 9] = "WorldGlow";
    RenderMode[RenderMode["None"] = 10] = "None";
})(RenderMode || (RenderMode = {}));
class SpriteMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.colorMask[3] = 0.0;
        this.setDefine('IS_TRANSLUCENT');
        if ( /*bAdditive2ndTexture || bAddOverBlend || */params['$addself'] !== undefined) {
            this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        else {
            if (params['$additive'] == 1) {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            }
            else {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            }
        }
        switch (Number(params['$spriterendermode'])) {
            //TODO: add other modes
            case RenderMode.TransAdd:
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
        }
        // this material always has blending
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        if (params['$additive'] == 1) ;
        /*if (parameters['$addself']) {
            this.setDefine('ALPHA_TEST', false);
        } else {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = Number.parseFloat(parameters['$alphatestreference'] || 0.5);
        }*/
        if (params['$addself'] !== undefined) {
            this.uniforms['uAddSelf'] = Number.parseFloat(params['$addself']);
            this.setDefine('ADD_SELF');
            //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        let overbrightFactor = this.variables.get('$overbrightfactor') ?? this.variables.get('srgb?$overbrightfactor'); //TODO: improve this
        this.uniforms['uOverbrightFactor'] = overbrightFactor ?? 1.0;
        //this.modeRGB = GL_MAX;
        this.modeAlpha = GL_MAX;
    }
    clone() {
        return new SpriteMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_sprite';
    }
}
SourceEngineVMTLoader.registerMaterial('sprite', SpriteMaterial);

class UnlitGenericMaterial extends SourceEngineMaterial {
    diffuseModulation = fromValues$3(1.0, 1.0, 1.0, 1.0);
    constructor(params = {}) {
        super(params);
        this.setValues(params);
        this.uniforms['g_ShaderControls'] = fromValues$3(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.diffuseModulation;
        if (params['$additive'] == 1) {
            //this.setBlending('additive');
            this.setBlending(MATERIAL_BLENDING_ADDITIVE);
        }
    }
    clone() {
        return new UnlitGenericMaterial(this.parameters);
    }
    get shaderSource() {
        //Note: this is vertexlitgeneric without lighting
        return 'source1_unlitgeneric';
    }
}
SourceEngineVMTLoader.registerMaterial('unlitgeneric', UnlitGenericMaterial);

const IDENTITY_MATRIX = create$5();
class UnlitTwoTextureMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
        if (params['$texture2']) {
            this.setColor2Map(Source1TextureManager.getTexture(this.repository, params['$texture2'], params['$frame2'] || 0));
        }
        else {
            this.setColor2Map(TextureManager.createCheckerTexture());
        }
        this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        if (params['$additive'] == 1) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            //this.setBlending('additive');
        }
        this.modeAlpha = GL_MAX;
        this.uniforms['uTextureTransform'] = IDENTITY_MATRIX;
        this.uniforms['uTexture2Transform'] = IDENTITY_MATRIX;
        this.setDefine('USE_TEXTURE_TRANSFORM');
        this.setDefine('USE_TEXTURE2_TRANSFORM');
    }
    clone() {
        return new UnlitTwoTextureMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_unlittwotexture';
    }
    afterProcessProxies() {
        let variables = this.variables;
        let parameters = this.parameters;
        const texture2Transform = variables.get('$texture2transform');
        if (texture2Transform) {
            this.uniforms['uTexture2Transform'] = texture2Transform;
        }
        {
            if (parameters['$texture2']) {
                this.setColor2Map(Source1TextureManager.getTexture(this.repository, parameters['$texture2'], parameters['$frame2'] || variables.get('$frame2') || 0));
            }
        }
    }
}
SourceEngineVMTLoader.registerMaterial('unlittwotexture', UnlitTwoTextureMaterial);

class VertexLitGenericMaterial extends SourceEngineMaterial {
    diffuseModulation = fromValues$3(1.0, 1.0, 1.0, 1.0);
    constructor(params = {}) {
        params.useSrgb = false;
        super(params /*repository, fileName, parameters*/);
        this.setValues(params);
        //this.uniforms['phongfresnelranges'] = SourceEngineMaterial.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = fromValues$3(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba == 1) {
            this.alphaTest = false;
            this.variables.set('$alphatest', 0);
            if (this.variables.get('$selfillum') != 1) {
                this.removeDefine('USE_SELF_ILLUM');
                this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
                this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
                // TODO : properly set these variables
                this.variables.set('$translucent', 0);
                this.removeDefine('ALPHA_TEST');
                this.setBlending(MATERIAL_BLENDING_NONE);
                this.removeDefine('IS_TRANSLUCENT');
                if (this.variables.get('$additive') == 1) {
                    this.setBlending(MATERIAL_BLENDING_ADDITIVE, true);
                }
            }
            //TODO end
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = create$4();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams) {
        let variables = this.variables;
        let parameters = this.parameters;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.setTexture('sheenMaskMap', Source1TextureManager.getTexture(this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame), 'USE_SHEEN_MASK_MAP');
            this.uniforms['g_vPackedConst6'] = fromValues$3(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = fromValues$3(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.setTexture('sheenMap', Source1TextureManager.getTexture(this.repository, parameters['$sheenmap'], 0, true), 'USE_SHEEN_MAP');
        }
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            let sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.diffuseModulation);
    }
    clone() {
        return new VertexLitGenericMaterial(/*this.repository, this.fileName, */ this.parameters);
    }
    get shaderSource() {
        return 'source1_vertexlitgeneric';
    }
}
SourceEngineVMTLoader.registerMaterial('vertexlitgeneric', VertexLitGenericMaterial);
MaterialManager.registerMaterial('VertexLitGeneric', VertexLitGenericMaterial, SourceEngineMaterialManager);

class WaterMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.setValues(params);
        this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        this.setDefine('IS_TRANSLUCENT');
    }
    clone() {
        return new WaterMaterial(this.parameters);
    }
    getShaderSource() {
        return 'source1_water';
    }
}
SourceEngineVMTLoader.registerMaterial('water', WaterMaterial);

//TODO: deprecate
class WeaponDecalMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
        this.setValues(params);
        let variables = this.variables;
        this.setDefine('MIRROR', variables.get('$mirrorhorizontal') ?? 0);
        this.setDefine('DESATBASETINT', variables.get('$desatbasetint') ? '1' : '0');
        this.uniforms['uTintLerpBase'] = variables.get('$desatbasetint');
        this.polygonOffset = true;
        this.polygonOffsetFactor = -5;
        this.polygonOffsetUnits = -5;
        this.setPatternTexCoordTransform(fromValues(1, 1), create(), 0);
    }
    afterProcessProxies(proxyParams) {
        let variables = this.variables;
        let parameters = this.parameters;
        this.setDefine('DECALSTYLE', variables.get('$decalstyle') ?? 0); //TODO: set this on variable change
        let baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            this.uniforms['colorMap'] = Source1TextureManager.getTexture(this.repository, baseTexture, 0);
            this.setDefine('USE_COLOR_MAP'); //TODOv3: set this automaticaly
        }
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = fromValues$3(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = fromValues$3(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = Source1TextureManager.getTexture(this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$maskstexture']) {
            this.uniforms['mask1Map'] = Source1TextureManager.getTexture(this.repository, parameters['$maskstexture'], 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$pattern']) {
            this.uniforms['patternMap'] = Source1TextureManager.getTexture(this.repository, parameters['$pattern'], 0);
            this.setDefine('USE_PATTERN_MAP'); //TODOv3: set this automaticaly
        }
        let aoTexture = variables.get('$aotexture');
        if (aoTexture) {
            this.uniforms['aoMap'] = Source1TextureManager.getTexture(this.repository, aoTexture, 0);
            this.setDefine('USE_AO_MAP'); //TODOv3: set this automaticaly
        }
        let wearTexture = variables.get('$weartexture');
        if (wearTexture) {
            this.uniforms['scratchesMap'] = Source1TextureManager.getTexture(this.repository, wearTexture, 0);
            this.setDefine('USE_SCRATCHES_MAP'); //TODOv3: set this automaticaly
        }
        let grungeTexture = variables.get('$grungetexture');
        if (grungeTexture) {
            this.uniforms['grungeMap'] = Source1TextureManager.getTexture(this.repository, grungeTexture, 0);
            this.setDefine('USE_GRUNGE_MAP'); //TODOv3: set this automaticaly
        }
        let expTexture = parameters['$exptexture'];
        if (expTexture) {
            this.uniforms['exponentMap'] = Source1TextureManager.getTexture(this.repository, expTexture, 0);
            this.setDefine('USE_EXPONENT_MAP'); //TODOv3: set this automaticaly
        }
        let holoMaskTexture = variables.get('$holomask');
        if (holoMaskTexture) {
            this.uniforms['holoMaskMap'] = Source1TextureManager.getTexture(this.repository, holoMaskTexture, 0);
            this.setDefine('USE_HOLO_MASK_MAP'); //TODOv3: set this automaticaly
        }
        let holoSpectrumTexture = variables.get('$holospectrum');
        if (holoSpectrumTexture) {
            this.uniforms['holoSpectrumMap'] = Source1TextureManager.getTexture(this.repository, holoSpectrumTexture, 0);
            this.setDefine('USE_HOLO_SPECTRUM_MAP'); //TODOv3: set this automaticaly
        }
        /*

                    if( bAOTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER0, true );		// [sRGB] Ambient Occlusion
                    }
                    if( bWearTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER1, true );		// Scratches
                    }
                    if( bExpTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER2, true );		// Exponent
                    }
                    if ( bBaseTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER3, true );		// [sRGB] Base
                    }
                    if( bMasksTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER4, true );		// Masks
                    }
                    if( bGrungeTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER5, true );		// [sRGB] Grunge
                    }
                    if( bSurfaceTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER6, true );		// Obj-space normal and cavity
                    }
                    if( bPosTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER7, true );		// High-precision Position
                    }
                    if( bPaintTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER8, true );		// Paint
                    }	*/
        this.uniforms['uColorTint'] = variables.get('$colortint');
        this.uniforms['uColorTin2'] = variables.get('$colortint2');
        this.uniforms['uColorTint3'] = variables.get('$colortin3');
        this.uniforms['uColorTint4'] = variables.get('$colortint4');
        // Todo: optimize
        this.uniforms['uPhongParams'] = fromValues$3(4.0, 1.0, 1.0, 2.0); //TODO: set actual values
        this.uniforms['uPhongFresnel'] = fromValues$3(1.0, 1.0, 1.0, 0.0); //TODO: set actual values
        let wearProgress = proxyParams['WearProgress'] ?? 0.0; //TODO
        variables.get('$wearremapmid');
        let flX = wearProgress;
        let flP = variables.get('$wearremapmid');
        let flRemappedWear = 2.0 * (1.0 - flX) * flX * flP + (flX * flX);
        //remap wear to custom min/max bounds
        flRemappedWear *= (variables.get('$wearremapmax') - variables.get('$wearremapmin'));
        flRemappedWear += variables.get('$wearremapmin');
        //we already shipped wear progress levels, this is an additional param that individual stickers
        //can drive to bias their wear AGAIN as they move away from 0
        flRemappedWear += flX * flX * variables.get('$wearbias');
        //lerp wear width along wear progress
        //float flLerpedWearWidth = Lerp( variables[info.m_nWearProgress]->GetFloatValue(), variables[info.m_nWearWidthMin]->GetFloatValue(), variables[info.m_nWearWidthMax]->GetFloatValue() );
        let flLerpedWearWidth = lerp(variables.get('$wearwidthmin'), variables.get('$wearwidthmax'), wearProgress);
        this.uniforms['uWearParams'] = fromValues$3(wearProgress, flLerpedWearWidth, flRemappedWear, variables.get('$unwearstrength'));
    }
    set style(style) {
        this.setDefine('PAINT_STYLE', style);
    }
    setColorUniform(uniformName, value) {
        let color = readColor(value);
        if (color) {
            //vec3.scale(color, color, 1 / 255.0);
            this.uniforms[uniformName] = color;
        }
    }
    set color0(color) {
        this.setColorUniform('uCamoColor0', color);
    }
    set color1(color) {
        this.setColorUniform('uCamoColor1', color);
    }
    set color2(color) {
        this.setColorUniform('uCamoColor2', color);
    }
    set color3(color) {
        this.setColorUniform('uCamoColor3', color);
    }
    setPatternTexCoordTransform(scale, translation, rotation) {
        let transformMatrix = this.getTexCoordTransform(scale, translation, rotation);
        this.uniforms['g_patternTexCoordTransform[0]'] = new Float32Array([
            transformMatrix[0], transformMatrix[4], transformMatrix[8], transformMatrix[12],
            transformMatrix[1], transformMatrix[5], transformMatrix[9], transformMatrix[13]
        ]);
    }
    getTexCoordTransform(scale, translation, rotation) {
        let transformMatrix = create$5();
        let tempMatrix = create$5();
        let tempVec3 = create$4();
        tempVec3[0] = translation[0] - 0.5;
        tempVec3[1] = translation[1] - 0.5;
        tempVec3[2] = 0.0;
        fromTranslation$1(transformMatrix, tempVec3);
        tempVec3[0] = scale[0];
        tempVec3[1] = scale[1];
        tempVec3[2] = 1.0;
        fromScaling(tempMatrix, tempVec3);
        multiply$6(transformMatrix, transformMatrix, tempMatrix);
        fromZRotation(tempMatrix, rotation);
        multiply$6(transformMatrix, transformMatrix, tempMatrix);
        let offset = fromValues(0.5 / scale[0], 0.5 / scale[1]);
        rotate(offset, offset, create(), -rotation);
        tempVec3[0] = offset[0];
        tempVec3[1] = offset[1];
        tempVec3[2] = 0.0;
        fromTranslation$1(tempMatrix, tempVec3);
        multiply$6(transformMatrix, transformMatrix, tempMatrix);
        return transformMatrix;
    }
    getDefaultParameters() {
        return WEAPON_DECAL_DEFAULT_PARAMETERS;
    }
    clone() {
        return new WeaponDecalMaterial(this.parameters);
    }
    get shaderSource() {
        return 'source1_weapondecal';
    }
}
SourceEngineVMTLoader.registerMaterial('weapondecal', WeaponDecalMaterial);
const WEAPON_DECAL_DEFAULT_PARAMETERS = {
    //$basetexture : [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/stickers/default/sticker_default'],
    //$aotexture : [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/stickers/default/ao_default'],
    $grungetexture: [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/shared/sticker_paper'],
    $weartexture: [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/shared/paint_wear'],
    $decalstyle: [SHADER_PARAM_TYPE_INTEGER, 0],
    $colortint: [SHADER_PARAM_TYPE_COLOR, [255, 255, 255]],
    $colortint2: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $colortint3: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $colortint4: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $unwearstrength: [SHADER_PARAM_TYPE_FLOAT, 0.2],
    $wearremapmin: [SHADER_PARAM_TYPE_FLOAT, 0.8],
    $wearremapmid: [SHADER_PARAM_TYPE_FLOAT, 0.75],
    $wearremapmax: [SHADER_PARAM_TYPE_FLOAT, 1.],
    $wearwidthmin: [SHADER_PARAM_TYPE_FLOAT, 0.06],
    $wearwidthmax: [SHADER_PARAM_TYPE_FLOAT, 0.12],
    $wearbias: [SHADER_PARAM_TYPE_FLOAT, 0.0],
    $desatbasetint: [SHADER_PARAM_TYPE_FLOAT, 0.0],
};

class WorldVertexTransitionMaterial extends SourceEngineMaterial {
    constructor(params = {}) {
        super(params);
    }
    afterProcessProxies(proxyParams) {
        this.variables;
        this.parameters;
        let baseTexture2 = this.variables.get('$basetexture2');
        this.setColor2Map(baseTexture2 ? Source1TextureManager.getTexture(this.repository, baseTexture2, 0, true) : null);
        let blendModulateTexture = this.variables.get('$blendmodulatetexture');
        if (blendModulateTexture) {
            this.setTexture('blendModulateMap', Source1TextureManager.getTexture(this.repository, blendModulateTexture, 0, true), 'USE_BLEND_MODULATE_MAP');
        }
    }
    clone() {
        return new WorldVertexTransitionMaterial(this.parameters);
    }
    getShaderSource() {
        return 'source1_worldvertextransition';
    }
}
SourceEngineVMTLoader.registerMaterial('worldvertextransition', WorldVertexTransitionMaterial);

class SourceEngineParticleOperator {
    #parameters = {};
    particleSystem;
    material;
    materialLoaded = false;
    paramList = [];
    endCapState = -1;
    mesh; //for renderers
    constructor() {
        this.setNameId(this.functionName);
    }
    get functionName() {
        return this.constructor.getFunctionName();
    }
    static get functionName() {
        return 'Operator';
    }
    static getFunctionName() {
        return this.functionName;
    }
    initializeParticle(particle, elapsedTime) {
        if (!particle) {
            return;
        }
        this.doInit(particle, elapsedTime);
    }
    operateParticle(particle, elapsedTime) {
        if (this.endCapState != 1) {
            this.doOperate(particle, elapsedTime);
        }
    }
    forceParticle(particle, elapsedTime, accumulatedForces) {
        if (!particle) {
            return;
        }
        this.doForce(particle, elapsedTime, accumulatedForces);
    }
    constraintParticle(particle) {
        if (!particle) {
            return;
        }
        this.applyConstraint(particle);
    }
    doEmit(elapsedTime) { }
    doInit(particle, elapsedTime) { }
    doOperate(particle, elapsedTime) { }
    doForce(particle, elapsedTime, accumulatedForces, strength) { }
    applyConstraint(particle) { }
    doRender(particle, elapsedTime, material) { }
    initRenderer(particleSystem) { }
    emitParticle(creationTime, elapsedTime) {
        if (!this.particleSystem) {
            return;
        }
        return this.particleSystem.createParticle(creationTime, elapsedTime);
    }
    renderParticle(particleList, elapsedTime, material) {
        if (!particleList) {
            return;
        }
        this.doRender(particleList, elapsedTime, material);
    }
    setMaterial(material) {
        this.material = material;
    }
    setParticleSystem(particleSystem) {
        this.particleSystem = particleSystem;
    }
    paramChanged(name, value) {
        // Override this function is you need a notification when a parm is modified
    }
    setParameter(parameter, type, value) {
        if (parameter == '' || parameter == undefined) {
            return this;
        }
        if (parameter == 'operator end cap state') {
            this.endCapState = value;
        }
        if (this.#parameters[parameter] == undefined) {
            this.#parameters[parameter] = {};
        }
        this.#parameters[parameter].type = type;
        this.#parameters[parameter].value = value;
        //this.propertyChanged(parameter);
        this.paramChanged(parameter, value);
        return this;
    }
    getParameter(parameter) {
        const p = this.#parameters[parameter];
        if (p == undefined) {
            return null;
        }
        return p.value;
    }
    getParameters() {
        return this.#parameters;
    }
    setParameters(parameters) {
        for (let i in parameters) {
            const pair = parameters[i];
            this.setParameter(pair[0], pair[1], pair[2]);
        }
        return this;
    }
    setNameId(name) {
        //this.functionName = name;
        this.addParam('id', PARAM_TYPE_ID, generateRandomUUID()); //TODO
        this.addParam('name', PARAM_TYPE_STRING, name);
        this.addParam('functionName', PARAM_TYPE_STRING, name);
    }
    doNothing() {
    }
    reset() {
    }
    getOperatorFade() {
        return this.getOperatorStrength();
    }
    getOperatorStrength() {
        if (!this.particleSystem) {
            return 0;
        }
        let start_fadein = this.getParameter('operator start fadein') ?? 0;
        let end_fadein = this.getParameter('operator end fadein') ?? 0;
        let start_fadeout = this.getParameter('operator start fadeout') ?? 0;
        let end_fadeout = this.getParameter('operator end fadeout') ?? 0;
        const fade_oscillate = this.getParameter('operator fade oscillate') ?? 0;
        let currentTime = this.particleSystem.currentTime;
        if (fade_oscillate > 0) {
            currentTime = (currentTime / fade_oscillate) % 1.;
        }
        if (start_fadein > currentTime) {
            return 0;
        }
        if (end_fadeout > 0 && end_fadeout < currentTime) {
            return 0;
        }
        let flStrength = 1.0;
        if (end_fadein > currentTime && end_fadein > start_fadein) {
            flStrength = Math.min(flStrength, (currentTime - start_fadein) / (end_fadein - start_fadein));
        }
        if ((currentTime > start_fadeout) &&
            (end_fadeout > start_fadeout)) {
            flStrength = Math.min(flStrength, (currentTime - end_fadeout) / (start_fadeout - end_fadeout));
        }
        return flStrength;
        /*
        float FadeInOut( float flFadeInStart, float flFadeInEnd, float flFadeOutStart, float flFadeOutEnd, float flCurTime )
        {
            if ( flFadeInStart > flCurTime )						// started yet?
                return 0.0;

            if ( ( flFadeOutEnd > 0. ) && ( flFadeOutEnd < flCurTime ) ) // timed out?
                return 0.;

            // handle out of order cases
            flFadeInEnd = max( flFadeInEnd, flFadeInStart );
            flFadeOutStart = max( flFadeOutStart, flFadeInEnd );
            flFadeOutEnd = max( flFadeOutEnd, flFadeOutStart );

            float flStrength = 1.0;
            if (
                ( flFadeInEnd > flCurTime ) &&
                ( flFadeInEnd > flFadeInStart ) )
                flStrength = min( flStrength, FLerp( 0, 1, flFadeInStart, flFadeInEnd, flCurTime ) );

            if ( ( flCurTime > flFadeOutStart) &&
                 ( flFadeOutEnd > flFadeOutStart) )
                flStrength = min ( flStrength, FLerp( 0, 1, flFadeOutEnd, flFadeOutStart, flCurTime ) );

            return flStrength;

        }
        */
    }
    getParamList() {
        return this.paramList;
    }
    addParam(param, type, value) {
        this.paramList.push(new ParamType(param, type));
        this.setParameter(param, type, value);
    }
    /*
        toString() {
            const s = '';
            s = '"DmeParticleOperator"\n{\n';

            for (let i in this.#parameters) {
                const parameter = this.#parameters[i];
                if (parameter) {
                    if (parameter.type == 'string') {
                        s += '"' + i + '" "' + parameter.type + '" "' + escapeValue(parameter.value) + '"\n'
                    } else {
                        s += '"' + i + '" "' + parameter.type + '" "' + parameter.value + '"\n'
                    }
                } else {
                    if (ERROR) { console.error('parameter is null'); }
                }
            }
            s += '}';
            return s;
        }
    */
    getInputValue(inputField, particle) {
        let input = 0;
        switch (inputField) {
            case 0: //creation time
                input = clone$4(particle.position);
                break;
            case 8: //creation time
                input = particle.cTime;
                break;
        }
        return input;
    }
    getInputValueAsVector(inputField, particle, v) {
        switch (inputField) {
            case 0: //creation time
                copy$4(v, particle.position);
                break;
            case 4:
                v[0] = particle.rotationRoll;
                v[1] = particle.rotationRoll;
                v[2] = particle.rotationRoll;
                break;
            case 8: //creation time
                v[0] = particle.cTime;
                v[1] = particle.cTime;
                v[2] = particle.cTime;
                break;
        }
    }
    setOutputValue(outputField, value, particle) {
        particle.setInitialField(outputField, value /*TODO*/);
    }
    initMultipleOverride() {
        return false;
    }
    finished() {
        return false;
    }
    setOrientationType(orientationType) {
        switch (orientationType) {
            case 0:
                this.mesh.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_ALIGNED);
                break;
            case 1:
                this.mesh.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED);
                break;
            case 2:
                this.mesh.setDefine('USE_PARTICLE_YAW', 0);
                this.mesh.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            case 3:
                this.mesh.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            default:
                console.error('Unknonw orientationType ', orientationType);
        }
    }
    dispose() {
    }
}

const tempVec3_1$2 = create$4();
const tempVec3_2$8 = create$4();
class CollisionViaTraces extends SourceEngineParticleOperator {
    static functionName = 'Collision via traces';
    #raycaster = new Raycaster();
    #world;
    #collisionMode;
    constructor() {
        super();
        this.addParam('collision mode', PARAM_TYPE_INT, 0);
        this.addParam('amount of bounce', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('amount of slide', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('radius scale', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('brush only', PARAM_TYPE_BOOL, 0);
        this.addParam('collision group', PARAM_TYPE_STRING, 0.0);
        this.addParam('control point offset for fast collisions', PARAM_TYPE_VECTOR, create$4());
        this.addParam('control point movement distance tolerance', PARAM_TYPE_FLOAT, 5.0);
        this.addParam('kill particle on collision', PARAM_TYPE_BOOL, 0.0);
        this.addParam('trace accuracy tolerance', PARAM_TYPE_FLOAT, 24.0);
        //DMXELEMENT_UNPACK_FIELD( "collision mode", "0", int, m_nCollisionMode )
        //DMXELEMENT_UNPACK_FIELD( "amount of bounce", "0", float, m_flBounceAmount )
        //DMXELEMENT_UNPACK_FIELD( "amount of slide", "0", float, m_flSlideAmount )
        //DMXELEMENT_UNPACK_FIELD( "radius scale", "1", float, m_flRadiusScale )
        //DMXELEMENT_UNPACK_FIELD( "brush only", "0", bool, m_bBrushOnly )
        //DMXELEMENT_UNPACK_FIELD_STRING( "collision group", "NONE", m_CollisionGroupName )
        //DMXELEMENT_UNPACK_FIELD( "control point offset for fast collisions", "0 0 0", Vector, m_vecCpOffset )
        //DMXELEMENT_UNPACK_FIELD( "control point movement distance tolerance", "5", float, m_flCpMovementTolerance )
        //DMXELEMENT_UNPACK_FIELD( "kill particle on collision", "0", bool, m_bKillonContact )
        //DMXELEMENT_UNPACK_FIELD( "trace accuracy tolerance", "24", float, m_flTraceTolerance )
    }
    paramChanged(name, value) {
        switch (name) {
            case 'collision mode':
                this.#collisionMode = value;
                console.log('collisionMode', this.#collisionMode);
                break;
        }
    }
    applyConstraint(particle) {
        {
            if (particle.position[2] < 0.0) {
                particle.position[2] = 0.0;
            }
        }
        //TODO: do a proper collision
    }
    #worldCollision(particle, world) {
        //const cp = this.particleSystem.getControlPoint(0);
        //particle.prevPosition[2] = 50;
        const rayDirection = sub$2(tempVec3_1$2, particle.position, particle.prevPosition);
        len$4(rayDirection);
        normalize$5(rayDirection, rayDirection);
        // We probably already are on the surface, move back the ray origin to prevent falling thru
        const rayPosition = scaleAndAdd$2(tempVec3_2$8, particle.prevPosition, rayDirection, -0.001);
        let intersections = this.#raycaster.castRay(rayPosition, rayDirection, [world], true);
        if (intersections.length) {
            //console.error(intersections);
            let min = Infinity;
            for (let intersection of intersections) {
                if (intersection.distance < min) {
                    copy$4(particle.position, intersection.position);
                    min = intersection.distance;
                }
            }
        }
    }
    #getWorld() {
        const iterator = this.particleSystem.getParentIterator();
        for (let e of iterator) {
            if (e.is('Scene')) {
                const world = e.getWorld();
                if (world) {
                    this.#world = world;
                    iterator.return(null);
                    return world;
                }
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(CollisionViaTraces);

let cpPosition = create$4();
let tempVec3_2$7 = create$4();
class ConstrainDistanceToControlPoint extends SourceEngineParticleOperator {
    static functionName = 'Constrain distance to control point';
    constructor() {
        super();
        //this.setNameId('Constrain distance to control point');
        this.addParam('minimum distance', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 100.0);
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        this.addParam('offset of center', PARAM_TYPE_VECTOR, create$4());
        this.addParam('global center point', PARAM_TYPE_BOOL, 0);
        //	DMXELEMENT_UNPACK_FIELD('minimum distance', '0', float, m_fMinDistance)
        //	DMXELEMENT_UNPACK_FIELD('maximum distance', '100', float, m_fMaxDistance)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('offset of center', '0 0 0', Vector, m_CenterOffset)
        //	DMXELEMENT_UNPACK_FIELD('global center point', '0', bool, m_bGlobalCenter)
    }
    applyConstraint(particle) {
        const minDistance = this.getParameter('minimum distance');
        const maxDistance = this.getParameter('maximum distance');
        this.getParameter('offset of center');
        const cpNumber = this.getParameter('control point number');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        const v = copy$4(tempVec3_2$7, particle.position);
        if (cp) {
            sub$2(v, v, cp.getWorldPosition(cpPosition));
        }
        const distance = length$5(v);
        if (distance > 0) {
            scale$5(v, v, 1 / distance);
            if (distance < minDistance) {
                scale$5(v, v, minDistance);
                add$5(particle.position, cpPosition, v);
            }
            else {
                if (distance > maxDistance) {
                    scale$5(v, v, maxDistance);
                    add$5(particle.position, cpPosition, v);
                }
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(ConstrainDistanceToControlPoint);

const a$6 = create$4();
const b = create$4();
/*
    DMXELEMENT_UNPACK_FIELD( "minimum distance", "0", float, m_fMinDistance )
    DMXELEMENT_UNPACK_FIELD( "maximum distance", "100", float, m_flMaxDistance0 )
    DMXELEMENT_UNPACK_FIELD( "maximum distance middle", "-1", float, m_flMaxDistanceMid )
    DMXELEMENT_UNPACK_FIELD( "maximum distance end", "-1", float, m_flMaxDistance1 )
    DMXELEMENT_UNPACK_FIELD( "travel time", "10", float, m_flTravelTime )
    DMXELEMENT_UNPACK_FIELD( "random bulge", "0", float, m_PathParameters.m_flBulge )
    DMXELEMENT_UNPACK_FIELD( "start control point number", "0", int, m_PathParameters.m_nStartControlPointNumber )
    DMXELEMENT_UNPACK_FIELD( "end control point number", "0", int, m_PathParameters.m_nEndControlPointNumber )
    DMXELEMENT_UNPACK_FIELD( "bulge control 0=random 1=orientation of start pnt 2=orientation of end point", "0", int, m_PathParameters.m_nBulgeControl )
    DMXELEMENT_UNPACK_FIELD( "mid point position", "0.5", float, m_PathParameters.m_flMidPoint )
    */
class ConstrainDistanceToPathBetweenTwoControlPoints extends SourceEngineParticleOperator {
    static functionName = 'Constrain distance to path between two control points';
    constructor() {
        super();
        //this.setNameId('constrain distance to path between two control points');
        this.addParam('start control point number', PARAM_TYPE_INT, 0);
        this.addParam('end control point number', PARAM_TYPE_INT, 0);
        this.addParam('travel time', PARAM_TYPE_FLOAT, 10);
        this.addParam('minimum distance', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 100);
        this.addParam('offset of center', PARAM_TYPE_VECTOR, create$4());
        // TODO: add more parameters
    }
    applyConstraint(particle) {
        const startNumber = this.getParameter('start control point number') || 0;
        const endNumber = this.getParameter('end control point number') || 1;
        let travelTime = this.getParameter('travel time') || 1;
        travelTime = clamp(particle.currentTime / travelTime, 0, 1);
        const startCP = this.particleSystem.getControlPoint(startNumber);
        const endCP = this.particleSystem.getControlPoint(endNumber);
        if (startCP && endCP) {
            const delta = sub$2(create$4(), endCP.getWorldPosition(b), startCP.getWorldPosition(a$6));
            scaleAndAdd$2(particle.position, a$6, delta, travelTime);
        }
    }
}
SourceEngineParticleOperators.registerOperator(ConstrainDistanceToPathBetweenTwoControlPoints);

class EmitContinuously extends SourceEngineParticleOperator {
    static functionName = 'emit continuously';
    remainder = 0;
    constructor() {
        super();
        //this.setNameId('Emit Continuously');
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission_rate', PARAM_TYPE_FLOAT, 100);
        this.addParam('emission_duration', PARAM_TYPE_FLOAT, 0);
    }
    doEmit(elapsedTime) {
        const emission_start_time = this.getParameter('emission_start_time') || 0;
        let emission_rate = this.getParameter('emission_rate') || 100;
        const emission_duration = this.getParameter('emission_duration') || 0;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        //console.log(emission_rate + ' ' + this.remainder);
        let currentTime = this.particleSystem.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.remainder + elapsedTime * emission_rate;
        this.remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
    finished() {
        const emission_start_time = this.getParameter('emission_start_time') ?? 0;
        const emission_duration = this.getParameter('emission_duration') ?? 0;
        let currentTime = this.particleSystem.currentTime;
        return emission_duration != 0 && (currentTime > emission_start_time + emission_duration);
    }
}
SourceEngineParticleOperators.registerOperator(EmitContinuously);

/**
 *TODO
 */
class EmitInstantaneously extends SourceEngineParticleOperator {
    static functionName = 'emit_instantaneously';
    emitted = false;
    constructor() {
        super();
        //this.setNameId('Emit Instantaneously');
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('num_to_emit_minimum', PARAM_TYPE_INT, -1);
        this.addParam('num_to_emit', PARAM_TYPE_INT, 100);
        this.addParam('maximum emission per frame', PARAM_TYPE_INT, -1);
        this.addParam('emission count scale control point', PARAM_TYPE_INT, -1);
        this.addParam('emission count scale control point field', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('emission_start_time', '0', float, m_flStartTime)
        //	DMXELEMENT_UNPACK_FIELD('num_to_emit_minimum', '-1', int, m_nMinParticlesToEmit)
        //	DMXELEMENT_UNPACK_FIELD('num_to_emit', '100', int, m_nParticlesToEmit)
        //	DMXELEMENT_UNPACK_FIELD('maximum emission per frame', '-1', int, m_nPerFrameNum)
        //	DMXELEMENT_UNPACK_FIELD('emission count scale control point', '-1', int, m_nScaleControlPoint)
        //	DMXELEMENT_UNPACK_FIELD('emission count scale control point field', '0', int, m_nScaleControlPointField)
    }
    doEmit(elapsedTime) {
        if (this.emitted) {
            return;
        }
        const m_flStartTime = this.getParameter('emission_start_time');
        const num_to_emit = this.getParameter('num_to_emit');
        const currentTime = this.particleSystem.currentTime;
        if (currentTime < m_flStartTime)
            return;
        for (let i = 0; i < num_to_emit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime); //TODO: change particle time ?
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
        }
        this.emitted = true;
    }
    reset() {
        this.emitted = false;
    }
    finished() {
        return this.emitted;
    }
}
SourceEngineParticleOperators.registerOperator(EmitInstantaneously);

class EmitNoise extends SourceEngineParticleOperator {
    static functionName = 'emit noise';
    remainder = 0;
    constructor() {
        super();
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission_duration', PARAM_TYPE_FLOAT, 0);
        this.addParam('scale emission to used control points', PARAM_TYPE_FLOAT, 0);
        this.addParam('time noise coordinate scale', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('time coordinate offset', PARAM_TYPE_FLOAT, 0);
        this.addParam('absolute value', PARAM_TYPE_BOOL, 0);
        this.addParam('invert absolute value', PARAM_TYPE_BOOL, 0);
        this.addParam('emission minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission maximum', PARAM_TYPE_FLOAT, 100);
        this.addParam('world time noise coordinate scale', PARAM_TYPE_FLOAT, 0);
    }
    doEmit(elapsedTime) {
        let emission_start_time = this.getParameter('emission_start_time');
        let emissionMinimum = this.getParameter('emission minimum');
        let emissionMaximum = this.getParameter('emission maximum');
        let emission_duration = this.getParameter('emission_duration');
        let emission_rate = (emissionMinimum + emissionMaximum) / 2;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        //console.log(emission_rate + ' ' + this.remainder);
        let currentTime = this.particleSystem.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.remainder + elapsedTime * emission_rate;
        this.remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
SourceEngineParticleOperators.registerOperator(EmitNoise);

let tempVec3$i = create$4();
class PullTowardsControlPoint extends SourceEngineParticleOperator {
    static functionName = 'Pull towards control point';
    constructor() {
        super();
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
        this.addParam('falloff power', PARAM_TYPE_FLOAT, 2);
        //	DMXELEMENT_UNPACK_FIELD('amount of force', '0', float, m_fForceAmount)
        //	DMXELEMENT_UNPACK_FIELD('falloff power', '2', float, m_fFalloffPower)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
    }
    doForce(particle, elapsedTime, accumulatedForces) {
        //console.log(particle.position);
        const m_fForceAmount = this.getParameter('amount of force');
        const cpNumber = this.getParameter('control point number');
        const m_fFalloffPower = this.getParameter('falloff power');
        const fForceScale = -m_fForceAmount * 1.0 /*flStrength*/;
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (!cp) {
            return;
        }
        const ofs = clone$4(particle.position);
        subtract$3(ofs, ofs, cp.getWorldPosition(tempVec3$i)); //TODO: add particle base cp
        let len = length$5(ofs);
        if (len === 0) {
            len = FLT_EPSILON;
        }
        scale$5(ofs, ofs, fForceScale / len * Math.pow(len, -m_fFalloffPower));
        ///console.log(len, Math.pow(len, power_frac), ofs);
        //vec3.scale(ofs, ofs, 10000000);//TODO
        //vec3.scale(v, v, 1 / Math.pow(len, power_frac));
        add$5(accumulatedForces, accumulatedForces, ofs);
    }
}
SourceEngineParticleOperators.registerOperator(PullTowardsControlPoint);

class RandomForce$1 extends SourceEngineParticleOperator {
    static functionName = 'random force';
    constructor() {
        super();
        this.addParam('min force', PARAM_TYPE_VECTOR, create$4());
        this.addParam('max force', PARAM_TYPE_VECTOR, create$4());
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
    }
    doForce(particle, elapsedTime, accumulatedForces) {
        const minForce = this.getParameter('min force') || create$4();
        const maxForce = this.getParameter('max force') || create$4();
        const f = vec3RandomBox(create$4(), minForce, maxForce);
        /*if (elapsedTime) {
            vec3.scale(f, f , 1 / elapsedTime);
        }*/
        add$5(accumulatedForces, accumulatedForces, f);
    }
}
SourceEngineParticleOperators.registerOperator(RandomForce$1);

const tempVec3$h = create$4();
const tempVec3_2$6 = create$4();
create$4();
create$2();
class TwistAroundAxis extends SourceEngineParticleOperator {
    static functionName = 'twist around axis';
    constructor() {
        super();
        this.addParam('twist axis', PARAM_TYPE_VECTOR, fromValues$4(0, 0, 1));
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
        this.addParam('object local space axis 0/1', PARAM_TYPE_BOOL, 0);
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        const axis = this.getParameter('twist axis'); //TODO: set in world space
        const amountOfForce = this.getParameter('amount of force');
        this.getParameter('object local space axis 0/1');
        const cp = particle.system.getControlPoint(0);
        const offsetToAxis = sub$2(tempVec3$h, particle.position, cp.getWorldPosition(tempVec3$h));
        /*
                if (!localSpace) {
                    cp.getWorldQuaternion(tempQuat);
                    axis = vec3.transformQuat(tempAxis, axis, tempQuat);
                }
                    */
        normalize$5(offsetToAxis, offsetToAxis);
        scale$5(tempVec3_2$6, offsetToAxis, dot$4(offsetToAxis, axis));
        sub$2(offsetToAxis, offsetToAxis, tempVec3_2$6);
        normalize$5(offsetToAxis, offsetToAxis);
        const f = cross$2(tempVec3_2$6, axis, offsetToAxis);
        scale$5(f, f, amountOfForce * strength);
        add$5(accumulatedForces, accumulatedForces, f);
    }
}
SourceEngineParticleOperators.registerOperator(TwistAroundAxis);

class AlphaRandom extends SourceEngineParticleOperator {
    static functionName = 'Alpha Random';
    constructor() {
        super();
        this.addParam('alpha_min', PARAM_TYPE_INT, 0);
        this.addParam('alpha_max', PARAM_TYPE_INT, 255);
        this.addParam('alpha_random_exponent', PARAM_TYPE_FLOAT, 1.0);
        //	DMXELEMENT_UNPACK_FIELD('alpha_min', '255', int, m_nAlphaMin)
        //	DMXELEMENT_UNPACK_FIELD('alpha_max', '255', int, m_nAlphaMax)
        //	DMXELEMENT_UNPACK_FIELD('alpha_random_exponent', '1', float, m_flAlphaRandExponent)
    }
    doInit(particle, elapsedTime) {
        const alpha_min = this.getParameter('alpha_min') / 255.0;
        const alpha_max = this.getParameter('alpha_max') / 255.0;
        const alpha_random_exponent = this.getParameter('alpha_random_exponent');
        const alpha = RandomFloatExp(alpha_min, alpha_max, alpha_random_exponent);
        particle.alpha = alpha;
        particle.startAlpha = alpha;
    }
}
SourceEngineParticleOperators.registerOperator(AlphaRandom);

class ColorRandom extends SourceEngineParticleOperator {
    static functionName = 'Color Random';
    constructor() {
        super();
        this.addParam('color1', PARAM_TYPE_COLOR, BLACK);
        this.addParam('color2', PARAM_TYPE_COLOR, WHITE);
    }
    doInit(particle, elapsedTime) {
        particle.color.randomize(this.getParameter('color1'), this.getParameter('color2'));
        particle.initialColor.setColor(particle.color);
    }
}
SourceEngineParticleOperators.registerOperator(ColorRandom);

class LifetimeFromSequence extends SourceEngineParticleOperator {
    static functionName = 'Lifetime From Sequence';
    constructor() {
        super();
        this.addParam('Frames Per Second', PARAM_TYPE_FLOAT, 30);
    }
    doInit(particle, elapsedTime) {
        const paramFramesPerSecond = this.getParameter('Frames Per Second');
        if (this.particleSystem.material) {
            const frameSpan = this.particleSystem.material.getFrameSpan(particle.sequence);
            if (frameSpan !== null) {
                const lifetime = frameSpan / paramFramesPerSecond;
                //particle.timeToLive = lifetime;
                particle.setInitialTTL(lifetime / 2.0);
            }
        }
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(LifetimeFromSequence);

class LifetimeRandom extends SourceEngineParticleOperator {
    static functionName = 'Lifetime Random';
    constructor() {
        super();
        this.addParam('lifetime_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('lifetime_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('lifetime_random_exponent', PARAM_TYPE_FLOAT, 1);
    }
    doInit(particle, elapsedTime) {
        const lifetime_min = this.getParameter('lifetime_min');
        const lifetime_max = this.getParameter('lifetime_max');
        const lifetime_random_exponent = this.getParameter('lifetime_random_exponent');
        //const lifetime = (lifetime_max - lifetime_min) * Math.random() + lifetime_min;
        particle.setInitialTTL(RandomFloatExp(lifetime_min, lifetime_max, lifetime_random_exponent));
    }
}
SourceEngineParticleOperators.registerOperator(LifetimeRandom);

const a$5 = create$4();
class PositionAlongPathRandom extends SourceEngineParticleOperator {
    static functionName = 'Position Along Path Random';
    sequence = 0;
    constructor() {
        super();
        this.addParam('restart behavior (0 = bounce, 1 = loop )', PARAM_TYPE_BOOL, 0);
        this.addParam('particles to map from start to end', PARAM_TYPE_FLOAT, 2);
        this.addParam('mid point position', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('bulge control 0=random 1=orientation of start pnt 2=orientation of end point', PARAM_TYPE_INT, 0);
        this.addParam('start control point number', PARAM_TYPE_INT, 1);
        this.addParam('end control point number', PARAM_TYPE_INT, 2);
        this.addParam('bulge', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const startNumber = this.getParameter('start control point number') ?? 1;
        const endNumber = this.getParameter('end control point number') ?? 2;
        const startCP = this.particleSystem.getControlPoint(startNumber);
        const endCP = this.particleSystem.getControlPoint(endNumber);
        const nbPart = this.getParameter('particles to map from start to end') || 2;
        const delta = startCP.deltaPosFrom(endCP);
        this.sequence / nbPart;
        scale$5(delta, delta, Math.random());
        add$5(particle.position, startCP.getWorldPosition(a$5), delta);
        copy$4(particle.prevPosition, particle.position);
        ++this.sequence;
        if (this.sequence > nbPart) { //TODO: handle loop
            this.sequence = 0;
        }
    }
    reset() {
        this.sequence = 0;
    }
}
SourceEngineParticleOperators.registerOperator(PositionAlongPathRandom);

const tempVec3_1$1 = create$4();
const tempVec3_2$5 = create$4();
class PositionAlongPathSequential extends SourceEngineParticleOperator {
    static functionName = 'Position Along Path Sequential';
    sequence = 0;
    constructor() {
        super();
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('bulge', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('start control point number', PARAM_TYPE_INT, 0);
        this.addParam('end control point number', PARAM_TYPE_INT, 0);
        this.addParam('bulge control 0=random 1=orientation of start pnt 2=orientation of end point', PARAM_TYPE_INT, 0);
        this.addParam('mid point position', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('particles to map from start to end', PARAM_TYPE_FLOAT, 100);
        this.addParam('restart behavior (0 = bounce, 1 = loop )', PARAM_TYPE_BOOL, 1);
    }
    doInit(particle, elapsedTime) {
        const startControlPointNumber = this.getParameter('start control point number');
        const endControlPointNumber = this.getParameter('end control point number');
        const startCP = this.particleSystem.getControlPoint(startControlPointNumber);
        const endCP = this.particleSystem.getControlPoint(endControlPointNumber);
        const nbPart = this.getParameter('particles to map from start to end');
        startCP.deltaPosFrom(endCP, tempVec3_1$1);
        const s = this.sequence / nbPart;
        scale$5(tempVec3_1$1, tempVec3_1$1, s);
        add$5(particle.position, startCP.getWorldPosition(tempVec3_2$5), tempVec3_1$1);
        copy$4(particle.prevPosition, particle.position);
        ++this.sequence;
        if (this.sequence > nbPart) {
            const restartBehavior = this.getParameter('restart behavior (0 = bounce, 1 = loop )');
            if (restartBehavior == 1) {
                this.sequence = 0;
            }
            else {
                this.sequence = nbPart;
            }
        }
    }
    reset() {
        this.sequence = 0;
    }
}
SourceEngineParticleOperators.registerOperator(PositionAlongPathSequential);

class PositionFromParentParticles extends SourceEngineParticleOperator {
    static functionName = 'Position From Parent Particles';
    constructor() {
        super();
    }
    doInit(particle, elapsedTime) {
        const parent = this.particleSystem.parentSystem;
        if (parent == null) {
            return;
        }
        const base = parent.getParticle();
        if (base != null) {
            /*particle.timeToLive = 0;
            particle.die();
            return;*/
            base.getWorldPos(particle.position);
            base.getLocalPos(particle.position);
            copy$4(particle.prevPosition, particle.position);
        }
        else {
            particle.die();
        }
        particle.PositionFromParentParticles = true;
    }
}
SourceEngineParticleOperators.registerOperator(PositionFromParentParticles);

const tempVec3$g = create$4();
class PositionModifyOffsetRandom extends SourceEngineParticleOperator {
    static functionName = 'Position Modify Offset Random';
    constructor() {
        super();
        this.addParam('offset min', PARAM_TYPE_VECTOR, create$4());
        this.addParam('offset max', PARAM_TYPE_VECTOR, create$4());
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('offset in local space 0/1', PARAM_TYPE_BOOL, 0);
        this.addParam('offset proportional to radius 0/1', PARAM_TYPE_BOOL, 0);
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('offset min', '0 0 0', Vector, m_OffsetMin)
        //	DMXELEMENT_UNPACK_FIELD('offset max', '0 0 0', Vector, m_OffsetMax)
        //	DMXELEMENT_UNPACK_FIELD('offset in local space 0/1', '0', bool, m_bLocalCoords)
        //	DMXELEMENT_UNPACK_FIELD('offset proportional to radius 0/1', '0', bool, m_bProportional)
    }
    doInit(particle, elapsedTime) {
        const localSpace = this.getParameter('offset in local space 0/1');
        const offsetMin = this.getParameter('offset min');
        const offsetMax = this.getParameter('offset max');
        random$2(create(), 1.0);
        const controlPointNumber = this.getParameter('control_point_number');
        const offset = vec3RandomBox(tempVec3$g, offsetMin, offsetMax);
        if (localSpace == 1) {
            const cp = particle.system.getControlPoint(controlPointNumber);
            if (cp) {
                transformQuat$1(offset, offset, cp.getWorldQuaternion());
            }
            /*const a = offset[1];
            offset[1] = offset[2];
            offset[2] = a;*/
            /*
// assume in2 is a rotation and rotate the input vector
void VectorRotate(const float *in1, const matrix3x4_t& in2, float *out)
{
    Assert(s_bMathlibInitialized);
    Assert(in1 != out);
    out[0] = DotProduct(in1, in2[0]);
    out[1] = DotProduct(in1, in2[1]);
    out[2] = DotProduct(in1, in2[2]);
}
*/
        }
        if (particle.initialVec) {
            particle.initialVecOffset = clone$4(offset); //TODO: optimize
        }
        add$5(particle.position, particle.position, offset);
        add$5(particle.prevPosition, particle.prevPosition, offset);
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(PositionModifyOffsetRandom);

const a$4 = create$4();
class PositionOnModelRandom extends SourceEngineParticleOperator {
    static functionName = 'Position on Model Random';
    constructor() {
        super();
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('force to be inside model', PARAM_TYPE_INT, 0);
        this.addParam('hitbox scale', PARAM_TYPE_INT, 1);
        this.addParam('direction bias', PARAM_TYPE_VECTOR, create$4());
        //	DMXELEMENT_UNPACK_FIELD( 'control_point_number', '0', int, m_nControlPointNumber )
        //	DMXELEMENT_UNPACK_FIELD( 'force to be inside model', '0', int, m_nForceInModel )
        //	DMXELEMENT_UNPACK_FIELD( 'hitbox scale', '1.0', int, m_flHitBoxScale )
        //	DMXELEMENT_UNPACK_FIELD( 'direction bias', '0 0 0', Vector, m_vecDirectionBias )
    }
    doInit(particle, elapsedTime) {
        const controlPointNumber = this.getParameter('control_point_number');
        const controlPoint = particle.system.getControlPoint(controlPointNumber);
        // TODO : Actually we should get the model parenting the control point
        const controllingModel = controlPoint.parentModel;
        if (controllingModel) {
            //TODOv3
            let bones = [];
            particle.bones = bones;
            particle.initialVec = create$4();
            const position = controllingModel.getRandomPointOnModel(create$4(), particle.initialVec, bones);
            //vec3.copy(particle.position, position);
            //vec3.copy(particle.prevPosition, position);
            if (controlPoint) {
                copy$4(particle.position, position);
                copy$4(particle.prevPosition, position);
            }
        }
        else {
            if (controlPoint) {
                copy$4(particle.position, controlPoint.getWorldPosition(a$4));
                copy$4(particle.prevPosition, particle.position);
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(PositionOnModelRandom);

let tempVec3$f = create$4();
class PositionWithinBoxRandom extends SourceEngineParticleOperator {
    static functionName = 'Position Within Box Random';
    constructor() {
        super();
        this.addParam('min', PARAM_TYPE_VECTOR, create$4());
        this.addParam('max', PARAM_TYPE_VECTOR, create$4());
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('min', '0 0 0', Vector, m_vecMin)
        //	DMXELEMENT_UNPACK_FIELD('max', '0 0 0', Vector, m_vecMax)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
    }
    doInit(particle, elapsedTime) {
        const min = this.getParameter('min');
        const max = this.getParameter('max');
        const controlPointNumber = this.getParameter('control point number');
        vec3RandomBox(particle.position, min, max);
        copy$4(particle.prevPosition, particle.position);
        const controlPoint = particle.system.getControlPoint(controlPointNumber);
        if (controlPoint) {
            controlPoint.getWorldPosition(tempVec3$f);
            add$5(particle.position, particle.position, tempVec3$f);
            add$5(particle.prevPosition, particle.prevPosition, tempVec3$f);
        }
    }
}
SourceEngineParticleOperators.registerOperator(PositionWithinBoxRandom);

let tempVec3$e = create$4();
class PositionWithinSphereRandom extends SourceEngineParticleOperator {
    static functionName = 'Position Within Sphere Random';
    constructor() {
        super();
        this.addParam('distance_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance_bias', PARAM_TYPE_VECTOR, fromValues$4(1, 1, 1));
        this.addParam('distance_bias_absolute_value', PARAM_TYPE_VECTOR, fromValues$4(0, 0, 0));
        this.addParam('speed_in_local_coordinate_system_min', PARAM_TYPE_VECTOR, create$4());
        this.addParam('speed_in_local_coordinate_system_max', PARAM_TYPE_VECTOR, create$4());
        this.addParam('speed_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('speed_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('distance_min', '0', float, m_fRadiusMin)
        //	DMXELEMENT_UNPACK_FIELD('distance_max', '0', float, m_fRadiusMax)
        //	DMXELEMENT_UNPACK_FIELD('distance_bias', '1 1 1', Vector, m_vecDistanceBias)
        //	DMXELEMENT_UNPACK_FIELD('distance_bias_absolute_value', '0 0 0', Vector, m_vecDistanceBiasAbs)
        //	DMXELEMENT_UNPACK_FIELD('bias in local system', '0', bool, m_bLocalCoords)
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('speed_min', '0', float, m_fSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_max', '0', float, m_fSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('speed_random_exponent', '1', float, m_fSpeedRandExp)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_min', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_max', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('create in model', '0', int, m_nCreateInModel)
        //	DMXELEMENT_UNPACK_FIELD('randomly distribute to highest supplied Control Point', '0', bool, m_bUseHighestEndCP)
        //	DMXELEMENT_UNPACK_FIELD('randomly distribution growth time', '0', float, m_flEndCPGrowthTime)
    }
    doInit(particle, elapsedTime) {
        const m_fRadiusMin = this.getParameter('distance_min');
        const m_fRadiusMax = this.getParameter('distance_max');
        const speed_min = this.getParameter('speed_min');
        const speed_max = this.getParameter('speed_max');
        const m_vecDistanceBias = this.getParameter('distance_bias');
        const m_vecDistanceBiasAbs = this.getParameter('distance_bias_absolute_value');
        const controlPointNumber = this.getParameter('control_point_number');
        const m_bLocalCoords = this.getParameter('bias in local system');
        const m_bDistanceBias = (m_vecDistanceBias[0] != 1.0) || (m_vecDistanceBias[1] != 1.0) || (m_vecDistanceBias[2] != 1.0);
        const m_bDistanceBiasAbs = (m_vecDistanceBiasAbs[0] != 0.0) || (m_vecDistanceBiasAbs[1] != 0.0) || (m_vecDistanceBiasAbs[2] != 0.0);
        const speed_in_local_coordinate_system_min = this.getParameter('speed_in_local_coordinate_system_min');
        const speed_in_local_coordinate_system_max = this.getParameter('speed_in_local_coordinate_system_max');
        //const distance = (distance_max - distance_min) * Math.random() + distance_min;
        const speed = (speed_max - speed_min) * Math.random() + speed_min;
        //const v = vec3.random(vec3.create(), distance);
        //Lerp(flLength, m_fRadiusMin, m_fRadiusMax);
        const randpos = create$4(); //, randDir;
        let cp;
        //for(int nTryCtr = 0 ; nTryCtr < 10; nTryCtr++)
        {
            const flLength = RandomVectorInUnitSphere(randpos);
            // Absolute value and biasing for creating hemispheres and ovoids.
            if (m_bDistanceBiasAbs) {
                if (m_vecDistanceBiasAbs[0] != 0.0) {
                    randpos[0] = Math.abs(randpos[0]);
                }
                if (m_vecDistanceBiasAbs[1] != 0.0) {
                    randpos[1] = Math.abs(randpos[1]);
                }
                if (m_vecDistanceBiasAbs[2] != 0.0) {
                    randpos[2] = Math.abs(randpos[2]);
                }
            }
            mul$4(randpos, randpos, m_vecDistanceBias); //randpos *= m_vecDistanceBias;
            normalize$5(randpos, randpos); //randpos.NormalizeInPlace();
            clone$4(randpos);
            scale$5(randpos, randpos, lerp(m_fRadiusMin, m_fRadiusMax, flLength)); //randpos *= Lerp(flLength, m_fRadiusMin, m_fRadiusMax);
            if (!m_bDistanceBias || !m_bLocalCoords) {
                /*Vector vecControlPoint;
                pParticles->GetControlPointAtTime(nCurrentControlPoint, *ct, &vecControlPoint);
                randpos += vecControlPoint;*/
                cp = particle.system.getControlPoint(controlPointNumber);
                if (cp) {
                    cp.getWorldPosition(tempVec3$e);
                    add$5(randpos, randpos, tempVec3$e);
                }
            }
            else {
                /*matrix3x4_t mat;
                pParticles->GetControlPointTransformAtTime(nCurrentControlPoint, *ct, &mat);
                Vector vecTransformLocal = vec3_origin;
                VectorTransform(randpos, mat, vecTransformLocal);
                randpos = vecTransformLocal;*/
                cp = particle.system.getControlPoint(controlPointNumber);
                if (cp) {
                    transformQuat$1(randpos, randpos, cp.getWorldQuaternion());
                    cp.getWorldPosition(tempVec3$e);
                    add$5(randpos, randpos, tempVec3$e);
                }
            }
        }
        //vec3.multiply(v, v, distance_bias);
        //vec3.add(particle.position, particle.position, v);
        //const cp = particle.system.getControlPoint(controlPointNumber);
        if (cp) {
            particle.cpOrientation = clone$2(cp.getWorldQuaternion());
        }
        copy$4(particle.position, randpos);
        vec3RandomBox(particle.velocity, speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max); //particle.velocity.randomize(speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max);
        particle.velocity[1] = -particle.velocity[1]; //For some reason y is inversed
        if (cp) {
            transformQuat$1(particle.velocity, particle.velocity, cp.getWorldQuaternion());
        }
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation/*cp.getWorldQuaternion()*/);
        if (speed) {
            const v = random$5(create$4(), speed);
            add$5(particle.velocity, particle.velocity, v);
            //vec3.add(randpos, randpos, v);
        }
        invert$2(particle.cpOrientationInvert, particle.cpOrientation);
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation);
        const vGrav = clone$4(particle.velocity);
        particle.velocity[0] = vGrav[2];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = -vGrav[0];
        particle.velocity[0] = vGrav[0];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = vGrav[2];
        //particle.velocity[2] = -vGrav[2];
        //vec3.add(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
        scaleAndAdd$2(randpos, randpos, particle.velocity, -elapsedTime);
        copy$4(particle.prevPosition, randpos);
        //vec3.scaleAndAdd(particle.position, particle.prevPosition, particle.velocity, 0.01);//TODO: fix
        //vec3.copy(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
    }
}
SourceEngineParticleOperators.registerOperator(PositionWithinSphereRandom);
SourceEngineParticleOperators.registerOperator('Position Within Sphere', PositionWithinSphereRandom);

class RadiusRandom extends SourceEngineParticleOperator {
    static functionName = 'Radius Random';
    constructor() {
        super();
        this.addParam('radius_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('radius_max', PARAM_TYPE_FLOAT, 1);
    }
    doInit(particle, elapsedTime) {
        const radius_min = this.getParameter('radius_min') || 1;
        const radius_max = this.getParameter('radius_max') || 1;
        const radius = (radius_max - radius_min) * Math.random() + radius_min;
        particle.setInitialRadius(radius);
    }
}
SourceEngineParticleOperators.registerOperator(RadiusRandom);

const a$3 = create$4();
class RemapControlPointToScalar extends SourceEngineParticleOperator {
    static functionName = 'remap control point to scalar';
    constructor() {
        super();
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point number', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field 0-2 X/Y/Z', PARAM_TYPE_INT, 0); // X/Y/Z
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        /*
                    'operator start fadein' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator fade oscillate' 'float' '0'
                    'emitter lifetime start time (seconds)' 'float' '-1'
                    'emitter lifetime end time (seconds)' 'float' '-1'
                    'input control point number' 'int' '1'
                    'input minimum' 'float' '0.25'
                    'input maximum' 'float' '1'
                    'input field 0-2 X/Y/Z' 'int' '0'
                    'output field' 'int' '7'
                    'output minimum' 'float' '1'
                    'output maximum' 'float' '0'
                    'output is scalar of initial random range' 'bool' '0'
                    */
    }
    doInit(particle, elapsedTime) {
        /*if (!this.firstTime) {
            console.error('I don\'t know what i\'m supposed to do ' + this.functionName);
            console.log(this.parameters);
            this.firstTime = true;
            return;
        }*/
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field 0-2 X/Y/Z');
        const outputField = this.getParameter('output field');
        const cpNumber = this.getParameter('input control point number');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp && (inputField == 0 || inputField == 1 || inputField == 2)) {
            const v = cp._position[inputField]; //this.getInputValue(inputField, cpNumber);
            const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
            const out = d * (outputMaximum - outputMinimum) + outputMinimum;
            //out = Clamp(out, outputMinimum, outputMaximum);
            this.setOutputValue(outputField, out, particle);
        }
    }
    getInputValue(inputField, cpNumber) {
        console.log('Input field ' + inputField + ' ' + cpNumber);
        if (inputField == 0 || inputField == 1 || inputField == 2) {
            const cp = this.particleSystem.getControlPoint(cpNumber);
            if (cp) {
                return cp.getWorldPosition(a$3)[inputField];
            }
        }
        return 0;
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RemapControlPointToScalar);

let tempVec3_1 = create$4();
let tempVec3_2$4 = create$4();
let tempVec3_3$1 = create$4();
let tempVec3_4 = create$4();
let tempVec3_5 = create$4();
const a$2 = create$4();
class RemapControlPointToVector extends SourceEngineParticleOperator {
    static functionName = 'remap control point to vector';
    constructor() {
        super();
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point number', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_VECTOR, create$4());
        this.addParam('input maximum', PARAM_TYPE_VECTOR, create$4());
        this.addParam('output minimum', PARAM_TYPE_VECTOR, create$4());
        this.addParam('output maximum', PARAM_TYPE_VECTOR, create$4());
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        /*'operator strength scale control point' 'int' '16'
        'input control point number' 'int' '15'
        'input maximum' 'vector3' '255 255 255'
        'output field' 'int' '6'
        'output maximum' 'vector3' '1 1 1'*/
    }
    doInit(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const outputField = this.getParameter('output field');
        const cpNumber = this.getParameter('input control point number');
        const init = this.getParameter('output is scalar of initial random range');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            const iDelta = sub$2(tempVec3_1, inputMaximum, inputMinimum);
            const oDelta = sub$2(tempVec3_2$4, outputMaximum, outputMinimum);
            const vDelta = sub$2(tempVec3_3$1, cp._position, inputMinimum);
            const v1Delta = div$2(tempVec3_4, vDelta, iDelta);
            const v2Delta = mul$4(tempVec3_5, v1Delta, oDelta);
            add$5(v2Delta, v2Delta, outputMinimum);
            particle.setInitialField(outputField, v2Delta, init);
        }
    }
    getInputValue(inputField, cpNumber) {
        console.log('Input field ' + inputField + ' ' + cpNumber);
        if (inputField == 0 || inputField == 1 || inputField == 2) {
            const cp = this.particleSystem.getControlPoint(cpNumber);
            if (cp) {
                return cp.getWorldPosition(a$2)[inputField];
            }
        }
        return 0;
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RemapControlPointToVector);

class RemapInitialScalar extends SourceEngineParticleOperator {
    static functionName = 'Remap Initial Scalar';
    constructor() {
        super();
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field', PARAM_TYPE_INT, 0);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('emitter lifetime start time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('emitter lifetime end time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
    }
    doInit(particle, elapsedTime) {
        const emitterStartTime = this.getParameter('emitter lifetime start time (seconds)');
        const emitterEndTime = this.getParameter('emitter lifetime end time (seconds)');
        const currentTime = this.particleSystem.currentTime;
        if ((emitterStartTime != -1) && (currentTime < emitterStartTime))
            return;
        if ((emitterEndTime != -1) && (currentTime > emitterEndTime))
            return;
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field');
        const outputField = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        //const v = this.getInputValue(inputField, particle);
        const v = particle.getField(inputField);
        const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
        let out = d * (outputMaximum - outputMinimum) + outputMinimum;
        //out = clamp(out, outputMinimum, outputMaximum);
        //this.setOutputValue(outputField, out, particle);
        particle.setField(outputField, out, init);
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RemapInitialScalar);

class RemapNoiseToScalar extends SourceEngineParticleOperator {
    static functionName = 'remap noise to scalar';
    constructor() {
        super();
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const field = this.getParameter('output field') || 1;
        const minimum = this.getParameter('output minimum') || 0.0;
        const maximum = this.getParameter('output maximum') || 1.0;
        //TODO: do a proper noise
        const noise = (maximum - minimum) * Math.random() + minimum;
        particle.setInitialField(field, noise);
    }
}
SourceEngineParticleOperators.registerOperator(RemapNoiseToScalar);
/*

                    'id' 'elementid' '7668c8af-2f2a-4c07-9e93-f9e6123b172e'
                    'name' 'string' 'Remap Noise to Scalar'
                    'functionName' 'string' 'Remap Noise to Scalar'
                    'world time noise coordinate scale' 'float' '0'
                    'output maximum' 'float' '3'
                    'output minimum' 'float' '1'
                    'invert absolute value' 'bool' '0'
                    'absolute value' 'bool' '0'
                    'spatial coordinate offset' 'vector3' '0 0 0'
                    'time coordinate offset' 'float' '0'
                    'output field' 'int' '3'
                    'spatial noise coordinate scale' 'float' '3'
                    'time noise coordinate scale' 'float' '5'
                    'operator fade oscillate' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadein' 'float' '0'
*/

const tempQuat$4 = create$2();
const tempVec3$d = create$4();
const tempVec3_2$3 = create$4();
class RemapScalarToVector extends SourceEngineParticleOperator {
    static functionName = 'Remap Scalar to Vector';
    constructor() {
        super();
        this.addParam('emitter lifetime start time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('emitter lifetime end time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('input field', PARAM_TYPE_INT, 8);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output minimum', PARAM_TYPE_VECTOR3, create$4());
        this.addParam('output maximum', PARAM_TYPE_VECTOR3, fromValues$4(1, 1, 1));
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('use local system', PARAM_TYPE_BOOL, 1);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
    }
    doInit(particle, elapsedTime) {
        const m_flStartTime = this.getParameter('emitter lifetime start time (seconds)');
        const m_flEndTime = this.getParameter('emitter lifetime end time (seconds)');
        const m_nControlPointNumber = this.getParameter('control_point_number');
        const m_nFieldInput = this.getParameter('input field');
        const m_flInputMin = this.getParameter('input minimum');
        const m_flInputMax = this.getParameter('input maximum');
        const m_nFieldOutput = this.getParameter('output field');
        const m_vecOutputMin = this.getParameter('output minimum');
        const m_vecOutputMax = this.getParameter('output maximum');
        const m_bLocalCoords = this.getParameter('use local system');
        if ((m_flStartTime != -1) && (m_flStartTime != -1) && ((particle.currentTime < m_flStartTime) || (particle.currentTime >= m_flEndTime))) {
            return;
        }
        const input = particle.getField(m_nFieldInput);
        tempVec3$d[0] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[0], m_vecOutputMax[0]);
        tempVec3$d[1] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[1], m_vecOutputMax[1]);
        tempVec3$d[2] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[2], m_vecOutputMax[2]);
        const cp = this.particleSystem.getControlPoint(m_nControlPointNumber);
        if (m_nFieldOutput == 0) { // Position
            if (!m_bLocalCoords) {
                add$5(tempVec3$d, cp.getWorldPosition(tempVec3_2$3), tempVec3$d);
            }
            else {
                if (cp) {
                    cp.getWorldQuaternion(tempQuat$4);
                    transformQuat$1(tempVec3$d, tempVec3$d, tempQuat$4);
                    add$5(tempVec3$d, cp.getWorldPosition(tempVec3_2$3), tempVec3$d);
                }
                particle.setField(0, tempVec3$d); //position
                particle.setField(2, tempVec3$d); //previous position
            }
        }
        else {
            throw 'code me';
        }
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RemapScalarToVector);

class RotationRandom extends SourceEngineParticleOperator {
    static functionName = 'Rotation Random';
    constructor() {
        super();
        this.addParam('rotation_initial', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_offset_min', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_offset_max', PARAM_TYPE_FLOAT, 360.0);
        //	DMXELEMENT_UNPACK_FIELD('rotation_initial', '0', float, m_flDegrees)
        //	DMXELEMENT_UNPACK_FIELD('rotation_offset_min', '0', float, m_flDegreesMin)
        //	DMXELEMENT_UNPACK_FIELD('rotation_offset_max', '360', float, m_flDegreesMax)
        //	DMXELEMENT_UNPACK_FIELD('rotation_random_exponent', '1', float, m_flRotationRandExponent)
    }
    doInit(particle, elapsedTime) {
        const rotation_initial = this.getParameter('rotation_initial');
        const rotation_offset_min = this.getParameter('rotation_offset_min');
        const rotation_offset_max = this.getParameter('rotation_offset_max');
        //TODO :exponent
        const rotation = (rotation_initial + (rotation_offset_max - rotation_offset_min) * Math.random() + rotation_offset_min) * DEG_TO_RAD;
        particle.setInitialRoll(rotation);
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RotationRandom);

class RotationSpeedRandom extends SourceEngineParticleOperator {
    static functionName = 'Rotation Speed Random';
    constructor() {
        super();
        this.addParam('rotation_speed_constant', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_speed_random_min', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_speed_random_max', PARAM_TYPE_FLOAT, 360.0);
        this.addParam('rotation_speed_random_exponent', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('randomly_flip_direction', PARAM_TYPE_BOOL, 1);
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_constant', '0', float, m_flDegrees)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_min', '0', float, m_flDegreesMin)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_max', '360', float, m_flDegreesMax)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_exponent', '1', float, m_flRotationRandExponent)
        //	DMXELEMENT_UNPACK_FIELD('randomly_flip_direction', '1', bool, m_bRandomlyFlipDirection)
    }
    doInit(particle, elapsedTime) {
        const m_flDegrees = this.getParameter('rotation_speed_constant');
        const m_flDegreesMin = this.getParameter('rotation_speed_random_min');
        const m_flDegreesMax = this.getParameter('rotation_speed_random_max');
        const randomly_flip_direction = this.getParameter('randomly_flip_direction');
        const m_flRotationRandExponent = this.getParameter('rotation_speed_random_exponent');
        const m_flRadians = m_flDegrees * DEG_TO_RAD;
        const m_flRadiansMin = m_flDegreesMin * DEG_TO_RAD;
        const m_flRadiansMax = m_flDegreesMax * DEG_TO_RAD;
        let rotationSpeed = m_flRadians + RandomFloatExp(m_flRadiansMin, m_flRadiansMax, m_flRotationRandExponent);
        if (randomly_flip_direction == 1 && Math.random() > 0.5) {
            rotationSpeed = -rotationSpeed;
        }
        particle.rotationSpeedRoll = rotationSpeed;
    }
}
SourceEngineParticleOperators.registerOperator(RotationSpeedRandom);

class RotationYawFlipRandom extends SourceEngineParticleOperator {
    static functionName = 'Rotation Yaw Flip Random';
    constructor() {
        super();
        this.addParam('Flip Percentage', PARAM_TYPE_FLOAT, 0.5);
        //DMXELEMENT_UNPACK_FIELD('Flip Percentage', '.5', float, m_flPercent)
    }
    doInit(particle, elapsedTime) {
        const flip_percent = this.getParameter('Flip Percentage') || 0.5;
        particle.rotationYaw += (Math.random() < flip_percent) ? 180 : 0;
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(RotationYawFlipRandom);

class RotationYawRandom extends SourceEngineParticleOperator {
    static functionName = 'Rotation Yaw Random';
    constructor() {
        super();
        this.addParam('Percentage', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('yaw_offset_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('yaw_offset_max', PARAM_TYPE_FLOAT, 360);
    }
    doInit(particle, elapsedTime) {
        this.getParameter('Percentage') ?? 0.5; //TODO
        const yaw_offset_min = this.getParameter('yaw_offset_min') ?? 0;
        const yaw_offset_max = this.getParameter('yaw_offset_max') ?? 360;
        const yaw_initial = this.getParameter('yaw_initial') ?? 0;
        particle.rotationYaw = yaw_initial + (yaw_offset_max - yaw_offset_min) * Math.random() + yaw_offset_min;
    }
}
SourceEngineParticleOperators.registerOperator(RotationYawRandom);

class SequenceRandom extends SourceEngineParticleOperator {
    static functionName = 'Sequence Random';
    constructor() {
        super();
        this.addParam('sequence_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('sequence_max', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const sequence_min = this.getParameter('sequence_min');
        const sequence_max = this.getParameter('sequence_max');
        const sequence = Math.round((sequence_max - sequence_min) * Math.random()) + sequence_min;
        particle.setInitialSequence(sequence);
    }
}
SourceEngineParticleOperators.registerOperator(SequenceRandom);

class TrailLengthRandom extends SourceEngineParticleOperator {
    static functionName = 'Trail Length Random';
    constructor() {
        super();
        this.addParam('length_min', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length_max', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length_random_exponent', PARAM_TYPE_FLOAT, 1);
        //	DMXELEMENT_UNPACK_FIELD('length_min', '0.1', float, m_flMinLength)
        //	DMXELEMENT_UNPACK_FIELD('length_max', '0.1', float, m_flMaxLength)
        //	DMXELEMENT_UNPACK_FIELD('length_random_exponent', '1', float, m_flLengthRandExponent)
    }
    doInit(particle, elapsedTime) {
        const length_min = this.getParameter('length_min');
        const length_max = this.getParameter('length_max');
        const length_random_exponent = this.getParameter('length_random_exponent');
        particle.trailLength = RandomFloatExp(length_min, length_max, length_random_exponent);
    }
}
SourceEngineParticleOperators.registerOperator(TrailLengthRandom);

const Four_Zeros = 0;
const Four_Ones = 1;
const Four_Twos = 2;
const Four_PointFives = 0.5;
function CmpGtSIMD(a, b) {
    return a > b;
}
function CmpGeSIMD(a, b) {
    return a >= b;
}
function CmpLtSIMD(a, b) {
    return a < b;
}
function AndSIMD(a, b) {
    return a && b;
}
function MulSIMD(a, b) {
    return a * b;
}
function DivSIMD(a, b) {
    return a / b;
}
function AddSIMD(a, b) {
    return a + b;
}
function SubSIMD(a, b) {
    return a - b;
}
function ReciprocalEstSIMD(a) {
    return 1 / a;
}
function ReciprocalSIMD(a) {
    return 1 / a;
}
function MaxSIMD(a, b) {
    return Math.max(a, b);
}
function MinSIMD(a, b) {
    return Math.min(a, b);
}
function BiasSIMD(val, precalc_param) {
    // similar to bias function except pass precalced bias value from calling PreCalcBiasParameter.
    // !!speed!! use reciprocal est?
    // !!speed!! could save one op by precalcing _2_ values
    return DivSIMD(val, AddSIMD(MulSIMD(precalc_param, SubSIMD(Four_Ones, val)), Four_Ones));
}
function MaskedAssign(ReplacementMask, NewValue, OldValue) {
    // TODO: params are vec4
    return ReplacementMask ? NewValue : OldValue;
    /*return OrSIMD(
        AndSIMD(ReplacementMask, NewValue),
        AndNotSIMD(ReplacementMask, OldValue));*/
}
function SinEst01SIMD(val) {
    return Math.sin(val * Math.PI);
}
function SimpleSplineRemapValWithDeltasClamped(val, A, BMinusA, OneOverBMinusA, C, DMinusC) {
    //	if (A == B)
    //		return val >= B ? D : C;
    let cVal = (val - A) * OneOverBMinusA; //fltx4 cVal = MulSIMD(SubSIMD(val, A), OneOverBMinusA);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //Clamp(cVal, 0.0, 1.0);//cVal = MinSIMD(Four_Ones, MaxSIMD(Four_Zeros, cVal));
    return C + DMinusC * SimpleSpline(cVal); //AddSIMD(C, MulSIMD(DMinusC, SimpleSpline(cVal)));
}

const perm_a = [
    66, 147, 106, 213, 89, 115, 239, 25, 171, 175, 9, 114, 141, 226, 118, 128, 41, 208, 4, 56,
    180, 248, 43, 82, 246, 219, 94, 245, 133, 131, 222, 103, 160, 130, 168, 145, 238, 38, 23, 6,
    236, 67, 99, 2, 70, 232, 80, 209, 1, 3, 68, 65, 102, 210, 13, 73, 55, 252, 187, 170, 22, 36,
    52, 181, 117, 163, 46, 79, 166, 224, 148, 75, 113, 95, 156, 185, 220, 164, 51, 142, 161, 35,
    206, 251, 45, 136, 197, 190, 132, 32, 218, 127, 63, 27, 137, 93, 242, 20, 189, 108, 183,
    122, 139, 191, 249, 253, 87, 98, 69, 0, 144, 64, 24, 214, 97, 116, 158, 42, 107, 15, 53, 212,
    83, 111, 152, 240, 74, 237, 62, 77, 205, 149, 26, 151, 178, 204, 91, 176, 234, 49, 154, 203,
    33, 221, 125, 134, 165, 124, 86, 39, 37, 60, 150, 157, 179, 109, 110, 44, 159, 153, 5, 100,
    10, 207, 40, 186, 96, 215, 143, 162, 230, 184, 101, 54, 174, 247, 76, 59, 241, 223, 192, 84,
    104, 78, 169, 146, 138, 30, 48, 85, 233, 19, 29, 92, 126, 17, 199, 250, 31, 81, 188, 225, 28,
    112, 88, 11, 182, 173, 211, 129, 194, 172, 14, 120, 200, 167, 135, 12, 177, 227, 229, 155,
    201, 61, 105, 195, 193, 244, 235, 58, 8, 196, 123, 254, 16, 18, 50, 121, 71, 243, 90, 57,
    202, 119, 255, 47, 7, 198, 228, 21, 217, 216, 231, 140, 72, 34
];
const perm_b = [
    123, 108, 201, 64, 40, 75, 24, 221, 137, 110, 191, 142, 9, 69, 230, 83, 7, 247, 51, 54, 115,
    133, 180, 248, 109, 116, 62, 99, 251, 55, 89, 253, 65, 106, 228, 167, 131, 132, 58, 143,
    97, 102, 163, 202, 149, 234, 12, 117, 174, 94, 121, 74, 32, 113, 20, 60, 159, 182, 204, 29,
    244, 118, 3, 178, 255, 38, 6, 114, 36, 93, 30, 134, 213, 90, 245, 209, 88, 232, 162, 125,
    84, 166, 70, 136, 208, 231, 27, 71, 157, 80, 76, 0, 170, 225, 203, 176, 33, 161, 196, 128,
    252, 236, 246, 2, 138, 1, 250, 197, 77, 243, 218, 242, 19, 164, 68, 212, 14, 237, 144, 63,
    46, 103, 177, 188, 85, 223, 8, 160, 222, 4, 216, 219, 35, 15, 44, 23, 126, 127, 100, 226,
    235, 37, 168, 101, 49, 22, 11, 73, 61, 135, 111, 183, 72, 96, 185, 239, 82, 18, 50, 155,
    186, 153, 17, 233, 146, 156, 107, 5, 254, 10, 192, 198, 148, 207, 104, 13, 124, 48, 95,
    129, 120, 206, 199, 81, 249, 91, 150, 210, 119, 240, 122, 194, 92, 34, 28, 205, 175, 227,
    179, 220, 140, 152, 79, 26, 195, 47, 66, 173, 169, 241, 53, 184, 187, 145, 112, 238, 214,
    147, 98, 171, 229, 200, 151, 25, 67, 78, 189, 217, 130, 224, 57, 172, 59, 41, 43, 16, 105,
    158, 165, 21, 45, 56, 141, 139, 215, 190, 86, 42, 52, 39, 87, 181, 31, 154, 193, 211
];
const perm_c = [
    97, 65, 96, 25, 122, 26, 219, 85, 148, 251, 102, 0, 140, 130, 136, 213, 138, 60, 236, 52,
    178, 131, 115, 183, 144, 78, 147, 168, 39, 45, 169, 70, 57, 146, 67, 142, 252, 216, 28, 54,
    86, 222, 194, 200, 48, 5, 205, 125, 214, 56, 181, 255, 196, 155, 37, 218, 153, 208, 66,
    242, 73, 248, 206, 61, 62, 246, 177, 2, 197, 107, 162, 152, 89, 41, 6, 160, 94, 8, 201, 38,
    235, 228, 165, 93, 111, 239, 74, 231, 121, 47, 166, 221, 157, 64, 77, 244, 29, 105, 150,
    123, 190, 191, 225, 118, 133, 42, 10, 84, 185, 159, 124, 132, 240, 180, 44, 1, 9, 19, 99,
    254, 12, 207, 186, 71, 234, 184, 11, 20, 16, 193, 139, 175, 98, 59, 113, 27, 170, 230, 91,
    187, 46, 156, 249, 108, 195, 171, 114, 14, 188, 82, 192, 233, 24, 32, 241, 87, 164, 90, 43,
    163, 245, 92, 40, 215, 55, 226, 15, 3, 112, 158, 250, 172, 22, 227, 137, 35, 128, 145, 247,
    161, 119, 80, 217, 189, 81, 7, 63, 202, 120, 223, 83, 179, 4, 106, 199, 229, 95, 53, 50, 33,
    182, 72, 143, 23, 243, 75, 18, 173, 141, 167, 198, 204, 58, 174, 237, 17, 129, 238, 127,
    31, 101, 176, 36, 30, 110, 209, 34, 203, 135, 232, 68, 149, 49, 134, 126, 212, 79, 76, 117,
    104, 210, 211, 224, 253, 100, 220, 109, 116, 88, 13, 151, 154, 69, 21, 51, 103
];
const impulse_xcoords = [
    0.788235, 0.541176, 0.972549, 0.082353, 0.352941, 0.811765, 0.286275, 0.752941,
    0.203922, 0.705882, 0.537255, 0.886275, 0.580392, 0.137255, 0.800000, 0.533333,
    0.117647, 0.447059, 0.129412, 0.925490, 0.086275, 0.478431, 0.666667, 0.568627,
    0.678431, 0.313725, 0.321569, 0.349020, 0.988235, 0.419608, 0.898039, 0.219608,
    0.243137, 0.623529, 0.501961, 0.772549, 0.952941, 0.517647, 0.949020, 0.701961,
    0.454902, 0.505882, 0.564706, 0.960784, 0.207843, 0.007843, 0.831373, 0.184314,
    0.576471, 0.462745, 0.572549, 0.247059, 0.262745, 0.694118, 0.615686, 0.121569,
    0.384314, 0.749020, 0.145098, 0.717647, 0.415686, 0.607843, 0.105882, 0.101961,
    0.200000, 0.807843, 0.521569, 0.780392, 0.466667, 0.552941, 0.996078, 0.627451,
    0.992157, 0.529412, 0.407843, 0.011765, 0.709804, 0.458824, 0.058824, 0.819608,
    0.176471, 0.317647, 0.392157, 0.223529, 0.156863, 0.490196, 0.325490, 0.074510,
    0.239216, 0.164706, 0.890196, 0.603922, 0.921569, 0.839216, 0.854902, 0.098039,
    0.686275, 0.843137, 0.152941, 0.372549, 0.062745, 0.474510, 0.486275, 0.227451,
    0.400000, 0.298039, 0.309804, 0.274510, 0.054902, 0.815686, 0.647059, 0.635294,
    0.662745, 0.976471, 0.094118, 0.509804, 0.650980, 0.211765, 0.180392, 0.003922,
    0.827451, 0.278431, 0.023529, 0.525490, 0.450980, 0.725490, 0.690196, 0.941176,
    0.639216, 0.560784, 0.196078, 0.364706, 0.043137, 0.494118, 0.796078, 0.113725,
    0.760784, 0.729412, 0.258824, 0.290196, 0.584314, 0.674510, 0.823529, 0.905882,
    0.917647, 0.070588, 0.862745, 0.345098, 0.913725, 0.937255, 0.031373, 0.215686,
    0.768627, 0.333333, 0.411765, 0.423529, 0.945098, 0.721569, 0.039216, 0.792157,
    0.956863, 0.266667, 0.254902, 0.047059, 0.294118, 0.658824, 0.250980, 1.000000,
    0.984314, 0.756863, 0.027451, 0.305882, 0.835294, 0.513725, 0.360784, 0.776471,
    0.611765, 0.192157, 0.866667, 0.858824, 0.592157, 0.803922, 0.141176, 0.435294,
    0.588235, 0.619608, 0.341176, 0.109804, 0.356863, 0.270588, 0.737255, 0.847059,
    0.050980, 0.764706, 0.019608, 0.870588, 0.933333, 0.784314, 0.549020, 0.337255,
    0.631373, 0.929412, 0.231373, 0.427451, 0.078431, 0.498039, 0.968627, 0.654902,
    0.125490, 0.698039, 0.015686, 0.878431, 0.713725, 0.368627, 0.431373, 0.874510,
    0.403922, 0.556863, 0.443137, 0.964706, 0.909804, 0.301961, 0.035294, 0.850980,
    0.882353, 0.741176, 0.380392, 0.133333, 0.470588, 0.643137, 0.282353, 0.396078,
    0.980392, 0.168627, 0.149020, 0.235294, 0.670588, 0.596078, 0.733333, 0.160784,
    0.376471, 0.682353, 0.545098, 0.482353, 0.745098, 0.894118, 0.188235, 0.329412,
    0.439216, 0.901961, 0.000000, 0.600000, 0.388235, 0.172549, 0.090196, 0.066667
];

function GetLatticePointValue(idx_x, idx_y, idx_z) {
    let ret_idx = perm_a[idx_x & 0xff];
    ret_idx = perm_b[(idx_y + ret_idx) & 0xff];
    ret_idx = perm_c[(idx_z + ret_idx) & 0xff];
    return impulse_xcoords[ret_idx];
}
const MAGIC_NUMBER = 1 << 15;
const Four_MagicNumbers = MAGIC_NUMBER;
const DATAVIEW = new DataView(new ArrayBuffer(4));
const INV_256 = 1 / 256.;
function NoiseSIMD(x, y, z) {
    // use magic to convert to integer index
    /*fltx4 x_idx = AndSIMD( MASK255, AddSIMD( x, Four_MagicNumbers ) );
    fltx4 y_idx = AndSIMD( MASK255, AddSIMD( y, Four_MagicNumbers ) );
    fltx4 z_idx = AndSIMD( MASK255, AddSIMD( z, Four_MagicNumbers ) );*/
    DATAVIEW.setFloat32(0, AddSIMD(x, Four_MagicNumbers), true);
    const x_idx = DATAVIEW.getUint16(0, true);
    DATAVIEW.setFloat32(0, AddSIMD(y, Four_MagicNumbers), true);
    const y_idx = DATAVIEW.getUint16(0, true);
    DATAVIEW.setFloat32(0, AddSIMD(z, Four_MagicNumbers), true);
    const z_idx = DATAVIEW.getUint16(0, true);
    //console.log(x_idx, y_idx, z_idx);
    /*fltx4 lattice000 = Four_Zeros, lattice001 = Four_Zeros, lattice010 = Four_Zeros, lattice011 = Four_Zeros;
    fltx4 lattice100 = Four_Zeros, lattice101 = Four_Zeros, lattice110 = Four_Zeros, lattice111 = Four_Zeros;*/
    let lattice000 = Four_Zeros, lattice001 = Four_Zeros, lattice010 = Four_Zeros, lattice011 = Four_Zeros;
    let lattice100 = Four_Zeros, lattice101 = Four_Zeros, lattice110 = Four_Zeros, lattice111 = Four_Zeros;
    // FIXME: Converting the input vectors to int indices will cause load-hit-stores (48 bytes)
    //        Converting the indexed noise values back to vectors will cause more (128 bytes)
    //        The noise table could store vectors if we chunked it into 2x2x2 blocks.
    //fltx4 xfrac = Four_Zeros, yfrac = Four_Zeros, zfrac = Four_Zeros;
    let xfrac = Four_Zeros, yfrac = Four_Zeros, zfrac = Four_Zeros;
    /*#define DOPASS(i)															\
        {	unsigned int xi = SubInt( x_idx, i );								\
            unsigned int yi = SubInt( y_idx, i );								\
            unsigned int zi = SubInt( z_idx, i );								\
            SubFloat( xfrac, i ) = (xi & 0xff)*(1.0/256.0);						\
            SubFloat( yfrac, i ) = (yi & 0xff)*(1.0/256.0);						\
            SubFloat( zfrac, i ) = (zi & 0xff)*(1.0/256.0);						\
            xi>>=8;																\
            yi>>=8;																\
            zi>>=8;																\
                                                                                \
            SubFloat( lattice000, i ) = GetLatticePointValue( xi,yi,zi );		\
            SubFloat( lattice001, i ) = GetLatticePointValue( xi,yi,zi+1 );		\
            SubFloat( lattice010, i ) = GetLatticePointValue( xi,yi+1,zi );		\
            SubFloat( lattice011, i ) = GetLatticePointValue( xi,yi+1,zi+1 );	\
            SubFloat( lattice100, i ) = GetLatticePointValue( xi+1,yi,zi );		\
            SubFloat( lattice101, i ) = GetLatticePointValue( xi+1,yi,zi+1 );	\
            SubFloat( lattice110, i ) = GetLatticePointValue( xi+1,yi+1,zi );	\
            SubFloat( lattice111, i ) = GetLatticePointValue( xi+1,yi+1,zi+1 );	\
        }*/
    function DOPASS(i) {
        /*unsigned int xi = SubInt( x_idx, i );
        unsigned int yi = SubInt( y_idx, i );
        unsigned int zi = SubInt( z_idx, i );*/
        let xi = x_idx;
        let yi = y_idx;
        let zi = z_idx;
        /*SubFloat( xfrac, i ) = (xi & 0xff)*(1.0/256.0);
        SubFloat( yfrac, i ) = (yi & 0xff)*(1.0/256.0);
        SubFloat( zfrac, i ) = (zi & 0xff)*(1.0/256.0);*/
        xfrac = (xi & 0xff) * INV_256;
        yfrac = (yi & 0xff) * INV_256;
        zfrac = (zi & 0xff) * INV_256;
        xi >>= 8;
        yi >>= 8;
        zi >>= 8;
        /*SubFloat( lattice000, i ) = GetLatticePointValue( xi,yi,zi );
        SubFloat( lattice001, i ) = GetLatticePointValue( xi,yi,zi+1 );
        SubFloat( lattice010, i ) = GetLatticePointValue( xi,yi+1,zi );
        SubFloat( lattice011, i ) = GetLatticePointValue( xi,yi+1,zi+1 );
        SubFloat( lattice100, i ) = GetLatticePointValue( xi+1,yi,zi );
        SubFloat( lattice101, i ) = GetLatticePointValue( xi+1,yi,zi+1 );
        SubFloat( lattice110, i ) = GetLatticePointValue( xi+1,yi+1,zi );
        SubFloat( lattice111, i ) = GetLatticePointValue( xi+1,yi+1,zi+1 );*/
        lattice000 = GetLatticePointValue(xi, yi, zi);
        lattice001 = GetLatticePointValue(xi, yi, zi + 1);
        lattice010 = GetLatticePointValue(xi, yi + 1, zi);
        lattice011 = GetLatticePointValue(xi, yi + 1, zi + 1);
        lattice100 = GetLatticePointValue(xi + 1, yi, zi);
        lattice101 = GetLatticePointValue(xi + 1, yi, zi + 1);
        lattice110 = GetLatticePointValue(xi + 1, yi + 1, zi);
        lattice111 = GetLatticePointValue(xi + 1, yi + 1, zi + 1);
    }
    DOPASS();
    /*DOPASS( 1 );
    DOPASS( 2 );
    DOPASS( 3 );*/
    // now, we have 8 lattice values for each of four points as m128s, and interpolant values for
    // each axis in m128 form in [xyz]frac. Perfom the trilinear interpolation as SIMD ops
    // first, do x interpolation
    /*fltx4 l2d00 = AddSIMD( lattice000, MulSIMD( xfrac, SubSIMD( lattice100, lattice000 ) ) );
    fltx4 l2d01 = AddSIMD( lattice001, MulSIMD( xfrac, SubSIMD( lattice101, lattice001 ) ) );
    fltx4 l2d10 = AddSIMD( lattice010, MulSIMD( xfrac, SubSIMD( lattice110, lattice010 ) ) );
    fltx4 l2d11 = AddSIMD( lattice011, MulSIMD( xfrac, SubSIMD( lattice111, lattice011 ) ) );*/
    const l2d00 = AddSIMD(lattice000, MulSIMD(xfrac, SubSIMD(lattice100, lattice000)));
    const l2d01 = AddSIMD(lattice001, MulSIMD(xfrac, SubSIMD(lattice101, lattice001)));
    const l2d10 = AddSIMD(lattice010, MulSIMD(xfrac, SubSIMD(lattice110, lattice010)));
    const l2d11 = AddSIMD(lattice011, MulSIMD(xfrac, SubSIMD(lattice111, lattice011)));
    // now, do y interpolation
    /*fltx4 l1d0 = AddSIMD( l2d00, MulSIMD( yfrac, SubSIMD( l2d10, l2d00 ) ) );
    fltx4 l1d1 = AddSIMD( l2d01, MulSIMD( yfrac, SubSIMD( l2d11, l2d01 ) ) );*/
    const l1d0 = AddSIMD(l2d00, MulSIMD(yfrac, SubSIMD(l2d10, l2d00)));
    const l1d1 = AddSIMD(l2d01, MulSIMD(yfrac, SubSIMD(l2d11, l2d01)));
    // final z interpolation
    //fltx4 rslt = AddSIMD( l1d0, MulSIMD( zfrac, SubSIMD( l1d1, l1d0 ) ) );
    const rslt = AddSIMD(l1d0, MulSIMD(zfrac, SubSIMD(l1d1, l1d0)));
    // map to 0..1
    return MulSIMD(Four_Twos, SubSIMD(rslt, Four_PointFives));
}

class VelocityNoise extends SourceEngineParticleOperator {
    static functionName = 'Velocity Noise';
    randX = Math.random() * 1000;
    randY = Math.random() * 1000;
    randZ = Math.random() * 1000;
    constructor() {
        super();
        this.addParam('', PARAM_TYPE_INT, 0);
        this.addParam('Control Point Number', PARAM_TYPE_INT, 0);
        this.addParam('Time Noise Coordinate Scale', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('Spatial Noise Coordinate Scale', PARAM_TYPE_FLOAT, 0.01);
        this.addParam('Time Coordinate Offset', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('Spatial Coordinate Offset', PARAM_TYPE_VECTOR, create$4());
        this.addParam('Absolute Value', PARAM_TYPE_VECTOR, create$4());
        this.addParam('Invert Abs Value', PARAM_TYPE_VECTOR, create$4());
        this.addParam('output minimum', PARAM_TYPE_VECTOR, create$4());
        this.addParam('output maximum', PARAM_TYPE_VECTOR, fromValues$4(1, 1, 1));
        this.addParam('Apply Velocity in Local Space (0/1)', PARAM_TYPE_BOOL, false);
        //	DMXELEMENT_UNPACK_FIELD('Control Point Number','0',int,m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('Time Noise Coordinate Scale','1',float,m_flNoiseScale)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Noise Coordinate Scale','0.01',float,m_flNoiseScaleLoc)
        //	DMXELEMENT_UNPACK_FIELD('Time Coordinate Offset','0', float, m_flOffset)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Coordinate Offset','0 0 0', Vector, m_vecOffsetLoc)
        //	DMXELEMENT_UNPACK_FIELD('Absolute Value','0 0 0', Vector, m_vecAbsVal)
        //	DMXELEMENT_UNPACK_FIELD('Invert Abs Value','0 0 0', Vector, m_vecAbsValInv)
        //	DMXELEMENT_UNPACK_FIELD('output minimum','0 0 0', Vector, m_vecOutputMin)
        //	DMXELEMENT_UNPACK_FIELD('output maximum','1 1 1', Vector, m_vecOutputMax)
        //	DMXELEMENT_UNPACK_FIELD('Apply Velocity in Local Space (0/1)','0', bool, m_bLocalSpace)
    }
    doInit(particle, elapsedTime) {
        const m_nControlPointNumber = this.getParameter('Control Point Number');
        const m_flNoiseScale = this.getParameter('Time Noise Coordinate Scale');
        const m_flNoiseScaleLoc = this.getParameter('Spatial Noise Coordinate Scale');
        const m_flOffset = this.getParameter('Time Coordinate Offset');
        const m_vecOffsetLoc = this.getParameter('Spatial Coordinate Offset');
        const m_vecAbsVal = this.getParameter('Absolute Value');
        const m_vecAbsValInv = this.getParameter('Invert Abs Value');
        const m_vecOutputMin = this.getParameter('output minimum');
        const m_vecOutputMax = this.getParameter('output maximum');
        const m_bLocalSpace = this.getParameter('Apply Velocity in Local Space (0/1)');
        //	DMXELEMENT_UNPACK_FIELD('Control Point Number','0',int,m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('Time Noise Coordinate Scale','1',float,m_flNoiseScale)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Noise Coordinate Scale','0.01',float,m_flNoiseScaleLoc)
        //	DMXELEMENT_UNPACK_FIELD('Time Coordinate Offset','0', float, m_flOffset)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Coordinate Offset','0 0 0', Vector, m_vecOffsetLoc)
        //	DMXELEMENT_UNPACK_FIELD('Absolute Value','0 0 0', Vector, m_vecAbsVal)
        //	DMXELEMENT_UNPACK_FIELD('Invert Abs Value','0 0 0', Vector, m_vecAbsValInv)
        //	DMXELEMENT_UNPACK_FIELD('output minimum','0 0 0', Vector, m_vecOutputMin)
        //	DMXELEMENT_UNPACK_FIELD('output maximum','1 1 1', Vector, m_vecOutputMax)
        //	DMXELEMENT_UNPACK_FIELD('Apply Velocity in Local Space (0/1)','0', bool, m_bLocalSpace)
        let flAbsScaleX, flAbsScaleY, flAbsScaleZ;
        flAbsScaleX = 0.5;
        flAbsScaleY = 0.5;
        flAbsScaleZ = 0.5;
        // Set up single if check for absolute value inversion inside the loop
        const m_bNoiseAbs = (m_vecAbsValInv[0] != 0.0) || (m_vecAbsValInv[1] != 0.0) || (m_vecAbsValInv[2] != 0.0);
        // Set up values for more optimal absolute value calculations inside the loop
        if (m_vecAbsVal[0] != 0.0) {
            flAbsScaleX = 1.0;
        }
        if (m_vecAbsVal[1] != 0.0) {
            flAbsScaleY = 1.0;
        }
        if (m_vecAbsVal[2] != 0.0) {
            flAbsScaleZ = 1.0;
        }
        const ValueScaleX = (flAbsScaleX * (m_vecOutputMax[0] - m_vecOutputMin[0]));
        const ValueBaseX = (m_vecOutputMin[0] + ((1.0 - flAbsScaleX) * (m_vecOutputMax[0] - m_vecOutputMin[0])));
        const ValueScaleY = (flAbsScaleY * (m_vecOutputMax[1] - m_vecOutputMin[1]));
        const ValueBaseY = (m_vecOutputMin[1] + ((1.0 - flAbsScaleY) * (m_vecOutputMax[1] - m_vecOutputMin[1])));
        const ValueScaleZ = (flAbsScaleZ * (m_vecOutputMax[2] - m_vecOutputMin[2]));
        const ValueBaseZ = (m_vecOutputMin[2] + ((1.0 - flAbsScaleZ) * (m_vecOutputMax[2] - m_vecOutputMin[2])));
        const fl4ValueBaseX = ValueBaseX;
        const fl4ValueBaseY = ValueBaseY;
        const fl4ValueBaseZ = ValueBaseZ;
        const fl4ValueScaleX = ValueScaleX;
        const fl4ValueScaleY = ValueScaleY;
        const fl4ValueScaleZ = ValueScaleZ;
        const CoordScale = m_flNoiseScale;
        const CoordScaleLoc = m_flNoiseScaleLoc;
        const ofs_y = fromValues$4(100000.5, 300000.25, 9000000.75);
        const ofs_z = fromValues$4(110000.25, 310000.75, 9100000.5);
        /*size_t attr_stride;

        const FourVectors *xyz = pParticles->Get4VAttributePtr(PARTICLE_ATTRIBUTE_XYZ, &attr_stride);
        xyz += attr_stride * start_block;
        FourVectors *pxyz = pParticles->Get4VAttributePtrForWrite(PARTICLE_ATTRIBUTE_PREV_XYZ, &attr_stride);
        pxyz += attr_stride * start_block;
        const fltx4 *pCreationTime = pParticles->GetM128AttributePtr(PARTICLE_ATTRIBUTE_CREATION_TIME, &attr_stride);
        pCreationTime += attr_stride * start_block;*/
        // setup
        /*fltx4 fl4Offset = ReplicateX4(m_flOffset);*/
        clone$4(m_vecOffsetLoc); //TODO use it ?
        /*CParticleSIMDTransformation CPTransform;
        float flCreationTime = SubFloat(*pCreationTime, 0);
        pParticles->GetControlPointTransformAtTime(m_nControlPointNumber, flCreationTime, &CPTransform);*/
        //while(n_blocks--)
        {
            const fvCoordLoc = clone$4(particle.position);
            add$5(fvCoordLoc, fvCoordLoc, fvCoordLoc); //fvCoordLoc += fvOffsetLoc;
            const c = particle.cTime * 30 + m_flOffset; //vec3.add(vec3.create(), [particle.cTime, particle.cTime, particle.cTime], m_flOffset);
            const fvCoord = fromValues$4(c, c, c);
            //fvCoord[0] = AddSIMD(*pCreationTime, fl4Offset);
            //fvCoord[1] = AddSIMD(*pCreationTime, fl4Offset);
            //fvCoord[2] = AddSIMD(*pCreationTime, fl4Offset);
            scale$5(fvCoordLoc, fvCoordLoc, CoordScaleLoc); //fvCoordLoc *= CoordScaleLoc;
            scale$5(fvCoord, fvCoord, CoordScale * 0.01); //fvCoord *= CoordScale;
            add$5(fvCoord, fvCoord, fvCoordLoc); //fvCoord += fvCoordLoc;
            const fvCoord2 = clone$4(fvCoord);
            let fvOffsetTemp = clone$4(ofs_y);
            //fvOffsetTemp.DuplicateVector(ofs_y);
            add$5(fvCoord2, fvCoord2, fvOffsetTemp); //fvCoord2 +=	fvOffsetTemp;
            const fvCoord3 = clone$4(fvCoord);
            fvOffsetTemp = clone$4(ofs_z);
            //fvOffsetTemp.DuplicateVector(ofs_z);
            add$5(fvCoord3, fvCoord3, fvOffsetTemp); //fvCoord3 += fvOffsetTemp;
            let fl4NoiseX = NoiseSIMD(fvCoord[0], fvCoord[1], fvCoord[2]);
            let fl4NoiseY = NoiseSIMD(fvCoord2[0], fvCoord2[1], fvCoord2[2]);
            let fl4NoiseZ = NoiseSIMD(fvCoord3[0], fvCoord3[1], fvCoord3[2]);
            //console.log(fl4NoiseX/*, fl4NoiseY, fl4NoiseZ*/);
            //fl4NoiseX = fl4NoiseX & fl4AbsValX;//AndSIMD (fl4NoiseX, fl4AbsValX);
            //fl4NoiseY = fl4NoiseY & fl4AbsValY;//AndSIMD (fl4NoiseY, fl4AbsValY);
            //fl4NoiseZ = fl4NoiseZ & fl4AbsValZ;//AndSIMD (fl4NoiseZ, fl4AbsValZ);
            //fl4NoiseX = Math.random();
            //fl4NoiseY = Math.random();
            //fl4NoiseZ = Math.random();
            if (m_bNoiseAbs) {
                if (m_vecAbsValInv[0] != 0.0) {
                    fl4NoiseX = 1.0 - fl4NoiseX; //SubSIMD(Four_Ones, fl4NoiseX);
                }
                if (m_vecAbsValInv[1] != 0.0) {
                    fl4NoiseY = 1.0 - fl4NoiseY; //SubSIMD(Four_Ones, fl4NoiseY);
                }
                if (m_vecAbsValInv[2] != 0.0) {
                    fl4NoiseZ = 1.0 - fl4NoiseZ; //SubSIMD(Four_Ones, fl4NoiseZ);
                }
            }
            const fvOffset = create$4();
            fvOffset[0] = fl4ValueBaseX + fl4ValueScaleX * fl4NoiseX; //AddSIMD(fl4ValueBaseX, (MulSIMD(fl4ValueScaleX , fl4NoiseX)));
            fvOffset[1] = fl4ValueBaseY + fl4ValueScaleY * fl4NoiseY; //AddSIMD(fl4ValueBaseY, (MulSIMD(fl4ValueScaleY , fl4NoiseY)));
            fvOffset[2] = fl4ValueBaseZ + fl4ValueScaleZ * fl4NoiseZ; //AddSIMD(fl4ValueBaseZ, (MulSIMD(fl4ValueScaleZ , fl4NoiseZ)));
            //TODO fvOffset *= pParticles->m_flPreviousDt;
            if (m_bLocalSpace) {
                //CPTransform.VectorRotate(fvOffset);
                //TODO
                const cp = particle.system.getControlPoint(m_nControlPointNumber);
                if (cp) {
                    transformQuat$1(fvOffset, fvOffset, cp.getWorldQuaternion());
                    //vec3.add(randpos, randpos, cp.getOrigin());
                }
            }
            //console.log(fvOffset);
            add$5(particle.velocity, particle.velocity, fvOffset);
            scaleAndAdd$2(particle.prevPosition, particle.prevPosition, fvOffset, -elapsedTime);
            //vec3.scaleAndAdd(particle.velocity, particle.velocity, fvOffset, -10);
            //vec3.scaleAndAdd(particle.prevPosition, particle.prevPosition, fvOffset, -this.particleSystem.elapsedTime);
            //vec3.scaleAndAdd(particle.prevPosition, particle.position, fvOffset, 0.1);
            //vec3.scaleAndAdd(particle.prevPosition, particle.position, [0, 0, 1], 0.1);
            //particle.prevPosition = vec3.create();
        }
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(VelocityNoise);

let identityVec3 = create$4();
const tempVec3$c = create$4();
class VelocityRandom$1 extends SourceEngineParticleOperator {
    static functionName = 'Velocity Random';
    constructor() {
        super();
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('random_speed_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('random_speed_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('speed_in_local_coordinate_system_min', PARAM_TYPE_VECTOR, create$4());
        this.addParam('speed_in_local_coordinate_system_max', PARAM_TYPE_VECTOR, create$4());
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('random_speed_min', '0', float, m_fSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('random_speed_max', '0', float, m_fSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_min', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_max', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMax)
    }
    doInit(particle, elapsedTime) {
        const speed_in_local_coordinate_system_min = this.getParameter('speed_in_local_coordinate_system_min');
        const speed_in_local_coordinate_system_max = this.getParameter('speed_in_local_coordinate_system_max');
        const random_speed_min = this.getParameter('random_speed_min');
        const random_speed_max = this.getParameter('random_speed_max');
        const m_nControlPointNumber = this.getParameter('control_point_number');
        const randomVector = create$4();
        const randomSpeed = (random_speed_max - random_speed_min) * Math.random() + random_speed_min;
        if (exactEquals$4(speed_in_local_coordinate_system_min, identityVec3) &&
            exactEquals$4(speed_in_local_coordinate_system_max, identityVec3)) {
            random$5(randomVector); //randomVector.randomizeUnit();
        }
        else {
            vec3RandomBox(randomVector, speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max); //randomVector.randomize(speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max);
        }
        if (randomSpeed != 0) {
            random$5(tempVec3$c, randomSpeed);
            add$5(randomVector, randomVector, tempVec3$c);
        }
        const cp = particle.system.getControlPoint(m_nControlPointNumber);
        if (cp) {
            transformQuat$1(randomVector, randomVector, cp.getWorldQuaternion());
        }
        //vec3.copy(particle.velocity, randomVector);
        //vec3.add(particle.velocity, particle.velocity, randomVector);
        scale$5(randomVector, randomVector, -elapsedTime);
        add$5(particle.prevPosition, particle.prevPosition, randomVector);
    }
    initMultipleOverride() {
        return true;
    }
}
SourceEngineParticleOperators.registerOperator(VelocityRandom$1);

class AlphaFadeAndDecay extends SourceEngineParticleOperator {
    static functionName = 'Alpha Fade and Decay';
    constructor() {
        super();
        this.addParam('start_alpha', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('end_alpha', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('start_fade_in_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_fade_in_time', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('start_fade_out_time', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('end_fade_out_time', PARAM_TYPE_FLOAT, 1.0);
    }
    doOperate(particle, elapsedTime) {
        const start_alpha = this.getParameter('start_alpha');
        const end_alpha = this.getParameter('end_alpha');
        const m_flStartFadeInTime = this.getParameter('start_fade_in_time');
        const m_flEndFadeInTime = this.getParameter('end_fade_in_time');
        const m_flStartFadeOutTime = this.getParameter('start_fade_out_time');
        const m_flEndFadeOutTime = this.getParameter('end_fade_out_time');
        const proportionOfLife = particle.currentTime / particle.timeToLive;
        const fl4FadeInDuration = m_flEndFadeInTime - m_flStartFadeInTime;
        const fl4OOFadeInDuration = 1.0 / fl4FadeInDuration;
        const fl4FadeOutDuration = m_flEndFadeOutTime - m_flStartFadeOutTime;
        const fl4OOFadeOutDuration = 1.0 / fl4FadeOutDuration;
        let fl4Goal, fl4NewAlpha;
        switch (true) {
            case proportionOfLife <= m_flStartFadeInTime:
                //				alpha = start_alpha;
                break;
            case proportionOfLife < m_flEndFadeInTime:
                fl4Goal = particle.startAlpha * start_alpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, m_flStartFadeInTime, fl4FadeInDuration, fl4OOFadeInDuration, fl4Goal, particle.startAlpha - fl4Goal);
                particle.alpha = fl4NewAlpha;
                break;
            case proportionOfLife < m_flStartFadeOutTime:
                break;
            case proportionOfLife < m_flEndFadeOutTime:
                fl4Goal = particle.startAlpha * end_alpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, m_flStartFadeOutTime, fl4FadeOutDuration, fl4OOFadeOutDuration, particle.startAlpha, fl4Goal - particle.startAlpha);
                particle.alpha = fl4NewAlpha;
                break;
        }
        //alpha *= particle.startAlpha;
        //particle.alpha = alpha;
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
SourceEngineParticleOperators.registerOperator(AlphaFadeAndDecay);

class AlphaFadeInRandom extends SourceEngineParticleOperator {
    static functionName = 'Alpha Fade In Random';
    constructor() {
        super();
        this.addParam('fade in time min', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade in time max', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade in time exponent', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
    }
    doOperate(particle, elapsedTime) {
        const proportional = this.getParameter('proportional 0/1');
        const fade_in_time_min = this.getParameter('fade in time min');
        const fade_in_time_max = this.getParameter('fade in time max');
        const m_flFadeInTimeExp = this.getParameter('fade in time exponent');
        //const fade_in_time = (fade_in_time_max - fade_in_time_min) * Math.random() + fade_in_time_min;
        const fade_in_time = (fade_in_time_max - fade_in_time_min) * Math.pow(ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset), m_flFadeInTimeExp) + fade_in_time_min;
        let time;
        if (proportional == 1 && particle.timeToLive) {
            time = particle.currentTime / particle.timeToLive;
        }
        else {
            time = particle.currentTime;
        }
        let d, d2;
        if (time < fade_in_time) {
            d = fade_in_time;
            if (d != 0) {
                d2 = particle.startAlpha;
                particle.alpha = d2 / d * (time);
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(AlphaFadeInRandom);

class AlphaFadeOutRandom extends SourceEngineParticleOperator {
    static functionName = 'Alpha Fade Out Random';
    constructor() {
        super();
        this.addParam('fade out time min', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade out time max', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade out time exponent', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
        this.addParam('fade bias', PARAM_TYPE_FLOAT, 0.5); //Neutral bias
    }
    doOperate(particle, elapsedTime) {
        const proportional = this.getParameter('proportional 0/1');
        const fade_out_time_min = this.getParameter('fade out time min');
        const fade_out_time_max = this.getParameter('fade out time max');
        this.getParameter('fade bias');
        const m_flFadeOutTimeExp = this.getParameter('fade in time exponent');
        const fade_out_time = (fade_out_time_max - fade_out_time_min) * Math.pow(ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset), m_flFadeOutTimeExp) + fade_out_time_min;
        let time;
        let start_fade_out_time;
        let lifeSpan;
        if (proportional == 1) {
            time = particle.currentTime / particle.timeToLive;
            start_fade_out_time = 1 - fade_out_time;
            lifeSpan = 1 - time;
        }
        else {
            time = particle.currentTime;
            start_fade_out_time = particle.timeToLive - fade_out_time;
            lifeSpan = particle.timeToLive - time;
        }
        let alpha = 0;
        switch (true) {
            case time > start_fade_out_time:
                const d = fade_out_time;
                if (d != 0) {
                    const d2 = particle.startAlpha;
                    alpha = d2 * (lifeSpan);
                }
                break;
            default:
                alpha = particle.startAlpha;
                break;
        }
        particle.alpha = alpha;
    }
}
SourceEngineParticleOperators.registerOperator(AlphaFadeOutRandom);

class ColorFade extends SourceEngineParticleOperator {
    static functionName = 'Color Fade';
    constructor() {
        super();
        this.addParam('color_fade', PARAM_TYPE_COLOR, WHITE);
        this.addParam('fade_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('fade_end_time', PARAM_TYPE_FLOAT, 1);
        this.addParam('ease_in_and_out', PARAM_TYPE_BOOL, 1);
        //	DMXELEMENT_UNPACK_FIELD('color_fade', '255 255 255 255', Color, m_ColorFade)
        //	DMXELEMENT_UNPACK_FIELD('fade_start_time', '0', float, m_flFadeStartTime)
        //	DMXELEMENT_UNPACK_FIELD('fade_end_time', '1', float, m_flFadeEndTime)
        //	DMXELEMENT_UNPACK_FIELD('ease_in_and_out', '1', bool, m_bEaseInOut)
    }
    doOperate(particle, elapsedTime) {
        const color_fade = this.getParameter('color_fade');
        const fade_start_time = this.getParameter('fade_start_time');
        const fade_end_time = this.getParameter('fade_end_time');
        const m_bEaseInOut = this.getParameter('ease_in_and_out');
        if (fade_start_time == fade_end_time) {
            return;
        }
        const ooInRange = 1 / (fade_end_time - fade_start_time);
        const color = new Color().setColor(particle.initialColor);
        const flLifeTime = particle.currentTime / particle.timeToLive;
        //if (proportionOfLife>1)proportionOfLife=1;
        /*
        if (proportionOfLife<fade_start_time) {
            return;
        }
            */
        let T = (flLifeTime - fade_start_time) * ooInRange;
        T = clamp(T, 0, 1);
        if (m_bEaseInOut) {
            T = SimpleSpline(T);
        }
        particle.color.r = (color_fade.r - color.r) * T + color.r;
        particle.color.g = (color_fade.g - color.g) * T + color.g;
        particle.color.b = (color_fade.b - color.b) * T + color.b;
        /*
                    if (proportionOfLife < fade_end_time) {
                        const a = (proportionOfLife - fade_start_time) / (fade_end_time - fade_start_time);
                        particle.color.r = (color_fade.r - color.r) * a + color.r;
                        particle.color.g = (color_fade.g - color.g) * a + color.g;
                        particle.color.b = (color_fade.b - color.b) * a + color.b;

                        return;
                    }*/
    }
}
SourceEngineParticleOperators.registerOperator(ColorFade);

class LifespanDecay$1 extends SourceEngineParticleOperator {
    static functionName = 'Lifespan Decay';
    constructor() {
        super();
    }
    doOperate(particle, elapsedTime) {
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
SourceEngineParticleOperators.registerOperator(LifespanDecay$1);

const tempVec3$b = create$4();
const tempMat4 = create$5();
const IDENTITY_MAT4$2 = create$5();
class LockToBone$1 extends SourceEngineParticleOperator {
    static functionName = 'Movement Lock to Bone';
    constructor() {
        super();
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
    }
    doOperate(particle, elapsedTime) {
        let controlPoint = particle.system.getControlPoint(this.getParameter('control_point_number'));
        if (controlPoint) {
            // TODO : Actually we should get the model parenting the control point
            let controllingModel = controlPoint.parentModel;
            if (controllingModel) {
                let bones = particle.bones;
                let initialVec = particle.initialVec;
                if (bones && initialVec) {
                    tempMat4[0] = 0;
                    tempMat4[1] = 0;
                    tempMat4[2] = 0;
                    tempMat4[4] = 0;
                    tempMat4[5] = 0;
                    tempMat4[6] = 0;
                    tempMat4[8] = 0;
                    tempMat4[9] = 0;
                    tempMat4[10] = 0;
                    tempMat4[12] = 0;
                    tempMat4[13] = 0;
                    tempMat4[14] = 0;
                    copy$4(tempVec3$b, initialVec);
                    for (let [bone, boneWeight] of bones) {
                        let boneMat;
                        if (bone) {
                            boneMat = fromRotationTranslationScale(create$5(), bone.worldQuat, bone.worldPos, bone.worldScale);
                        }
                        else {
                            boneMat = IDENTITY_MAT4$2;
                        }
                        if (boneWeight && boneMat) {
                            tempMat4[0] += boneWeight * boneMat[0];
                            tempMat4[1] += boneWeight * boneMat[1];
                            tempMat4[2] += boneWeight * boneMat[2];
                            tempMat4[4] += boneWeight * boneMat[4];
                            tempMat4[5] += boneWeight * boneMat[5];
                            tempMat4[6] += boneWeight * boneMat[6];
                            tempMat4[8] += boneWeight * boneMat[8];
                            tempMat4[9] += boneWeight * boneMat[9];
                            tempMat4[10] += boneWeight * boneMat[10];
                            tempMat4[12] += boneWeight * boneMat[12];
                            tempMat4[13] += boneWeight * boneMat[13];
                            tempMat4[14] += boneWeight * boneMat[14];
                        }
                    }
                    transformMat4$2(tempVec3$b, tempVec3$b, tempMat4);
                    if (particle.initialVecOffset) {
                        add$5(tempVec3$b, tempVec3$b, particle.initialVecOffset);
                    }
                    copy$4(particle.prevPosition, particle.position);
                    copy$4(particle.position, tempVec3$b);
                }
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(LockToBone$1);

const tempVec3$a = create$4();
const tempVec3_2$2 = create$4();
const tempVec3_3 = create$4();
class MovementBasic extends SourceEngineParticleOperator {
    static functionName = 'Movement Basic';
    constructor() {
        super();
        this.addParam('drag', PARAM_TYPE_FLOAT, 0);
        this.addParam('gravity', PARAM_TYPE_VECTOR, create$4());
        this.addParam('max constraint passes', PARAM_TYPE_INT, 3);
    }
    doOperate(particle, elapsedTime) {
        const drag = this.getParameter('drag');
        const gravity = this.getParameter('gravity');
        this.getParameter('max constraint passes'); //TODO
        //ReplicateX4((pParticles->m_flDt / pParticles->m_flPreviousDt) * ExponentialDecay((1.0f-max(0.0,m_fDrag)), (1.0f/30.0f), pParticles->m_flDt));
        //fltx4 adj_dt = ReplicateX4((pParticles->m_flDt / pParticles->m_flPreviousDt) * ExponentialDecay((1.0f-max(0.0,m_fDrag)), (1.0f/30.0f), pParticles->m_flDt));
        let adj_dt = (elapsedTime / this.particleSystem.previousElapsedTime) * ExponentialDecay((1.0 - Math.max(0.0, drag)), (1.0 / 30.0), elapsedTime);
        /*if (particle.previousElapsedTime) {
            adj_dt *= (elapsedTime / particle.previousElapsedTime);
        }
        particle.previousElapsedTime = elapsedTime;*/
        const accumulatedForces = copy$4(tempVec3$a, gravity);
        //vec3.scale(accumulatedForces, accumulatedForces, 0.5);
        /*if (elapsedTime) {
            vec3.scale(accumulatedForces, accumulatedForces, 1/elapsedTime);
        }*/
        for (let force of this.particleSystem.forces.values()) {
            //const force = this.particleSystem.forces[j];
            force.forceParticle(particle, elapsedTime, accumulatedForces);
        }
        //elapsedTime *= 0.001;
        const accFactor = scale$5(tempVec3_2$2, accumulatedForces, elapsedTime * elapsedTime);
        const vecTemp = sub$2(tempVec3_3, particle.position, particle.prevPosition);
        scale$5(vecTemp, vecTemp, adj_dt);
        add$5(vecTemp, vecTemp, accFactor);
        copy$4(particle.prevPosition, particle.position);
        add$5(particle.position, particle.position, vecTemp);
        this.particleSystem.stepConstraints(particle);
    }
}
SourceEngineParticleOperators.registerOperator(MovementBasic);
SourceEngineParticleOperators.registerOperator('basic movement', MovementBasic);

class MovementLocktoControlPoint extends SourceEngineParticleOperator {
    static functionName = 'Movement Lock to Control Point';
    static once;
    constructor() {
        super();
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('start_fadeout_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_fadeout_max', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_fadeout_exponent', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_fadeout_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('end_fadeout_max', PARAM_TYPE_FLOAT, 1);
        this.addParam('lock rotation', PARAM_TYPE_BOOL, false);
        /*'start_fadeout_min' 'float' '0.1000000015'
        'start_fadeout_max' 'float' '0.200000003'
        'start_fadeout_exponent' 'float' '1'
        'end_fadeout_min' 'float' '0.3000000119'
        'end_fadeout_max' 'float' '0.400000006'*/
    }
    doOperate(particle, elapsedTime) {
        if (!MovementLocktoControlPoint.once) {
            MovementLocktoControlPoint.once = true;
        }
        //return;
        if (particle.posLockedToCP == -1) {
            return;
        }
        this.getParameter('start_fadeout_min');
        this.getParameter('start_fadeout_max');
        const end_fadeout_min = this.getParameter('end_fadeout_min');
        const end_fadeout_max = this.getParameter('end_fadeout_max');
        const lockRotation = this.getParameter('lock rotation');
        const end_fadeout = (end_fadeout_max - end_fadeout_min) * Math.random() + end_fadeout_min;
        switch (true) {
            case end_fadeout == 1:
                break;
            case particle.proportionOfLife >= end_fadeout:
                particle.posLockedToCP = -1;
                break;
        }
        const cpNumber = this.getParameter('control_point_number');
        const distanceFadeRange = this.getParameter('distance fade range');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            if (!particle.initialCPPosition) {
                particle.initialCPPosition = cp.getWorldPosition();
            }
            else {
                particle.initialCPPosition = clone$4(particle.cpPosition);
            }
            if (!particle.initialCPQuaternion) {
                particle.initialCPQuaternion = cp.getWorldQuaternion();
            }
            else {
                particle.initialCPQuaternion = clone$2(particle.cpOrientation);
            }
            particle.cpPosition = cp.getWorldPosition();
            particle.cpOrientation = cp.getWorldQuaternion();
            let invertQuat = invert$2(create$2(), particle.initialCPQuaternion); //TODO: optimize
            const delta = subtract$3(create$4(), particle.cpPosition, particle.initialCPPosition); //TODO: optimize
            const deltaQuaternion = mul$2(create$2(), particle.cpOrientation, invertQuat);
            normalize$3(deltaQuaternion, deltaQuaternion);
            const deltaL = length$5(delta);
            particle.deltaL = particle.deltaL || 0;
            particle.deltaL += deltaL;
            //console.log(deltaL);
            if (distanceFadeRange != 0 && particle.deltaL > distanceFadeRange) {
                particle.posLockedToCP = -1;
            }
            clone$4(particle.position);
            let delta2 = sub$2(create$4(), particle.position, particle.cpPosition);
            let delta3 = sub$2(create$4(), particle.prevPosition, particle.cpPosition);
            transformQuat$1(delta2, delta2, deltaQuaternion);
            transformQuat$1(delta3, delta3, deltaQuaternion);
            add$5(particle.position, particle.cpPosition, delta2);
            add$5(particle.prevPosition, particle.cpPosition, delta3);
            add$5(particle.position, particle.position, delta);
            add$5(particle.prevPosition, particle.prevPosition, delta);
            if (lockRotation) {
                particle.cpOrientation = clone$2(cp.getWorldQuaternion());
                //TODO
            }
            else {
                zero$3(particle.cpOrientation);
            }
        }
        if (particle.PositionFromParentParticles) {
            particle.PositionFromParentParticles = false;
        }
    }
}
SourceEngineParticleOperators.registerOperator(MovementLocktoControlPoint);
//TODO: postion lock to controlpoint
//SourceEngineParticleOperators.registerOperator('postion lock to controlpoint', MovementLocktoControlPoint);
/*
Movement Lock to Controlpoint
Forces the position of a particle to that of some control point on the emitter.

start_fadeout_min
Bottom range of time to start fading out the lock (leave the particle behind).
start_fadeout_max
Top range of time to start fading out the lock (leave the particle behind).
end_fadeout_min
Bottom range of time to end fading out the lock. Particle will be fully disengaged from the control points movement at this point.
end_fadeout_max
Top range of time to end fading out the lock. Particle will be fully disengaged from the control points movement at this point.
start/end exponents
Bias on the selection within the range.
control point number
Which control point to lock to
fade distance
Particles will detach as they approach this distance
lock rotation
This will update a particle relative to a Control Point's rotation as well as position.
*/

const tempVec3$9 = create$4();
class MovementMaxVelocity extends SourceEngineParticleOperator {
    static functionName = 'Movement Max Velocity';
    constructor() {
        super();
        this.addParam('Maximum Velocity', PARAM_TYPE_FLOAT, 0);
    }
    doOperate(particle, elapsedTime) {
        const maxVelocity = this.getParameter('Maximum Velocity');
        const velocity = sub$2(tempVec3$9, particle.position, particle.prevPosition);
        let speed = length$5(velocity);
        normalize$5(velocity, velocity);
        const maxVelocityNormalized = maxVelocity * elapsedTime;
        speed = Math.min(maxVelocityNormalized, speed);
        scaleAndAdd$2(particle.position, particle.prevPosition, velocity, speed);
    }
}
SourceEngineParticleOperators.registerOperator(MovementMaxVelocity);

let tempVec3$8 = create$4();
class MovementRotateParticleAroundAxis$1 extends SourceEngineParticleOperator {
    static functionName = 'Movement Rotate Particle Around Axis';
    once = true;
    constructor() {
        super();
        this.addParam('Rotation Axis', PARAM_TYPE_VECTOR, fromValues$4(0, 0, 1));
        this.addParam('Rotation Rate', PARAM_TYPE_FLOAT, 180);
        this.addParam('Control Point', PARAM_TYPE_INT, 0);
        this.addParam('Use Local Space', PARAM_TYPE_BOOL, 0);
        /*
        DMXELEMENT_UNPACK_FIELD( "Rotation Axis", "0 0 1", Vector, m_vecRotAxis )
        DMXELEMENT_UNPACK_FIELD( "Rotation Rate", "180", float, m_flRotRate )
        DMXELEMENT_UNPACK_FIELD( "Control Point", "0", int, m_nCP )
        DMXELEMENT_UNPACK_FIELD( "Use Local Space", "0", bool, m_bLocalSpace )*/
    }
    doOperate(particle, elapsedTime) {
        const axis = this.getParameter('Rotation Axis');
        const rate = this.getParameter('Rotation Rate');
        const useLocalSpace = this.getParameter('Use Local Space');
        const controlPointNumber = this.getParameter('Control Point');
        const modelView = create$5();
        identity$2(modelView);
        const q = create$2(); //TODO: memory
        const cp = particle.system.getControlPoint(controlPointNumber);
        if (cp) {
            if (useLocalSpace == 1) {
                copy$2(q, cp.getWorldQuaternion());
            }
            cp.getWorldPosition(tempVec3$8);
            sub$2(particle.position, particle.position, tempVec3$8);
            sub$2(particle.prevPosition, particle.prevPosition, tempVec3$8);
            const axis2 = clone$4(axis); //TODO: memory
            //axis2[1] = -axis2[1];
            //const tempQuat = quat.fromEuler(quat.create(), vec3.scale(vec3.create(), vec3.normalize(vec3.create(), axis), Math.HALF_PI));
            //quat.mul(tempQuat, tempQuat, q);
            //quat.fromEuler7(axis2, tempQuat);
            transformQuat$1(axis2, axis2, q);
            rotate$1(modelView, modelView, DEG_TO_RAD * (rate * elapsedTime), axis2);
            transformMat4$2(particle.position, particle.position, modelView);
            add$5(particle.position, particle.position, tempVec3$8);
            transformMat4$2(particle.prevPosition, particle.prevPosition, modelView);
            add$5(particle.prevPosition, particle.prevPosition, tempVec3$8);
        }
        else {
            rotate$1(modelView, modelView, DEG_TO_RAD * (rate * elapsedTime), axis);
            transformMat4$2(particle.position, particle.position, modelView);
        }
    }
}
SourceEngineParticleOperators.registerOperator(MovementRotateParticleAroundAxis$1);

class OscillateScalar$1 extends SourceEngineParticleOperator {
    static functionName = 'Oscillate Scalar';
    constructor() {
        super();
        this.setNameId('Oscillate Scalar');
        this.addParam('oscillation field', PARAM_TYPE_INT, 7); //Alpha
        this.addParam('oscillation rate min', PARAM_TYPE_FLOAT, 0);
        this.addParam('oscillation rate max', PARAM_TYPE_FLOAT, 0);
        this.addParam('oscillation frequency min', PARAM_TYPE_FLOAT, 1);
        this.addParam('oscillation frequency max', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, true);
        this.addParam('start time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('start time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('start/end proportional', PARAM_TYPE_BOOL, true);
        this.addParam('oscillation multiplier', PARAM_TYPE_FLOAT, 2);
        this.addParam('oscillation start phase', PARAM_TYPE_FLOAT, 0.5);
        //	DMXELEMENT_UNPACK_FIELD_USERDATA('oscillation field', '7', int, m_nField, 'intchoice particlefield_scalar')
        //	DMXELEMENT_UNPACK_FIELD('oscillation rate min', '0', float, m_RateMin)
        //	DMXELEMENT_UNPACK_FIELD('oscillation rate max', '0', float, m_RateMax)
        //	DMXELEMENT_UNPACK_FIELD('oscillation frequency min', '1', float, m_FrequencyMin)
        //	DMXELEMENT_UNPACK_FIELD('oscillation frequency max', '1', float, m_FrequencyMax)
        //	DMXELEMENT_UNPACK_FIELD('proportional 0/1', '1', bool, m_bProportional)
        //	DMXELEMENT_UNPACK_FIELD('start time min', '0', float, m_flStartTime_min)
        //	DMXELEMENT_UNPACK_FIELD('start time max', '0', float, m_flStartTime_max)
        //	DMXELEMENT_UNPACK_FIELD('end time min', '1', float, m_flEndTime_min)
        //	DMXELEMENT_UNPACK_FIELD('end time max', '1', float, m_flEndTime_max)
        //	DMXELEMENT_UNPACK_FIELD('start/end proportional', '1', bool, m_bProportionalOp)
        //	DMXELEMENT_UNPACK_FIELD('oscillation multiplier', '2', float, m_flOscMult)
        //	DMXELEMENT_UNPACK_FIELD('oscillation start phase', '.5', float, m_flOscAdd)
    }
    doOperate(particle, elapsedTime) {
        const m_bProportional = this.getParameter('proportional 0/1');
        const m_bProportionalOp = this.getParameter('start/end proportional');
        const oscillationField = this.getParameter('oscillation field');
        const m_RateMin = this.getParameter('oscillation rate min');
        const m_RateMax = this.getParameter('oscillation rate max');
        const m_FrequencyMin = this.getParameter('oscillation frequency min');
        const m_FrequencyMax = this.getParameter('oscillation frequency max');
        this.getParameter('oscillation multiplier');
        const m_flStartTime_min = this.getParameter('start time min');
        const m_flStartTime_max = this.getParameter('start time max');
        const m_flEndTime_min = this.getParameter('end time min');
        const m_flEndTime_max = this.getParameter('end time max');
        const m_flOscMult = this.getParameter('oscillation multiplier');
        const m_flOscAdd = this.getParameter('oscillation start phase');
        const fl4StartTimeWidth = m_flStartTime_max - m_flStartTime_min;
        const fl4EndTimeWidth = m_flEndTime_max - m_flEndTime_min;
        const fl4FrequencyWidth = m_FrequencyMax - m_FrequencyMin;
        const fl4RateWidth = m_RateMax - m_RateMin;
        const fl4ScaleFactor = /*flStrength * */ elapsedTime;
        const fl4CosFactor = m_flOscMult * particle.currentTime + m_flOscAdd;
        if (particle.timeToLive) {
            let fl4LifeTime;
            if (m_bProportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            let fl4StartTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 11);
            fl4StartTime = m_flStartTime_min + fl4StartTimeWidth * fl4StartTime;
            let fl4EndTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 12);
            fl4EndTime = m_flEndTime_min + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                let fl4Frequency = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset);
                fl4Frequency = m_FrequencyMin + fl4FrequencyWidth * fl4Frequency;
                let fl4Rate = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 1);
                fl4Rate = m_RateMin + fl4RateWidth * fl4Rate;
                let fl4Cos;
                if (m_bProportional) {
                    fl4LifeTime = (particle.currentTime - particle.cTime) / particle.timeToLive;
                    fl4Cos = ((m_flOscMult * (fl4LifeTime * fl4Frequency)) + m_flOscAdd);
                }
                else {
                    fl4Cos = fl4CosFactor * fl4Frequency;
                }
                const fl4OscMultiplier = fl4Rate * fl4ScaleFactor;
                let fl4OscVal = particle.getField(oscillationField) + fl4OscMultiplier * Math.sin(fl4Cos * Math.PI);
                if (oscillationField == 7) { //alpha
                    fl4OscVal = clamp(fl4OscVal, 0.0, 1.0);
                }
                particle.setField(oscillationField, fl4OscVal);
                //console.error(fl4OscVal);
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(OscillateScalar$1);

/*					'oscillation field' 'int' '0'
                    'oscillation field' 'int' '16'
                    'oscillation field' 'int' '3'
                    'oscillation field' 'int' '4'
                    'oscillation field' 'int' '7'*/
const tempVec3Freq = create$4();
const tempVec3Rate = create$4();
class OscillateVector$1 extends SourceEngineParticleOperator {
    static functionName = 'Oscillate Vector';
    constructor() {
        super();
        this.addParam('oscillation field', PARAM_TYPE_INT, 0);
        this.addParam('oscillation rate min', PARAM_TYPE_VECTOR3, create$4());
        this.addParam('oscillation rate max', PARAM_TYPE_VECTOR3, create$4());
        this.addParam('oscillation frequency min', PARAM_TYPE_VECTOR3, fromValues$4(1.0, 1.0, 1.0));
        this.addParam('oscillation frequency max', PARAM_TYPE_VECTOR3, fromValues$4(1.0, 1.0, 1.0));
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
        this.addParam('start time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('start time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time min', PARAM_TYPE_FLOAT, 1);
        this.addParam('end time max', PARAM_TYPE_FLOAT, 1);
        this.addParam('start/end proportional', PARAM_TYPE_BOOL, 1);
        this.addParam('oscillation multiplier', PARAM_TYPE_FLOAT, 2.0);
        this.addParam('oscillation start phase', PARAM_TYPE_FLOAT, 0.5);
    }
    doOperate(particle, elapsedTime) {
        const m_nField = this.getParameter('oscillation field');
        const m_RateMin = this.getParameter('oscillation rate min');
        const m_RateMax = this.getParameter('oscillation rate max');
        const m_FrequencyMin = this.getParameter('oscillation frequency min');
        const m_FrequencyMax = this.getParameter('oscillation frequency max');
        const m_bProportional = this.getParameter('proportional 0/1');
        const m_flStartTime_min = this.getParameter('start time min');
        const m_flStartTime_max = this.getParameter('start time max');
        const m_flEndTime_min = this.getParameter('end time min');
        const m_flEndTime_max = this.getParameter('end time max');
        const m_bProportionalOp = this.getParameter('start/end proportional');
        const m_flOscMult = this.getParameter('oscillation multiplier');
        const m_flOscAdd = this.getParameter('oscillation start phase');
        particle.cTime; //CM128AttributeIterator pCreationTime(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        const pLifeDuration = particle.timeToLive; //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //C4IAttributeIterator pParticleId (PARTICLE_ATTRIBUTE_PARTICLE_ID, pParticles);
        //C4VAttributeWriteIterator pOscField (m_nField, pParticles) ;
        const fl4CurTime = particle.currentTime;
        //const nRandomOffset = particle->OperatorRandomSampleOffset();
        const fvOscVal = create$4(); //todov3optimize
        const flStrength = 1;
        const fl4ScaleFactor = flStrength * elapsedTime;
        const fl4CosFactorMultiplier = m_flOscMult;
        const fl4CosFactorAdd = m_flOscAdd;
        const fl4CosFactor = fl4CosFactorMultiplier * fl4CurTime + fl4CosFactorAdd;
        const fl4CosFactorProp = fl4CosFactorMultiplier;
        const fl4StartTimeWidth = m_flStartTime_max - m_flStartTime_min;
        const fl4EndTimeWidth = m_flEndTime_max - m_flEndTime_min;
        const fvFrequencyMin = m_FrequencyMin;
        const fvFrequencyWidth = sub$2(create$4(), m_FrequencyMax, m_FrequencyMin); //todov3optimize
        const fvRateMin = m_RateMin;
        const fvRateWidth = sub$2(create$4(), m_RateMax, m_RateMin); //todov3optimize
        //int nCtr = pParticles->m_nPaddedActiveParticles;
        //do
        {
            const fl4LifeDuration = pLifeDuration;
            const fl4GoodMask = fl4LifeDuration > 0.0;
            let fl4LifeTime;
            if (m_bProportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            //let fl4StartTime = Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            let fl4StartTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 11);
            fl4StartTime = m_flStartTime_min + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            //let fl4EndTime= Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            let fl4EndTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 12);
            fl4EndTime = m_flEndTime_min + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                //let fvFrequency = vec3.fromValues(Math.random(), Math.random(), Math.random());
                let fvFrequency = ParticleRandomVec3(tempVec3Freq, particle.id + particle.system.operatorRandomSampleOffset, 8, 12, 15);
                //fvFrequency[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 8);
                //fvFrequency[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
                //fvFrequency[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 15);
                mul$4(fvFrequency, fvFrequency, fvFrequencyWidth);
                add$5(fvFrequency, fvFrequency, fvFrequencyMin);
                //let fvRate = vec3.fromValues(Math.random(), Math.random(), Math.random());
                let fvRate = ParticleRandomVec3(tempVec3Rate, particle.id + particle.system.operatorRandomSampleOffset, 3, 7, 9);
                //fvRate[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 3);
                //fvRate[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 7);
                //fvRate[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 9);
                //fvRate = AddSIMD(fvRateMin, MulSIMD(fvRateWidth, fvRate));
                mul$4(fvRate, fvRate, fvRateWidth);
                add$5(fvRate, fvRate, fvRateMin);
                const fvCos = create$4(); //todov3optimize
                if (m_bProportional) {
                    fl4LifeTime = particle.currentTime / particle.timeToLive;
                    fvCos[0] = fl4CosFactorProp * fvFrequency[0] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[1] = fl4CosFactorProp * fvFrequency[1] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[2] = fl4CosFactorProp * fvFrequency[2] * fl4LifeTime + fl4CosFactorAdd;
                }
                else {
                    scale$5(fvCos, fvFrequency, fl4CosFactor);
                }
                const fvOscMultiplier = create$4(); //todov3optimize
                scale$5(fvOscMultiplier, fvRate, fl4ScaleFactor);
                let fvOutput = create$4(); //TODO: perf//todov3optimize
                this.getInputValueAsVector(m_nField, particle, fvOutput); //*pOscField;
                fvOscVal[0] = AddSIMD(fvOutput[0], MulSIMD(fvOscMultiplier[0], SinEst01SIMD(fvCos[0])));
                fvOscVal[1] = AddSIMD(fvOutput[1], MulSIMD(fvOscMultiplier[1], SinEst01SIMD(fvCos[1])));
                fvOscVal[2] = AddSIMD(fvOutput[2], MulSIMD(fvOscMultiplier[2], SinEst01SIMD(fvCos[2])));
                const pOscField = create$4(); //todov3optimize
                if (m_nField == 6) {
                    pOscField[0] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[0], Four_Ones), Four_Zeros), fvOutput[0]);
                    pOscField[1] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[1], Four_Ones), Four_Zeros), fvOutput[1]);
                    pOscField[2] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[2], Four_Ones), Four_Zeros), fvOutput[2]);
                }
                else {
                    //pOscField[0] = MaskedAssign(fl4GoodMask, fvOscVal[0], fvOutput[0]);
                    //pOscField[1] = MaskedAssign(fl4GoodMask, fvOscVal[1], fvOutput[1]);
                    //pOscField[2] = MaskedAssign(fl4GoodMask, fvOscVal[2], fvOutput[2]);
                    pOscField[0] = fvOscVal[0];
                    pOscField[1] = fvOscVal[1];
                    pOscField[2] = fvOscVal[2];
                }
                this.setOutputValue(m_nField, pOscField, particle);
            }
            //++pCreationTime;
            //++pLifeDuration;
            //++pOscField;
            //++pParticleId;
            //} while (--nCtr);
        }
    }
}
SourceEngineParticleOperators.registerOperator(OscillateVector$1);

class RadiusScale extends SourceEngineParticleOperator {
    static functionName = 'Radius Scale';
    constructor() {
        super();
        this.addParam('radius_start_scale', PARAM_TYPE_FLOAT, 1);
        this.addParam('radius_end_scale', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_time', PARAM_TYPE_FLOAT, 1);
        this.addParam('scale_bias', PARAM_TYPE_FLOAT, 0.5); //Neutral bias
        this.addParam('ease_in_and_out', PARAM_TYPE_BOOL, 0); //Neutral bias
        /*DMXELEMENT_UNPACK_FIELD('start_time', '0', float, m_flStartTime)
        DMXELEMENT_UNPACK_FIELD('end_time', '1', float, m_flEndTime)
        DMXELEMENT_UNPACK_FIELD('radius_start_scale', '1', float, m_flStartScale)
        DMXELEMENT_UNPACK_FIELD('radius_end_scale', '1', float, m_flEndScale)
        DMXELEMENT_UNPACK_FIELD('ease_in_and_out', '0', bool, m_bEaseInAndOut)
        DMXELEMENT_UNPACK_FIELD('scale_bias', '0.5', float, m_flBias)*/
    }
    doOperate(particle, elapsedTime) {
        const radius_start_scale = this.getParameter('radius_start_scale');
        const radius_end_scale = this.getParameter('radius_end_scale');
        const start_time = this.getParameter('start_time');
        const end_time = this.getParameter('end_time');
        const scaleBias = this.getParameter('scale_bias');
        const easeInAndOut = this.getParameter('ease_in_and_out');
        const fl4OOTimeWidth = ReciprocalSIMD(SubSIMD(end_time, start_time));
        const biasParam = 1 / scaleBias - 2;
        const fl4LifeDuration = particle.timeToLive;
        let fl4GoodMask = CmpGtSIMD(fl4LifeDuration, 0);
        const fl4CurTime = this.particleSystem.currentTime;
        const fl4ScaleWidth = radius_end_scale - radius_start_scale;
        const fl4LifeTime = MulSIMD(SubSIMD(fl4CurTime, particle.cTime), ReciprocalEstSIMD(fl4LifeDuration)); // maybe need accurate div here?
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpGeSIMD(fl4LifeTime, start_time));
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpLtSIMD(fl4LifeTime, end_time));
        fl4GoodMask = (fl4LifeDuration > 0) && (fl4LifeTime >= start_time) && (fl4LifeTime < end_time);
        if (fl4GoodMask /* IsAnyNegative(fl4GoodMask) */) {
            let fl4FadeWindow = MulSIMD(SubSIMD(fl4LifeTime, start_time), fl4OOTimeWidth);
            if (easeInAndOut) {
                fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(SimpleSpline(fl4FadeWindow), fl4ScaleWidth));
            }
            else {
                if (scaleBias != 0.5) {
                    fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(BiasSIMD(fl4FadeWindow, biasParam), fl4ScaleWidth));
                }
                else {
                    fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(fl4FadeWindow, fl4ScaleWidth));
                }
            }
            if (fl4GoodMask) {
                particle.radius = fl4FadeWindow * particle.initialRadius;
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(RadiusScale);

const a$1 = create$4();
class RemapCPSpeedToCP extends SourceEngineParticleOperator {
    static functionName = 'remap cp speed to cp';
    constructor() {
        super();
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('Output field 0-2 X/Y/Z', PARAM_TYPE_INT, 0); // X/Y/Z
        this.addParam('output control point', PARAM_TYPE_INT, 1);
    }
    doOperate(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const outputField = this.getParameter('Output field 0-2 X/Y/Z');
        const inCPNumber = this.getParameter('input control point');
        const outCPNumber = this.getParameter('output control point');
        const incp = this.particleSystem.getControlPoint(inCPNumber);
        const outcp = this.particleSystem.getControlPoint(outCPNumber);
        if (incp && outcp && (outputField == 0 || outputField == 1 || outputField == 2)) {
            length$5(incp.getWorldPosition(a$1));
            let position = outcp.position; //TODO optimize
            position[outputField] = RemapValClamped(200, inputMinimum, inputMaximum, outputMinimum, outputMaximum);
            outcp.position = position;
        }
    }
}
SourceEngineParticleOperators.registerOperator(RemapCPSpeedToCP);

const tempVec3$7 = create$4();
class RemapDistanceToControlPointToScalar extends SourceEngineParticleOperator {
    static functionName = 'Remap Distance to Control Point to Scalar';
    constructor() {
        super();
        this.addParam('control point', PARAM_TYPE_INT, 0);
        this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('distance minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance maximum', PARAM_TYPE_FLOAT, 128);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('only active within specified distance', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle, elapsedTime) {
        const cpNumber = this.getParameter('control point');
        const dMin = this.getParameter('distance minimum');
        const dMax = this.getParameter('distance maximum');
        const oMin = this.getParameter('output minimum');
        const oMax = this.getParameter('output maximum');
        const field = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        const active = this.getParameter('only active within specified distance');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            const delta = subtract$3(tempVec3$7, cp.getWorldPosition(tempVec3$7), particle.position);
            const deltaL = length$5(delta);
            if (active && ((deltaL < dMin) || (deltaL > dMax))) {
                return;
            }
            const output = RemapValClamped(deltaL, dMin, dMax, oMin, oMax); //(deltaL-dMin)/(dMax-dMin) * (oMax-oMin) + oMin;
            const strength = this.getOperatorStrength();
            if (strength == 1) {
                particle.setField(field, output, init); //TODO
            }
            else {
                const value = particle.getField(field);
                particle.setField(field, lerp(value, output, strength), init); //TODO
            }
        }
    }
}
SourceEngineParticleOperators.registerOperator(RemapDistanceToControlPointToScalar);
/*
                    'id' 'elementid' '141980ed-af1c-4ffb-9890-b42e39fc0d28'
                    'name' 'string' 'Remap Distance to Control Point to Scalar'
                    'functionName' 'string' 'Remap Distance to Control Point to Scalar'
                    'operator start fadein' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator fade oscillate' 'float' '0'
                    'distance minimum' 'float' '0'
                    'distance maximum' 'float' '200'
                    'output field' 'int' '1'
                    'output minimum' 'float' '1'
                    'output maximum' 'float' '0'
                    'control point' 'int' '0'
                    'ensure line of sight' 'bool' '0'
                    'LOS collision group' 'string' 'NONE'
                    'Maximum Trace Length' 'float' '-1'
                    'LOS Failure Scalar' 'float' '0'
                    'output is scalar of initial random range' 'bool' '1'
                    'only active within specified distance' 'bool' '0'
                    */

const tempVec3$6 = create$4();
class RemapDistanceToControlPointToVector extends SourceEngineParticleOperator {
    static functionName = 'Remap Distance to Control Point to Vector';
    constructor() {
        super();
        this.addParam('control point', PARAM_TYPE_INT, 0);
        //this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('distance minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_VECTOR, fromValues$4(0, 0, 0));
        this.addParam('output maximum', PARAM_TYPE_VECTOR, fromValues$4(1, 1, 1));
        this.addParam('output field', PARAM_TYPE_INT, 1);
        //this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('only active within specified distance', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle) {
        const cpNumber = this.getParameter('control point');
        const distanceMin = this.getParameter('distance minimum');
        const distanceMax = this.getParameter('distance maximum');
        const deltaDistance = distanceMax - distanceMin;
        const outputMin = this.getParameter('output minimum');
        const outputMax = this.getParameter('output maximum');
        const field = this.getParameter('output field');
        const activeDistance = this.getParameter('only active within specified distance');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp == undefined) {
            return;
        }
        subtract$3(tempVec3$6, particle.cpPosition, particle.position);
        const deltaL = length$5(tempVec3$6);
        if (activeDistance && (deltaL < distanceMin || deltaL > distanceMax)) {
            // Outside distance window
            return;
        }
        lerp$5(tempVec3$6, outputMin, outputMax, (deltaL - distanceMin) / deltaDistance);
        particle.setField(field, tempVec3$6);
    }
}
SourceEngineParticleOperators.registerOperator(RemapDistanceToControlPointToVector);
/*
        "DmeParticleOperator"
        {
            "id" "elementid" "0d3d4ec1-b821-4970-a69d-57c97da97915"
            "name" "string" "Remap Distance to Control Point to Vector"
            "functionName" "string" "Remap Distance to Control Point to Vector"
            "operator start fadein" "float" "0"
            "operator end fadein" "float" "0"
            "operator start fadeout" "float" "0"
            "operator end fadeout" "float" "0"
            "operator fade oscillate" "float" "0"
            "distance minimum" "float" "0"
            "distance maximum" "float" "64"
            "output field" "int" "6"
            "output minimum" "vector3" "0 1 0"
            "output maximum" "vector3" "1.5 0 3"
            "control point" "int" "0"
            "only active within specified distance" "bool" "1"
            "local space CP" "int" "-1"
        }
    ]
                    */

class RemapScalar extends SourceEngineParticleOperator {
    static functionName = 'remap scalar';
    constructor() {
        super();
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field', PARAM_TYPE_INT, 0);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field');
        const outputField = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        //const v = this.getInputValue(inputField, particle);
        const v = particle.getField(inputField, init);
        const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
        const out = d * (outputMaximum - outputMinimum) + outputMinimum;
        this.setOutputValue(outputField, out, particle);
    }
}
SourceEngineParticleOperators.registerOperator(RemapScalar);

class RotationBasic extends SourceEngineParticleOperator {
    static functionName = 'Rotation Basic';
    constructor() {
        super();
    }
    doOperate(particle, elapsedTime) {
        particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
    }
}
SourceEngineParticleOperators.registerOperator(RotationBasic);

/**
 * TODO
 */
class RotationSpinRoll extends SourceEngineParticleOperator {
    static functionName = 'Rotation Spin Roll';
    constructor() {
        super();
        this.addParam('spin_rate_degrees', PARAM_TYPE_INT, 0);
        this.addParam('spin_stop_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('spin_rate_min', PARAM_TYPE_INT, 0);
        //DMXELEMENT_UNPACK_FIELD('spin_rate_degrees', '0', int, m_nSpinRateDegrees)
        //DMXELEMENT_UNPACK_FIELD('spin_stop_time', '0', float, m_fSpinRateStopTime)
        //DMXELEMENT_UNPACK_FIELD('spin_rate_min', '0', int, m_nSpinRateMinDegrees)
    }
    doOperate(particle, elapsedTime) {
        const m_nSpinRateDegrees = this.getParameter('spin_rate_degrees');
        const m_fSpinRateStopTime = this.getParameter('spin_stop_time');
        const m_nSpinRateMinDegrees = this.getParameter('spin_rate_min');
        const m_fSpinRateRadians = (m_nSpinRateDegrees) * DEG_TO_RAD;
        const m_fSpinRateMinRadians = (m_nSpinRateMinDegrees) * DEG_TO_RAD;
        const fCurSpinRate = m_fSpinRateRadians /* * flStrength*/; //TODO
        if (fCurSpinRate == 0.0) {
            return;
        }
        const dt = elapsedTime;
        let drot = dt * Math.abs(fCurSpinRate * TWO_PI);
        if (m_fSpinRateStopTime == 0.0) {
            drot = drot % TWO_PI; //fmod(drot, (float)(2.0f * M_PI));
        }
        if (fCurSpinRate < 0.0) {
            drot = -drot;
        }
        //fltx4 Rot_Add = ReplicateX4(drot);
        const Rot_Add = drot;
        //fltx4 Pi_2 = ReplicateX4(2.0*M_PI);
        //fltx4 nPi_2 = ReplicateX4(-2.0*M_PI);
        // FIXME: This is wrong
        const minSpeedRadians = dt * Math.abs(m_fSpinRateMinRadians * TWO_PI); //fltx4 minSpeedRadians = ReplicateX4(dt * fabs(m_fSpinRateMinRadians * 2.0f * M_PI));
        const now = this.particleSystem.currentTime;
        const SpinRateStopTime = m_fSpinRateStopTime;
        //CM128AttributeIterator pCreationTimeStamp(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //CM128AttributeWriteIterator pRot(GetAttributeToSpin(), pParticles);
        // HACK: Rather than redo this, I'm simply remapping the stop time into the percentage of lifetime, rather than seconds
        const LifeSpan = particle.timeToLive;
        let SpinFadePerc = 0;
        let OOSpinFadeRate = 0;
        if (m_fSpinRateStopTime) {
            SpinFadePerc = LifeSpan * SpinRateStopTime;
            OOSpinFadeRate = 1.0 / SpinFadePerc;
        }
        const Age = now - particle.cTime;
        const RScale = Math.max(0, 1.0 - (Age * OOSpinFadeRate));
        // Cap the rotation at a minimum speed
        let deltaRot = Rot_Add * RScale;
        //fltx4 Tooslow = CmpLeSIMD(deltaRot, minSpeedRadians);
        //deltaRot = OrSIMD(AndSIMD(Tooslow, minSpeedRadians), AndNotSIMD(Tooslow, deltaRot));
        deltaRot = Math.max(minSpeedRadians, deltaRot);
        const NewRot = particle.rotationRoll + deltaRot;
        // now, cap at +/- 2*pi
        /*fltx4 Toobig =CmpGeSIMD(NewRot, Pi_2);
        fltx4 Toosmall = CmpLeSIMD(NewRot, nPi_2);

        NewRot = OrSIMD(AndSIMD(Toobig, SubSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toobig, NewRot));

        NewRot = OrSIMD(AndSIMD(Toosmall, AddSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toosmall, NewRot));*/
        //NewRot = Math.min(Math.max(-Math.TWO_PI, NewRot), Math.TWO_PI);
        particle.rotationRoll = NewRot;
        // Note: this should be PI / 180, but for some reason there is a bug in source engine
        //		particle.rotationRoll += spin_rate_degrees*elapsedTime * Math.PI * Math.PI / 90.0;
    }
}
SourceEngineParticleOperators.registerOperator(RotationSpinRoll);
SourceEngineParticleOperators.registerOperator('Rotation Spin', RotationSpinRoll);

class RotationSpinYaw extends SourceEngineParticleOperator {
    static functionName = 'Rotation Spin Yaw';
    constructor() {
        super();
        this.addParam('yaw_rate_degrees', PARAM_TYPE_FLOAT, 0);
    }
    doOperate(particle, elapsedTime) {
        const yaw_rate_degrees = this.getParameter('yaw_rate_degrees');
        particle.rotationYaw += yaw_rate_degrees * elapsedTime; //TODO
    }
}
SourceEngineParticleOperators.registerOperator(RotationSpinYaw);

class SetChildControlPointsFromParticlePositions extends SourceEngineParticleOperator {
    static functionName = 'Set child control points from particle positions';
    constructor() {
        super();
        this.addParam('# of control points to set', PARAM_TYPE_INT, 1);
        this.addParam('First control point to set', PARAM_TYPE_INT, 0);
    }
    doOperate(particle, elapsedTime) {
        const number = this.getParameter('# of control points to set');
        const first = this.getParameter('First control point to set');
        //const v = vec3.clone(particle.position);
        //v.add(particle.offsetPosition);
        //const v = vec3.add(vec3.create(), particle.position, particle.cpPosition);//v.add(particle.cpPosition);
        //TODO
        const v = create$4();
        particle.getWorldPos(v);
        this.particleSystem.setChildControlPointPosition(first, first + number - 1, v);
    }
}
SourceEngineParticleOperators.registerOperator(SetChildControlPointsFromParticlePositions);

const tempVec3$5 = create$4();
class SetControlPointPositions$1 extends SourceEngineParticleOperator {
    static functionName = 'set control point positions';
    constructor() {
        super();
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Set positions in world space', PARAM_TYPE_BOOL, false);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('First Control Point Location', PARAM_TYPE_VECTOR3, fromValues$4(128, 0, 0));
        this.addParam('First Control Point Number', PARAM_TYPE_INT, 1);
        this.addParam('First Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Second Control Point Location', PARAM_TYPE_VECTOR3, fromValues$4(0, 128, 0));
        this.addParam('Second Control Point Number', PARAM_TYPE_INT, 2);
        this.addParam('Second Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Third Control Point Location', PARAM_TYPE_VECTOR3, fromValues$4(-128, 0, 0));
        this.addParam('Third Control Point Number', PARAM_TYPE_INT, 3);
        this.addParam('Third Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Fourth Control Point Location', PARAM_TYPE_VECTOR3, fromValues$4(0, -128, 0));
        this.addParam('Fourth Control Point Number', PARAM_TYPE_INT, 4);
        this.addParam('Fourth Control Point Parent', PARAM_TYPE_INT, 0);
    }
    doOperate(particle) {
        const list = ['First', 'Second', 'Third', 'Fourth'];
        const useWorldLocation = this.getParameter('Set positions in world space');
        const headLocation = this.getParameter('Control Point to offset positions from');
        const vecControlPoint = this.particleSystem.getControlPointPosition(headLocation);
        for (let cpIndex = 0; cpIndex < 4; ++cpIndex) {
            const name = list[cpIndex];
            const cpNumber = this.getParameter(name + ' Control Point Number');
            if (cpNumber == headLocation) {
                continue;
            }
            const cpParent = this.getParameter(name + ' Control Point Parent');
            const cpLocation = this.getParameter(name + ' Control Point Location');
            if (!useWorldLocation) {
                const a = add$5(tempVec3$5, cpLocation, vecControlPoint);
                this.particleSystem.setControlPointPosition(cpNumber, a);
            }
            else {
                this.particleSystem.setControlPointPosition(cpNumber, cpLocation);
            }
            let controlPoint = this.particleSystem.getControlPoint(cpNumber);
            if (controlPoint) {
                controlPoint.setWorldQuaternion(create$2());
            }
            this.particleSystem.setControlPointParent(cpNumber, cpParent);
        }
    }
}
SourceEngineParticleOperators.registerOperator(SetControlPointPositions$1);

const tempVec3_min = create$4();
const tempVec3_max = create$4();
class SetControlPointToParticlesCenter extends SourceEngineParticleOperator {
    static functionName = 'Set Control Point to Particles\' Center';
    constructor() {
        super();
        this.addParam('Control Point Number to Set', PARAM_TYPE_INT, 1);
        this.addParam('Center Offset', PARAM_TYPE_VECTOR3, fromValues$4(0, 0, 0));
    }
    doOperate(particle, elapsedTime) {
        const cpNumber = this.getParameter('Control Point Number to Set');
        const centerOffset = this.getParameter('Center Offset');
        //const v = vec3.add(tempVec3, particle.position, particle.cpPosition);
        this.particleSystem.getBounds(tempVec3_min, tempVec3_max);
        lerp$5(tempVec3_min, tempVec3_min, tempVec3_max, 0.5);
        add$5(tempVec3_min, tempVec3_min, centerOffset);
        this.particleSystem.setChildControlPointPosition(cpNumber, cpNumber, tempVec3_min);
    }
}
SourceEngineParticleOperators.registerOperator(SetControlPointToParticlesCenter);

const TEXTURE_WIDTH = 8;

const tempQuat$3 = create$2();
const IDENTITY_QUAT = create$2();
const vecDelta = create$4();
class RenderAnimatedSprites extends SourceEngineParticleOperator {
    static functionName = 'render_animated_sprites';
    #orientationType;
    texture;
    geometry;
    #maxParticles;
    imgData;
    constructor() {
        super();
        this.addParam('animation rate', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('animation_fit_lifetime', PARAM_TYPE_BOOL, 0);
        this.addParam('orientation_type', PARAM_TYPE_INT, 0);
        this.addParam('orientation control point', PARAM_TYPE_INT, -1);
        this.addParam('second sequence animation rate', PARAM_TYPE_FLOAT, 0);
        this.addParam('use animation rate as FPS', PARAM_TYPE_BOOL, 0);
        this.addParam('Visibility Proxy Input Control Point Number', PARAM_TYPE_INT, -1);
        this.addParam('Visibility Camera Depth Bias', PARAM_TYPE_FLOAT, 0);
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderAnimatedSprites(particleList[i], elapsedTime, material);
        }
    }
        */
    updateParticles(particleSystem, particleList) {
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        this.geometry.count = particleList.length * 6;
        let maxParticles = this.#maxParticles;
        this.setupParticlesTexture(particleList, maxParticles);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setUniform('uVisibilityCameraDepthBias', this.getParameter('Visibility Camera Depth Bias')); //TODOv3:optimize
        this.mesh.setVisible(Source1ParticleControler.visible);
        let orientationControlPointNumber = this.getParameter('orientation control point');
        let orientationControlPoint = this.particleSystem.getControlPoint(orientationControlPointNumber);
        if (orientationControlPoint) {
            this.mesh.setUniform('uOrientationControlPoint', orientationControlPoint.getWorldQuaternion(tempQuat$3));
        }
        else {
            this.mesh.setUniform('uOrientationControlPoint', IDENTITY_QUAT);
        }
        const uvs = this.geometry.attributes.get('aTextureCoord')._array;
        let index = 0;
        for (let i = 0; i < particleList.length; i++) {
            let particle = particleList[i];
            const sequence = particle.sequence;
            let flAgeScale;
            if (m_bFitCycleToLifetime) {
                let flLifetime = particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
                flAgeScale = (flLifetime > 0.0) ? (1.0 / flLifetime) * SEQUENCE_SAMPLE_COUNT : 0.0;
            }
            else {
                flAgeScale = rate * SEQUENCE_SAMPLE_COUNT;
                if (useAnimRate) {
                    //particle.frame+=elapsedTime*rate;
                    const frameSpan = this.particleSystem.material.getFrameSpan(sequence);
                    if (frameSpan !== null) {
                        flAgeScale = flAgeScale / frameSpan;
                    }
                }
            }
            let coords = this.particleSystem.material.getTexCoords(0, particle.currentTime, flAgeScale, sequence);
            if (coords) {
                coords = coords.m_TextureCoordData[0];
                let uMin = coords.m_fLeft_U0;
                let vMin = coords.m_fTop_V0;
                let uMax = coords.m_fRight_U0;
                let vMax = coords.m_fBottom_V0;
                uvs[index++] = uMin;
                uvs[index++] = vMin;
                uvs[index++] = uMax;
                uvs[index++] = vMin;
                uvs[index++] = uMin;
                uvs[index++] = vMax;
                uvs[index++] = uMax;
                uvs[index++] = vMax;
                //uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            }
            else {
                index += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = new Graphics().isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this.#initBuffers();
    }
    #initBuffers() {
        let geometry = this.geometry;
        const vertices = [];
        const uvs = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            let indiceBase = i * 4;
            if (this.#orientationType == 2 || this.#orientationType == 3) {
                indices.push(indiceBase, indiceBase + 1, indiceBase + 2, indiceBase + 2, indiceBase + 1, indiceBase + 3);
            }
            else {
                indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            }
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer(particleSystem) {
        this.geometry = new BufferGeometry();
        this.mesh = new Mesh(this.geometry, particleSystem.material);
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
        this.#orientationType = this.getParameter('orientation_type');
        this.setOrientationType(this.#orientationType);
        this.#initBuffers();
        /*
                switch (orientation) {
                    case 0: //always face camera
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
                        break;
                    case 1: //rotate around z
                        particleSystem.material.setDefine('SPRITE_ROTATE_AROUND_Z');
                        break;
                    case 2: //parallel to ground
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_WORLD_Z_ALIGNED');
                        //TODO
                        break;
                    case 3: //use normal
                    default:
                        //glCanvas.setUniform1f('uFaceCamera', -1.0);
                        break;
                }*/
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        this.texture.addUser(this);
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = new Graphics().glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles) {
        const a = this.imgData;
        let index = 0;
        for (let particle of particleList) { //TODOv3
            subtract$3(vecDelta, particle.prevPosition, particle.position);
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha * particle.alpha2;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            // Vec delta
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            index++;
            // normal
            index += 4;
            // renderScreenVelocityRotate
            a[index++] = particle.renderScreenVelocityRotate ? 1 : 0;
            a[index++] = particle.m_flRotateRate;
            a[index++] = particle.m_flForward;
            index++;
            // free for now
            index += 8;
        }
        this.updateParticlesTexture();
    }
    dispose() {
        this.mesh?.dispose();
        this.texture?.removeUser(this);
    }
}
SourceEngineParticleOperators.registerOperator(RenderAnimatedSprites);

const tempVec2$1 = create();
class RenderRope extends SourceEngineParticleOperator {
    static functionName = 'render rope';
    #maxParticles = 0;
    texture;
    geometry;
    imgData;
    constructor() {
        super();
        this.addParam('subdivision_count', PARAM_TYPE_INT, 3);
        this.addParam('texel_size', PARAM_TYPE_FLOAT, 4.0);
        this.addParam('texture_scroll_rate', PARAM_TYPE_FLOAT, 0.0);
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderAnimatedSprites(particleList[i], elapsedTime, material);
        }
    }
        */
    updateParticles(particleSystem, particleList) {
        this.getParameter('subdivision_count');
        const m_flTexelSizeInUnits = this.getParameter('texel_size');
        const m_flTextureScrollRate = this.getParameter('texture_scroll_rate');
        const m_flTextureScale = 1.0 / (this.particleSystem.material.getColorMapSize(tempVec2$1)[1] * m_flTexelSizeInUnits);
        const flTexOffset = m_flTextureScrollRate * particleSystem.currentTime;
        let geometry = this.geometry;
        let segments = [];
        let particle;
        let ropeLength = 0.0;
        let previousSegment = null;
        for (let i = 0, l = particleList.length; i < l; i++) {
            //for (let i = 0, l = (particleList.length - 1) * subdivCount + 1; i < l; i++) {
            particle = particleList[i];
            let segment = new BeamSegment(particle.position, [particle.color.r, particle.color.g, particle.color.b, particle.alpha], 0.0, particle.radius);
            if (previousSegment) {
                ropeLength += segment.distanceTo(previousSegment);
            }
            segment.texCoordY = (ropeLength + flTexOffset) * m_flTextureScale;
            segments.push(segment);
            previousSegment = segment;
        }
        geometry.segments = segments;
        return;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = maxParticles;
        this.#createParticlesArray();
        //this._initBuffers();
    }
    initRenderer(particleSystem) {
        this.geometry = new BeamBufferGeometry();
        this.mesh = new Mesh(this.geometry, particleSystem.material);
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('IS_ROPE');
        this.mesh.setDefine('USE_VERTEX_COLOR');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
        this.setOrientationType(this.getParameter('orientation_type')); //TODO: remove orientation_type : only for RenderAnimatedSprites
        particleSystem.material.renderFace(RenderFace.Both);
        /*
                switch (orientation) {
                    case 0: //always face camera
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
                        break;
                    case 1: //rotate around z
                        particleSystem.material.setDefine('SPRITE_ROTATE_AROUND_Z');
                        break;
                    case 2: //parallel to ground
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_WORLD_Z_ALIGNED');
                        //TODO
                        break;
                    case 3: //use normal
                    default:
                        //glCanvas.setUniform1f('uFaceCamera', -1.0);
                        break;
                }*/
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        this.texture.addUser(this);
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = new Graphics().glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles) {
        const a = this.imgData;
        let index = 0;
        for (let particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            index++;
            index++;
            index++;
            index++;
            index += 16;
        }
        this.updateParticlesTexture();
    }
    dispose() {
        this.mesh?.dispose();
        this.texture.removeUser(this);
    }
}
SourceEngineParticleOperators.registerOperator(RenderRope);

// Note: this operator doesn't render anything, it simply orientate the particle for other renderers
class RenderScreenVelocityRotate extends SourceEngineParticleOperator {
    static functionName = 'render_screen_velocity_rotate';
    isScreenVelocityRotate = true;
    constructor() {
        super();
        this.addParam('rotate_rate(dps)', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('forward_angle', PARAM_TYPE_FLOAT, -90.0);
    }
    /*
        doRender(particleList, elapsedTime, material) {
            for (let i = 0; i < particleList.length; ++i) {
                this.renderAnimatedSprites(particleList[i], elapsedTime, material);
            }
        }
    */
    updateParticles(particleSystem, particleList) {
        const m_flRotateRate = this.getParameter('rotate_rate(dps)') * DEG_TO_RAD;
        const m_flForward = this.getParameter('forward_angle') * DEG_TO_RAD;
        for (let i = 0; i < particleList.length; i++) {
            let particle = particleList[i];
            particle.renderScreenVelocityRotate = true;
            particle.m_flRotateRate = m_flRotateRate;
            particle.m_flForward = m_flForward;
        }
    }
    initRenderer(particleSystem) {
        // Nothing to do
    }
}
SourceEngineParticleOperators.registerOperator(RenderScreenVelocityRotate);

class RenderSpriteTrail extends SourceEngineParticleOperator {
    static functionName = 'render_sprite_trail';
    texture;
    geometry;
    imgData;
    constructor() {
        super();
        this.addParam('animation rate', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length fade in time', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('max length', PARAM_TYPE_FLOAT, 2000.0);
        this.addParam('min length', PARAM_TYPE_FLOAT, 0.0);
        //	DMXELEMENT_UNPACK_FIELD('animation rate', '.1', float, m_flAnimationRate)
        //	DMXELEMENT_UNPACK_FIELD('length fade in time', '0', float, m_flLengthFadeInTime)
        //	DMXELEMENT_UNPACK_FIELD('max length', '2000', float, m_flMaxLength)
        //	DMXELEMENT_UNPACK_FIELD('min length', '0', float, m_flMinLength)
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderSpriteTrail(particleList[i], elapsedTime, material);
        }
    }*/
    updateParticles(particleSystem, particleList, elapsedTime) {
        const rate = this.getParameter('animation rate') ?? 30;
        this.geometry.count = particleList.length * 6;
        let maxParticles = new Graphics().isWebGL2 ? particleSystem.maxParticles : ceilPowerOfTwo(particleSystem.maxParticles);
        this.setupParticlesTexture(particleList, maxParticles, elapsedTime);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source1ParticleControler.visible);
        let index = 0;
        for (const particle of particleList) {
            let coords = this.particleSystem.material.getTexCoords(0, particle.currentTime, rate * SEQUENCE_SAMPLE_COUNT, particle.sequence);
            if (coords) {
                const uvs = this.geometry.attributes.get('aTextureCoord')._array;
                coords = coords.m_TextureCoordData[0];
                let uMin = coords.m_fLeft_U0;
                let vMin = coords.m_fTop_V0;
                let uMax = coords.m_fRight_U0;
                let vMax = coords.m_fBottom_V0;
                uvs[index++] = uMin;
                uvs[index++] = vMin;
                uvs[index++] = uMax;
                uvs[index++] = vMin;
                uvs[index++] = uMin;
                uvs[index++] = vMax;
                uvs[index++] = uMax;
                uvs[index++] = vMax;
            }
            else {
                index += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
    }
    initRenderer(particleSystem) {
        let maxParticles = new Graphics().isWebGL2 ? particleSystem.maxParticles : ceilPowerOfTwo(particleSystem.maxParticles);
        this.createParticlesArray(maxParticles);
        this.#createParticlesTexture();
        const vertices = [];
        const uvs = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < maxParticles; i++) {
            let indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        let vertexPosition = new Float32BufferAttribute(vertices, 3);
        let textureCoord = new Float32BufferAttribute(uvs, 2);
        let particleId = new Float32BufferAttribute(id, 1);
        let geometry = new BufferGeometry();
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', vertexPosition);
        geometry.setAttribute('aTextureCoord', textureCoord);
        geometry.setAttribute('aParticleId', particleId);
        geometry.count = indices.length;
        this.mesh = new Mesh(geometry, particleSystem.material);
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.mesh.setUniform('uParticles', this.texture);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        particleSystem.addChild(this.mesh);
        this.geometry = geometry;
        particleSystem.material.setDefine('RENDER_SPRITE_TRAIL');
        //particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
        this.setOrientationType(0);
    }
    createParticlesArray(maxParticles) {
        this.imgData = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        this.texture.addUser(this);
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture(maxParticles, pixels) {
        const gl = new Graphics().glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, maxParticles, 0, GL_RGBA, GL_FLOAT, pixels);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, maxParticles, 0, GL_RGBA, GL_FLOAT, pixels);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles, elapsedTime) {
        const m_flMaxLength = this.getParameter('max length');
        const m_flMinLength = this.getParameter('min length');
        const m_flLengthFadeInTime = this.getParameter('length fade in time');
        this.getParameter('animation rate') ?? 30;
        this.getParameter('animation_fit_lifetime') ?? 0;
        /*
                if (fit) {
                    rate = material.sequenceLength / particle.timeToLive;
                }
                    */
        const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;
        for (let particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = subtract$3(create$4(), particle.prevPosition, particle.position); //TODOv3: optimize
            const flMag = length$5(vecDelta);
            normalize$5(vecDelta, vecDelta);
            const flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength;
            if (flLength <= 0.0) {
                return;
            }
            flLength = clamp(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3
            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius;
            if (flLength < rad) {
                rad = flLength;
            }
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            index += 16;
        }
        this.updateParticlesTexture(maxParticles, a);
    }
    setupParticlesTexture1(particleList, maxParticles, elapsedTime) {
        const m_flMaxLength = this.getParameter('max length');
        const m_flMinLength = this.getParameter('min length');
        const m_flLengthFadeInTime = this.getParameter('length fade in time');
        this.getParameter('animation rate') || 30;
        this.getParameter('animation_fit_lifetime') || 0;
        /*
                if (fit) {
                    rate = material.sequenceLength / particle.timeToLive;
                }
        */
        const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;
        for (let particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = subtract$3(create$4(), particle.prevPosition, particle.position); //TODOv3: optimize
            const flMag = length$5(vecDelta);
            normalize$5(vecDelta, vecDelta);
            const flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength;
            if (flLength <= 0.0) {
                return;
            }
            flLength = clamp(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3
            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius;
            if (flLength < rad) {
                rad = flLength;
            }
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            index += 16;
        }
        this.updateParticlesTexture(maxParticles, a);
    }
    dispose() {
        this.mesh?.dispose();
        this.texture.removeUser(this);
    }
}
SourceEngineParticleOperators.registerOperator(RenderSpriteTrail);

var source1_blend_pixel_fog_const = `
vec3 BlendPixelFogConst( const vec3 vShaderColor, float pixelFogFactor, const vec3 vFogColor, float fPixelFogType )
{
	pixelFogFactor = clamp( pixelFogFactor, 0.0, 1.0);
	vec3 fRangeResult = mix( vShaderColor.rgb, vFogColor.rgb, pixelFogFactor * pixelFogFactor ); //squaring the factor will get the middle range mixing closer to hardware fog
	vec3 fHeightResult = mix( vShaderColor.rgb, vFogColor.rgb, pixelFogFactor);
	return mix( fRangeResult, fHeightResult, fPixelFogType );
}
`;

var source1_blend_tint = `
#ifdef BLEND_TINT_BY_BASE_ALPHA
	vec3 tintedColor = albedo * g_DiffuseModulation.rgb;
	tintedColor = mix(tintedColor, g_DiffuseModulation.rgb, uBlendTintColorOverBase);
	albedo = mix(albedo, tintedColor, texelColor.a);
#else
	albedo = albedo * g_DiffuseModulation.rgb;
#endif
`;

var source1_colormap_alpha = `
#ifdef IS_TRANSLUCENT
	#if !defined(BASE_ALPHA_ENV_MAP_MASK) && !defined(SELF_ILLUM) && !defined(BLEND_TINT_BY_BASE_ALPHA) && !defined(USE_COLOR_ALPHA_AS_PHONG_MASK)
		alpha *= texelColor.a;
	#endif
#endif
`;

var source1_compute_particle_position = `
vec4 q;
vec3 a;
#ifndef PARTICLE_ORIENTATION
	#define PARTICLE_ORIENTATION 3
#endif
#ifndef USE_PARTICLE_YAW
	#define USE_PARTICLE_YAW 1
#endif

#define PARTICLE_ORIENTATION_SCREEN_ALIGNED 0
#define PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED 1
#define PARTICLE_ORIENTATION_WORLD_Z_ALIGNED 2
#define PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL 3
#define PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL 4
#define PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION 5

	particle p = getParticle(int(aParticleId));
	vTextureCoord.xy = aTextureCoord;
	vColor = p.color;

	vec3 aVertexPosition3 = aVertexPosition;


	//vec4 test = vec4(aVertexPosition3 + vecDelta, 1.0);// * p.radius * rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 1.0);
	vec4 test = vec4(aVertexPosition3, 1.0) * p.radius * rotationMatrix(vec3(0.0, .0, 1.0), -p.roll * 1.0);
	vec4 vertexPositionModelSpace = vec4(p.center.xyz + test.xyz, 1.0);
	//vertexPositionModelSpace *= rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 100.0);

	vec4 vertexPositionCameraSpace;// = uModelViewMatrix * vertexPositionModelSpace;


#ifdef RENDER_SPRITE_TRAIL
	vec3 vecDelta = p.vecDelta.xyz;
	//vecDelta = vec3(1.0, 1.0, 0.0);
	vec3 aVertexPosition2;

	a = cross(vec3(1.0, 0.0, 0.0), vecDelta);
	q.xyz = a;
	q.w = 1.0 + dot(vec3(1.0, 0.0, 0.0), vecDelta);

	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w, 0.0, p.radius), normalize(q));

	vertexPositionModelSpace = vec4(p.center + aVertexPosition2 + vecDelta * p.vecDelta.w * 0.0, 1.0);


	vec3 test2 = vec3_transformQuat(vec3(0.0, 0.0, 1.0), normalize(q));
	test2 = normalize(test2);


	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w * 0.5, p.radius * 0.5, 0.0), normalize(q));
	vec3 eyeDir = p.center - uCameraPosition;
	q.xyz = vecDelta;
	q.w = 1.0 + dot(eyeDir, a);

#endif


#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREEN_ALIGNED
#ifdef RENDER_SPRITE_TRAIL
	//A + dot(AP,AB) / dot(AB,AB) * AB
	vec3 A =  p.center;
	vec3 B =  A + vecDelta;
	vec3 P =  uCameraPosition;
	vec3 AP = P-A;
	vec3 AB = B-A;

	vec3 projPoint = A + dot(AP,AB) / dot(AB,AB) * AB;


	vec3 vDirToBeam = normalize(projPoint - uCameraPosition);
	vec3 vTangentY = normalize(cross(vDirToBeam, vecDelta));
	vTangentY = test2;
	vertexPositionModelSpace = vec4(aVertexPosition2 + vecDelta * p.vecDelta.w * 0.5, 1.0);


	A = -vDirToBeam;
	B = normalize(vecDelta);
	mat3 M  = mat3(
1.0-B.x*B.x,-B.y*B.x,-B.z*B.x,
-B.x*B.y,1.0-B.y*B.y,-B.z*B.y,
-B.x*B.z,-B.y*B.z,1.0-B.z*B.z
	    );
	vec3 C = M * A;//B * (A * B / length(B)) / length(B);

	q.xyz = cross(vTangentY, C);
	q.w = 1.0 + dot(vTangentY, C);
	vertexPositionModelSpace = vec4_transformQuat(vertexPositionModelSpace, normalize(q));
	vertexPositionModelSpace.xyz += p.center;


	//vertexPositionModelSpace.xyz = vertexPositionModelSpace.xyz + vTangentY * p.radius * 0.5;


	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#else
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));

#endif
#else
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), -p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_WORLD_Z_ALIGNED
	mat4 yawMatrix = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);

	#ifdef IS_SPRITE_CARD_MATERIAL
		mat4 rollMatrix = rotationMatrix(vec3(0.0, 0.0, 1.0), HALF_PI - p.roll);
	#else
		mat4 rollMatrix = rotationMatrix(vec3(0.0, 0.0, 1.0), p.roll);
	#endif
	mat4 lookAt;

	mat4 cpMat = mat4FromQuat(uOrientationControlPoint);

	#if USE_PARTICLE_YAW == 1
		lookAt = cpMat * yawMatrix * rollMatrix;
	#else
		lookAt = cpMat * rollMatrix;
	#endif

	#ifndef IS_SPRITE_CARD_MATERIAL
		gl_Position = uProjectionMatrix * (uModelViewMatrix * (vec4(p.center, 1.0) + lookAt * vec4(vec2(1.0, -1.0) * aVertexPosition.xy * p.radius, 0.0, 0.0)));
	#else
		gl_Position = uProjectionMatrix * (uModelViewMatrix * (vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0)));
	#endif
#endif

#ifdef SOURCE1_PARTICLES
	#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), -p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		lookAt = lookAt * lookAt2;
		gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
	#endif
#else //SOURCE2
	#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL
		vec3 particleNormal = normalize(p.normal);//not sure we have to normalize
		mat4 lookAt = rotationMatrix(particleNormal, p.roll);
		vec4 pos;

		vec3 vTrialVector = vec3( 0.0, 0.0, 1.0 );
		if ( abs( particleNormal.z ) > 0.9 )
		{
			vTrialVector = float3( 1, 0, 0 );
		}
		vec3 up = normalize( cross( particleNormal, vTrialVector ) );
		vec3 right = cross( particleNormal, up );

	    pos.xyz = aVertexPosition.x * p.radius * right;
	    pos.xyz += aVertexPosition.y * p.radius * up;
		pos = lookAt * pos;
		pos += vec4(p.center, 1.0);
		gl_Position = uProjectionMatrix * (uModelViewMatrix * pos);
	#endif
#endif
`;

var source1_compute_selfillum = `
#if defined(USE_SELF_ILLUM) && COLOR_MAP_ALPHA_BITS > 0
	#ifdef USE_SELF_ILLUM_ENVMAPMASK_ALPHA
		#ifdef USE_CUBE_MAP
			vec3 selfIllumComponent = uSelfIllumTint * albedo;
			float Adj_Alpha = 1. * cubeMapColor.a;
			diffuse = max(0., 1. - Adj_Alpha) * diffuse + Adj_Alpha * selfIllumComponent;
		#endif
	#else
		#ifdef USE_SELF_ILLUM_MASK_MAP
			vec3 selfIllumMask = texture2D(uSelfIllumMaskMap, vTextureCoord.xy).rgb;
		#else
			vec3 selfIllumMask = texelColor.aaa;
		#endif

		#if !defined(SKIP_SELF_ILLUM_FRESNEL) && defined(USE_SELF_ILLUM_FRESNEL)
			vec3 worldVertToEyeVectorXYZ_tangentSpaceVertToEyeVectorZ = normalize(uCameraPosition - vVertexPositionWorldSpace.xyz);
			vec3 vVertexNormal = normalize(vVertexNormalWorldSpace.xyz);

			float flSelfIllumFresnel = (
										pow(
											saturate(
												dot(vVertexNormal, normalize(worldVertToEyeVectorXYZ_tangentSpaceVertToEyeVectorZ))
											), uSelfIllumScaleBiasExpBrightness.z
										) * uSelfIllumScaleBiasExpBrightness.x) + uSelfIllumScaleBiasExpBrightness.y;
			diffuse = mix(diffuse, albedo * uSelfIllumTint * uSelfIllumScaleBiasExpBrightness.w, selfIllumMask * saturate(flSelfIllumFresnel));
		#else
			// Not sure why I need to multiply by g_DiffuseModulation.rgb, but it works better
			diffuse = mix(diffuse, albedo * uSelfIllumTint * g_DiffuseModulation.rgb, selfIllumMask);
		#endif
	#endif
#endif
`;

var source1_compute_sheen = `
vec3 sheenMapColor = vec3(1.0);

#ifdef USE_SHEEN_MASK_MAP
	vec2 sheenMaskCoords = vec2(0.0);
	if (g_flSheenDirection == 0.0) {
		sheenMaskCoords.x = vVertexPositionModelSpace.z;
		sheenMaskCoords.y = vVertexPositionModelSpace.y;
	} else if (g_flSheenDirection == 1.0) {
		sheenMaskCoords.x = vVertexPositionModelSpace.z;
		sheenMaskCoords.y = vVertexPositionModelSpace.x;
	} else {
		sheenMaskCoords.x = vVertexPositionModelSpace.y;
		sheenMaskCoords.y = vVertexPositionModelSpace.x;
	}

	sheenMaskCoords = (sheenMaskCoords - g_vPackedConst6.zw) / g_vPackedConst6.xy;

	sheenMapColor *= texture2D(sheenMaskMap, sheenMaskCoords).rgb;
#endif


	//vec3 sheenMapTint = texture2D(sheenMapMask, (sheenMaskCoord - vec2(sheenMapMaskOffsetX)) / sheenMapMaskScaleX).rgb;
#ifdef USE_SHEEN_MAP
	sheenMapColor *= vec4(textureCube(sheenMap, reflectDir)).rgb;
	sheenMapColor *= g_cCloakColorTint.rgb;

	gl_FragColor.rgb += sheenMapColor * 3.0;
#endif


#ifdef USE_SHEEN_MASK_MAP
	//albedo = abs(vec3(sheenMaskCoords.xy, 0.0));
#endif
`;

var source1_declare_gamma_functions = `
#ifndef SKIP_GAMMA_TO_LINEAR
	float GammaToLinear(const float gamma) {
		return pow(gamma, 2.2);
	}
	vec3 GammaToLinear(const vec3 gamma) {
		return pow(gamma, vec3(2.2));
	}
	vec4 GammaToLinear(const vec4 gamma) {
		return vec4(pow(gamma.rgb, vec3(2.2)), gamma.a);
	}
#else
	float GammaToLinear(const float gamma) {
		return gamma;
	}
	vec3 GammaToLinear(const vec3 gamma) {
		return gamma;
	}
	vec4 GammaToLinear(const vec4 gamma) {
		return gamma;
	}
#endif
`;

var source1_declare_particle_position = `
vec4 vec4_transformQuat(vec4 a, vec4 q) {
	vec4 ret;
	float qx = q.x;
	float qy = q.y;
	float qz = q.z;
	float qw = q.w;

	float x = a.x;
	float y = a.y;
	float z = a.z;

	// calculate quat * vec
	float ix = qw * x + qy * z - qz * y;
	float iy = qw * y + qz * x - qx * z;
	float iz = qw * z + qx * y - qy * x;
	float iw = -qx * x - qy * y - qz * z;

	// calculate result * inverse quat
	ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	ret.w = a.w;
	return ret;
}
`;

var source1_declare_phong = `
//TODO: set a vec2 for these two ?
uniform float uPhongExponent;
uniform float uPhongExponentFactor;
uniform float uPhongBoost;
`;

var source1_declare_selfillum = `
#ifdef USE_SELF_ILLUM
	uniform vec3 uSelfIllumTint;

	#ifdef USE_SELF_ILLUM_MASK_MAP
		uniform sampler2D uSelfIllumMaskMap;
	#endif

	#ifndef SKIP_SELF_ILLUM_FRESNEL
		#ifdef USE_SELF_ILLUM_FRESNEL
			uniform vec4 uSelfIllumScaleBiasExpBrightness;
		#endif
	#endif
#endif
`;

var source1_declare_sheen = `
#ifdef USE_SHEEN_MAP
	uniform samplerCube sheenMap;
#endif
#ifdef USE_SHEEN_MASK_MAP
	uniform sampler2D sheenMaskMap;
#endif

uniform vec4 g_vPackedConst6;
uniform vec4 g_vPackedConst7;
uniform vec3 g_cCloakColorTint;

#define g_flSheenMapMaskScaleX g_vPackedConst6.x // Default = 1.0f
#define g_flSheenMapMaskScaleY g_vPackedConst6.y // Default = 1.0f
#define g_flSheenMapMaskOffsetX g_vPackedConst6.z // Default = 0.0f
#define g_flSheenMapMaskOffsetY g_vPackedConst6.w // Default = 0.0f

#define g_flSheenDirection		g_vPackedConst7.x // 0,1,2 -> XYZ
#define g_flEffectIndex			g_vPackedConst7.y // W
`;

var source1_final_output_const = `
#include source1_blend_pixel_fog_const

vec4 FinalOutputConst( const vec4 vShaderColor, float pixelFogFactor, float fPixelFogType, const int iTONEMAP_SCALE_TYPE, float fWriteDepthToDestAlpha, const float flProjZ )
{
	vec4 result = vShaderColor;
	if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_LINEAR )
	{
		result.rgb *= LINEAR_LIGHT_SCALE;
	}
	else if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_GAMMA )
	{
		result.rgb *= GAMMA_LIGHT_SCALE;
	}

	result.a = mix( result.a, DepthToDestAlpha( flProjZ ), fWriteDepthToDestAlpha );

	result.rgb = BlendPixelFogConst( result.rgb, pixelFogFactor, g_LinearFogColor.rgb, fPixelFogType );
	result.rgb = SRGBOutput( result.rgb ); //SRGB in pixel shader conversion

	return result;
}
`;

var source1_fragment_common = `

const vec4 g_LinearFogColor = vec4(0.0, 0.0, 0.0, 1.0 / 192.0);
#define OO_DESTALPHA_DEPTH_RANGE (g_LinearFogColor.w)

#define HDR_INPUT_MAP_SCALE 16.0

#define TONEMAP_SCALE_NONE 0
#define TONEMAP_SCALE_LINEAR 1
#define TONEMAP_SCALE_GAMMA 2


#define LINEAR_LIGHT_SCALE 1.0
#define LIGHT_MAP_SCALE 1.0
#define ENV_MAP_SCALE 1.0
#define GAMMA_LIGHT_SCALE pow(1.0, 1.0 / 2.2);

//sampler1D GammaTableSampler : register( s15 );
uniform sampler2D gammaTableMap;

vec3 SRGBOutput( const vec3 vShaderColor )
{
	return vShaderColor;//TODOv3: remove me
	//On ps2b capable hardware we always have the linear->gamma conversion table texture in sampler s15.
	vec3 result;
	result.r = texture2D( gammaTableMap, vec2(vShaderColor.r, 0.5)).r;
	result.g = texture2D( gammaTableMap, vec2(vShaderColor.g, 0.5)).r;
	result.b = texture2D( gammaTableMap, vec2(vShaderColor.b, 0.5)).r;
	return result;
}

float SoftParticleDepth( float flDepth )
{
	return flDepth * OO_DESTALPHA_DEPTH_RANGE;
}
float DepthToDestAlpha( const float flProjZ )
{
	return SoftParticleDepth( flProjZ );
}


float3 CalcReflectionVectorUnnormalized( float3 normal, float3 eyeVector )
{
	// FIXME: might be better of normalizing with a normalizing cube map and
	// get rid of the dot( normal, normal )
	// compute reflection vector r = 2 * ((n dot v)/(n dot n)) n - v
	//  multiply all values through by N.N.  uniformly scaling reflection vector won't affect result
	//  since it is used in a cubemap lookup
	return (2.0*(dot( normal, eyeVector ))*normal) - (dot( normal, normal )*eyeVector);
}


// Traditional fresnel term approximation
float Fresnel( const float3 vNormal, const float3 vEyeDir )
{
	float fresnel = 1.0-saturate( dot( vNormal, vEyeDir ) );				// 1-(N.V) for Fresnel term
	return fresnel * fresnel;											// Square for a more subtle look
}

// Traditional fresnel term approximation which uses 4th power (square twice)
float Fresnel4( const float3 vNormal, const float3 vEyeDir )
{
	float fresnel = 1.0-saturate( dot( vNormal, vEyeDir ) );				// 1-(N.V) for Fresnel term
	fresnel = fresnel * fresnel;										// Square
	return fresnel * fresnel;											// Square again for a more subtle look
}

float Fresnel( const float3 vNormal, const float3 vEyeDir, float3 vRanges )
{
	float result, f = Fresnel( vNormal, vEyeDir );			// Traditional Fresnel

	if ( f > 0.5 )
		result = lerp( vRanges.y, vRanges.z, (2.0*f)-1.0 );		// Blend between mid and high values
	else
		result = lerp( vRanges.x, vRanges.y, 2.0*f );			// Blend between low and mid values
	return result;
}
`;

var source1_varying_character = `
#include varying_standard
`;

var source1_varying_customweapon = `
#include varying_standard
`;

var source1_varying_eyerefract = `
`;

var source1_varying_refract = `
#include varying_standard
varying vec4 vDetailTextureCoord;
`;

var source1_varying_sprite = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_spritecard = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_unlit_generic = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_unlittwotexture = `
#include varying_standard

varying vec4 vColor;
`;

var source1_varying_vertexlit_generic = `
#include varying_standard
varying vec4 vDetailTextureCoord;
`;

var source1_varying_weapondecal = `
varying vec4 vVertexPositionWorldSpace;
varying vec4 vVertexPositionCameraSpace;

varying vec3 vVertexNormalWorldSpace;
varying vec3 vVertexNormalCameraSpace;
varying vec3 vVertexTangentWorldSpace;
varying vec3 vVertexTangentCameraSpace;
varying vec3 vVertexBitangentWorldSpace;
varying vec3 vVertexBitangentCameraSpace;

varying vec4 vTextureCoord;
`;

var source1_varying_worldvertextransition = `
#include varying_standard
varying vec2 vLightCoord;
varying float vVertexAlpha;
varying float vEyeDistance;
`;

Includes['source1_blend_pixel_fog_const'] = source1_blend_pixel_fog_const;
Includes['source1_blend_tint'] = source1_blend_tint;
Includes['source1_colormap_alpha'] = source1_colormap_alpha;
Includes['source1_compute_particle_position'] = source1_compute_particle_position;
Includes['source1_compute_selfillum'] = source1_compute_selfillum;
Includes['source1_compute_sheen'] = source1_compute_sheen;
Includes['source1_declare_gamma_functions'] = source1_declare_gamma_functions;
Includes['source1_declare_particle_position'] = source1_declare_particle_position;
Includes['source1_declare_phong'] = source1_declare_phong;
Includes['source1_declare_selfillum'] = source1_declare_selfillum;
Includes['source1_declare_sheen'] = source1_declare_sheen;
Includes['source1_final_output_const'] = source1_final_output_const;
Includes['source1_fragment_common'] = source1_fragment_common;
Includes['source1_varying_character'] = source1_varying_character;
Includes['source1_varying_customweapon'] = source1_varying_customweapon;
Includes['source1_varying_eyerefract'] = source1_varying_eyerefract;
Includes['source1_varying_refract'] = source1_varying_refract;
Includes['source1_varying_sprite'] = source1_varying_sprite;
Includes['source1_varying_spritecard'] = source1_varying_spritecard;
Includes['source1_varying_unlit_generic'] = source1_varying_unlit_generic;
Includes['source1_varying_unlittwotexture'] = source1_varying_unlittwotexture;
Includes['source1_varying_vertexlit_generic'] = source1_varying_vertexlit_generic;
Includes['source1_varying_weapondecal'] = source1_varying_weapondecal;
Includes['source1_varying_worldvertextransition'] = source1_varying_worldvertextransition;

var source1_character_fs = `
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#include declare_fragment_mask_map
#include declare_fragment_alpha_test
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map

uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;

#include source1_final_output_const

#include declare_lights

#include source1_varying_character

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map
	#include compute_fragment_mask1_map
	#include compute_fragment_mask2_map

	#include compute_fragment_normal

	float phongMask = 0.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;
	//gl_FragColor = FinalOutputConst(vec4(albedo, alpha), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, worldPos_projPosZ.w );
	//gl_FragColor = FinalOutputConst( float4( result.rgb, alpha ), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, i.worldPos_projPosZ.w );

	if (gl_FragCoord.x < 400.) {
		//gl_FragColor = vec4(texelColor.rgb, 1.);
	}
	/*if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}*/
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif

#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongExponent;
#endif
	material.specularStrength = uPhongBoost;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/

#include compute_fragment_render_mode
/* TEST SHADING BEGIN*/
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = alpha;

/* TEST SHADING END*/


#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif


	//gl_FragColor = texelMask1;

	#include source1_compute_selfillum
	#include source1_compute_sheen
	#include compute_fragment_standard
}
`;

var source1_character_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source1_varying_character

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection

	vec4 vProjPos = uViewProjectionMatrix * vertexPositionWorldSpace;
	//o.projPos = vProjPos;
	vProjPos.z = dot(vertexPositionWorldSpace, uViewProjectionMatrix[2] );
	//worldPos_projPosZ = vec4(vertexPositionWorldSpace.xyz, vProjPos.z );
}
`;

var source1_customweapon_fs = `
#define PAINT_STYLE_NONE 0
#define PAINT_STYLE_SOLID 1
#define PAINT_STYLE_HYDROGRAPHIC 2
#define PAINT_STYLE_SPRAY 3
#define PAINT_STYLE_ANODIZED 4
#define PAINT_STYLE_ANODIZED_MULTI 5
#define PAINT_STYLE_ANODIZED_AIR 6
#define PAINT_STYLE_CUSTOM 7
#define PAINT_STYLE_ANTIQUED 8
#define PAINT_STYLE_GUNSMITH 9

#ifndef PAINT_STYLE
	#define PAINT_STYLE 0
#endif
#ifndef EXPONENTMODE
	#define EXPONENTMODE 0
#endif
#ifndef PREVIEW
	#define PREVIEW 1
#endif
#ifndef CHEAPMODE
	#define CHEAPMODE 0
#endif
#ifndef PHONGALBEDOFACTORMODE
	#define PHONGALBEDOFACTORMODE 0
#endif
#ifndef PREVIEWPHONGALBEDOTINT
	#define PREVIEWPHONGALBEDOTINT 1
#endif
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_exponent_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map
#ifdef USE_PATTERN_MAP
	uniform sampler2D patternMap;
#endif
#include declare_fragment_ao_map
#ifdef USE_SCRATCHES_MAP
	uniform sampler2D scratchesMap;
#endif
#ifdef USE_GRUNGE_MAP
	uniform sampler2D grungeMap;
#endif
#ifdef USE_SURFACE_MAP
	uniform sampler2D surfaceMap;
#endif
#ifdef USE_POS_MAP
	uniform sampler2D posMap;
#endif

#if ((PAINT_STYLE == PAINT_STYLE_SPRAY) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR))
	uniform vec4 g_patternTexCoordTransform[2];
#endif


uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;
uniform float uWearProgress;
#define g_flWearAmt uWearProgress//TODO: manually replace

#include source1_final_output_const

#include declare_lights

/*********/
//customization

uniform vec3 uCamoColor0;
uniform vec3 uCamoColor1;
uniform vec3 uCamoColor2;
uniform vec3 uCamoColor3;
#define g_cCamo0 uCamoColor0
#define g_cCamo1 uCamoColor1
#define g_cCamo2 uCamoColor2
#define g_cCamo3 uCamoColor3
/*********/
/*vec4 triplanarPatternColor(vec3 posColor) {
	vec4 color;
	float mXY = abs(normalVector.z);
	float mXZ = abs(normalVector.y);
	float mYZ = abs(normalVector.x);


	float total = mXY + mXZ + mYZ;
	mXY /= total;
	mXZ /= total;
	mYZ /= total;

	vec2 scale = vec2(1.0/16.0);
	vec2 t1 = v.xy * scale + uPatternOffset;
	vec2 t2 = v.xz * scale + uPatternOffset;
	vec2 t3 = v.yz * scale + uPatternOffset;

	vec2 c1,c2,c3;

	c1.s = t1.s*cos(uPatternRotate)-t1.t*sin(uPatternRotate);
	c1.t = t1.t*cos(uPatternRotate)+t1.s*sin(uPatternRotate);
	c2.s = t2.s*cos(uPatternRotate)-t2.t*sin(uPatternRotate);
	c2.t = t2.t*cos(uPatternRotate)+t2.s*sin(uPatternRotate);
	c3.s = t3.s*cos(uPatternRotate)-t3.t*sin(uPatternRotate);
	c3.t = t3.t*cos(uPatternRotate)+t3.s*sin(uPatternRotate);

	vec4 cXY = texture2D(detailMap, c1);
	vec4 cXZ = texture2D(detailMap, c2);
	vec4 cYZ = texture2D(detailMap, c3);

	color = cXY*mXY + cXZ*mXZ + cYZ*mYZ;
	return cYZ * (abs(mYZ)+abs(mXZ)) + cXY * mXY;//side good
	return color;
}*/

#define		 g_flBlendYPow			7.0
#define		 g_flBlendZPow			7.0
#define		 g_flAnodizedBaseExponent 0.004
#define		 g_flAnodizedBasePhongIntensity 1.0
#define		 g_cAnodizedBase		vec3(0.05)

#define		 g_flPhongAlbedoFactor	 1.0//g_fvPhongSettings_wear.x//TODO
#define		 g_flPaintExponent		 1.0//g_fvPhongSettings_wear.y
#define		 g_flPaintPhongIntensity 1.0//g_fvPhongSettings_wear.z

uniform vec4 g_PreviewPhongBoosts;
#define  g_PreviewPhongAlbedoBoost	1.0//	g_PreviewPhongBoosts.x//TODO
#define  g_PreviewPhongBoost		1.0//	g_PreviewPhongBoosts.y
#define  g_PreviewPatternScale		g_PreviewPhongBoosts.z

#include source1_varying_customweapon

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform

void main(void) {
	float4 cOut = vec4(0.0, 0.0, 0.0, 1.0);
	#include compute_fragment_ao_map
#define fvAoSrc texelAo//TODO: manually replace
	float flCavity = texelAo.r;
	float flPaintBlend = fvAoSrc.a;

	#ifdef USE_SCRATCHES_MAP
		vec4 texelScratches = texture2D(scratchesMap, vTexture2Coord.xy);
	#else
		vec4 texelScratches = vec4(1.0);
	#endif
#define flPaintWear	texelScratches.g//TODO: manually replace

	#ifdef USE_PATTERN_MAP
		vec4 texelPattern = texture2D(patternMap, vTextureCoord.zw);
	#else
		vec4 texelPattern = vec4(1.0);
	#endif
#define fvPattern texelPattern//TODO: manually replace

	#include compute_fragment_mask1_map
#define fvMasks texelMask1//TODO: manually replace

	#include compute_fragment_exponent_map
#define cExp texelExponent//TODO: manually replace
#define cOrigExp texelExponent//TODO: manually replace

	#if (PAINT_STYLE != PAINT_STYLE_ANTIQUED)
		flPaintBlend += flPaintWear * flCavity;
		flPaintBlend *= g_flWearAmt * 6.0 + 1.0;
		#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_CUSTOM) || (PAINT_STYLE == PAINT_STYLE_GUNSMITH)) // Paint patterns and durability
			float flCuttableArea = 1.0;
			#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI))
				flCuttableArea = 1.0 - saturate(fvMasks.g + fvMasks.b);
			#endif
			// cut through
			flPaintBlend += smoothstep(0.5, 0.6, fvPattern.a) * smoothstep(1.0, 0.9, fvPattern.a);
			#if (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI)
				// rescale the alpha to represent exponent in the range of 0-255 and let the cutout mask area fall off the top end
				fvPattern.a = saturate(fvPattern.a * 2.0);
			#elif (PAINT_STYLE == PAINT_STYLE_GUNSMITH)
				flPaintBlend *= max (1.0 - flCuttableArea, smoothstep(0.0, 0.5, fvPattern.a));
				// rescale the alpha to represent exponent in the range of 0-255 and let the cutout mask area fall off the top end
				fvPattern.a = lerp(fvPattern.a, saturate(fvPattern.a * 2.0), fvMasks.r);
				// indestructible paint
			#else
				// indestructible paint
				flPaintBlend *= max (1.0 - flCuttableArea, smoothstep(0.0, 0.5, fvPattern.a));
			#endif
		#endif//#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_CUSTOM) || (PAINT_STYLE == PAINT_STYLE_GUNSMITH))
		#if (((EXPONENTMODE == 1) || (PREVIEW == 1)) && ((PAINT_STYLE == PAINT_STYLE_ANODIZED) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR )))
			float flPaintExpBlend = smoothstep( 0.99, 1.0, flPaintBlend );
		#else
			float flPaintExpBlend = flPaintBlend;
		#endif
	#elif ((EXPONENTMODE == 1) || (PREVIEW == 1))
		float flPaintExpBlend = flPaintBlend;
	#endif//#if (PAINT_STYLE != 8)

	#if ( ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_SPRAY ) ) // paint wears off in layers
		vec3 fvPaintEdges = vec3(1.0);
		float3 spread = vec3(0.06) * g_flWearAmt; // spread of partially worn paint increases as the gun becomes more worn
		spread.y *= 2.0;
		spread.z *= 3.0;

		fvPaintEdges.x = smoothstep ( 0.58, 0.56 - spread.x, flPaintBlend );
		fvPaintEdges.y = smoothstep ( 0.56 - spread.x, 0.54 - spread.y, flPaintBlend );
		fvPaintEdges.z = smoothstep ( 0.54 - spread.y, 0.52 - spread.z, flPaintBlend );
	#endif

	#if ( ( PAINT_STYLE != 8 ) && ( PAINT_STYLE != 9 ) )
		flPaintBlend = smoothstep( 0.58, 0.68, flPaintBlend );
	#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
		flPaintBlend = lerp( smoothstep( 0.58, 0.68, flPaintBlend ), flPaintBlend, fvMasks.r );
	#endif

	#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) ) // Anodized paint scratches through uncolored base coat
		float flPaintEdges = smoothstep ( 0.0, 0.01, flPaintBlend );
	#endif


	// ------------------------------------------------------------------------------------------------------
	// Exponent texture
	// ------------------------------------------------------------------------------------------------------
	#if ( ( EXPONENTMODE == 1 ) || ( PREVIEW == 1 ) )
		//float4 cExp = tex2D( ExponentSampler, i.vBaseUV_PatternUV.xy );
		#if ( ( PREVIEW == 1 ) && ( PREVIEWPHONGALBEDOTINT == 0 ) )
			cExp.g = 0.0;
		#endif
		float4 cPaintExp = cExp;

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) || ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) ) // Anodized/metallic
			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				flPaintBlend = 1.0 - step( flPaintExpBlend, 0.996 ) * fvMasks.r;
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				flPaintBlend = lerp( flPaintBlend, 1.0 - step( flPaintExpBlend, 0.996 ), fvMasks.r );
			#else
				flPaintBlend = saturate( 1.0 + flPaintExpBlend - fvMasks.r );
			#endif

			// exponent
			#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI )
				float flPatternExponentBlend = max( max( fvMasks.g, fvMasks.b ), flPaintBlend );
				cPaintExp.r = lerp( fvPattern.a, cExp.r, flPatternExponentBlend );
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaintExp.r = lerp( g_flPaintExponent, fvPattern.a, fvMasks.r );
				cPaintExp.r = lerp( cPaintExp.r, cExp.r, flPaintBlend );
			#else
				cPaintExp.r = lerp( g_flPaintExponent, cExp.r, flPaintBlend );
			#endif

			// phongalbedo
			#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaintExp.g = saturate( fvMasks.r + flPaintBlend * cExp.g );
			#else
				cPaintExp.g = lerp ( 1.0, cExp.g, flPaintBlend );
			#endif

			cPaintExp.a = 1.0;
		#else // Everything else not anodized
			cPaintExp = lerp ( float4( g_flPaintExponent, 0.0, 0.0, 1.0 ), cExp, flPaintBlend );
			cPaintExp.a = 1.0;
		#endif

		#if ( PREVIEW == 0 )
			cOut = cPaintExp;
		#endif
	#endif


	// ------------------------------------------------------------------------------------------------------
	// Diffuse texture
	// ------------------------------------------------------------------------------------------------------
	#if ( ( EXPONENTMODE == 0 ) || ( PREVIEW == 1 ) )
		#include compute_fragment_color_map
		#ifndef USE_COLOR_MAP//TODO: probably not the best way to do that. We should remove all texelColor if no colorMap
			vec4 texelColor = vec4(1.0);
		#endif
#define cBase texelColor
		//float4 cBase = tex2D( BaseSampler, i.vBaseUV_PatternUV.xy );

		float3 cPaint = g_cCamo0;

		// ambient occlusion
		float flAo = fvAoSrc.g;

		// apply grunge to paint only in creases
		//float4 cGrunge = tex2D( GrungeSampler, i.vWearUV_GrungeUV.zw );
		#ifdef USE_GRUNGE_MAP
			vec4 texelGrunge = texture2D(grungeMap, vTexture2Coord.zw);
		#else
			vec4 texelGrunge = vec4(0.0);
		#endif
#define cGrunge texelGrunge//TODO: manually replace
		#if ( ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )
			float flGrunge = cGrunge.r * cGrunge.g * cGrunge.b;
		#endif
		cGrunge = lerp( vec4(1.0), cGrunge, ( pow( ( 1.0 - flCavity ), 4.0 ) * 0.25 + 0.75 * g_flWearAmt ) );

		// ------------------------------------------------------------------------------------------------------
		// Solid style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_SOLID )
			// apply color in solid blocks using masking from the part kit MasksSampler
			cPaint = lerp( cPaint, g_cCamo1, fvMasks.r );
			cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
			cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Hydrographic/anodized multicolored style
		// ------------------------------------------------------------------------------------------------------
		#if ( ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) )
			// create camo using pattern
			cPaint = lerp( lerp( lerp( g_cCamo0, g_cCamo1, fvPattern.r ), g_cCamo2, fvPattern.g ), g_cCamo3, fvPattern.b );

			// apply any masking from the last two masks from MasksSampler, allowing some areas to be solid color
			cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
			cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Spraypaint/anodized airbrushed style
		// ------------------------------------------------------------------------------------------------------
		#if ( ( PAINT_STYLE == PAINT_STYLE_SPRAY ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) )
			// apply spraypaint via box map based on mesh's object-space position as stored in the position pmap
			//float4 fvNormalSrc = tex2D( NormalsSampler, i.vBaseUV_PatternUV.xy );
			#ifdef USE_SURFACE_MAP
				vec4 texelSurface = texture2D(surfaceMap, vTextureCoord.xy);
			#else
				vec4 texelSurface = vec4(1.0);//this is probably wrong. we should never enter here anyway
			#endif
#define fvNormalSrc texelSurface//TODO: manually replace

			float2 fvPosCoord = float2( vTextureCoord.x, 1.0 - vTextureCoord.y );

			float4 fvPos = float4( 0.0, 0.0, 0.0, 0.0 );

			#if ( CHEAPMODE == 0 ) // if supersampling is not disabled
				//super sampling of position map
				float2 offsets[17];
				offsets[ 0] = float2( -0.00107234 ,-0.00400203 );
				offsets[ 1] = float2( 0.00195312, -0.00338291 ),
				offsets[ 2] = float2( 0.00400203, -0.00107234 ),
				offsets[ 3] = float2( -0.000714896, -0.00266802 ),
				offsets[ 4] = float2( 0.000976565, -0.00169146 ),
				offsets[ 5] = float2( 0.00266802, -0.000714896 );
				offsets[ 6] = float2( -0.00338291, -0.00195312 );
				offsets[ 7] = float2( -0.00169146, -0.000976565 );
				offsets[ 8] = float2( 0.0, 0.0 );
				offsets[ 9] = float2( 0.00169146, 0.000976565 );
				offsets[10] = float2( 0.00338291, 0.00195312 );
				offsets[11] = float2( -0.00266802, 0.000714896 );
				offsets[12] = float2( -0.000976565, 0.00169146 );
				offsets[13] = float2( 0.000714896, 0.00266802 );
				offsets[14] = float2( -0.00400203, 0.00107234 );
				offsets[15] = float2( -0.00195312, 0.00338291 );
				offsets[16] = float2( 0.00107234, 0.00400203 );
				for ( int k = 0; k < 17; k++ )
				{
					#ifdef USE_POS_MAP
						//fvPos += tex2D( OSPosSampler, fvPosCoord + offsets[k] ) * 0.05882353;
						fvPos += texture2D( posMap, fvPosCoord + offsets[k] ) * 0.05882353;// 1/17
					#endif

				}
			#else
				fvPos = texture2D( posMap, fvPosCoord );
			#endif

			//extract integer HDR values out from the RGBA vtf
			//developer.valvesoftware.com/wiki/Valve_Texture_Format#HDR_compression
			fvPos.rgb = (fvPos.rgb * (fvPos.a * 16.0) );

			float3 fvNormal = normalize( fvNormalSrc.xyz * 2.0 - 1.0 );

			// Project the mask in object-space x, y and z
			float2 flCoord;


			#if ( PREVIEW == 1 )

				// apply the preview pattern scale to only the scale portion of the pattern transform.

				mat2 tempMatrix = mat2(g_PreviewPatternScale, 0, 0, g_PreviewPatternScale);
				mat2 tempMatrix2 = mat2(g_patternTexCoordTransform[0].xy, g_patternTexCoordTransform[1].xy);
				tempMatrix = tempMatrix * tempMatrix2;

				flCoord.x = dot( fvPos.yz, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yz, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexX = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexX = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.xz, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.xz, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexY = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexY = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.yx, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yx, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexZ = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexZ = texture2D( patternMap, flCoord ).rgb;

			#else

				flCoord.x = dot( fvPos.yz, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yz, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexX = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexX = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.xz, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.xz, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexY = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexY = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.yx, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yx, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexZ = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexZ = texture2D( patternMap, flCoord ).rgb;

			#endif



			// smooth blend the three projections across the object-space surface normals
			float yBlend = abs( dot( fvNormal.xyz, float3( 0.0, 1.0, 0.0 ) ) );
			yBlend = pow( yBlend, g_flBlendYPow );

			float zBlend = abs( dot( fvNormal.xyz, float3( 0.0, 0.0, 1.0 ) ) );
			zBlend = pow( zBlend, g_flBlendZPow );

			float3 fvPatternMask = lerp( lerp( fvTexX, fvTexY, yBlend ), fvTexZ, zBlend );

			#if ( PAINT_STYLE == PAINT_STYLE_SPRAY )// paint wears off in layers
				fvPatternMask.xyz *= fvPaintEdges.xyz;
			#endif

			cPaint = lerp( lerp( lerp( g_cCamo0, g_cCamo1, fvPatternMask.r ), g_cCamo2, fvPatternMask.g ), g_cCamo3, fvPatternMask.b );
			#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR )
				// apply any masking from the last two masks from MasksSampler, allowing some areas to be solid color
				cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
				cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
			#endif
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Anodized style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED )
			cPaint.rgb = g_cCamo0.rgb;
		#endif

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) )
			// chipped edges of anodized dye
			cPaint = lerp( cPaint, g_cAnodizedBase, flPaintEdges );
			cGrunge.rgb = lerp( cGrunge.rgb, float3( 1.0, 1.0, 1.0 ), flPaintEdges );

			// anodize only in areas specified by the masks texture
			flPaintBlend = saturate( 1.0 + flPaintBlend - fvMasks.r );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Custom painted style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_CUSTOM )
			cPaint = fvPattern.rgb;
		#endif
		// ------------------------------------------------------------------------------------------------------
		// Antiqued or Gunsmith style
		// ------------------------------------------------------------------------------------------------------

		#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
			//float4 fvPattern = tex2D( PatternSampler, i.vBaseUV_PatternUV.zw );
		#endif

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )
			float flPatinaBlend = flPaintWear * flAo * flCavity * flCavity;
			flPatinaBlend = smoothstep( 0.1, 0.2, flPatinaBlend * g_flWearAmt );

			float flOilRubBlend = saturate( flCavity * flAo - g_flWearAmt * 0.1 ) - flGrunge;
			flOilRubBlend = smoothstep( 0.0, 0.15, flOilRubBlend + 0.08 );

			float3 cPatina = lerp( g_cCamo1, g_cCamo2, g_flWearAmt );
			float3 cOilRubColor = lerp( g_cCamo1, g_cCamo3, pow( g_flWearAmt, 0.5 ) );
			cPatina = lerp( cOilRubColor, cPatina, flOilRubBlend ) * fvPattern.rgb;

			float3 vLumCoefficients = vec3(0.3, 0.59, 0.11);//TODO: set const
			float fPatternLum = dot( fvPattern.rgb, vLumCoefficients );

			float3 cScratches = g_cCamo0 * fPatternLum;

			cPatina = lerp( cPatina, cScratches, flPatinaBlend );

			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				cPaint = cPatina;
				flPaintBlend = 1.0 - fvMasks.r;
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaint = lerp ( fvPattern.rgb, cPatina, fvMasks.r );
				flPaintBlend = flPaintBlend * ( 1.0 - fvMasks.r );
			#endif
		#endif

		// ------------------------------------------------------------------------------------------------------
		// All paints
		// ------------------------------------------------------------------------------------------------------

		float3 cModulation = fvAoSrc.bbb;//TODO: not sure was float3 cModulation = fvAoSrc.b;
		cPaint.rgb *= cGrunge.rgb;

		// On very dark paints, increase the modulation slightly by adding
		float3 lumCoefficients = vec3(0.3, 0.59, 0.11);//TODO: set const
		float flModulationLum = dot( cPaint.rgb, lumCoefficients );
		flModulationLum = 1.0 - smoothstep( 0.08, 0.15, flModulationLum );

		#if ( ( PAINT_STYLE == PAINT_STYLE_SOLID ) || ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_SPRAY ) || ( PAINT_STYLE == PAINT_STYLE_CUSTOM ) )
			flModulationLum *= 0.03;
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * 0.5;
		#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
			flModulationLum *= lerp( 0.03, 0.005, fvMasks.r );
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * lerp( 0.5, 2.0, fvMasks.r );
		#else
			flModulationLum *= 0.005;
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * 2.0;
		#endif


		cPaint = saturate( cPaint + cModulation );

		cPaint.rgb *= flAo;

		cOut.rgb = lerp( cPaint, cBase.rgb, flPaintBlend );

		// ------------------------------------------------------------------------------------------------------
		// Specular Intensity Mask
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
			#if ( PHONGALBEDOFACTORMODE == 1 )
				float flSpecMask = lerp( g_flPaintPhongIntensity, 1.0, fvMasks.r ) * flAo * cGrunge.a;
			#else
				float flSpecMask = lerp( g_flPaintPhongIntensity, g_flPhongAlbedoFactor, fvMasks.r ) * flAo * cGrunge.a;
			#endif
		#else
			float flSpecMask = g_flPaintPhongIntensity * flAo * cGrunge.a;
		#endif
		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) || ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )// anodized/metallic
			// phongalbedoboost must be increased in the material for the anodized look, so in areas that are
			// already using phongalbedo the specular intensity must be reduced in order to retain approximately
			// the same intensity as the originally authored texture
			float flInvPaintBlend = 1.0 - flPaintBlend;

			//float4 cOrigExp = tex2D( ExponentSampler, i.vBaseUV_PatternUV.xy );
			#if ( ( PREVIEW == 1 ) && ( PREVIEWPHONGALBEDOTINT == 0 ) )
				cOrigExp.g = 0.0;
			#endif
			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				flSpecMask *= lerp( flOilRubBlend * ( 1.0 - flPatinaBlend * g_flWearAmt ), 1.0, flPatinaBlend );
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				float flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend ) * fvMasks.r;
				flSpecMask *= lerp(  smoothstep( 0.01, 0.0, flPaintBlend ), lerp( flOilRubBlend * ( 1.0 - flPatinaBlend * g_flWearAmt ), 1.0, flPatinaBlend ), fvMasks.r );
				flSpecMask = lerp( flSpecMask, cBase.a, flPaintSpecBlend );
				flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend ) * ( 1.0 - fvMasks.r );
			#else
				flSpecMask *= lerp( g_flPaintPhongIntensity, g_flAnodizedBasePhongIntensity, flPaintEdges );
			#endif

			float flPhongAlbedoBlend = flPaintBlend;

			float flAdjustedBase = 1.0;
			#if ( PHONGALBEDOFACTORMODE == 1 )
				flAdjustedBase = lerp( 1.0, g_flPhongAlbedoFactor, cOrigExp.g * flPhongAlbedoBlend );
				cOut.a = lerp( flSpecMask, cBase.a * flAdjustedBase, flPaintBlend );
			#else
				cOut.a = lerp( flSpecMask * g_flPhongAlbedoFactor, cBase.a, flPhongAlbedoBlend );
			#endif

			#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cOut.a = lerp( flSpecMask, cBase.a * flAdjustedBase, flPaintSpecBlend );
			#endif

		#else // everything else
			float flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend );
			flSpecMask *= smoothstep( 0.01, 0.0, flPaintBlend );
			cOut.a = lerp( flSpecMask, cBase.a, flPaintSpecBlend );
		#endif


	#endif

















	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map
	#ifndef USE_COLOR_MAP//TODO: probably not the best way to do that. We should remove all texelColor if no colorMap
		//vec4 texelColor = vec4(1.0);
	#endif
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map

	#include compute_fragment_normal

	/*#ifdef USE_POS_MAP
		vec4 texelPos = texture2D(posMap, vTextureCoord.xy);
		texelPos.rgb *= texelPos.a * 16.0;//HDR decompression
	#else
		vec4 texelPos = vec4(0.0);
	#endif*/

	vec4 paintColor = texelPattern;

	float phongMask = 0.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	//diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = vec3(1.0);//texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;

	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
	//	discard;
	}
	//gl_FragColor = vec4(albedo, alpha);
	//gl_FragColor.rgb = g_DiffuseModulation.rgb;
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif

#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongExponent;
#endif
	material.specularStrength = uPhongBoost;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/

#include compute_fragment_render_mode
/* TEST SHADING BEGIN*/
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = alpha;

//gl_FragColor.rgb = vec3(phongMask);
/* TEST SHADING END*/




#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif

#if PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR
	//gl_FragColor.rgb = vec3(1.0);
	/*patternColor = triplanarPatternColor(vPatternCoord2);
	float mask0 = max((1.0 - length(patternColor.rgb)) * texelMask1.r, 0.0);
	if (length(texelMask1.rgb) != texelMask1.r) {
		patternColor = vec4(0.0);
		mask0 = 0.0;
	}

	float mask1 = clamp(							patternColor.r, 0.0, 1.0);
	float mask2 = max(texelMask1.g, patternColor.g);
	float mask3 = max(texelMask1.b, patternColor.b);

	vec3 color0 = mask0 * uColor0;
	vec3 color1 = mask1 * uColor1;
	vec3 color2 = mask2 * uColor2;
	vec3 color3 = mask3 * uColor3;
	paintColor.rgb = vec3(color0 + color1 + color2 + color3) * 2.0;
	paintColor.a = texelMask1.r;
*/
#endif


	gl_FragColor.rgb = texelPattern.rgb;
	gl_FragColor.rgb = vec3(cOut);
	#include source1_compute_selfillum
	#include source1_compute_sheen
	#include compute_fragment_standard

	//gl_FragColor.rgb = texture2D(scratchesMap, vTexture2Coord.xy).rgb;
	//gl_FragColor.rgb = texture2D(grungeMap, vTexture2Coord.zw).rgb;
	//gl_FragColor.rgb = texelAo.aaa;
}
`;

var source1_customweapon_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec4 g_patternTexCoordTransform[2];
uniform vec4 g_wearTexCoordTransform[2];
uniform vec4 g_grungeTexCoordTransform[2];

#include source1_varying_customweapon

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	vTextureCoord.xy = mod(vTextureCoord.xy, 1.0);

	vTextureCoord.z = dot(vTextureCoord.xy, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
	vTextureCoord.w = dot(vTextureCoord.xy, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	vTexture2Coord.x = dot(aTextureCoord, g_wearTexCoordTransform[0].xy) + g_wearTexCoordTransform[0].w;
	vTexture2Coord.y = dot(aTextureCoord, g_wearTexCoordTransform[1].xy) + g_wearTexCoordTransform[1].w;
	vTexture2Coord.z = dot(aTextureCoord, g_grungeTexCoordTransform[0].xy) + g_grungeTexCoordTransform[0].w;
	vTexture2Coord.w = dot(aTextureCoord, g_grungeTexCoordTransform[1].xy) + g_grungeTexCoordTransform[1].w;
}
`;

var source1_eyerefract_fs = `
#include declare_lights
#include declare_shadow_mapping

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_alpha_test

uniform sampler2D corneaMap;

/*const vec4 g_vIrisProjectionU = vec4(0, 1, 0, 0);
const vec4 g_vIrisProjectionV = vec4(0, 0, 1, 0);*/


uniform vec3 uEyeOrigin;
uniform vec4 uIrisProjectionU;
uniform vec4 uIrisProjectionV;
/********************************************/
varying vec4 vWorldPosition_ProjPosZ;
varying vec4 vTangentViewVector;

varying vec3 vWorldNormal;
varying vec3 vWorldTangent;
varying vec3 vWorldBinormal;

#define g_flEyeballRadius	5.51
//#define g_bRaytraceSphere	1.0
#define g_flParallaxStrength 0.25
/********************************************/

#include source1_varying_eyerefract
#include varying_standard

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map_mod1

	#ifdef USE_COLOR_MAP
		vec4 texelColor = texture2D(colorMap, mod(vTextureCoord.xy, 1.0));
	#endif
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
		//texelColor.a = 1.0;
		gl_FragColor = texelColor;
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif
	//gl_FragColor = vec4(vTextureCoord/2.0, 0.0, 1.0);



/********************************************/
	vec3 vWorldPosition = vWorldPosition_ProjPosZ.xyz;
	vec2 vCorneaUv; // Note: Cornea texture is a cropped version of the iris texture
	vCorneaUv.x = dot( uIrisProjectionU, vec4( vWorldPosition, 1.0 ) );
	vCorneaUv.y = dot( uIrisProjectionV, vec4( vWorldPosition, 1.0 ) );
	vec2 vSphereUv = ( vCorneaUv.xy * 0.5 ) + 0.25;

	vec4 corneaColor = texture2D(corneaMap, mod(vCorneaUv, 1.0));
	float fIrisOffset = corneaColor.b;

	vec2 vParallaxVector = ( vTangentViewVector.xy * fIrisOffset * g_flParallaxStrength ) / ( 1.0 - vTangentViewVector.z ); // Note: 0.25 is a magic number
	vParallaxVector = ( vTangentViewVector.xy* g_flParallaxStrength) / ( 1.0 - vTangentViewVector.z );
	vParallaxVector.x = -vParallaxVector.x; //Need to flip x...not sure why.
	vParallaxVector = vec2(0.0);

	vec2 vIrisUv = vSphereUv.xy - vParallaxVector.xy;
	vec4 cIrisColor = texture2D(colorMap, vIrisUv);//tex2D( g_tIrisSampler, vIrisUv.xy );
	cIrisColor = pow(cIrisColor, vec4(1./2.2));
	cIrisColor.a = 1.0;
	gl_FragColor = cIrisColor;
	//gl_FragColor = vec4(abs(normalize(vCorneaUv.xy)),0.0 , 1.0);
	//gl_FragColor = vec4(abs(normalize(vParallaxVector.xy)), 0.0, 1.0);
	//gl_FragColor = vec4(abs(normalize(vWorldPosition.xyz)), 1.0);
	//gl_FragColor = vec4(abs(normalize(vTangentViewVector.xyz)), 1.0);
	//gl_FragColor = vec4(((1.0 - abs(vTangentViewVector).z)), 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(abs(normalize(vIrisUv)), 0.0, 1.0);
	//gl_FragColor = texture2D(colorMap, mod(vTextureCoord, 1.0));gl_FragColor.a = 1.0;
	//gl_FragColor = vec4(abs(normalize(uEyeOrigin)), 1.0);
	//gl_FragColor = vec4(abs(normalize(uEyeOrigin)), 1.0);
	//gl_FragColor = vec4(length(vWorldPosition_ProjPosZ .xyz - uEyeOrigin) / 100.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldPosition_ProjPosZ.xyz - uEyeOrigin)), 1.0);

	//gl_FragColor = vec4(abs(vWorldPosition_ProjPosZ.x) / 50.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldNormal)), 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldTangent)), 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldBinormal)), 1.0);
/********************************************/
#include compute_fragment_render_mode
	#include compute_fragment_standard

#ifdef SKIP_PROJECTION
	gl_FragColor = texture2D(colorMap, mod(vTextureCoord.xy, 1.0));
	gl_FragColor.a = 1.;
#endif
}
`;

var source1_eyerefract_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_camera_position
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec3 uEyeOrigin;
uniform vec4 uIrisProjectionU;
uniform vec4 uIrisProjectionV;

/********************************************/
varying vec4 vWorldPosition_ProjPosZ;
varying vec4 vTangentViewVector;
varying vec3 vWorldNormal;
varying vec3 vWorldTangent;
varying vec3 vWorldBinormal;



vec3 Vec3WorldToTangent( vec3 iWorldVector, vec3 iWorldNormal, vec3 iWorldTangent, vec3 iWorldBinormal )
{
	vec3 vTangentVector;
	vTangentVector.x = dot( iWorldVector.xyz, iWorldTangent.xyz );
	vTangentVector.y = dot( iWorldVector.xyz, iWorldBinormal.xyz );
	vTangentVector.z = dot( iWorldVector.xyz, iWorldNormal.xyz );
	return vTangentVector.xyz; // Return without normalizing
}
vec3 Vec3WorldToTangentNormalized( vec3 iWorldVector, vec3 iWorldNormal, vec3 iWorldTangent, vec3 iWorldBinormal )
{
	return normalize( Vec3WorldToTangent( iWorldVector, iWorldNormal, iWorldTangent, iWorldBinormal ) );
}
//const vec4 g_vIrisProjectionU = vec4(0, 1, 0, 0);
//const vec4 g_vIrisProjectionV = vec4(0, 0, 1, 0);

/********************************************/

#include source1_varying_eyerefract
#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection


/********************************************/
	vWorldPosition_ProjPosZ.xyz = vertexPositionWorldSpace.xyz;

	mat4 cViewProj = uProjectionMatrix * uViewMatrix;
	vec4 vProjPos = cViewProj * vertexPositionWorldSpace;//mul( vec4( vertexPositionWorldSpace, 1.0 ), cViewProj );
	//o.projPos = vProjPos;
	//vProjPos.z = dot(vertexPositionWorldSpace, cViewProjZ );
	//o.vWorldPosition_ProjPosZ.w = vProjPos.z;

	vec3 vEyeSocketUpVector = normalize( -uIrisProjectionV.xyz );
	vec3 vEyeSocketLeftVector = normalize( -uIrisProjectionU.xyz );

	//vEyeSocketUpVector = -vec3(0.0, 1.0, 0.0);
	//vEyeSocketLeftVector = -vec3(0.0, 0.0, 1.0);

	vWorldNormal = normalize( vertexPositionWorldSpace.xyz - uEyeOrigin.xyz );
	vWorldTangent = normalize( cross( vEyeSocketUpVector.xyz, vWorldNormal.xyz ) );
	vWorldBinormal = normalize( cross( vWorldNormal.xyz, vWorldTangent.xyz ) );

	vec3 vWorldViewVector = normalize (vertexPositionWorldSpace.xyz - uCameraPosition);
	vTangentViewVector.xyz = Vec3WorldToTangentNormalized(vWorldViewVector, vWorldNormal, vWorldTangent, vWorldBinormal);
	//vTangentViewVector.xyz = vWorldViewVector;
	//vTangentViewVector.xyz = vertexPositionWorldSpace.xyz;
	//vTangentViewVector.xyz = vWorldBinormal;

/********************************************/
}
`;

var source1_lightmappedgeneric_fs = `
#define FLAT_SHADING
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);
#include declare_lights
#include declare_shadow_mapping

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test

#include varying_standard

void main(void) {
	vec4 diffuseColor = vec4(1.0);

	vec3 lightmapColor1 = vec3(1.0, 1.0, 1.0);
	vec3 lightmapColor2 = vec3(1.0, 1.0, 1.0);
	vec3 lightmapColor3 = vec3(1.0, 1.0, 1.0);
	vec3 diffuseLighting = vec3(1.0);

	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_alpha_test

	#include compute_fragment_normal

	vec3 albedo = texelColor.rgb;

	#ifdef USE_SSBUMP
		vec3 tangentSpaceNormal = texelNormal.xyz;

		diffuseLighting = texelNormal.x * lightmapColor1 +
						  texelNormal.y * lightmapColor2 +
						  texelNormal.z * lightmapColor3;
	#else
		#ifdef USE_NORMAL_MAP
			vec3 tangentSpaceNormal = 2.0 * texelNormal.xyz - 1.0;
		#else
			vec3 tangentSpaceNormal = 2.0 * defaultNormalTexel.xyz - 1.0;
		#endif
	#endif

	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);
	#include compute_lights_setup_vars
	BlinnPhongMaterial material;
	material.diffuseColor = texelColor.rgb * diffuseLighting;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

	#include compute_fragment_lights

	/*gl_FragColor = textureColor;*/
	gl_FragColor.a = 1.0;
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse * 0.0/*TODO*/);
#endif


#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = albedo;
#endif
	#include compute_fragment_standard
}
`;

var source1_lightmappedgeneric_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_shadow_mapping

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source1_refract_fs = `

#include source1_varying_refract
void main(void) {
	discard;
}
`;

var source1_refract_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_detail_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_refract

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex_detail_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

var source1_sprite_fs = `
uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
#include declare_fragment_alpha_test

#include source1_varying_sprite

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	//blended_rgb.rgb *= uOverbrightFactor;
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= vColor.rgb;
	#else
		blended_rgb *= vColor;
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
}`;

var source1_sprite_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source1_varying_sprite

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
	vColor = GammaToLinear(p.color);
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif
}
`;

var source1_spritecard_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
#include declare_fragment_alpha_test

#include source1_varying_spritecard

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	blended_rgb.rgb *= uOverbrightFactor;
	//blended_rgb = pow(blended_rgb, vec4(2.2));
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= vColor.rgb * vColor.a;
	#else
		blended_rgb *= vColor;
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
}`;

var source1_spritecard_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source1_varying_spritecard

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = GammaToLinear(p.color);
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#else
		vColor = vec4(1.0);
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif



}
`;

var source1_unlitgeneric_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
#include declare_fragment_alpha_test

#include declare_lights
#include declare_shadow_mapping

#include source1_varying_unlit_generic

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	#if defined(USE_VERTEX_COLOR) || defined(HARDWARE_PARTICLES)
		gl_FragColor = texelColor * vColor;
	#else
		gl_FragColor = texelColor;
	#endif
	//gl_FragColor = vColor;
	#include compute_fragment_standard
}
`;

var source1_unlitgeneric_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_varying_unlit_generic

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif
}
`;

var source1_unlittwotexture_fs = `

uniform sampler2D colorMap;
uniform sampler2D color2Map;

#include source1_varying_unlittwotexture

/*unlittwotexture.fs*/
void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		vec4 texture2Color = texture2D(color2Map, vTexture2Coord.xy);
		gl_FragColor = textureColor * vColor * textureColor.a;
		//gl_FragColor = vColor;
		//gl_FragColor = vec4(uAddSelf);
		//gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
		//gl_FragColor = vec4(vTextureCoord, 0.0, 1.0);
		gl_FragColor = textureColor * textureColor.a + texture2Color * texture2Color.a;
		//gl_FragColor = texture2Color * texture2Color.a;
		//gl_FragColor = vec4(vTexture2Coord, 0.0, 1.0);
		//gl_FragColor = vec4(vTexture2Coord, 0.0, 1.0);
		gl_FragColor = textureColor * textureColor.a * texture2Color * texture2Color.a;
	#include compute_fragment_standard
}
`;

var source1_unlittwotexture_vs = `
//#version 300 es

#ifdef HARDWARE_PARTICLES
attribute float aParticleId;
#endif
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform float uFaceCamera;
uniform vec3 uCameraPosition;

//uniform mat4 uTextureTransform;
uniform mat4 uTexture2Transform;

#include source_declare_particle

#include source1_varying_unlittwotexture

/*unlittwotexture.vs*/
void main(void) {
#ifdef HARDWARE_PARTICLES
	particle p = getParticle(int(aParticleId));
	vColor = p.color;
#else
	vColor = vec4(1.0);
#endif
	//vTextureCoord = aTextureCoord;

#ifdef USE_TEXTURE_TRANSFORM
	vTextureCoord.xy = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
	vTexture2Coord.xy = (uTexture2Transform * vec4(aTextureCoord, 1.0, 1.0)).st;
#endif

#ifdef PARTICLE_ORIENTATION_WORLD_Z_ALIGNED
	//vec3 aVertexPosition3 = aVertexPosition.xyz;
#else
	//vec3 aVertexPosition3 = aVertexPosition.xyz;
#endif
	vec3 aVertexPosition3 = aVertexPosition;
#ifdef HARDWARE_PARTICLES
	vec4 vertexPositionCameraSpace;
	vec4 test = vec4(aVertexPosition3, 1.0) * p.radius * rotationMatrix(vec3(0.0, .0, 1.0), -p.roll * 1.0);
	vec4 vertexPositionModelSpace = vec4(p.center.xyz + test.xyz, 1.0);
	if(uFaceCamera == 10.0) {//face camera
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		lookAt = lookAt * lookAt2;
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));
		vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	}

	if(uFaceCamera == 11.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius*eyeDir.y, 0.0, 0.0));
	}

	if(uFaceCamera == 10.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius*eyeDir.y, 0.0, 0.0));
		vertexPositionCameraSpace = uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y, vertexPositionModelSpace.z , 1.0);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y*eyeDir.y, vertexPositionModelSpace.z, 1.0));
	}

	if(uFaceCamera == 1000.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		lookAt = lookAt * lookAt2;
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));
		vertexPositionCameraSpace = lookAt * (uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y*eyeDir.y, vertexPositionModelSpace.z, 1.0));
	}

#else
	/*#ifdef HARDWARE_SKINNING
		mat4 skinMat = accumulateSkinMat();
		vec4 vertexPositionModelSpace = skinMat * vec4(aVertexPosition, 1.0);
	#else
		vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
	#endif*/
	#include compute_vertex_uv
	#include compute_vertex_uv2
	#include compute_vertex
	#include compute_vertex_skinning
	//#include compute_vertex_projection
#endif
	//vertexPositionModelSpace *= rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 100.0);

	// = uModelViewMatrix * vertexPositionModelSpace;




#ifdef RENDER_SPRITE_TRAIL
	vec3 vecDelta = p.vecDelta.xyz;
	//vecDelta = vec3(1.0, 1.0, 0.0);
	vec3 aVertexPosition2;

	vec4 q;
	vec3 a = cross(vec3(1.0, 0.0, 0.0), vecDelta);
	q.xyz = a;
	q.w = /*length(vecDelta)*/1.0 + dot(vec3(1.0, 0.0, 0.0), vecDelta);

	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w, 0.0, p.radius), normalize(q));
/*
	vec3 test2 = vec3(1.0, 0.0, 0.0);
	vec3 eyeDir = aVertexPosition2 - uCameraPosition;
	q.xyz = cross(test2, eyeDir);
	q.w = length(eyeDir) + dot(test2, vecDelta);
	aVertexPosition2.xyz = vec3_transformQuat(aVertexPosition2.xyz, normalize(q));*/
	vertexPositionModelSpace = vec4(p.center + aVertexPosition2 + vecDelta * p.vecDelta.w, 1.0);

#endif


#ifdef PARTICLE_ORIENTATION_SCREEN_ALIGNED
#ifdef RENDER_SPRITE_TRAIL
#else
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));

#endif
#else
	//vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	//gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#ifdef HARDWARE_PARTICLES
	vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#else
#include compute_vertex_projection
#endif


}
`;

var source1_vertexlitgeneric_fs = `
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_detail_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#include declare_fragment_alpha_test
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map

uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;
uniform float uDetailBlendFactor;

#include source1_final_output_const

#include declare_lights
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_vertexlit_generic

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform
void main(void) {
	#ifdef NO_DRAW
		discard;
	#endif

	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_detail_map
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map

	#include compute_fragment_normal

	float phongMask = 1.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;
	//gl_FragColor = FinalOutputConst(vec4(albedo, alpha), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, worldPos_projPosZ.w );
	//gl_FragColor = FinalOutputConst( float4( result.rgb, alpha ), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, i.worldPos_projPosZ.w );

	if (gl_FragCoord.x < 400.) {
		//gl_FragColor = vec4(texelColor.rgb, 1.);
	}
	/*if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}*/
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
	//	discard;
	}
	//gl_FragColor = vec4(albedo, alpha);
	//gl_FragColor.rgb = g_DiffuseModulation.rgb;


#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif



	#if defined(USE_DETAIL_MAP) && defined(DETAIL_BLEND_MODE)
		#if (DETAIL_BLEND_MODE == 0)
		//TODO
		#elif (DETAIL_BLEND_MODE == 1)
			gl_FragColor.rgb += texelDetail.rgb * uDetailBlendFactor;
		#elif (DETAIL_BLEND_MODE == 2)
		//TODO
		#elif (DETAIL_BLEND_MODE == 3) // TCOMBINE_FADE
			albedo = mix(albedo, texelDetail.rgb, uDetailBlendFactor);
		#endif
	#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g);
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongBoost * uPhongExponent;
#endif
	material.specularStrength = phongMask;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#include compute_fragment_lights

/* TEST SHADING END*/

#include compute_fragment_render_mode
/* TEST SHADING BEGIN*/

vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
#include source1_compute_selfillum


#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + diffuse);
#else
	gl_FragColor.rgb = (diffuse);
#endif
gl_FragColor.a = alpha;

//gl_FragColor.rgb = vec3(phongMask);
/* TEST SHADING END*/
//gl_FragColor.rgb = texelPhongExponent.rgb;
//gl_FragColor.rgb = material.specularColor;
//gl_FragColor.rgb = vec3(texelColor.a);


#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif




/*


	computePointLightIrradiance(uPointLights[0], geometry, directLight);
	RE_Direct( directLight, geometry, material, reflectedLight );
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		irradiance = dotNL * directLight.color;

	vec3 halfDir = normalize( directLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( directLight.direction, halfDir ) );
	vec3 F = F_Schlick( material.specularColor, dotLH );
	float D = D_BlinnPhong( material.specularShininess, dotNH );

	float D_BlinnPhong = RECIPROCAL_PI * ( material.specularShininess * 0.5 + 1.0 ) * pow( dotNH + 0.1, material.specularShininess );


gl_FragColor.rgb = 0.5 + 0.5 * vec3(D_BlinnPhong);
*/
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = albedo;
#endif

	#include source1_compute_sheen
	#include compute_fragment_standard
	#include compute_fragment_log_depth

	#if defined(USE_DETAIL_MAP) && defined(DETAIL_BLEND_MODE)
		#if (DETAIL_BLEND_MODE == 5)
		//TODO
		#elif (DETAIL_BLEND_MODE == 6)
			float f = uDetailBlendFactor - 0.5;
			float fMult = (f >= 0.0) ? 1.0 / uDetailBlendFactor : 4.0 * uDetailBlendFactor;
			float fAdd = (f >= 0.0) ? 1.0-fMult : -0.5*fMult;
			gl_FragColor.rgb += saturate(fMult * texelDetail.rgb + fAdd);
		#endif
	#endif
}
`;

var source1_vertexlitgeneric_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_detail_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_vertexlit_generic

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex_detail_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

var source1_water_fs = `
uniform vec3 phongfresnelranges;

uniform sampler2D colorMap;
#ifdef ALPHA_TEST
uniform float uAlphaTestReference;
#endif

varying vec2 vTextureCoord;
void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord);
#ifdef ALPHA_TEST
		if (textureColor.a < uAlphaTestReference) {
			discard;
		}
#endif

		gl_FragColor = textureColor;
		gl_FragColor = vec4(0.5, 0.5, 1.0, 0.5);
		/*if (length(mod(gl_FragCoord.xy, vec2(2.0))) > 1.0) {
			discard;
		}*/
	#include compute_fragment_standard
}
`;

var source1_water_vs = `
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

uniform mat4 uTextureTransform;

varying vec2 vTextureCoord;

void main(void) {
	vTextureCoord = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
	vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);

	vec4 vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;

	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
}
`;

var source1_weapondecal_fs = `
#ifndef DESATBASETINT
	#define DESATBASETINT 0
#endif
#ifndef ALPHAMASK
	#define ALPHAMASK 0
#endif
#ifndef THIRDPERSON
	#define THIRDPERSON 0
#endif
#ifndef HIGHLIGHT
	#define HIGHLIGHT 0
#endif
#ifndef PHONG
	#define PHONG 0
#endif
#ifndef USE_CUBE_MAP
	#define USE_CUBE_MAP 0
#endif
#ifndef PEEL
	#define PEEL 0
#endif
#ifndef CASCADED_SHADOW_MAPPING
	#define CASCADED_SHADOW_MAPPING 0
#endif
#ifndef DYN_CSM_ENABLED
	#define DYN_CSM_ENABLED 0
#endif
#ifndef NUM_LIGHTS
	#define NUM_LIGHTS 0
#endif

#if ( DESATBASETINT == 1 )
	const float3 g_desat = vec3(0.299, 0.587, 0.114);
#endif
#if (HIGHLIGHT > 0)
	#define			TAU									6.28318
	#define			ONE_OVER_SIXTEEN					0.0625
	#define			CSTRIKE_BLUE						float3( 0.204, 0.266, 0.343 )
#endif
#define			g_flScratchwidth					0.02



#include source1_fragment_common
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#if (THIRDPERSON == 0)
	#include declare_fragment_ao_map
	uniform sampler2D scratchesMap;
	uniform sampler2D grungeMap;
#endif

#if (DECALSTYLE == 3) // hologram
	uniform sampler2D holoMaskMap;
	uniform sampler2D holoSpectrumMap;
#endif


#include declare_fragment_cube_map

uniform vec3 uCubeMapTint;


uniform vec4 uWearParams;//g_fvConstRegister0
#define			g_flWearAmt							uWearParams.x
#define			g_flWearWidth						uWearParams.y
#define			g_flWearRemapped					uWearParams.z
#define			g_flUnWearStrength					uWearParams.w

uniform vec4 uPhongParams;//g_fvConstRegister1
#define			g_flPhongExponent					uPhongParams.x
#define			g_flPhongBoost						uPhongParams.y
#define			g_flPhongAlbedoBoost				uPhongParams.z
#define			g_flGrungeScale						uPhongParams.w

uniform vec4 uPhongFresnel;//g_fvConstRegister2
#define			g_fvPhongFresnelRanges				uPhongFresnel.xyz
#define			g_bPhongAlbedoTint					uPhongFresnel.w



uniform vec3 uColorTint;//m_nColorTint
uniform vec3 uColorTint2;//m_nColorTint2
uniform vec3 uColorTint3;//m_nColorTint3
uniform vec3 uColorTint4;//m_nColorTint4


uniform float uTintLerpBase;
#define			g_flTintLerpBase uTintLerpBase//g_fvConstRegister13

#if (HIGHLIGHT > 0) || (PEEL == 1)
	uniform vec2 uHighlight;//m_nHighlight, m_nHighlightCycle
	#define			g_flHighlightAmount					uHighlight.x
	#define			g_flHighlightCycle					uHighlight.y
#endif


#include source1_varying_weapondecal

void main(void) {
	#ifdef USE_COLOR_MAP
		float4 cOut = texture2D(colorMap, vTextureCoord.zw);
	#else
		float4 cOut = vec4(1.0);
	#endif

	#if ( DESATBASETINT == 1 )
		cOut.rgb = lerp( vec3(dot(g_desat.rgb, cOut.rgb)), cOut.rgb, g_flTintLerpBase );
	#endif

	#if ( ALPHAMASK == 1 )
		cOut.a = step( 0.1, cOut.a );
		cOut.rgb = vec3(cOut.a);
		cOut.a = 1.0;
		gl_FragColor = cOut;
		return;
	#endif

	#if ( THIRDPERSON == 1 )
		//clip off any pixels outside 0-1 UV space to prevent smearing edge pixels on lower mips
		//clip( (saturate( vTextureCoord.z ) != vTextureCoord.z) ? -1 : 1 );
		if ((saturate( vTextureCoord.z ) != vTextureCoord.z)) {
			discard;
		}
		//clip( (saturate( vTextureCoord.w ) != vTextureCoord.w) ? -1 : 1 );
		if ((saturate( vTextureCoord.w ) != vTextureCoord.w)) {
			discard;
		}
	#endif

	//alpha values above 0.1 locally decrease wear to retain important areas of the sticker
	float flUnWearImportance = g_flUnWearStrength * ( 1.0 - cOut.a );

	//semi-on/off alpha
	cOut.a = step( 0.1, cOut.a );
	#if (HIGHLIGHT == 0) && (PEEL == 0)
		//clip( cOut.a - 0.001 );
		if (cOut.a < 0.001) {
			discard;
		}
	#endif

	#if (DECALSTYLE != 2) // non-color-replace logos can still be color tinted by the first color tint value

		#if (DESATBASETINT == 1)
			cOut.rgb = lerp( cOut.rgb * (uColorTint / 255.0), cOut.rgb, cOut.g * g_flTintLerpBase );
		#else
			cOut.rgb *= (uColorTint / 255.0);
		#endif

	#endif

	#if (PHONG == 1)
		// default to numerically defined specular values
		float4 fvSpecularExponent = float4( g_flPhongExponent, g_bPhongAlbedoTint, 0.0, 1.0 );
		#ifdef USE_PHONG_EXPONENT_MAP
			// override the existing specular exponent values with values from the exponent map
			fvSpecularExponent.xy = tex2D( phongExponentMap, vTextureCoord.xy ).xy;
		#endif
	#endif

	//float3 vWorldPos = i.worldPos;
#define vWorldPos vVertexPositionWorldSpace.xyz
	float3 vEyeDir = normalize( uCameraPosition - vWorldPos );

	#if ( (DECALSTYLE == 4) || ( DECALSTYLE == 5 ) )// foil emboss uses normal map
		float4 vNormalTexel = tex2D(normalMap, vTextureCoord.zw * vec2(1.0, -1.0));//I don't know why we have to inverse y axis
		float3 vTangentSpaceNormal = 2.0 * vNormalTexel.xyz - 1.0;

		vec3 fragmentNormalWorldSpace = normalize(vVertexNormalWorldSpace.xyz);
		vec3 fragmentTangentWorldSpace = normalize(vVertexTangentWorldSpace.xyz);
		vec3 fragmentBitangentWorldSpace = normalize(vVertexBitangentWorldSpace.xyz);
		mat3 TBNMatrixWorldSpace = mat3(fragmentTangentWorldSpace, fragmentBitangentWorldSpace, fragmentNormalWorldSpace);


		float3 vWorldNormal = normalize( (TBNMatrixWorldSpace/* (float3x3)i.tangentSpaceTranspose*/ * vTangentSpaceNormal ) );
		#if ( DECALSTYLE == 5)
			// flatten the normal for anisotropic spec to reduce aliasing
			float3 vSpecNormal = normalize( (TBNMatrixWorldSpace/* (float3x3)i.tangentSpaceTranspose*/ * lerp( vTangentSpaceNormal, float3( 0.0, 0.0, 1.0 ), 0.95 ) ) );
		#endif
	#else
		float3 vWorldNormal = normalize ( vVertexNormalWorldSpace.xyz );
	#endif

	#if (DECALSTYLE == 2) // color-replace logo
		cOut.rgb = lerp( lerp( lerp( (uColorTint / 255.0), (uColorTint2 / 255.0), cOut.r ), (uColorTint3 / 255.0), cOut.g ), (uColorTint4 / 255.0), cOut.b );
	#endif

	#if (DECALSTYLE == 3) // hologram
		float3 fvHoloMask = tex2D( holoMaskMap, vTextureCoord.zw ).rgb;

		#if (NUM_LIGHTS > 0)
			float2 fvSpectrumUV = float2( fvHoloMask.g + dot( vEyeDir, vWorldNormal ), fvHoloMask.b );
			float3 fvlightdir0 = normalize(cLightInfo[0].pos.xyz - vWorldPos);
			fvSpectrumUV.x += dot( vEyeDir, fvlightdir0 );
		#else
			float2 fvSpectrumUV = float2( fvHoloMask.g + dot( vEyeDir + vWorldNormal, float3( 0, 1, 0 ) ), fvHoloMask.b );
		#endif

		float3 fvHoloSpectrumSrc = tex2D( holoSpectrumMap, fvSpectrumUV ).rgb;
		cOut.rgb = lerp( cOut.rgb, fvHoloSpectrumSrc, fvHoloMask.r );
	#endif

	// lighting
	#if ( (CASCADED_SHADOW_MAPPING == 1) && (DYN_CSM_ENABLED == 1) )
		float flCSMShadow = CSMComputeShadowing( vWorldPos );
	#else
		float flCSMShadow = 1.0;
	#endif

	//float3 linearColor = PixelShaderDoLighting( vWorldPos, vWorldNormal, float3( 0.1, 0.1, 0.1), false, true, i.lightAtten, g_cAmbientCube, NormalizeSampler, NUM_LIGHTS, cLightInfo, false, false, NULL, flCSMShadow );//TODO
	vec3 linearColor = vec3(1.0);

	#ifdef USE_CUBE_MAP
		float3 vReflect = CalcReflectionVectorUnnormalized( vWorldNormal, vEyeDir );
		float3 envMapColor = ENV_MAP_SCALE * texCUBE( cubeMap, vReflect ).rgb * uCubeMapTint;
		// TODO: envmap fresnel
		#if (DECALSTYLE == 4)
			envMapColor *= cOut.rgb * linearColor.rgb;
		#endif
	#endif

	#if (PHONG == 1)
		float3 specularLighting, rimLighting;
		float fFresnelRanges = Fresnel( vWorldNormal, vEyeDir, g_fvPhongFresnelRanges );
		#if ( DECALSTYLE == 5)
			float3 vTangentS = float3( i.tangentSpaceTranspose[0][0], i.tangentSpaceTranspose[1][0], i.tangentSpaceTranspose[2][0] );
			vTangentS = normalize( mul( (float3x3)i.tangentSpaceTranspose, vTangentS ) );
			float3 vTangentT = float3( i.tangentSpaceTranspose[0][1], i.tangentSpaceTranspose[1][1], i.tangentSpaceTranspose[2][1] );
			vTangentT = normalize( mul( (float3x3)i.tangentSpaceTranspose, vTangentT ) );

			vTangentS = normalize( cross( vSpecNormal, vTangentT ) );
			vTangentT = normalize( cross( vSpecNormal, vTangentS ) );

			float4 vAnisoDirSample = tex2D( AnisoDirSampler, vTextureCoord.zw );
			float2 vAnisoDir = vAnisoDirSample.yx * 2.0 - 1.0;

			//PixelShaderDoAnisotropicSpecularLighting( vWorldPos, vWorldNormal, vTangentS, vTangentT, fvSpecularExponent.r * 255.0, vEyeDir, i.lightAtten, NUM_LIGHTS, cLightInfo, fFresnelRanges, vAnisoDir, 1.0, specularLighting );
			//TODO

			rimLighting = 0.0;

			specularLighting *= vAnisoDirSample.a;
		#else
			//PixelShaderDoSpecularLighting( vWorldPos, vWorldNormal, fvSpecularExponent.r * 255.0, vEyeDir, i.lightAtten, NUM_LIGHTS, cLightInfo, false, NULL, fFresnelRanges, false, 1.0, 1.0, specularLighting, rimLighting );
			//TODO
		#endif

		specularLighting *= max( vec3(g_flPhongBoost), fvSpecularExponent.g * g_flPhongAlbedoBoost ) * cOut.rgb ;
		//specularLighting *= lerp( g_flPhongBoost.xxx, g_flPhongAlbedoBoost * cOut.rgb, fvSpecularExponent.g );
		//specularLighting *= g_flPhongBoost;

		#if ( DECALSTYLE != 5 )
			specularLighting *= cOut.a * fFresnelRanges; // specular mask
		#endif
	#endif

	#if ( THIRDPERSON == 0 )

		//sample ao
		#ifdef USE_AO_MAP
			float4 fvAOSrc = tex2D( aoMap, vTextureCoord.xy );
		#else
			float4 fvAOSrc = vec4(1.0);
		#endif

		//apply scratches and grunge

		//sample cavity and ao
		float4 fvScratchesSrc = tex2D( scratchesMap, vTextureCoord.xy * 0.5 );
		float4 fvGrungeSrc = tex2D( grungeMap, vTextureCoord.zw * g_flGrungeScale );
		float cavity = 1.0 - fvAOSrc.r * fvAOSrc.g * fvScratchesSrc.g;

		//apply uniform grunge
		cOut.rgb = lerp( cOut.rgb, cOut.rgb * fvGrungeSrc.rgb, g_flWearAmt * 0.7 );

		float flLocalRemappedWear = g_flWearRemapped - flUnWearImportance;

		float alphaWearPoint = saturate( flLocalRemappedWear - g_flWearWidth );

		//fast wear vertical threshold
		//float flFastWearThresholdValue = step( g_flFastWearThreshold, vTextureCoord.w ) * g_flWearAmt * 2.0;
		//alphaWearPoint += flFastWearThresholdValue;
		//flLocalRemappedWear += flFastWearThresholdValue;

		#if (DECALSTYLE == 4)
			//foil embossed labels have hard wear edges
			cOut.a *= step( alphaWearPoint + g_flScratchwidth, cavity );
		#else
			cOut.a *= smoothstep( alphaWearPoint - g_flScratchwidth, alphaWearPoint + g_flScratchwidth, cavity );
		#endif

		#if ( DECALSTYLE == 1 || DECALSTYLE == 3 ) //paper-backed or holographic (which is also paper-backed)
			// wear down color to white paper backing
			float colorWear = smoothstep( flLocalRemappedWear - g_flScratchwidth, flLocalRemappedWear + g_flScratchwidth, cavity );
			cOut.rgb = lerp( fvGrungeSrc.rgb, cOut.rgb, colorWear );
		#endif

		#if ( ( DECALSTYLE != 4 ) && ( DECALSTYLE != 5 ) ) //foil stickers don't lose their shine
			// wear down spec and envmap
			#if (PHONG == 1 || defined(USE_CUBE_MAP))
				float specWearPoint = saturate( flLocalRemappedWear + g_flWearWidth );
				float specWear = smoothstep( specWearPoint - g_flScratchwidth, specWearPoint + g_flScratchwidth, cavity );
				#if (PHONG == 1)
					specularLighting *= specWear;
				#endif
				#ifdef USE_CUBE_MAP
					envMapColor *= specWear;
				#endif
			#endif
		#endif

	#endif //THIRDPERSON == 0

	#if ( DECALSTYLE == 5 ) // color burn lighting for extra saturation
		cOut.rgb = lerp( cOut.rgb * cOut.rgb * cOut.rgb, cOut.rgb, linearColor );
	#endif

	#if (PHONG == 1)
		cOut.rgb += specularLighting;
	#endif

	// apply lighting
	cOut.rgb *= linearColor;

	#ifdef USE_CUBE_MAP
		cOut.rgb += envMapColor;
	#endif

	#if ( THIRDPERSON == 0 )
		//secondary blurred ao
		cOut.rgb *= lerp( 1.0, fvAOSrc.b, g_flWearAmt * 0.35 );

		//apply AO
		cOut.rgb *= fvAOSrc.g;
	#endif //THIRDPERSON == 0

	#if ( HIGHLIGHT > 0 )
		// cheap highlighting base pass
		float flModdedCycle = fmod( 0.5 * vTextureCoord.x + vTextureCoord.y + g_flHighlightCycle, 1.5 );
		flModdedCycle = smoothstep( 0.2, 0.6, abs( flModdedCycle - 0.5 ) );

		#ifdef USE_CUBE_MAP
			vReflect.r += flModdedCycle;
			float3 envMapColorSelect = texCUBE( cubeMap, vReflect ).rgb * HDR_INPUT_MAP_SCALE;
			float3 selectionColor = max( 4.0*envMapColorSelect.rgb, CSTRIKE_BLUE );
		#else
			float3 selectionColor = max( 4.0*cOut.rgb, CSTRIKE_BLUE );
		#endif

		cOut.rgb = lerp( cOut.rgb, selectionColor, flModdedCycle * g_flHighlightAmount );

	#endif

	#if ( HIGHLIGHT == 2)

		//also do expensive edge detection
		float flEdgeAlphaDetect = 0.0;

		float2 offsets[16] = {
			float2( 1.0, 0.0 ),
			float2( 0.9211, 0.3894 ),
			float2( 0.6967, 0.7174 ),
			float2( 0.3624, 0.932 ),
			float2( -0.0292, 0.9996 ),
			float2( -0.4161, 0.9093 ),
			float2( -0.7374, 0.6755 ),
			float2( -0.9422, 0.335 ),
			float2( -0.9983, -0.0584 ),
			float2( -0.8968, -0.4425 ),
			float2( -0.6536, -0.7568 ),
			float2( -0.3073, -0.9516 ),
			float2( 0.0875, -0.9962 ),
			float2( 0.4685, -0.8835 ),
			float2( 0.7756, -0.6313 ),
			float2( 0.9602, -0.2794 ),
		};

		for ( int k = 0; k < 16; k++ )
		{
			float flAlphaTap = tex2D( BaseSampler, vTextureCoord.zw + offsets[k] * 0.015 ).a;
			flEdgeAlphaDetect += step( 0.1, flAlphaTap );
		}

		flEdgeAlphaDetect = step( abs( (flEdgeAlphaDetect * ONE_OVER_SIXTEEN) - 0.5 ), 0.499 );

		cOut = lerp( cOut, float4(selectionColor, 1), flEdgeAlphaDetect * g_flHighlightAmount );

	#endif

	#if ( PEEL == 1 )
		//sticker peeling application effect in 2D
		float invHighlight = 1.0 - g_flHighlightAmount;
		float distort = pow( (invHighlight - vTextureCoord.x), 0.3 ) * 0.3;

		float2 backingUV = float2(invHighlight + (invHighlight - vTextureCoord.x), vTextureCoord.y );

		//fake vertical parallax
		float flParallaxY = dot( float3(0,0,1), vWorldNormal );
		backingUV.y += (flParallaxY * distort );

		#ifdef USE_COLOR_MAP
			float4 flBackingSample = tex2D( colorMap, backingUV );
		#else
			float4 flBackingSample = vec4(1.0);
		#endif

		//desaturate backing sample
		flBackingSample.rgb = vec3(dot( flBackingSample.rgb, float3(0.299,0.587,0.114) ));

		distort = smoothstep( 0.01, 0.2, distort);
		flBackingSample.rgb = lerp( flBackingSample.rgb, vec3(0.5), vec3(0.2) ) * distort;
		flBackingSample.a = step( 0.1, flBackingSample.a );

		//if ( flBackingSample.a > 0 && vTextureCoord.x < invHighlight )
		//{
		//	cOut.rgb = flBackingSample.rgb;
		//	float edgeFade = smoothstep( 0.0, 0.2, min( vTextureCoord.x, vTextureCoord.y ) );
		//	cOut.a = max( cOut.a, edgeFade );
		//}
		//becomes:
		cOut = lerp( cOut,
			   float4( flBackingSample.rgb, max( cOut.a, smoothstep( 0.0, 0.2, min( vTextureCoord.x, vTextureCoord.y ) ) ) ),
			   step( vTextureCoord.x, invHighlight ) * flBackingSample.a );

		//if ( vTextureCoord.x > invHighlight )
		//{
		//	cOut.rgb = 0;
		//	cOut.a *= (1.0 - distort) * 0.8;
		//}
		//becomes:
		cOut = lerp( cOut, float4( 0, 0, 0, cOut.a * (1.0 - distort) * 0.8 ), step( invHighlight, vTextureCoord.x ) );

	#endif

	//return FinalOutput( cOut, 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_LINEAR );
	#ifdef USE_COLOR_MAP
		//cOut = texture2D(colorMap, vTextureCoord.xy);
	#endif
	gl_FragColor = cOut;



	/*#if (USE_CUBE_MAP == 1)
		vReflect = CalcReflectionVectorUnnormalized( vWorldNormal, vEyeDir );
		envMapColor = texCUBE( cubeMap, vEyeDir ).rgb;
		gl_FragColor.rgb = envMapColor;
		gl_FragColor.a = 1.0;
	#endif*/
	//#include source1_compute_selfillum
	#include compute_fragment_standard
}
`;

var source1_weapondecal_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec4 g_patternTexCoordTransform[2];
uniform vec4 g_wearTexCoordTransform[2];
uniform vec4 g_grungeTexCoordTransform[2];

#include source1_varying_weapondecal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection


	vTextureCoord.z = dot(aTextureCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
	vTextureCoord.w = dot(aTextureCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;


	#if (MIRROR == 0)
		vTextureCoord.z = dot(aTextureCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
		vTextureCoord.w = dot(aTextureCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	#else
		float2 flippedTexCoord = float2( 1.0f - aTextureCoord.x, aTextureCoord.y );
		vTextureCoord.z = dot(flippedTexCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
		vTextureCoord.w = dot(flippedTexCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	#endif

}
`;

var source1_worldvertextransition_fs = `
#include declare_lights
#include declare_shadow_mapping
uniform sampler2D colorMap;
uniform sampler2D color2Map;
uniform sampler2D blendModulateMap;
uniform sampler2D lightMap;
/*uniform sampler2D normalMap;
uniform samplerCube cubeMap;*/

uniform vec3 uColor;
uniform vec3 uEnvMapTint;
uniform float uAlpha;
uniform bool uAlphaTest;
uniform float uUseCubeMap;
uniform float uUseEnvMapMask;
uniform float blendTintByBaseAlpha;
uniform float blendTintColorOverBase;
uniform float uBaseAlphaEnvMapMask;
uniform float uNormalMapAlphaEnvMapMask;
uniform float uEnvMapIntensity;
uniform float uMaskEnvByMetalness;
uniform bool uUseLighting;


uniform vec3 uAmbientColor;

const vec4 c1 = vec4(3.0, -2.0, 0.5, 0.5);

#include source1_varying_worldvertextransition

/* worldvertextransition.fs */
void main(void) {
	#include compute_fragment_color_map


	#include compute_fragment_normal

	vec4 texture2Color = texture2D(color2Map, vTextureCoord.xy);
		vec4 blendModulateColor = texture2D(blendModulateMap, vec2(mod(vTextureCoord.s, 1.0), mod(vTextureCoord.t, 1.0)));/*TODO: transform*/
	if(uAlphaTest && (texelColor.a <= 0.5)) {
		discard;
	}
		float vVertexAlpha2;

	#ifdef USE_BLEND_MODULATE_MAP
			vVertexAlpha2 = vVertexAlpha - blendModulateColor.g;
			vVertexAlpha2 = clamp(vVertexAlpha2 + c1.a, 0.0, 1.0);
		float vVertexAlpha3 =	c1.g * vVertexAlpha2 + c1.r;
			vVertexAlpha3 = vVertexAlpha3 * vVertexAlpha2;
			vVertexAlpha2 = vVertexAlpha3 * vVertexAlpha2;
	#else
		vVertexAlpha2 = vVertexAlpha;
	#endif

	#ifdef USE_COLOR_MAP
		#ifdef USE_COLOR2_MAP
			gl_FragColor = mix(texelColor, texture2Color, vVertexAlpha2);
		#else
			gl_FragColor = texelColor;
		#endif
	#else
		#ifdef USE_COLOR2_MAP
			gl_FragColor = texture2Color;
		#else
			gl_FragColor = vec4(1.0);
		#endif
	#endif
#ifdef USE_LIGHTING
#ifdef UNDEFINED
	gl_FragColor *= max( 1.0 - vEyeDistance / 1000.0, 0.1);
#endif
#endif
/*
	#include compute_lights_setup_vars
	BlinnPhongMaterial material;
	material.diffuseColor = texelColor.rgb;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

	#include compute_fragment_lights

	gl_FragColor.a = 1.0;
	#ifdef USE_PHONG_SHADING
		gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#else
		gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#endif
*/
	#include compute_fragment_standard
}


/*
; STATIC: "DETAIL" "0..1"
; STATIC: "BLENDMODULATETEXTURE" "0..1"
ps.1.4

def c1, 3.0, -2.0, 0.5, 0.5

texld	r0, t0
texld	r1, t1
texld	r2, t2
#if DETAIL
texld	r3, t3 ; detail
#endif
#if BLENDMODULATETEXTURE
texld	r4, t4 ; detail
#endif

#if BLEND_MODULATETEXTURE
sub r5.a, v0.a, r4.g
add_sat r5.a, r5.a, c1.a
mad	r6.a, c1.g, r5.a, c1.r
mul r6.a, r6.a, r5.a
mul r5.a, r6.a, r5.a
#else
mov_sat r5.a, v0.a
#endif
lrp r0, r5.a, r1, r0

mul r0, r0, r2
#if DETAIL
mul_x2 r0.rgb, r0, r3
#endif
mul_x2 r0.rgb, c0, r0 ; * 2 * (overbrightFactor/2)
*/
`;

var source1_worldvertextransition_vs = `
#include declare_attributes
attribute float aVertexAlpha;
attribute vec2 aLightCoord;

#include declare_matrix_uniforms
#include declare_vertex_uv

uniform vec4 uTextureCoordOffsetU;
uniform vec4 uTextureCoordOffsetV;

#include source1_varying_worldvertextransition

/* worldvertextransition.vs */
void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
	vVertexAlpha = aVertexAlpha;
}
`;

Shaders['source1_character.fs'] = source1_character_fs;
Shaders['source1_character.vs'] = source1_character_vs;
Shaders['source1_customweapon.fs'] = source1_customweapon_fs;
Shaders['source1_customweapon.vs'] = source1_customweapon_vs;
Shaders['source1_eyerefract.fs'] = source1_eyerefract_fs;
Shaders['source1_eyerefract.vs'] = source1_eyerefract_vs;
Shaders['source1_lightmappedgeneric.fs'] = source1_lightmappedgeneric_fs;
Shaders['source1_lightmappedgeneric.vs'] = source1_lightmappedgeneric_vs;
Shaders['source1_refract.fs'] = source1_refract_fs;
Shaders['source1_refract.vs'] = source1_refract_vs;
Shaders['source1_sprite.fs'] = source1_sprite_fs;
Shaders['source1_sprite.vs'] = source1_sprite_vs;
Shaders['source1_spritecard.fs'] = source1_spritecard_fs;
Shaders['source1_spritecard.vs'] = source1_spritecard_vs;
Shaders['source1_unlitgeneric.fs'] = source1_unlitgeneric_fs;
Shaders['source1_unlitgeneric.vs'] = source1_unlitgeneric_vs;
Shaders['source1_unlittwotexture.fs'] = source1_unlittwotexture_fs;
Shaders['source1_unlittwotexture.vs'] = source1_unlittwotexture_vs;
Shaders['source1_vertexlitgeneric.fs'] = source1_vertexlitgeneric_fs;
Shaders['source1_vertexlitgeneric.vs'] = source1_vertexlitgeneric_vs;
Shaders['source1_water.fs'] = source1_water_fs;
Shaders['source1_water.vs'] = source1_water_vs;
Shaders['source1_weapondecal.fs'] = source1_weapondecal_fs;
Shaders['source1_weapondecal.vs'] = source1_weapondecal_vs;
Shaders['source1_worldvertextransition.fs'] = source1_worldvertextransition_fs;
Shaders['source1_worldvertextransition.vs'] = source1_worldvertextransition_vs;

const PARTICLE_FIELD_POSITION = 0;
const PARTICLE_FIELD_POSITION_PREVIOUS = 2;
const PARTICLE_FIELD_RADIUS = 3;
const PARTICLE_FIELD_ROTATION_ROLL = 4;
const PARTICLE_FIELD_ROTATION_ROLL_SPEED = 5;
const PARTICLE_FIELD_COLOR = 6;
const PARTICLE_FIELD_ALPHA = 7;
const PARTICLE_FIELD_SEQUENCE_NUMBER = 9;
const PARTICLE_FIELD_TRAIL_LENGTH = 10;
const PARTICLE_FIELD_YAW = 12;
const PARTICLE_FIELD_HITBOX_OFFSET_POSITION = 15;
const PARTICLE_FIELD_SCRATCH_VECTOR = 17;
const PARTICLE_FIELD_SCRATCH_FLOAT = 18;
const PARTICLE_FIELD_PITCH = 20;
const PARTICLE_FIELD_GLOW_RGB = 22;
const PARTICLE_FIELD_GLOW_ALPHA = 23;
const ATTRIBUTES_WHICH_ARE_ANGLES = 1 << PARTICLE_FIELD_ROTATION_ROLL | 1 << PARTICLE_FIELD_ROTATION_ROLL_SPEED | 1 << PARTICLE_FIELD_YAW | 1 << PARTICLE_FIELD_PITCH;
const ATTRIBUTES_WHICH_ARE_0_TO_1 = 1 << PARTICLE_FIELD_ALPHA;

const DEFAULT_PARTICLE_NORMAL = fromValues$4(0, 0, 1);
class Source2Particle {
    id;
    isAlive = false;
    position = create$4();
    quaternion = create$2();
    prevPosition = create$4();
    velocity = create$4();
    color = create$3();
    initialColor = create$3();
    normal = create$4();
    scratchVec = create$4(); //?
    scratch = 0;
    hitboxOffsetPosition = create$4(); //?
    glowRGB = create$4();
    uMin = 0;
    uMax = 1;
    vMin = 0;
    vMax = 1;
    cTime = 0;
    context = new Map();
    system;
    currentTime = 0;
    timeToLive = 0;
    initialTimeToLive = 0;
    proportionOfLife = 0;
    trail = []; //TODO: remove ?
    modelName = '';
    u = 0; //TODO: remove ?
    v = 0; //TODO: remove ?
    radius = 0;
    initialRadius = 0;
    rotationRoll = 0;
    initialRoll = 0;
    rotationSpeedRoll = 0;
    rotationYaw = 0;
    startAlpha = 0;
    alpha = 0;
    glowAlpha = 0;
    sequence = 0;
    initialSequence = 0;
    sequence2 = 0;
    frame = 0;
    PositionFromParentParticles = false;
    posLockedToCP = false;
    rotLockedToCP = false;
    trailLength = 0.1;
    MovementRigidAttachToCP = false;
    static consoleAlphaAlternate = false;
    static consolePitch = false;
    constructor(id, system) {
        //this.name = 'Particle ' + id;
        //this.id = id;
        //this.cpPosition = vec3.create();
        //this.cpOrientation = quat.create();
        //this.cpOrientationInvert = quat.create();
        //this.cpPreviousTransform = mat4.create();//TODO: set this per particle list, not per particle
        //this.offsetPosition = vec3.create();
        this.system = system;
        this.reset(id);
        /*
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PREV_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_LIFE_DURATION, 1.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_RADIUS, pDef->m_flConstantRadius);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION, pDef->m_flConstantRotation);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION_SPEED, pDef->m_flConstantRotationSpeed);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TINT_RGB,
                pDef->m_ConstantColor.r() / 255.0f, pDef->m_ConstantColor.g() / 255.0f,
                pDef->m_ConstantColor.g() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ALPHA, pDef->m_ConstantColor.a() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_CREATION_TIME, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER, pDef->m_nConstantSequenceNumber);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER1, pDef->m_nConstantSequenceNumber1);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TRAIL_LENGTH, 0.1f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PARTICLE_ID, 0);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_YAW, 0);*/
    }
    step(elapsedTime) {
        this.currentTime += elapsedTime;
        if (this.timeToLive) {
            this.proportionOfLife = this.currentTime / this.timeToLive;
        }
    }
    start() {
        this.isAlive = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.trail = new Array();
    }
    die() {
        this.isAlive = false;
        this.modelName = '';
    }
    reset(id) {
        this.id = id;
        //this.firstRender = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.timeToLive = 1;
        zero$4(this.position);
        zero$4(this.prevPosition);
        //vec3.zero(this.cpPosition);
        //vec4.zero(this.cpOrientation);
        //vec3.zero(this.offsetPosition);
        zero$4(this.velocity);
        set$4(this.color, 1, 1, 1, 1);
        set$4(this.initialColor, 1, 1, 1, 1);
        copy$4(this.normal, DEFAULT_PARTICLE_NORMAL);
        zero$4(this.scratchVec);
        this.scratch = 0;
        this.u = 0;
        this.v = 0;
        this.radius = 5;
        this.initialRadius = 5;
        this.rotationRoll = 0;
        this.initialRoll = 0;
        this.rotationSpeedRoll = 0;
        this.rotationYaw = 0;
        this.startAlpha = 1;
        this.alpha = this.startAlpha;
        this.glowAlpha = 1;
        // sequence number for animated textures
        this.sequence = 0;
        this.sequence2 = 0;
        this.frame = 0;
        this.PositionFromParentParticles = false;
        this.posLockedToCP = false;
        this.rotLockedToCP = false;
        this.trailLength = 0.1;
        this.MovementRigidAttachToCP = false;
        this.context.clear();
        //this.initialCPPosition = null;
        //this.initialCPQuaternion = null;
        //mat4.identity(this.cpPreviousTransform);
    }
    setInitialField(field /*TODO: create a field enum*/, value, mulInitial = false) {
        this.setField(field, value, mulInitial, true);
    }
    setField(field = 0, value, mulInitial = false, setInitial = false, additive = false) {
        if (isNaN(field)) {
            return;
        }
        //console.log('Field ' + field + ' ' + value);
        switch (field) {
            case 0: // Position
                if (additive) {
                    add$5(this.position, this.position, value);
                }
                else {
                    copy$4(this.position, value);
                }
                if (setInitial) {
                    copy$4(this.prevPosition, this.position);
                }
                break;
            case 1: // Time to live
                //if (mulInitial) {value*=this.initialSequence;}
                //this.sequence = Math.round(value);
                if (mulInitial) {
                    value += this.initialTimeToLive;
                }
                this.timeToLive = value;
                //console.log(value);
                break;
            case 2: // Previous position
                copy$4(this.prevPosition, value);
                break;
            //case 2: vector position ?
            case 3:
                if (mulInitial) {
                    value *= this.initialRadius;
                }
                this.radius = value;
                if (setInitial) {
                    this.initialRadius = value;
                }
                break;
            case 4: //roll
                //value*=57.3;
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                if (mulInitial) {
                    value += this.initialRoll;
                }
                this.rotationRoll = value; //TODO
                break;
            case 5:
                this.rotationSpeedRoll = value * DEG_TO_RAD;
                break;
            case 6: // Color
                if (mulInitial) {
                    value[0] *= this.initialColor[0];
                    value[1] *= this.initialColor[1];
                    value[2] *= this.initialColor[2];
                }
                if (additive) {
                    add$5(this.color, this.color, value);
                }
                else {
                    copy$4(this.color, value);
                }
                //this.color.setColor({r:value[0], g:value[1], b:value[2]});
                this.color[0] = clamp(this.color[0], 0.0, 1.0);
                this.color[1] = clamp(this.color[1], 0.0, 1.0);
                this.color[2] = clamp(this.color[2], 0.0, 1.0);
                //vec3.copy(this.color, this.color[);
                if (setInitial) {
                    copy$4(this.initialColor, value);
                    //this.initialColor.setColor({r:value[0], g:value[1], b:value[2]});
                }
                break;
            case 7: // Alpha
                if (mulInitial) {
                    value *= this.startAlpha;
                }
                if (setInitial) {
                    this.startAlpha = value;
                }
                this.alpha = value;
                break;
            //case 8: // creation time
            case PARTICLE_FIELD_SEQUENCE_NUMBER:
                this.sequence = value << 0;
                break;
            case PARTICLE_FIELD_TRAIL_LENGTH:
                this.trailLength = value;
                break;
            case 12: // yaw
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                this.rotationYaw = value; //TODO
                break;
            case PARTICLE_FIELD_HITBOX_OFFSET_POSITION:
                copy$4(this.hitboxOffsetPosition, value);
                break;
            case 16:
                if (!Source2Particle.consoleAlphaAlternate) {
                    console.warn('alpha alternate code me');
                    Source2Particle.consoleAlphaAlternate = true;
                }
                break;
            case PARTICLE_FIELD_SCRATCH_VECTOR:
                copy$4(this.scratchVec, value);
                break;
            case PARTICLE_FIELD_SCRATCH_FLOAT:
                this.scratch = value;
                break;
            case 20:
                if (!Source2Particle.consolePitch) {
                    console.warn('pitch code me');
                    Source2Particle.consolePitch = true;
                }
                break;
            case 21:
                //TODO
                copy$4(this.normal, value);
                break;
            case PARTICLE_FIELD_GLOW_RGB:
                copy$4(this.glowRGB, value);
                break;
            case PARTICLE_FIELD_GLOW_ALPHA:
                this.glowAlpha = value;
                break;
        }
    }
    /**
    * TODO
    */
    /*
    // required
    DEFPARTICLE_ATTRIBUTE(XYZ, 0);

    // particle lifetime (duration) of particle as a float.
    DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

    // prev coordinates for verlet integration
    DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

    // radius of particle
    DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

    // rotation angle of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

    // rotation speed of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

    // tint of particle
    DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

    // alpha tint of particle
    DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

    // creation time stamp (relative to particle system creation)
    DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

    // sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

    // length of the trail
    DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

    // unique particle identifier
    DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

    // unique rotation around up vector
    DEFPARTICLE_ATTRIBUTE(YAW, 12);

    // second sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

    // hit box index
    DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

    DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);
    */
    getField(field = 0, initial = false) {
        switch (field) {
            case PARTICLE_FIELD_POSITION:
                return this.position;
            case 1: // Time to live
                return initial ? this.initialTimeToLive : this.timeToLive;
            case PARTICLE_FIELD_POSITION_PREVIOUS:
                return this.prevPosition;
            case 3:
                return this.radius;
            case 4:
                return this.rotationRoll;
            case 5:
                return this.rotationSpeedRoll;
            case PARTICLE_FIELD_COLOR:
                return this.color;
            case 7:
                return this.alpha;
            case 8: //creation time
                return this.cTime;
            case PARTICLE_FIELD_SEQUENCE_NUMBER:
                return this.sequence;
            case PARTICLE_FIELD_TRAIL_LENGTH:
                return this.trailLength;
            case 12: //yaw
                return this.rotationYaw;
            case PARTICLE_FIELD_HITBOX_OFFSET_POSITION:
                return this.hitboxOffsetPosition;
            case 16:
                if (!Source2Particle.consoleAlphaAlternate) {
                    console.warn('alpha alternate code me');
                    Source2Particle.consoleAlphaAlternate = true;
                }
                break;
            case PARTICLE_FIELD_SCRATCH_VECTOR:
                return this.scratchVec;
            case PARTICLE_FIELD_SCRATCH_FLOAT:
                return this.scratch;
            case 20:
                if (!Source2Particle.consolePitch) {
                    console.warn('pitch code me');
                    Source2Particle.consolePitch = true;
                }
                break;
            case 21:
                return this.normal;
            case PARTICLE_FIELD_GLOW_RGB:
                return this.glowRGB;
        }
        return 0;
    }
    /**
    * TODO
    */
    setInitialSequence(sequence) {
        this.sequence = sequence;
        this.initialSequence = sequence;
    }
    /**
    * TODO
    */
    setInitialRadius(radius) {
        this.radius = radius;
        this.initialRadius = radius;
    }
    /**
    * TODO
    */
    setInitialTTL(timeToLive) {
        this.timeToLive = timeToLive;
        this.initialTimeToLive = timeToLive;
    }
    /**
    * TODO
    */
    setInitialColor(color) {
        this.color = color;
        this.initialColor = color;
    }
    /**
    * Set particle initial rotation roll.
    * @param {Number} roll Initial rotation roll.
    */
    setInitialRoll(roll) {
        this.rotationRoll = roll;
        this.initialRoll = roll;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getWorldPos(worldPos = create$4()) {
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.transformQuat(worldPos, this.position, this.system.currentOrientation);
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //if (this.initialCPPosition) {
        //vec3.add(worldPos, worldPos, this.cpPosition);
        //}
        copy$4(worldPos, this.position);
        return worldPos;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getLocalPos(worldPos = create$4()) {
        //worldPos = worldPos || vec3.create();
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        transformQuat$1(worldPos, this.position, create$2());
        //vec3.add(worldPos, worldPos, this.cpPosition);
        return worldPos;
    }
}
/* FIELDS
0:velocity ??
1: TTL
3:radius
4:roll
5:roll speed ??
6: color
7: alpha
8:current time
10:scale
12:yaw???
//-----------------------------------------------------------------------------
// Particle attributes
//-----------------------------------------------------------------------------
#define MAX_PARTICLE_ATTRIBUTES 32

#define DEFPARTICLE_ATTRIBUTE(name, bit)						\
    const int PARTICLE_ATTRIBUTE_##name##_MASK = (1 << bit);	\
    const int PARTICLE_ATTRIBUTE_##name = bit;

// required
DEFPARTICLE_ATTRIBUTE(XYZ, 0);

// particle lifetime (duration) of particle as a float.
DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

// prev coordinates for verlet integration
DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

// radius of particle
DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

// rotation angle of particle
DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

// rotation speed of particle
DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

// tint of particle
DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

// alpha tint of particle
DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

// creation time stamp (relative to particle system creation)
DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

// sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

// length of the trail
DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

// unique particle identifier
DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

// unique rotation around up vector
DEFPARTICLE_ATTRIBUTE(YAW, 12);

// second sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

// hit box index
DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

*/
/**
 * TODO
 */

class Source2Snapshot {
    particleCount = 0;
    attributes = {};
    file;
    setParticleCount(particleCount) {
        this.particleCount = particleCount;
    }
}

const Source2SnapshotLoader = new (function () {
    class Source2SnapshotLoader {
        async load(repository, filename) {
            filename = filename.replace(/.vsnap_c/, '').replace(/.vsnap/, '');
            let snapFile = await new Source2FileLoader(true).load(repository, filename + '.vsnap_c');
            if (snapFile) {
                return this.loadSnapshot(snapFile);
            }
            else {
                return null;
            }
        }
        loadSnapshot(snapFile) {
            let snapShot = new Source2Snapshot();
            snapShot.file = snapFile;
            let dataBlock = snapFile.getBlockByType('DATA');
            let snapBlock = snapFile.getBlockByType('SNAP');
            if (dataBlock && snapBlock) {
                let particleCount = Number(dataBlock.getKeyValue('num_particles'));
                snapShot.setParticleCount(particleCount);
                let snapshotAttributes = dataBlock.getKeyValue('attributes') ?? [];
                let snapshotStringList = dataBlock.getKeyValue('string_list') ?? [];
                let reader = new BinaryReader(snapBlock.datas);
                let attributeValue;
                let bones;
                let weights;
                for (let snapshotAttribute of snapshotAttributes) {
                    reader.seek(Number(snapshotAttribute.data_offset));
                    switch (snapshotAttribute.type) {
                        case 'float3':
                        case 'vector':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(reader.getVector3());
                            }
                            break;
                        case 'skinning':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                let skinning = Object.create(null);
                                bones = [];
                                weights = [];
                                for (let i = 0; i < 4; ++i) {
                                    bones.push(snapshotStringList[reader.getUint16()]);
                                }
                                for (let i = 0; i < 4; ++i) {
                                    weights.push(reader.getFloat32());
                                }
                                skinning.bones = bones;
                                skinning.weights = weights;
                                attributeValue.push(skinning);
                            }
                            break;
                        case 'string':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(snapshotStringList[reader.getUint32()]);
                            }
                            break;
                        case 'float':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(reader.getFloat32());
                            }
                            break;
                        default:
                            attributeValue = null;
                            console.error('Unknow snapshot attribute type', snapshotAttribute.type, snapshotAttribute, snapFile, Number(snapshotAttribute.data_size) / particleCount);
                    }
                    snapShot.attributes[snapshotAttribute.name] = attributeValue;
                }
            }
            return snapShot;
        }
    }
    return Source2SnapshotLoader;
}());

const DEFAULT_CONTROL_POINT_SCALE = fromValues$4(1, 1, 1);
let vec$8 = create$4();
class Source2ParticleSystem extends Entity {
    isParticleSystem = true;
    isSource2ParticleSystem = true;
    fileName;
    repository;
    #parentModel;
    animable = true;
    resetable = true;
    speed = 1;
    isRunning = false;
    startAfterDelay = 0;
    preEmissionOperators = [];
    emitters = [];
    initializers = [];
    operators = [];
    forces = [];
    constraints = [];
    renderers = [];
    controlPoints = [];
    childSystems = [];
    livingParticles = [];
    poolParticles = [];
    minBounds = create$4();
    maxBounds = create$4();
    particleCount = 0;
    // particle to emit when the system starts
    initialParticles = 0;
    disabled = false;
    baseProperties;
    firstStep = false;
    currentTime = 0;
    elapsedTime = 0;
    previousElapsedTime = 0;
    maxParticles = 0;
    currentParticles = 0;
    resetDelay = 0;
    parentSystem;
    isBounded = false;
    constructor(repository, fileName, name) {
        super({ name: name });
        this.fileName = fileName;
        this.repository = repository;
        this.setMaxParticles(DEFAULT_MAX_PARTICLES);
        //Add first control point
        //this.getControlPoint(0);
        this.baseProperties = { color: fromValues$3(1.0, 1.0, 1.0, 1.0), radius: 5, lifespan: 1, sequenceNumber: 0, snapshotControlPoint: 0, snapshot: '' };
    }
    async init(snapshotModifiers) {
        await this.#initSnapshot(snapshotModifiers);
        for (let child of this.childSystems) {
            this.addChild(child);
        }
        for (let renderer of this.renderers) {
            renderer.initRenderer(this);
        }
    }
    async #initSnapshot(snapshotModifiers) {
        //TODO : we should add a snapshotmanager to avoid loading the same file multiple time
        let snapshotFile = this.baseProperties.snapshot;
        if (snapshotModifiers && snapshotModifiers.has(snapshotFile)) {
            snapshotFile = snapshotModifiers.get(snapshotFile);
        }
        if (snapshotFile) {
            let snapshot = await Source2SnapshotLoader.load(this.repository, snapshotFile);
            console.debug(snapshot);
            let cp = this.getControlPoint(this.baseProperties.snapshotControlPoint);
            if (cp && snapshot) {
                //TODO : what happens when this controlPoint is inherited and has already a snapshot ?
                cp.snapshot = snapshot;
            }
        }
    }
    start() {
        if (this.disabled)
            return;
        if (this.isRunning)
            return;
        Source2ParticleManager.setActive(this);
        this.firstStep = true;
        this.#reset();
        this.#startChildren();
        this.isRunning = true;
    }
    #startChildren() {
        for (let i = 0; i < this.childSystems.length; ++i) {
            this.childSystems[i].start();
        }
    }
    stop() {
        this.stopChildren();
        this.isRunning = false;
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            this.poolParticles.push(particle);
            this.livingParticles.splice(i, 1);
            --i;
        }
    }
    stopChildren() {
        for (let i = 0; i < this.childSystems.length; ++i) {
            this.childSystems[i].stop();
        }
    }
    do(action, params) {
        switch (action) {
            case 'reset':
                this.reset();
                break;
        }
    }
    reset() {
        this.stop();
        this.start();
    }
    #reset() {
        this.currentTime = 0;
        this.elapsedTime = 0.05;
        this.previousElapsedTime = 0.05;
        this.particleCount = 0;
        this.#resetChilds();
        this.#resetEmitters();
        //TODO: reset some operators
    }
    #resetChilds() {
        for (let i = 0; i < this.childSystems.length; ++i) {
            this.childSystems[i].#reset();
        }
    }
    #resetEmitters() {
        for (let emitter of this.emitters) {
            emitter.reset();
        }
    }
    #preEmission() {
        for (let operator of this.preEmissionOperators) {
            operator.operateParticle(true, this.elapsedTime);
        }
    }
    step(elapsedTime) {
        if (!this.isPlaying()) {
            elapsedTime = 0.0000001;
        }
        if (!this.isRunning)
            return;
        if (this.firstStep) {
            elapsedTime = 0.05;
        }
        this.previousElapsedTime = this.elapsedTime;
        this.elapsedTime = elapsedTime * this.speed;
        this.#preEmission();
        this.stepControlPoint();
        if (this.firstStep) {
            this.firstStep = false;
            this.#emitInitialParticles(elapsedTime);
        }
        this.#stepEmitters();
        this.#stepOperators();
        this.currentTime += this.elapsedTime;
        this.#stepRenderers(elapsedTime);
        this.#stepChildren(elapsedTime);
        this.#recomputeBounds();
    }
    #emitInitialParticles(elapsedTime) {
        for (let i = 0; i < this.initialParticles; ++i) {
            this.createParticle(0, elapsedTime);
        }
    }
    stepControlPoint() {
        for (let i in this.controlPoints) {
            const cp = this.controlPoints[i];
            cp.step();
            /*if (i == 0) {
                if (cp.attachementProp) {
                    const atta = cp.attachementProp;
                    if (atta) {
                        this.setOrientation(atta.getWorldQuat());
                    }
                }
            }*/
        }
        /*if (this.parentSystem) {
            this.setOrientation(this.parentSystem.getWorldQuaternion());
        }*/
    }
    #stepEmitters() {
        for (let emitter of this.emitters) {
            emitter.doEmit(this.elapsedTime);
        }
    }
    #stepOperators() {
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            particle.step(this.elapsedTime);
            for (let operator of this.operators) {
                //const operator = this.operators[j];
                if (operator.operateAllParticlesRemoveme) {
                    if (i == 0) { //do it only once
                        operator.operateParticle(this.livingParticles, this.elapsedTime);
                    }
                }
                else {
                    operator.operateParticle(particle, this.elapsedTime);
                }
                // break the loop if the particle is dead
                if (!particle.isAlive)
                    break;
            }
            if (!particle.isAlive) {
                this.poolParticles.push(particle);
                this.livingParticles.splice(i, 1);
                --i;
            }
        }
    }
    #stepRenderers(elapsedTime) {
        //TODOv3: multiple passes
        for (let renderer of this.renderers) {
            if (!renderer.disableOperator) {
                renderer.updateParticles(this, this.livingParticles, elapsedTime);
            }
        }
    }
    #stepChildren(elapsedTime) {
        for (let child of this.childSystems) {
            if (!child.endCap) {
                child.step(elapsedTime);
            }
        }
    }
    createParticle(creationTime, elapsedTime) {
        if (this.livingParticles.length < this.maxParticles) {
            // first try to get one from the pool
            if (this.poolParticles.length > 0) {
                const particle = this.poolParticles.pop();
                //init the particle to its initial state;
                particle.reset(++this.particleCount);
                particle.cTime = creationTime;
                this.#initControlPoint(particle);
                this.#startParticle(particle, elapsedTime);
                return particle;
            }
            const particle = new Source2Particle(/*'Particle ' + */ ++this.particleCount, this);
            particle.cTime = creationTime;
            this.#initControlPoint(particle);
            this.#startParticle(particle, elapsedTime);
            ++this.currentParticles;
            return particle;
        }
    }
    #startParticle(particle, elapsedTime) {
        this.resetDelay = 0;
        this.livingParticles.push(particle);
        this.#preInitParticle(particle);
        particle.previousElapsedTime = elapsedTime;
        particle.start();
        // Init modifiers in a 2nd loop
        for (let i in this.initializers) {
            const initializer = this.initializers[i];
            if (!initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
        for (let i in this.initializers) {
            const initializer = this.initializers[i];
            if (initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
    }
    #preInitParticle(particle) {
        particle.setInitialRadius(this.baseProperties.radius);
        copy$3(particle.color, this.baseProperties.color);
        copy$3(particle.initialColor, particle.color);
        particle.startAlpha = this.baseProperties.color[3];
        particle.alpha = this.baseProperties.color[3];
        particle.setInitialTTL(this.baseProperties.lifespan);
        particle.sequence = this.baseProperties.sequenceNumber;
        particle.rotationSpeedRoll = this.baseProperties.rotationSpeedRoll;
    }
    #initControlPoint(particle) {
        this.getWorldPosition(particle.cpPosition);
    }
    getWorldPosition(vec = create$4()) {
        return zero$4(vec);
    }
    getWorldQuaternion(q = create$2()) {
        return identity$1(q);
    }
    getControlPoint(controlPointId) {
        let parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            return this.controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId); //TODO: remove recursion
        }
        let controlPoint = this.controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
        }
        return controlPoint;
    }
    getControlPointForScale(controlPointId) {
        let parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            return this.controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId);
        }
        let controlPoint = this.controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
            controlPoint.position = DEFAULT_CONTROL_POINT_SCALE;
        }
        return controlPoint;
    }
    getOwnControlPoint(controlPointId) {
        //return this.getControlPoint(controlPointId);
        return this.controlPoints[controlPointId] ?? this.#createControlPoint(controlPointId);
    }
    #createControlPoint(controlPointId) {
        let controlPoint = new ControlPoint();
        controlPoint.name = controlPointId;
        this.addChild(controlPoint);
        this.controlPoints[controlPointId] = controlPoint;
        set$5(controlPoint.fVector, 0, 1, 0);
        set$5(controlPoint.uVector, 0, 0, 1);
        set$5(controlPoint.rVector, 1, 0, 0);
        return controlPoint;
    }
    getControlPointPosition(cpId) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            return cp.getWorldPosition(vec$8);
        }
        return create$4();
    }
    setControlPointPosition(cpId, position) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            cp.position = position;
        }
    }
    setMaxParticles(max) {
        this.maxParticles = Math.max(Math.min(max, HARD_MAX_PARTICLES), 1);
    }
    stepConstraints(particle) {
        //TODOv3: multiple passes
        for (let j in this.constraints) {
            const constraint = this.constraints[j];
            constraint.constraintParticle(particle);
        }
    }
    #recomputeBounds() {
        let minBounds = this.minBounds;
        let maxBounds = this.maxBounds;
        set$5(minBounds, Infinity, Infinity, Infinity);
        set$5(maxBounds, -Infinity, -Infinity, -Infinity);
        this.isBounded = false;
        for (let particle of this.livingParticles) {
            min$3(minBounds, minBounds, particle.position);
            max$3(maxBounds, maxBounds, particle.position);
            this.isBounded = true;
        }
    }
    getBounds(minBounds, maxBounds) {
        copy$4(minBounds, this.minBounds);
        copy$4(maxBounds, this.maxBounds);
    }
    getBoundsCenter(center) {
        if (this.isBounded) {
            add$5(center, this.minBounds, this.maxBounds);
            scale$5(center, center, 0.5);
        }
        else {
            zero$4(center);
        }
    }
    parentChanged(parent = null) {
        if (parent?.isSource2ParticleSystem) {
            this.parentSystem = parent;
        }
        else {
            parent?.addChild(this.getControlPoint(0));
            this.setParentModel(parent);
        }
    }
    setParentModel(model) {
        if (!model) {
            return;
        }
        this.#parentModel = model;
        this.getControlPoint(0).model = model;
        if (this.baseProperties.controlPointConfigurations) {
            for (let controlPointConfiguration of this.baseProperties.controlPointConfigurations) {
                /*if (controlPointConfiguration.m_name == 'point_follow')*/ {
                    let drivers = controlPointConfiguration.m_drivers;
                    if (drivers) {
                        let i = 0;
                        for (let driver of drivers) {
                            const attachmentName = driver.m_attachmentName;
                            if (attachmentName) {
                                let attachementInstance = model?.getAttachement(attachmentName);
                                if (driver.m_entityName == 'parent') {
                                    attachementInstance = model?.parent?.getAttachement?.(attachmentName) ?? attachementInstance;
                                }
                                if (attachementInstance) {
                                    let cp = this.getOwnControlPoint(driver.m_iControlPoint ?? i);
                                    attachementInstance.addChild(cp);
                                    cp.step();
                                }
                            }
                            ++i;
                        }
                    }
                }
            }
        }
    }
    getParentModel() {
        // TODO: remove recursion
        if (this.parentSystem) {
            return this.parentSystem.getParentModel();
        }
        return this.#parentModel;
    }
    getParticle(index) {
        if (index == undefined) {
            index = Math.floor(Math.random() * this.livingParticles.length);
        }
        if (index >= this.livingParticles.length) {
            index = Math.floor(Math.random() * this.poolParticles.length);
            return this.poolParticles[index];
        }
        return this.livingParticles[index];
    }
    dispose() {
        super.dispose();
        this.controlPoints.forEach(element => element.dispose());
        this.operators.forEach(element => element.dispose());
        this.renderers.forEach(element => element.dispose());
        this.childSystems.forEach(element => element.dispose());
        this.controlPoints.length = 0;
    }
    buildContextMenu() {
        let startStop = this.isRunning ? { i18n: '#stop', f: () => this.stop() } : { i18n: '#start', f: () => this.start() };
        return Object.assign(super.buildContextMenu(), {
            Source2ParticleSystem_1: null,
            startStop: startStop,
            reset: { i18n: '#reset', f: () => this.reset() },
        });
    }
    static getEntityName() {
        return 'Source 2 particle system';
    }
}
Source2ParticleSystem.prototype.isParticleSystem = true;
Source2ParticleSystem.prototype.isSource2ParticleSystem = true;

const Source2ParticleOperators = new Map;
function RegisterSource2ParticleOperator(operatorName, operator) {
    Source2ParticleOperators.set(operatorName, operator);
}
function GetSource2ParticleOperator(operatorName) {
    return Source2ParticleOperators.get(operatorName);
}

const CParticleSystemDefinition = 'CParticleSystemDefinition';
function _initProperties(system, systemDefinition) {
    let keys = Object.keys(systemDefinition);
    for (let key of keys) {
        let value = systemDefinition[key];
        switch (key) {
            case 'm_nMaxParticles':
                system.setMaxParticles(Number(value));
                break;
            case 'm_ConstantColor':
                set$4(system.baseProperties.color, Number(value[0]) / 255.0, Number(value[1]) / 255.0, Number(value[2]) / 255.0, Number(value[3]) / 255.0);
                break;
            case 'm_flConstantLifespan':
                system.baseProperties.lifespan = value;
                break;
            case 'm_flConstantRadius':
                system.baseProperties.radius = Number(value);
                break;
            case 'm_nConstantSequenceNumber':
                system.baseProperties.sequenceNumber = Number(value);
                break;
            case 'm_controlPointConfigurations':
                system.baseProperties.controlPointConfigurations = value;
                break;
            case 'm_hSnapshot':
                system.baseProperties.snapshot = value;
                break;
            case 'm_nSnapshotControlPoint':
                system.baseProperties.snapshotControlPoint = Number(value);
                break;
            case 'm_nInitialParticles':
                system.initialParticles = Number(value);
                break;
            case 'm_flConstantRotationSpeed':
                system.baseProperties.rotationSpeedRoll = value;
                break;
        }
    }
}
function _initOperators(system, systemArray, kv3Array) {
    if (kv3Array) {
        let properties = kv3Array;
        if (properties) {
            for (let property of properties) {
                if (property._class) {
                    let operatorClass = GetSource2ParticleOperator(property._class);
                    if (operatorClass) {
                        let operator = new operatorClass(system);
                        if (operator.isPreEmission()) {
                            system.preEmissionOperators.push(operator);
                        }
                        else {
                            systemArray.push(operator);
                        }
                        for (let param of Object.keys(property)) {
                            if (param != '_class') {
                                operator.setParam(param, property[param]);
                            }
                        }
                        operator.init();
                    }
                    else {
                        console.error('Unknown operator : ' + property._class, property, system.name);
                    }
                }
            }
        }
    }
}
async function _initChildren(repository, systemArray, kv3Array, snapshotModifiers) {
    let promises = [];
    if (kv3Array) {
        let properties = kv3Array;
        if (properties) {
            for (let childIndex = 0; childIndex < properties.length; ++childIndex) {
                let property = properties[childIndex];
                let m_ChildRef = property.m_ChildRef;
                let m_flDelay = property.m_flDelay || 0;
                if (m_ChildRef) {
                    let p = new Promise(async (resolve, reject) => {
                        let system = await Source2ParticleManager.getSystem(repository, m_ChildRef, snapshotModifiers);
                        system.disabled = property.m_bDisableChild ?? false;
                        if (system) {
                            system.endCap = property.m_bEndCap ?? false;
                            system.startAfterDelay = m_flDelay;
                            systemArray[childIndex] = system;
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    });
                    promises.push(p);
                }
            }
        }
    }
    await Promise.allSettled(promises);
}
const Source2ParticleLoader = new (function () {
    class Source2ParticleLoader {
        load(repository, fileName) {
            let promise = new Promise((resolve, reject) => {
                fileName = fileName.replace(/.vpcf_c/, '');
                let vpcfPromise = new Source2FileLoader(true).load(repository, fileName + '.vpcf_c');
                vpcfPromise.then((source2File) => {
                    resolve(source2File);
                }).catch((error) => reject(error));
            });
            return promise;
        }
        async getSystem(repository, vpcf, snapshotModifiers) {
            const fileName = vpcf.fileName;
            const result = /[ \w-]+?(?=\.)/.exec(fileName);
            let system = new Source2ParticleSystem(repository, fileName, result ? result[0] : fileName);
            let systemDefinition = vpcf.getBlockStruct('DATA.keyValue.root');
            if (systemDefinition._class == CParticleSystemDefinition) {
                _initOperators(system, system.preEmissionOperators, systemDefinition.m_PreEmissionOperators);
                _initOperators(system, system.emitters, systemDefinition.m_Emitters);
                _initOperators(system, system.initializers, systemDefinition.m_Initializers);
                _initOperators(system, system.operators, systemDefinition.m_Operators);
                _initOperators(system, system.renderers, systemDefinition.m_Renderers);
                _initOperators(system, system.forces, systemDefinition.m_ForceGenerators);
                _initOperators(system, system.constraints, systemDefinition.m_Constraints);
                await _initChildren(repository, system.childSystems, systemDefinition.m_Children, snapshotModifiers);
                _initProperties(system, systemDefinition);
            }
            await system.init(snapshotModifiers);
            return system;
        }
    }
    return Source2ParticleLoader;
}());
registerLoader('Source2ParticleLoader', Source2ParticleLoader);

/**
 * DynamicExpression
 */
let stack;
const hashes = {};
const HASH_SEED = 0x31415926;
hashes[murmurhash2_32_gc('time', HASH_SEED)] = 'time';
function executeDynamicExpression(byteCode, renderAttributes = []) {
    let pointer = -1;
    let storage = {};
    stack = [];
    let storeAddress;
    let location;
    while (pointer < byteCode.length) {
        ++pointer;
        let opcode = byteCode[pointer];
        switch (opcode) {
            case 0: // stop
                return stack.pop();
            case 2: // goto
                location = getlocation(byteCode, pointer + 1);
                if ((location >= 0) && (location < byteCode.length)) {
                    pointer = location - 1;
                }
                else {
                    //TODO: error message
                    return null;
                }
                break;
            case 4: // ?
                let conditionalValue = stack.pop();
                // Only the first value is tested
                location = conditionalValue[0] ? getlocation(byteCode, pointer + 1) : getlocation(byteCode, pointer + 3);
                if ((location >= 0) && (location < byteCode.length)) {
                    pointer = location - 1;
                }
                else {
                    //TODO: error message
                    return null;
                }
                break;
            case 6: // function
                let functionCode = getlocation(byteCode, pointer + 1);
                if (functionCode >= 0) {
                    processFunction(functionCode);
                    pointer += 2;
                }
                else {
                    //TODO: error message
                    return null;
                }
                break;
            case 7: // float32
                stack.push(getFloat32(byteCode, pointer + 1));
                pointer += 4;
                break;
            case 8: // save
                storeAddress = getByte(byteCode, pointer + 1);
                if (storeAddress >= 0) {
                    storage[storeAddress] = stack.pop();
                    pointer += 1;
                }
                else {
                    //TODO: error message
                    return null;
                }
                break;
            case 9: // restore
                storeAddress = getByte(byteCode, pointer + 1);
                if (storeAddress >= 0) {
                    stack.push(storage[storeAddress]);
                    pointer += 1;
                }
                else {
                    //TODO: error message
                    return null;
                }
                break;
            case 12:
                not();
                break;
            case 13: // ==
                equality();
                break;
            case 14: // !=
                inequality();
                break;
            case 15: // >
                greater();
                break;
            case 16: // >=
                greaterEqual();
                break;
            case 17: // <
                less();
                break;
            case 18: // <=
                lessEqual();
                break;
            case 19: // +
                add();
                break;
            case 20: // -
                subtract();
                break;
            case 21: // *
                multiply();
                break;
            case 22: // /
                divide();
                break;
            case 23: // /
                modulo();
                break;
            case 24: // negate
                negation();
                break;
            case 25: // get value
                let intValue = (byteCode[pointer + 1] + (byteCode[pointer + 2] << 8) + (byteCode[pointer + 3] << 16) + (byteCode[pointer + 4] << 24)) >>> 0;
                let stringValue = hashes[intValue];
                if (!stringValue) {
                    for (let renderAttribute of renderAttributes) {
                        renderAttribute = renderAttribute.toLowerCase();
                        hashes[murmurhash2_32_gc(renderAttribute, HASH_SEED)] = renderAttribute;
                    }
                    stringValue = hashes[intValue];
                }
                if (stringValue) {
                    let value = 0;
                    if (stringValue === 'time') {
                        value = performance.now() * 0.001;
                    }
                    stack.push(fromValues$3(value, value, value, value));
                }
                pointer += 4;
                break;
            //see m_renderAttributesUsed
            //time : 0: 25 1: 204 2: 133 3: 68 4: 150 5: 0
            //$gemcolor: 0: 25 1: 230 2: 22 3: 70 4: 81 5: 0
            //a: 0: 25 1: 225 2: 113 3: 207 4: 30 5: 0
            //b: 0: 25 1: 42 2: 183 3: 253 4: 183 5: 0
            //B: 0: 25 1: 42 2: 183 3: 253 4: 183 5: 0
            //$a: 0: 25 1: 96 2: 46 3: 222 4: 5 5: 0
            //??? 0: 25 1: 252 2: 99 3: 114 4: 40 5: 0 ==> $PA_ARCANA_DETAIL1SCALE
            //$gem 0: 25 1: 150 2: 173 3: 217 4: 104 5: 0
            case 30:
                swizzle(getByte(byteCode, ++pointer));
                break;
            case 31: // exist
                stack.push(fromValues$3(0, 0, 0, 0)); //TODO get an external var
                pointer += 4;
                break;
        }
    }
}
function processFunction(functionCode) {
    let a, b, c, d;
    switch (functionCode) {
        case 0: // sin
            sin();
            break;
        case 1: // cos
            cos();
            break;
        case 2: // tan
            tan();
            break;
        case 3: // frac
            frac();
            break;
        case 4: // floor
            floor();
            break;
        case 5: // ceil
            ceil();
            break;
        case 6: // saturate
            saturate();
            break;
        case 7: // clamp
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            a[0] = clamp(c[0], b[0], a[0]);
            a[1] = clamp(c[1], b[1], a[1]);
            a[2] = clamp(c[2], b[2], a[2]);
            a[3] = clamp(c[3], b[3], a[3]);
            stack.push(a);
            break;
        case 8: // lerp
            let factor = stack.pop();
            let second = stack.pop();
            let first = stack.pop();
            first[0] = first[0] + factor[0] * (second[0] - first[0]);
            first[1] = first[1] + factor[1] * (second[1] - first[1]);
            first[2] = first[2] + factor[2] * (second[2] - first[2]);
            first[3] = first[3] + factor[3] * (second[3] - first[3]);
            stack.push(first);
            break;
        case 9: // dot4
            dot4();
            break;
        case 10: // dot3
            dot3();
            break;
        case 11: // dot2
            dot2();
            break;
        case 12: // log
            log();
            break;
        case 13: // log2
            log2();
            break;
        case 14: // log10
            log10();
            break;
        case 15: // exp
            exp();
            break;
        case 16: // exp2
            exp2();
            break;
        case 17: // sqrt
            sqrt();
            break;
        case 18: // rsqrt
            rsqrt();
            break;
        case 19: // sign
            sign();
            break;
        case 20: // abs
            abs();
            break;
        case 21: // pow
            pow();
            break;
        case 22: // step
            step();
            break;
        case 23: // smoothstep
            smoothstep();
            break;
        case 24: // float4
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            d = stack.pop();
            stack.push(fromValues$3(d[0], c[0], b[0], a[0]));
            break;
        case 25: // float3
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            stack.push(fromValues$3(c[0], b[0], a[0], a[0]));
            break;
        case 26: // float2
            a = stack.pop();
            b = stack.pop();
            stack.push(fromValues$3(b[0], a[0], a[0], a[0]));
            break;
        case 27: // time
            let time = performance.now() * 0.001;
            stack.push(fromValues$3(time, time, time, time));
            break;
        case 28: // min
            min();
            break;
        case 29: // max
            max();
            break;
        case 30:
            SrgbLinearToGamma();
            break;
        case 31:
            SrgbGammaToLinear();
            break;
        case 32: // random
            random();
            break;
        case 33:
            normalize();
            break;
        case 34:
            length();
            break;
        case 35:
            sqr();
            break;
    }
}
function getByte(b, offset) {
    return (offset > b.length - 1) ? -1 : b[0 + offset];
}
function getFloat32(b, offset) {
    let sign = 1 - (2 * (b[3 + offset] >> 7)), exponent = (((b[3 + offset] << 1) & 0xff) | (b[2 + offset] >> 7)) - 127, mantissa = ((b[2 + offset] & 0x7f) << 16) | (b[1 + offset] << 8) | b[0 + offset];
    let ret;
    if (exponent === 128) {
        if (mantissa !== 0) {
            ret = NaN;
        }
        else {
            ret = sign * Infinity;
        }
    }
    else if (exponent === -127) { // Denormalized
        ret = sign * mantissa * pow2(-126 - 23);
    }
    else {
        ret = sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
    }
    return fromValues$3(ret, ret, ret, ret);
}
function getlocation(b, offset) {
    return (offset > b.length - 2) ? -1 : (b[1 + offset] << 8) | b[0 + offset];
}
function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}
function not() {
    let a = stack.pop();
    a[0] = !a[0];
    a[1] = !a[1];
    a[2] = !a[2];
    a[3] = !a[3];
    stack.push(a);
}
function equality() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] == a[0];
    a[1] = b[1] == a[1];
    a[2] = b[2] == a[2];
    a[3] = b[3] == a[3];
    stack.push(a);
}
function inequality() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] != a[0];
    a[1] = b[1] != a[1];
    a[2] = b[2] != a[2];
    a[3] = b[3] != a[3];
    stack.push(a);
}
function greater() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] > a[0];
    a[1] = b[1] > a[1];
    a[2] = b[2] > a[2];
    a[3] = b[3] > a[3];
    stack.push(a);
}
function greaterEqual() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] >= a[0];
    a[1] = b[1] >= a[1];
    a[2] = b[2] >= a[2];
    a[3] = b[3] >= a[3];
    stack.push(a);
}
function less() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] < a[0];
    a[1] = b[1] < a[1];
    a[2] = b[2] < a[2];
    a[3] = b[3] < a[3];
    stack.push(a);
}
function lessEqual() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] <= a[0];
    a[1] = b[1] <= a[1];
    a[2] = b[2] <= a[2];
    a[3] = b[3] <= a[3];
    stack.push(a);
}
function add() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] + a[0];
    a[1] = b[1] + a[1];
    a[2] = b[2] + a[2];
    a[3] = b[3] + a[3];
    stack.push(a);
}
function subtract() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] - a[0];
    a[1] = b[1] - a[1];
    a[2] = b[2] - a[2];
    a[3] = b[3] - a[3];
    stack.push(a);
}
function multiply() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] * a[0];
    a[1] = b[1] * a[1];
    a[2] = b[2] * a[2];
    a[3] = b[3] * a[3];
    stack.push(a);
}
function divide() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] / a[0];
    a[1] = b[1] / a[1];
    a[2] = b[2] / a[2];
    a[3] = b[3] / a[3];
    stack.push(a);
}
function modulo() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] % a[0];
    a[1] = b[1] % a[1];
    a[2] = b[2] % a[2];
    a[3] = b[3] % a[3];
    stack.push(a);
}
function negation() {
    let a = stack.pop();
    a[0] = -a[0];
    a[1] = -a[1];
    a[2] = -a[2];
    a[3] = -a[3];
    stack.push(a);
}
function swizzle(code) {
    let a = stack.pop();
    a[0] = a[(code >> 0) & 3];
    a[1] = a[(code >> 2) & 3];
    a[2] = a[(code >> 4) & 3];
    a[3] = a[(code >> 6) & 3];
    stack.push(a);
}
// Functions
function sin() {
    let a = stack.pop();
    a[0] = Math.sin(a[0]);
    a[1] = Math.sin(a[1]);
    a[2] = Math.sin(a[2]);
    a[3] = Math.sin(a[3]);
    stack.push(a);
}
function cos() {
    let a = stack.pop();
    a[0] = Math.cos(a[0]);
    a[1] = Math.cos(a[1]);
    a[2] = Math.cos(a[2]);
    a[3] = Math.cos(a[3]);
    stack.push(a);
}
function tan() {
    let a = stack.pop();
    a[0] = Math.tan(a[0]);
    a[1] = Math.tan(a[1]);
    a[2] = Math.tan(a[2]);
    a[3] = Math.tan(a[3]);
    stack.push(a);
}
function frac() {
    let a = stack.pop();
    a[0] = a[0] % 1;
    a[1] = a[1] % 1;
    a[2] = a[2] % 1;
    a[3] = a[3] % 1;
    stack.push(a);
}
function floor() {
    let a = stack.pop();
    a[0] = Math.floor(a[0]);
    a[1] = Math.floor(a[1]);
    a[2] = Math.floor(a[2]);
    a[3] = Math.floor(a[3]);
    stack.push(a);
}
function ceil() {
    let a = stack.pop();
    a[0] = Math.ceil(a[0]);
    a[1] = Math.ceil(a[1]);
    a[2] = Math.ceil(a[2]);
    a[3] = Math.ceil(a[3]);
    stack.push(a);
}
function saturate() {
    let a = stack.pop();
    a[0] = clamp(a[0], 0, 1);
    a[1] = clamp(a[1], 0, 1);
    a[2] = clamp(a[2], 0, 1);
    a[3] = clamp(a[3], 0, 1);
    stack.push(a);
}
function dot4() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    stack.push(a);
}
function dot3() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    stack.push(a);
}
function dot2() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1];
    stack.push(a);
}
function log() {
    let a = stack.pop();
    a[0] = Math.log(a[0]);
    a[1] = Math.log(a[1]);
    a[2] = Math.log(a[2]);
    a[3] = Math.log(a[3]);
    stack.push(a);
}
function log2() {
    let a = stack.pop();
    a[0] = Math.log2(a[0]);
    a[1] = Math.log2(a[1]);
    a[2] = Math.log2(a[2]);
    a[3] = Math.log2(a[3]);
    stack.push(a);
}
function log10() {
    let a = stack.pop();
    a[0] = Math.log10(a[0]);
    a[1] = Math.log10(a[1]);
    a[2] = Math.log10(a[2]);
    a[3] = Math.log10(a[3]);
    stack.push(a);
}
function exp() {
    let a = stack.pop();
    a[0] = Math.exp(a[0]);
    a[1] = Math.exp(a[1]);
    a[2] = Math.exp(a[2]);
    a[3] = Math.exp(a[3]);
    stack.push(a);
}
function exp2() {
    let a = stack.pop();
    a[0] = 2 ** a[0];
    a[1] = 2 ** a[1];
    a[2] = 2 ** a[2];
    a[3] = 2 ** a[3];
    stack.push(a);
}
function sqrt() {
    let a = stack.pop();
    a[0] = Math.sqrt(a[0]);
    a[1] = Math.sqrt(a[1]);
    a[2] = Math.sqrt(a[2]);
    a[3] = Math.sqrt(a[3]);
    stack.push(a);
}
function rsqrt() {
    let a = stack.pop();
    a[0] = 1 / Math.sqrt(a[0]);
    a[1] = 1 / Math.sqrt(a[1]);
    a[2] = 1 / Math.sqrt(a[2]);
    a[3] = 1 / Math.sqrt(a[3]);
    stack.push(a);
}
function sign() {
    let a = stack.pop();
    a[0] = Math.sign(a[0]);
    a[1] = Math.sign(a[1]);
    a[2] = Math.sign(a[2]);
    a[3] = Math.sign(a[3]);
    stack.push(a);
}
function abs() {
    let a = stack.pop();
    a[0] = Math.abs(a[0]);
    a[1] = Math.abs(a[1]);
    a[2] = Math.abs(a[2]);
    a[3] = Math.abs(a[3]);
    stack.push(a);
}
function pow() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] ** a[0];
    a[1] = b[1] ** a[1];
    a[2] = b[2] ** a[2];
    a[3] = b[3] ** a[3];
    stack.push(a);
}
function step() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = b[0] >= a[0] ? 1 : 0;
    a[1] = b[1] >= a[1] ? 1 : 0;
    a[2] = b[2] >= a[2] ? 1 : 0;
    a[3] = b[3] >= a[3] ? 1 : 0;
    stack.push(a);
}
function _smoothstep(min, max, x) {
    x = clamp((x - min) / (max - min), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}
function smoothstep() {
    let x = stack.pop();
    let max = stack.pop();
    let min = stack.pop();
    x[0] = _smoothstep(min[0], max[0], x[0]);
    x[1] = _smoothstep(min[1], max[1], x[1]);
    x[2] = _smoothstep(min[2], max[2], x[2]);
    x[3] = _smoothstep(min[3], max[3], x[3]);
    stack.push(x);
}
function min() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = Math.min(b[0], a[0]);
    a[1] = Math.min(b[1], a[1]);
    a[2] = Math.min(b[2], a[2]);
    a[3] = Math.min(b[3], a[3]);
    stack.push(a);
}
function max() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = Math.max(b[0], a[0]);
    a[1] = Math.max(b[1], a[1]);
    a[2] = Math.max(b[2], a[2]);
    a[3] = Math.max(b[3], a[3]);
    stack.push(a);
}
function SrgbLinearToGamma() {
    let a = stack.pop();
    //saturate
    a[0] = Math.min(Math.max(a[0], 0), 1);
    a[1] = Math.min(Math.max(a[1], 0), 1);
    a[2] = Math.min(Math.max(a[2], 0), 1);
    a[3] = Math.min(Math.max(a[3], 0), 1);
    a[0] = (a[0] <= 0.0031308) ? (a[0] * 12.92) : (1.055 * Math.pow(a[0], (1.0 / 2.4))) - 0.055;
    a[1] = (a[1] <= 0.0031308) ? (a[1] * 12.92) : (1.055 * Math.pow(a[1], (1.0 / 2.4))) - 0.055;
    a[2] = (a[2] <= 0.0031308) ? (a[2] * 12.92) : (1.055 * Math.pow(a[2], (1.0 / 2.4))) - 0.055;
    a[3] = (a[3] <= 0.0031308) ? (a[3] * 12.92) : (1.055 * Math.pow(a[3], (1.0 / 2.4))) - 0.055;
    stack.push(a);
}
function SrgbGammaToLinear() {
    let a = stack.pop();
    //saturate
    a[0] = Math.min(Math.max(a[0], 0), 1);
    a[1] = Math.min(Math.max(a[1], 0), 1);
    a[2] = Math.min(Math.max(a[2], 0), 1);
    a[3] = Math.min(Math.max(a[3], 0), 1);
    a[0] = (a[0] <= 0.04045) ? (a[0] / 12.92) : (Math.pow((a[0] + 0.055) / 1.055, 2.4));
    a[1] = (a[1] <= 0.04045) ? (a[1] / 12.92) : (Math.pow((a[1] + 0.055) / 1.055, 2.4));
    a[2] = (a[2] <= 0.04045) ? (a[2] / 12.92) : (Math.pow((a[2] + 0.055) / 1.055, 2.4));
    a[3] = (a[3] <= 0.04045) ? (a[3] / 12.92) : (Math.pow((a[3] + 0.055) / 1.055, 2.4));
    stack.push(a);
}
function random() {
    let a = stack.pop();
    let b = stack.pop();
    a[0] = getRandomArbitrary(b[0], a[0]);
    a[1] = getRandomArbitrary(b[1], a[1]);
    a[2] = getRandomArbitrary(b[2], a[2]);
    a[3] = getRandomArbitrary(b[3], a[3]);
    stack.push(a);
}
function normalize() {
    let a = stack.pop();
    normalize$5(a, a);
    stack.push(a);
}
function length() {
    let a = stack.pop();
    a[0] = a[1] = a[2] = a[3] = Math.hypot(a[0], a[1], a[2]);
    stack.push(a);
}
function sqr() {
    let a = stack.pop();
    a[0] = a[0] * a[0];
    a[1] = a[1] * a[1];
    a[2] = a[2] * a[2];
    a[3] = a[3] * a[3];
    stack.push(a);
}

const Source2TextureLoader = new (function () {
    class Source2TextureLoader {
        constructor() {
        }
        load(repository, fileName) {
            let promise = new Promise((resolve, reject) => {
                fileName = fileName.replace(/.vtex_c/, '');
                let vtexPromise = new Source2FileLoader(true).load(repository, fileName + '.vtex_c');
                vtexPromise.then((source2File) => {
                    resolve(source2File);
                    /*if (texture) {
                        resolve(texture);
                    } else {
                        reject(source2File);
                    }*/
                }).catch((error) => {
                    reject(error);
                });
            });
            return promise;
        }
    }
    return Source2TextureLoader;
}());

class Source2TextureManagerClass extends EventTarget {
    #texturesList = new Map();
    #loadingTexturesList = new Map();
    #defaultTexture;
    WEBGL_compressed_texture_s3tc;
    EXT_texture_compression_bptc;
    EXT_texture_compression_rgtc;
    constructor() {
        super();
        new Graphics().ready.then(() => {
            this.#defaultTexture = TextureManager.createCheckerTexture([127, 190, 255]);
            this.#defaultTexture.addUser(this);
            //this._missingTexture = TextureManager.createCheckerTexture();
            this.WEBGL_compressed_texture_s3tc = new Graphics().getExtension('WEBGL_compressed_texture_s3tc');
            this.EXT_texture_compression_bptc = new Graphics().getExtension('EXT_texture_compression_bptc');
            this.EXT_texture_compression_rgtc = new Graphics().getExtension('EXT_texture_compression_rgtc');
        });
        setInterval(() => this.#cleanup(), TEXTURE_CLEANUP_DELAY);
    }
    async getTexture(repository, path, frame) {
        frame = Math.floor(frame);
        let texture = await this.#getTexture(repository, path);
        return texture ? texture.getFrame(frame) : this.#defaultTexture; //TODOv3
    }
    async getTextureSheet(repository, path) {
        let texture = await this.#getTexture(repository, path);
        return texture?.properties.get('vtex')?.getBlockByType('DATA')?.spriteSheet;
    }
    async #getTexture(repository, path) {
        path = path.replace(/.vtex_c$/, '').replace(/.vtex$/, '');
        path = path + '.vtex_c';
        let fullPath = repository + path;
        if (this.#loadingTexturesList.has(fullPath)) {
            await this.#loadingTexturesList.get(fullPath);
        }
        if (!this.#texturesList.has(fullPath)) {
            const animatedTexture = new AnimatedTexture();
            let promise = new Promise(async (resolve, reject) => {
                let vtex = await Source2TextureLoader.load(repository, path);
                animatedTexture.properties.set('vtex', vtex);
                let texture = TextureManager.createTexture(); //TODOv3: add params
                this.#initTexture(texture.texture, vtex);
                animatedTexture.addFrame(0, texture);
                resolve(animatedTexture);
            });
            this.#loadingTexturesList.set(fullPath, promise);
            await promise;
            this.setTexture(fullPath, animatedTexture);
            this.#loadingTexturesList.delete(fullPath);
        }
        return this.#texturesList.get(fullPath);
    }
    setTexture(path, texture) {
        this.#texturesList.set(path, texture);
    }
    #initTexture(texture, vtexFile /*TODO: improve type*/) {
        if (!texture || !vtexFile) {
            return;
        }
        var imageData = vtexFile.blocks.DATA.imageData;
        let imageFormat = vtexFile.imageFormat;
        if (imageData) {
            if (vtexFile.isCubeTexture()) {
                this.#initCubeTexture(texture, imageFormat, vtexFile.getWidth(), vtexFile.getHeight(), imageData);
            }
            else {
                this.#initFlatTexture(texture, imageFormat, vtexFile.getWidth(), vtexFile.getHeight(), imageData);
                /*if (imageFormat & TEXTURE_FORMAT_COMPRESSED_S3TC) {
                    this.fillTextureDxt(texture, vtexFile.getWidth(), vtexFile.getHeight(), vtexFile.getDxtLevel(), imageData[0]);
                } else {
                    this.fillTexture(texture, vtexFile.getWidth(), vtexFile.getHeight(), imageData[0]);
                }*/
            }
            //new Graphics().glContext.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    #initCubeTexture(texture, imageFormat, width, height, imageData) {
        const glContext = new Graphics().glContext;
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture);
        switch (true) {
            case (imageFormat & TEXTURE_FORMAT_UNCOMPRESSED) == TEXTURE_FORMAT_UNCOMPRESSED:
                this.fillTexture(imageFormat, width, height, imageData[0], GL_TEXTURE_CUBE_MAP_POSITIVE_X);
                this.fillTexture(imageFormat, width, height, imageData[1], GL_TEXTURE_CUBE_MAP_NEGATIVE_X);
                this.fillTexture(imageFormat, width, height, imageData[2], GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
                this.fillTexture(imageFormat, width, height, imageData[3], GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);
                this.fillTexture(imageFormat, width, height, imageData[4], GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
                this.fillTexture(imageFormat, width, height, imageData[5], GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
                break;
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_S3TC) == TEXTURE_FORMAT_COMPRESSED_S3TC:
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[0], GL_TEXTURE_CUBE_MAP_POSITIVE_X);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[1], GL_TEXTURE_CUBE_MAP_NEGATIVE_X);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[2], GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[3], GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[4], GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[5], GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
                break;
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_BPTC) == TEXTURE_FORMAT_COMPRESSED_BPTC:
                throw 'TODO';
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_RGTC) == TEXTURE_FORMAT_COMPRESSED_RGTC:
                throw 'TODO';
        }
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        //glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        //glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
    }
    #initFlatTexture(texture, imageFormat /*TODO create an imageformat enum*/, width, height, imageData) {
        const glContext = new Graphics().glContext;
        glContext.bindTexture(GL_TEXTURE_2D, texture);
        switch (true) {
            case (imageFormat & TEXTURE_FORMAT_UNCOMPRESSED) == TEXTURE_FORMAT_UNCOMPRESSED:
                this.fillTexture(imageFormat, width, height, imageData[0], GL_TEXTURE_2D);
                break;
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_S3TC) == TEXTURE_FORMAT_COMPRESSED_S3TC:
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[0], GL_TEXTURE_2D);
                break;
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_BPTC) == TEXTURE_FORMAT_COMPRESSED_BPTC:
                this.#fillTextureBptc(texture, width, height, imageData[0]);
                break;
            case (imageFormat & TEXTURE_FORMAT_COMPRESSED_RGTC) == TEXTURE_FORMAT_COMPRESSED_RGTC:
                this.#fillTextureRgtc(texture, width, height, imageData[0]);
                break;
        }
        //glContext.bindTexture(GL_TEXTURE_2D, texture);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.bindTexture(GL_TEXTURE_2D, null);
    }
    fillTexture(imageFormat, width, height, datas, target) {
        const gl = new Graphics().glContext;
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        switch (imageFormat) {
            case TEXTURE_FORMAT_UNCOMPRESSED_RGBA:
            case TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888:
                gl.texImage2D(target, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, datas); //TODO: params
                break;
            case TEXTURE_FORMAT_UNCOMPRESSED_R8:
                gl.texImage2D(target, 0, GL_R8, width, height, 0, GL_RED, GL_UNSIGNED_BYTE, datas); //TODO: params
                break;
        }
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    fillTextureDxt(texture, imageFormat, width, height, datas, target) {
        var gl = new Graphics().glContext;
        var s3tc = this.WEBGL_compressed_texture_s3tc; //gl.getExtension("WEBGL_compressed_texture_s3tc");//TODO: store it
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (s3tc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            var dxtFormat = 0;
            switch (imageFormat) {
                case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    break;
                case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
            }
            //gl.bindTexture(target, texture);
            gl.compressedTexImage2D(target, 0, dxtFormat, width, height, 0, datas);
        }
        else {
            /*gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            var dxtflag = dxtLevel == 1 ? (1 << 0) : (1 << 2);
            var uncompressedData = decompress(datas, width, height, dxtflag);
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData);//TODO: params*/
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            let uncompressedData = new Uint8Array(width * height * 4);
            Detex.decode(imageFormat, width, height, datas, uncompressedData).then(() => {
                // TODO: fix target in the 3 lines below
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #fillTextureBptc(texture, width, height, datas) {
        var gl = new Graphics().glContext;
        var bptc = this.EXT_texture_compression_bptc;
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.bindTexture(GL_TEXTURE_2D, texture);
        if (bptc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            var bptcFormat = bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT; //COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
            gl.compressedTexImage2D(GL_TEXTURE_2D, 0, bptcFormat, width, height, 0, datas);
        }
        else {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            let uncompressedData = new Uint8Array(width * height * 4);
            Detex.decodeBC7(width, height, datas, uncompressedData).then(() => {
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        new Graphics().getGLError('texParameteri');
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        new Graphics().getGLError('texParameteri');
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //gl.bindTexture(GL_TEXTURE_2D, null);
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #fillTextureRgtc(texture, width, height, datas) {
        var gl = new Graphics().glContext;
        var rgtc = this.EXT_texture_compression_rgtc;
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.bindTexture(GL_TEXTURE_2D, texture);
        if (rgtc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            var bptcFormat = rgtc.COMPRESSED_RED_RGTC1_EXT; //COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
            gl.compressedTexImage2D(GL_TEXTURE_2D, 0, bptcFormat, width, height, 0, datas);
        }
        else {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            let uncompressedData = new Uint8Array(width * height * 4);
            Detex.decodeBC4(width, height, datas, uncompressedData).then(() => {
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #cleanup() {
        for (const [texturePath, texture] of this.#texturesList) {
            if (texture.hasOnlyUser(this)) {
                texture.removeUser(this);
                this.#texturesList.delete(texturePath);
            }
        }
    }
}
const Source2TextureManager = new Source2TextureManagerClass();

const UNIFORMS = new Map([
    ['g_vColorTint', 'g_vColorTint'],
    ['g_vEmissiveColor', 'g_vEmissiveColor'],
    ['g_tColor', 'colorMap'],
    ['g_tAmbientOcclusion', 'g_tAmbientOcclusion'],
    ['g_tColorA', 'g_tColorA'],
    ['g_tColorB', 'g_tColorB'],
    ['g_tColorC', 'g_tColorC'],
    //['g_tDetail', 'detailMap'],
    //['g_tDetail2', 'detail2Map'],
    ['g_tMasks', 'g_tMasks'],
    ['g_tNormalA', 'g_tNormalA'],
    ['g_tEmissiveB', 'g_tEmissiveB'],
    ['g_tEmissiveC', 'g_tEmissiveC'],
    ['g_flDetailBlendFactor', 'g_flDetailBlendFactor'],
    ['g_flMaterialCloakFactor', 'g_flMaterialCloakFactor'],
]);
const TEXTURE_UNIFORMS = new Map([
    ['g_tColor', ['colorMap', 'USE_COLOR_MAP']],
    ['TextureColor', ['colorMap', 'USE_COLOR_MAP']],
    ['g_tNormal', ['normalMap', 'USE_NORMAL_MAP']],
    ['g_tAmbientOcclusion', ['aoMap', 'USE_AO_MAP']],
    ['g_tTintColor', ['tintColorMap', 'USE_TINT_COLOR_MAP']],
    ['g_tSelfIllumFlowWaveform', ['selfIllumFlowWaveformMap', 'USE_SIFW_MAP']],
    ['g_tMaskParameters', ['maskParametersMap', 'USE_MASK_PARAMETERS_MAP']], //TextureSelfIllumMask
    ['g_tColorA', ['colorAMap', 'USE_COLOR_A_MAP']],
    ['g_tColorB', ['colorBMap', 'USE_COLOR_B_MAP']],
    ['g_tColorC', ['colorCMap', 'USE_COLOR_C_MAP']],
    ['g_tColor1', ['color1Map', 'USE_COLOR_1_MAP']],
    ['g_tMask', ['maskMap', 'USE_MASK_MAP']],
    ['g_tNormalA', ['normalAMap', 'USE_NORMAL_A_MAP']],
    ['g_tEmissiveB', ['emissiveBMap', 'USE_EMISSIVE_B_MAP']],
    ['g_tEmissiveC', ['emissiveCMap', 'USE_EMISSIVE_C_MAP']],
    ['g_tMasks1', ['mask1Map', 'USE_MASK1_MAP']],
    ['g_tMasks2', ['mask2Map', 'USE_MASK2_MAP']],
    ['g_tDetail', ['detail1Map', 'USE_DETAIL1_MAP']],
    ['g_tDetail2', ['detail2Map', 'USE_DETAIL2_MAP']],
    ['g_tMetalness', ['metalnessMap', 'USE_METALNESS_MAP']],
    ['g_tDisplacementMask', ['displacementMaskMap', 'USE_DISPLACEMENT_MASK_MAP']],
    ['g_tSpecular', ['specularMap', 'USE_SPECULAR_MAP']],
    ['g_tSpiralNormal', ['spiralNormalMap', 'USE_SPIRAL_NORMAL_MAP']],
    ['g_tSpiralOverlay', ['spiralOverlayMap', 'USE_SPIRAL_OVERLAY_MAP']],
    ['g_tCubeMap', ['cubeMap', 'USE_CUBE_MAP']],
    ['g_tNormalRoughness', ['normalMap', 'USE_NORMAL_MAP']],
    ['g_tTintMaskEdgeMask', ['tintMaskEdgeMaskMap', 'USE_TINT_MASK_EDGE_MASK_MAP']],
    ['g_tSelfIllumMask', ['selfIllumMaskMap', 'USE_SELF_ILLUM_MASK_MAP']],
    //g_tAnimationTexture
]);
const DEFAULT_ALPHA_TEST_REFERENCE = 0.7;
class Source2Material extends Material {
    #source2File;
    repository;
    constructor(repository, source2File) {
        super();
        this.repository = repository;
        this.#source2File = source2File;
        //this.setupUniforms();
        this.setupUniformsOnce();
    }
    setupUniformsOnce() {
        //TODO: F_RENDER_BACKFACES
        //F_DO_NOT_CAST_SHADOWS
        //F_MASKS_1
        //
        //---- Specular ----
        //F_MASK_CUBE_MAP_BY_METALNESS 1
        //F_SPECULAR_CUBE_MAP 1
        /*

        0: {m_name: "F_RENDER_BACKFACES", _name: "MaterialParamInt_t", m_nValue: 1}
        1: {m_name: "F_USE_STATUS_EFFECTS_PROXY", _name: "MaterialParamInt_t", m_nValue: 1}
        2: {m_name: "F_MASKS_1", _name: "MaterialParamInt_t", m_nValue: 1}
        3: {m_name: "F_MASKS_2", _name: "MaterialParamInt_t", m_nValue: 1}
        4: {m_name: "F_MORPH_SUPPORTED", _name: "MaterialParamInt_t", m_nValue: 1}
        5: {m_name: "F_SEPARATE_ALPHA_TRANSFORM", _name: "MaterialParamInt_t", m_nValue: 1}
        6: {m_name: "F_SEPARATE_NORMAL_TRANSFORM", _name: "MaterialParamInt_t", m_nValue: 1}
        7: {m_name: "F_ALPHA_TEST", _name: "MaterialParamInt_t", m_nValue: 1}
        8: {m_name: "F_DIFFUSE_WARP", _name: "MaterialParamInt_t", m_nValue: 1}
        */
        if (this.getIntParam('F_RENDER_BACKFACES')) {
            this.renderFace(RenderFace.Both);
        }
        if (this.getIntParam('F_TRANSLUCENT')) {
            this.setBlending(MATERIAL_BLENDING_NORMAL);
            this.setDefine('IS_TRANSLUCENT');
        }
        if (this.getIntParam('F_MASKS_1')) {
            this.setDefine('USE_MASK1_MAP');
        }
        if (this.getIntParam('F_MASKS_2')) {
            this.setDefine('USE_MASK2_MAP');
        }
        if (this.getIntParam('F_ENABLE_CLOAK')) {
            this.setDefine('ENABLE_CLOAK');
        }
        if (this.getIntParam('F_ADDITIVE_BLEND')) {
            this.setBlending(MATERIAL_BLENDING_ADDITIVE);
            this.setDefine('IS_TRANSLUCENT');
        }
        if (this.getIntParam('F_ALPHA_TEST') == 1) {
            this.setDefine('ALPHA_TEST'); //TODOv3: set this automaticaly
            this.uniforms['uAlphaTestReference'] = this.getParam('g_flAlphaTestReference') ?? DEFAULT_ALPHA_TEST_REFERENCE;
        }
        if (this.getIntParam('F_SEPARATE_ALPHA_TRANSFORM')) {
            this.setDefine('USE_SEPARATE_ALPHA_TRANSFORM');
        }
        if (this.getIntParam('F_SEPARATE_NORMAL_TRANSFORM')) {
            this.setDefine('USE_SEPARATE_NORMAL_TRANSFORM');
        }
        let detailBlendMode = this.getIntParam('F_DETAIL');
        if (detailBlendMode !== null) {
            this.setDefine('DETAIL_BLEND_MODE', detailBlendMode);
        }
        else {
            this.removeDefine('DETAIL_BLEND_MODE');
        }
        if (this.getIntParam('F_SELF_ILLUM') == 1) {
            this.setDefine('F_SELF_ILLUM');
        }
        this.uniforms['g_vDetailTexCoordOffset'] = this.getVectorParam('g_vDetailTexCoordOffset');
        this.uniforms['g_vDetailTexCoordScale'] = this.getVectorParam('g_vDetailTexCoordScale');
        this.uniforms['g_vDetail1ColorTint'] = fromValues$3(1, 1, 1, 1);
        this.uniforms['g_vDetail2ColorTint'] = fromValues$3(1, 1, 1, 1);
        this.uniforms['g_vColorTint'] = fromValues$3(1, 1, 1, 0);
        this.initFloatUniforms();
        this.initVectorUniforms();
        this.initTextureUniforms();
        /*
        0: {m_name: "g_flDetailBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        1: {m_name: "g_flEnvMapBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        2: {m_name: "g_flMetalnessBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        3: {m_name: "g_flReflectionsTintByBaseBlendToNone", _name: "MaterialParamFloat_t", m_flValue: 0}
        4: {m_name: "g_flSelfIllumBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        5: {m_name: "g_flSpecularBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        6: {m_name: "g_flSpecularExponentBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        7: {m_name: "g_flCloakBlurAmount", _name: "MaterialParamFloat_t", m_flValue: 0.004999999888241291}
        8: {m_name: "g_flCloakIntensity", _name: "MaterialParamFloat_t", m_flValue: 0.8500000238418579}
        9: {m_name: "g_flCloakRefractAmount", _name: "MaterialParamFloat_t", m_flValue: 0.10000000149011612}
        10: {m_name: "g_flMaterialCloakFactor", _name: "MaterialParamFloat_t", m_flValue: 0}
        11: {m_name: "g_flDiffuseModulationAmount", _name: "MaterialParamFloat_t", m_flValue: 1}
        12: {m_name: "g_flTexCoordRotation", _name: "MaterialParamFloat_t", m_flValue: 0}
        13: {m_name: "g_flDetailBlendFactor", _name: "MaterialParamFloat_t", m_flValue: 1}
        14: {m_name: "g_flDetailTexCoordRotation", _name: "MaterialParamFloat_t", m_flValue: 0}
        15: {m_name: "g_flDetail2BlendFactor", _name: "MaterialParamFloat_t", m_flValue: 0}
        16: {m_name: "g_flFresnelModulatesAlpha", _name: "MaterialParamFloat_t", m_flValue: 0}
        17: {m_name: "g_flAmbientScale", _name: "MaterialParamFloat_t", m_flValue: 1}
        18: {m_name: "g_flBloomScale", _name: "MaterialParamFloat_t", m_flValue: 0}
        19: {m_name: "g_flBloomShift", _name: "MaterialParamFloat_t", m_flValue: 0}
        20: {m_name: "g_flRimLightScale", _name: "MaterialParamFloat_t", m_flValue: 5}
        21: {m_name: "g_flCubeMapScalar", _name: "MaterialParamFloat_t", m_flValue: 5}
        22: {m_name: "g_flSpecularExponent", _name: "MaterialParamFloat_t", m_flValue: 15}
        23: {m_name: "g_flSpecularScale", _name: "MaterialParamFloat_t", m_flValue: 5}
        24: {m_name: "g_flAlphaTestReference", _name: "MaterialParamFloat_t", m_flValue: 0.5}
        */
    }
    setupUniforms() {
        for (let [paramName, uniformName] of UNIFORMS) {
            //console.error(uniformName);
            let paramValue = this.getParam(paramName);
            if (paramValue) {
                this.setUniform(uniformName, paramValue);
            }
        }
    }
    clone() {
        return new this.constructor(this.repository, this.#source2File);
    }
    getTextureByName(textureName) {
        if (this.#source2File) {
            var textures = this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_textureParams') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_textureParams');
            if (textures) {
                for (var textureIndex = 0; textureIndex < textures.length; textureIndex++) {
                    var texture = textures[textureIndex];
                    if (texture.m_name == textureName) {
                        return texture.m_pValue;
                    }
                }
            }
        }
        return null;
    }
    updateMaterial(time, mesh) {
        this.processProxies(time, mesh.materialsParams);
    }
    processProxies(time, proxyParams) {
        //todov3//rename function
        /*let proxies = this.proxies;
        for (let proxyIndex = 0, l = proxies.length; proxyIndex < l; ++proxyIndex) {
            proxies[proxyIndex].execute(this.variables, this.proxyParams, time);
        }*/
        this._afterProcessProxies(proxyParams);
        this.afterProcessProxies(proxyParams);
    }
    _afterProcessProxies(proxyParams) {
        //this.setupUniforms();
        this.initTextureUniforms(); //TODO : do this only once
        /*
                let g_tMasks1 = this.getTextureByName('g_tMasks1');
                if (g_tMasks1) {
                    this.uniforms['mask1Map'] = Source2TextureManager.getTexture(this.repository, g_tMasks1, 0);//TODOv3: rename uniform
                }

                let g_tMasks2 = this.getTextureByName('g_tMasks2');
                if (g_tMasks2) {
                    this.uniforms['mask2Map'] = Source2TextureManager.getTexture(this.repository, g_tMasks2, 0);//TODOv3: rename uniform
                }

                let g_tDetail = this.getTextureByName('g_tDetail');
                if (g_tDetail) {
                    this.uniforms['detail1Map'] = Source2TextureManager.getTexture(this.repository, g_tDetail, 0);//TODOv3: rename uniform
                    this.setDefine('USE_DETAIL1_MAP');//TODOv3: set this automaticaly
                } else {
                    //this.uniforms['detail1Map'] = TextureManager.createCheckerTexture();
                    this.setDefine('USE_DETAIL1_MAP', false);//TODOv3: set this automaticaly
                }

                let g_tDetail2 = this.getTextureByName('g_tDetail2');
                if (g_tDetail2) {
                    this.uniforms['detail2Map'] = Source2TextureManager.getTexture(this.repository, g_tDetail2, 0);//TODOv3: rename uniform
                    this.setDefine('USE_DETAIL2_MAP');//TODOv3: set this automaticaly
                } else {
                    this.setDefine('USE_DETAIL2_MAP', false);//TODOv3: set this automaticaly
                }*/
        //TODO: only do what is in m_dynamicParams
        this.setDynamicUniform('g_vDetailTexCoordOffset');
        this.setDynamicUniform('g_vDetailTexCoordScale');
        this.setDynamicUniform('g_vAlphaTexCoordOffset');
        this.setDynamicUniform('g_flDetailBlendFactor');
        this.setDynamicUniform('g_flDetailTexCoordRotation');
        this.setDynamicUniform('g_vDetail1ColorTint');
        this.setDynamicUniform('g_vSpecularColor');
        //this.setDynamicUniform('g_vNormalTexCoordOffset');
    }
    setDynamicUniform(uniformName) {
        let value = this.getDynamicParam(uniformName);
        if (value) {
            if (uniformName.startsWith('g_fl')) {
                this.uniforms[uniformName] = value[0];
            }
            else {
                this.uniforms[uniformName] = value;
            }
        }
    }
    afterProcessProxies(proxyParams) {
    }
    setUniform(uniformName, uniformValue) {
        this.uniforms[uniformName] = uniformValue;
    }
    initFloatUniforms() {
        if (this.#source2File) {
            var floats = this.#source2File.getMaterialResourceData('m_floatParams');
            if (floats) {
                for (let fl of floats) {
                    this.setUniform(fl.m_name, fl.m_flValue);
                }
            }
        }
    }
    initVectorUniforms() {
        if (this.#source2File) {
            var vectors = this.#source2File.getMaterialResourceData('m_vectorParams');
            if (vectors) {
                for (let vector of vectors) {
                    this.setUniform(vector.m_name, vector.m_value);
                }
            }
        }
    }
    getUniforms() {
        return [UNIFORMS];
    }
    getTextureUniforms() {
        return [TEXTURE_UNIFORMS];
    }
    async initTextureUniforms() {
        for (const map of this.getTextureUniforms()) {
            for (let [paramName, [uniformName, defineName]] of map) {
                let paramValue = this.getTextureByName(paramName);
                if (paramValue) {
                    this.setTexture(uniformName, paramValue ? await Source2TextureManager.getTexture(this.repository, paramValue, 0) : null, defineName);
                }
            }
        }
    }
    getParam(paramName) {
        if (paramName.startsWith('g_f')) {
            return this.getFloatParam(paramName);
        }
        else if (paramName.startsWith('g_v')) {
            return this.getVectorParam(paramName);
        }
        else if (paramName.startsWith('g_n')) {
            return this.getIntParam(paramName);
        } /* else if (paramName.startsWith('g_t')) {
            let textureName = this.getTextureByName(paramName);
            if (textureName) {
                return Source2TextureManager.getTexture(this.repository, textureName, 0);
            } else {
                return null;//TODO: disable texture;
            }
        }*/
        console.error(`unknown parameter : ${paramName}`, this);
    }
    getIntParam(intName) {
        if (this.#source2File) {
            var ints = this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_intParams') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_intParams');
            if (ints) {
                for (var intIndex = 0; intIndex < ints.length; intIndex++) {
                    var fl = ints[intIndex];
                    if (fl.m_name == intName) {
                        return fl.m_nValue;
                    }
                }
            }
        }
        return null;
    }
    getFloatParam(floatName) {
        if (this.#source2File) {
            var floats = this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_floatParams') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_floatParams');
            if (floats) {
                for (var floatIndex = 0; floatIndex < floats.length; floatIndex++) {
                    var fl = floats[floatIndex];
                    if (fl.m_name == floatName) {
                        return fl.m_flValue;
                    }
                }
            }
        }
        return null;
    }
    getVectorParam(vectorName) {
        if (this.#source2File) {
            var vectors = this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_vectorParams') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_vectorParams');
            if (vectors) {
                for (var vectorIndex = 0; vectorIndex < vectors.length; vectorIndex++) {
                    var vector = vectors[vectorIndex];
                    if (vector.m_name == vectorName) {
                        return vector.m_value;
                    }
                }
            }
        }
        return create$3();
    }
    getDynamicParam(dynamicName) {
        if (this.#source2File) {
            var dynamicParams = this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_dynamicParams') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_dynamicParams');
            if (dynamicParams) {
                for (var dynamicIndex = 0; dynamicIndex < dynamicParams.length; dynamicIndex++) {
                    var dynamicParam = dynamicParams[dynamicIndex];
                    if (dynamicParam.m_name == dynamicName) {
                        return executeDynamicExpression(dynamicParam.m_value, this.#source2File.getBlockStruct('DATA.structs.MaterialResourceData_t.m_renderAttributesUsed') || this.#source2File.getBlockStruct('DATA.keyValue.root.m_renderAttributesUsed'));
                    }
                }
            }
        }
        return null;
    }
}

class Source2CsgoCharacter extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_character.vfx', Source2CsgoCharacter);

class Source2CsgoComplex extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_complex.vfx', Source2CsgoComplex);

class Source2CsgoEffects extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_effects.vfx', Source2CsgoEffects);

class Source2CsgoEnvironmentBlend extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('csgo_environment_blend.vfx', Source2CsgoEnvironmentBlend);

class Source2CsgoEnvironment extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('csgo_environment.vfx', Source2CsgoEnvironment);

class Source2CsgoFoliage extends Source2Material {
    get shaderSource() {
        return 'source2_vr_xen_foliage'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_foliage.vfx', Source2CsgoFoliage);

class Source2CsgoGlass extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_glass.vfx', Source2CsgoGlass);

class Source2CsgoSimple extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_simple.vfx', Source2CsgoSimple);

class Source2CsgoStaticOverlay extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_static_overlay.vfx', Source2CsgoStaticOverlay);

class Source2CsgoUnlitGeneric extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_unlitgeneric.vfx', Source2CsgoUnlitGeneric);

class Source2CsgoVertexLitGeneric extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_vertexlitgeneric.vfx', Source2CsgoVertexLitGeneric);

class Source2CsgoWeaponStattrak extends Source2Material {
    _afterProcessProxies(proxyParams) {
        //Proxy param: $ent_stattrak
        super._afterProcessProxies(proxyParams);
        this.setDynamicUniform('g_nStatTrakValue');
    }
    get shaderSource() {
        return 'source2_csgo_weapon_stattrak';
    }
}
Source2MaterialLoader.registerMaterial('csgo_weapon_stattrak.vfx', Source2CsgoWeaponStattrak);

const STICKER_COUNT = 5;
class Source2CsgoWeapon extends Source2Material {
    setupUniformsOnce() {
        super.setupUniformsOnce();
        if (this.getIntParam('F_STICKERS')) {
            this.setDefine('ENABLE_STICKERS');
        }
        for (let i = 0; i < STICKER_COUNT; i++) {
            //if (this.getIntParam(`g_bEnableSticker${i}`)) {
            this.setDefine(`ENABLE_STICKER${i}`);
            //}
        }
    }
    getUniforms() {
        const uniforms = super.getUniforms();
        const m = new Map();
        for (let i = 0; i < STICKER_COUNT; i++) {
            m.set(`g_flSticker${i}Rotation`, `g_flSticker${i}Rotation`);
            m.set(`g_flSticker${i}Wear`, `g_flSticker${i}Wear`);
            m.set(`g_fWearScratchesSticker${i}`, `g_fWearScratchesSticker${i}`);
            m.set(`g_vSticker${i}Offset`, `g_vSticker${i}Offset`);
            m.set(`g_vSticker${i}Scale`, `g_vSticker${i}Scale`);
            m.set(`g_vWearBiasSticker${i}`, `g_vWearBiasSticker${i}`);
        }
        uniforms.push(m);
        return uniforms;
    }
    getTextureUniforms() {
        const uniforms = super.getTextureUniforms();
        const m = new Map();
        for (let i = 0; i < STICKER_COUNT; i++) {
            m.set(`g_tHoloSpectrumSticker${i}`, [`holoSpectrumSticker${i}Map`, `USE_HOLO_SPECTRUM_STICKER${i}_MAP`]);
            m.set(`g_tNormalRoughnessSticker${i}`, [`normalRoughnessSticker${i}Map`, `USE_NORMAL_ROUGHNESS_STICKER${i}_MAP`]);
            m.set(`g_tSfxMaskSticker${i}`, [`sfxMaskSticker${i}Map`, `USE_SFX_MASK_STICKER${i}_MAP`]);
            m.set(`g_tSticker${i}`, [`sticker${i}Map`, `USE_STICKER${i}_MAP`]);
        }
        m.set('g_tStickerWepInputs', [`stickerWepInputsMap`, `USE_STICKER_WEP_INPUT_MAP`]);
        uniforms.push(m);
        return uniforms;
    }
    get shaderSource() {
        return 'source2_csgo_weapon';
    }
}
Source2MaterialLoader.registerMaterial('csgo_weapon.vfx', Source2CsgoWeapon);
/*
{
    "m_materialName": "materials/models/weapons/v_models/rif_ak47/ak47.vmat",
    "m_shaderName": "csgo_weapon.vfx",
    "m_intParams": [
        {
            "m_name": "F_STICKERS",
            "m_nValue": 1
        },
        {
            "m_name": "g_bEnableSticker0",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker1",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker2",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker3",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker4",
            "m_nValue": 0
        },
        {
            "m_name": "g_bFogEnabled",
            "m_nValue": 1
        },
        {
            "m_name": "g_nScaleTexCoordUByModelScaleAxis",
            "m_nValue": 0
        },
        {
            "m_name": "g_nScaleTexCoordVByModelScaleAxis",
            "m_nValue": 0
        },
        {
            "m_name": "g_nTextureAddressModeU",
            "m_nValue": 0
        },
        {
            "m_name": "g_nTextureAddressModeV",
            "m_nValue": 0
        }
    ],
    "m_floatParams": [
        {
            "m_name": "g_flMetalnessTransitionBias",
            "m_flValue": 2
        },
        {
            "m_name": "g_flModelTintAmount",
            "m_flValue": 1
        },
        {
            "m_name": "g_flSticker0Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker0Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker1Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker1Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker2Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker2Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker3Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker3Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker4Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker4Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flTexCoordRotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_fWearScratchesSticker0",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker1",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker2",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker3",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker4",
            "m_flValue": 1
        }
    ],
    "m_vectorParams": [
        {
            "m_name": "g_vColorTint",
            "m_value": [
                1,
                1,
                1,
                0
            ]
        },
        {
            "m_name": "g_vMetalnessRemapRange",
            "m_value": [
                0,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker0Offset",
            "m_value": [
                0.15399999916553497,
                -0.43799999356269836,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker0Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker1Offset",
            "m_value": [
                0.06499999761581421,
                -0.4320000112056732,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker1Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker2Offset",
            "m_value": [
                -0.03200000151991844,
                -0.43799999356269836,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker2Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker3Offset",
            "m_value": [
                -0.164000004529953,
                -0.4440000057220459,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker3Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker4Offset",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker4Scale",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordCenter",
            "m_value": [
                0.5,
                0.5,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordOffset",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordScale",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordScrollSpeed",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker0",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker1",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker2",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker3",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker4",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        }
    ],
    "m_textureParams": [
        {
            "m_name": "g_tAmbientOcclusion",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_ao_psd_286fb1af.vtex"
        },
        {
            "m_name": "g_tColor",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_color_psd_1f318532.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker0",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker1",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker2",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker3",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker4",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tMetalness",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_rough_psd_73589151.vtex"
        },
        {
            "m_name": "g_tNormal",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_normal_psd_57f37ac9.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker0",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker1",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker2",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker3",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker4",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker0",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker1",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker2",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker3",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker4",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSticker0",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker1",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker2",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker3",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker4",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tStickerGlitterNormal",
            "m_pValue": "materials/default/stickers/squares_glitter_normal_tga_25145674.vtex"
        },
        {
            "m_name": "g_tStickerScratches",
            "m_pValue": "materials/default/stickers/sticker_default_scratches_psd_a9ad199b.vtex"
        },
        {
            "m_name": "g_tStickerWepInputs",
            "m_pValue": "weapons/models/ak47/materials/stickers/weapon_rif_ak47_sticker_mask_legacy_tga_1bdb00a.vtex"
        }
    ],
    "m_dynamicParams": [],
    "m_dynamicTextureParams": [],
    "m_intAttributes": [],
    "m_floatAttributes": [],
    "m_vectorAttributes": [],
    "m_textureAttributes": [],
    "m_stringAttributes": [
        {
            "m_name": "composite_inputs",
            "m_value": "materials/models/weapons/customization/rif_ak47/rif_ak47_composite_inputs.vmat"
        },
        {
            "m_name": "PreviewModel",
            "m_value": "weapons/models/ak47/weapon_rif_ak47.vmdl"
        }
    ],
    "m_renderAttributesUsed": []
}
*/

class Source2VrBlackUnlit extends Source2Material {
    get shaderSource() {
        return 'source2_vr_black_unlit';
    }
}
Source2MaterialLoader.registerMaterial('vr_black_unlit.vfx', Source2VrBlackUnlit);

class Source2VrComplex extends Source2Material {
    get shaderSource() {
        return 'source2_vr_complex';
    }
}
Source2MaterialLoader.registerMaterial('vr_complex.vfx', Source2VrComplex);

class Source2VrEyeball extends Source2Material {
    get shaderSource() {
        return 'source2_vr_eyeball';
    }
}
Source2MaterialLoader.registerMaterial('vr_eyeball.vfx', Source2VrEyeball);

class Source2VrGlass extends Source2Material {
    get shaderSource() {
        return 'source2_vr_glass';
    }
}
Source2MaterialLoader.registerMaterial('vr_glass.vfx', Source2VrGlass);

class Source2VrMonitor extends Source2Material {
    get shaderSource() {
        return 'source2_vr_monitor';
    }
}
Source2MaterialLoader.registerMaterial('vr_monitor.vfx', Source2VrMonitor);

class Source2VrSimple extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple.vfx', Source2VrSimple);
Source2MaterialLoader.registerMaterial('vr_simple_2layer_parallax.vfx', Source2VrSimple); //TODO : create own material

class Source2VrSimple2WayBlend extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple_2way_blend';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple_2way_blend.vfx', Source2VrSimple2WayBlend);

class Source2VrSimple3LayerParallax extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple_3layer_parallax';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple_3layer_parallax.vfx', Source2VrSimple3LayerParallax);
/*

m_textureParams: Array(7)
0: {m_name: "g_tNormalA", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_normal_psd_fd9ddafa.vtex"}
1: {m_name: "g_tColorC", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multitool_screen_r_vmat_g_tcolorc_79c08dd3.vtex"}
2: {m_name: "g_tColorB", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multitool_screen_r_vmat_g_tcolorb_9bba1794.vtex"}
3: {m_name: "g_tEmissiveB", _name: "MaterialParamTexture_t", m_pValue: "materials/default/default_tga_449484c6.vtex"}
4: {m_name: "g_tEmissiveC", _name: "MaterialParamTexture_t", m_pValue: "materials/default/default_tga_449484c6.vtex"}
5: {m_name: "g_tMasks", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_mask_psd_255bc5b7.vtex"}
6: {m_name: "g_tColorA", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_color_psd_4f0a4fd7.vtex"}
*/

class Source2VrSkin extends Source2Material {
    get shaderSource() {
        return 'source2_vr_skin';
    }
}
Source2MaterialLoader.registerMaterial('vr_skin.vfx', Source2VrSkin);

class Source2VrXenFoliage extends Source2Material {
    get shaderSource() {
        return 'source2_vr_xen_foliage';
    }
}
Source2MaterialLoader.registerMaterial('vr_xen_foliage.vfx', Source2VrXenFoliage);

class Source2Crystal extends Source2Material {
    setupUniformsOnce() {
        super.setupUniformsOnce();
        this.setBlending(MATERIAL_BLENDING_ADDITIVE);
        this.setDefine('IS_TRANSLUCENT');
    }
    getShaderSource() {
        return 'source2_crystal';
    }
}
Source2MaterialLoader.registerMaterial('crystal.vfx', Source2Crystal);

class Source2EnvironmentBlend extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('environment_blend.vfx', Source2EnvironmentBlend);
Source2MaterialLoader.registerMaterial('environment_layer.vfx', Source2EnvironmentBlend); //TODO: proper material

class Source2Error extends Source2Material {
    constructor(repository, source2File) {
        super(repository, source2File);
        this.renderFace(RenderFace.Both);
    }
    get shaderSource() {
        return 'source2_error';
    }
}
Source2MaterialLoader.registerMaterial('error.vfx', Source2Error);

class Source2Generic extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('generic.vfx', Source2Generic);

class Source2Pbr extends Source2Material {
    get shaderSource() {
        return 'source2_pbr';
    }
}
Source2MaterialLoader.registerMaterial('pbr.vfx', Source2Pbr);

class Source2GlobalLitSimple extends Source2Material {
    getShaderSource() {
        return 'source2_global_lit_simple';
    }
}
Source2MaterialLoader.registerMaterial('global_lit_simple.vfx', Source2GlobalLitSimple);

class Source2Hero extends Source2Material {
    get shaderSource() {
        return 'source2_hero';
    }
}
Source2MaterialLoader.registerMaterial('hero.vfx', Source2Hero);

class Source2HeroFluid extends Source2Material {
    get shaderSource() {
        return 'source2_hero_fluid';
    }
}
Source2MaterialLoader.registerMaterial('hero_fluid.vfx', Source2HeroFluid);

class Source2SpringMeteor extends Source2Material {
    get shaderSource() {
        return 'source2_spring_meteor';
    }
}
Source2MaterialLoader.registerMaterial('spring_meteor.vfx', Source2SpringMeteor);

class Source2SpriteCard extends Source2Material {
    #texturePath = '';
    constructor(repository, source2File) {
        super(repository, source2File);
        //TODO: we should adapt transparency depending on particle renderer params ?
        this.setTransparency(GL_SRC_ALPHA, GL_DST_ALPHA);
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        this.setTransparency(GL_SRC_ALPHA, GL_ONE);
        this.renderFace(RenderFace.Both);
        this.setUniform('uFinalTextureScale', fromValues(1, 1));
        this.setUniform('uColorScale', fromValues$4(1, 1, 1));
        //this.setTransparency( GL_SRC_ALPHA, GL_ONE);
        this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    }
    setOutputBlendMode(outputBlendMode) {
        switch (outputBlendMode) {
            case 0:
                this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                break;
            case 1: //PARTICLE_OUTPUT_BLEND_MODE_ADD
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 2: //PARTICLE_OUTPUT_BLEND_MODE_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 3: //PARTICLE_OUTPUT_BLEND_MODE_HALF_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 4: //PARTICLE_OUTPUT_BLEND_MODE_NEG_HALF_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 5: //PARTICLE_OUTPUT_BLEND_MODE_MOD2X
                this.setTransparency(GL_SRC_ALPHA, GL_DST_ALPHA);
                break;
            case 5: //PARTICLE_OUTPUT_BLEND_MODE_LIGHTEN //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
        }
    }
    async setTexturePath(texturePath) {
        this.#texturePath = texturePath;
    }
    async initTextureUniforms() {
        await super.initTextureUniforms();
        if (this.#texturePath) {
            this.setTexture('colorMap', await Source2TextureManager.getTexture(this.repository, this.#texturePath, 0), 'USE_COLOR_MAP');
        }
    }
    getFrameSpan(sequence) {
        console.error('code me');
        return 0;
    }
    getShaderSource() {
        return 'source2_spritecard';
    }
}
Source2MaterialLoader.registerMaterial('spritecard.vfx', Source2SpriteCard);

class Source2UI extends Source2Material {
    get shaderSource() {
        return 'source2_ui';
    }
}
Source2MaterialLoader.registerMaterial('ui.vfx', Source2UI);

class Source2Unlit extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('unlit.vfx', Source2Unlit);

const COLOR_SCALE = 1 / 255;
function vec4Scale(out, a, b) {
    out[0] = Number(a[0]) * b;
    out[1] = Number(a[1]) * b;
    out[2] = Number(a[2]) * b;
    out[3] = Number(a[3]) * b;
    return out;
}
function vec4Lerp(out, a, b, t) {
    let ax = Number(a[0]);
    let ay = Number(a[1]);
    let az = Number(a[2]);
    let aw = Number(a[3]);
    out[0] = ax + t * (Number(b[0]) - ax);
    out[1] = ay + t * (Number(b[1]) - ay);
    out[2] = az + t * (Number(b[2]) - az);
    out[3] = aw + t * (Number(b[3]) - aw);
    return out;
}
class Operator {
    static PVEC_TYPE_PARTICLE_VECTOR = false;
    #parameters = {};
    system;
    opStartFadeInTime = 0;
    opEndFadeInTime = 0;
    opStartFadeOutTime = 0;
    opEndFadeOutTime = 0;
    opFadeOscillatePeriod = 0;
    normalizePerLiving = false;
    disableOperator = false;
    controlPointNumber = 0;
    fieldInput = -1;
    fieldOutput = -1;
    scaleCp;
    mesh;
    material;
    endCapState;
    currentTime = 0;
    constructor(system) {
        this.system = system;
    }
    setParam(paramName, value) {
        if (value instanceof Kv3Array) {
            let arr = [];
            for (let v of value.properties) {
                if (typeof v == 'bigint') {
                    arr.push(Number(v));
                }
                else {
                    arr.push(v);
                }
            }
            this.#parameters[paramName] = arr;
        }
        else {
            if (typeof value == 'bigint') {
                this.#parameters[paramName] = Number(value);
            }
            else {
                this.#parameters[paramName] = value;
            }
        }
        this._paramChanged(paramName, value);
    }
    getParam(paramName) {
        return this.#parameters[paramName];
    }
    getParamScalarValue(paramName, particle) {
        let parameter = this.#parameters[paramName];
        return this.#getParamScalarValue(parameter, particle);
    }
    #getParamScalarValue(parameter, particle) {
        if (parameter) {
            let inputValue;
            let type = parameter.m_nType;
            if (type) {
                switch (type) {
                    case 'PF_TYPE_LITERAL':
                        return parameter.m_flLiteralValue;
                    case 'PF_TYPE_PARTICLE_AGE':
                        return parameter.m_vLiteralValue;
                    case 'PF_TYPE_PARTICLE_NUMBER_NORMALIZED':
                        if (this.normalizePerLiving) {
                            let max = this.system.livingParticles.length;
                            inputValue = (particle?.id ?? 0) % max / max;
                        }
                        else {
                            inputValue = (particle?.id ?? 0) / this.system.maxParticles;
                        }
                        return this.#getParamScalarValue2(parameter, inputValue);
                    case 'PF_TYPE_PARTICLE_NUMBER':
                        inputValue = particle?.id ?? 0;
                        return this.#getParamScalarValue2(parameter, inputValue);
                    case 'PF_TYPE_PARTICLE_AGE_NORMALIZED':
                        return this.#getParamScalarValue2(parameter, particle?.proportionOfLife ?? 0);
                    case 'PF_TYPE_RANDOM_BIASED':
                        //TODO: use parameter.m_nBiasType
                        return RemapValClampedBias(Math.random(), 0, 1, parameter.m_flRandomMin, parameter.m_flRandomMax, 0.5 /*parameter.m_flBiasParameter*/); //TODO: use another bias function bias varies from -1 to 1
                    case 'PF_TYPE_RANDOM_UNIFORM':
                        return RandomFloat(parameter.m_flRandomMin, parameter.m_flRandomMax);
                    case 'PF_TYPE_COLLECTION_AGE':
                        return this.#getParamScalarValue2(parameter, this.system.currentTime);
                    case 'PF_TYPE_PARTICLE_NOISE':
                        return this.#getParamScalarValue2(parameter, RandomFloat(parameter.m_flNoiseOutputMin, parameter.m_flNoiseOutputMax)); //TODO
                    case 'PF_TYPE_CONTROL_POINT_COMPONENT':
                        let cp = this.system.getControlPoint(parameter.m_nControlPoint);
                        if (cp) {
                            return cp.position[parameter.m_nVectorComponent];
                        }
                        return 0;
                    case 'PF_TYPE_PARTICLE_FLOAT':
                        return inputValue = RemapValClamped(particle?.getField(parameter.m_nScalarAttribute ?? 0) ?? 0, parameter.m_flInput0 ?? 0, parameter.m_flInput1 ?? 1, parameter.m_flOutput0 ?? 0, parameter.m_flOutput1 ?? 1);
                    default:
                        console.error('#getParamScalarValue unknown type', parameter);
                        throw 'Code me';
                }
            }
            else {
                return parameter;
            }
        }
    }
    #getParamScalarValue2(parameter /*TODO: improve type*/, inputValue) {
        let mapType = parameter.m_nMapType;
        switch (mapType) {
            case 'PF_MAP_TYPE_DIRECT':
                return inputValue;
            case 'PF_MAP_TYPE_CURVE':
                return this.#getParamScalarValueCurve(parameter, inputValue);
            case 'PF_MAP_TYPE_MULT':
                return inputValue * parameter.m_flMultFactor;
            case 'PF_MAP_TYPE_REMAP':
                return inputValue; //TODO
            default:
                console.error('Unknown map type : ', mapType, parameter);
                return 0;
        }
    }
    #getParamScalarValueCurve(parameter /*TODO: improve type*/, inputValue) {
        let curve = parameter.m_Curve /*TODO: improve type*/;
        let inputMin = curve.m_vDomainMins[0];
        let inputMax = curve.m_vDomainMaxs[0];
        curve.m_vDomainMins[1];
        curve.m_vDomainMaxs[1];
        parameter.m_nInputMode;
        //let modeClamped = parameter.m_nInputMode == "PF_INPUT_MODE_CLAMPED" ? true : false;
        if (parameter.m_nInputMode == 'PF_INPUT_MODE_CLAMPED') {
            inputValue = clamp(inputValue, inputMin, inputMax);
        }
        else {
            //"PF_INPUT_MODE_LOOPED"
            //Note : the loop goes from 0 to inputMax, not inputMin to inputMax
            inputValue = inputMax !== 0 ? inputValue % inputMax : inputMin;
        }
        return this.#getCurveValue(curve, inputValue);
    }
    #getCurveValue(curve /*TODO: improve type*/, x) {
        //TODO: do a real curve
        let spline = curve.m_spline;
        let previousKey = spline[0];
        let key = previousKey;
        if (x < previousKey.x) {
            return previousKey.y;
        }
        let index = 0;
        while (key = spline[++index]) {
            if (x < key.x) {
                return lerp(previousKey.y, key.y, (x - previousKey.x) / (key.x - previousKey.x));
            }
            previousKey = key;
        }
        return previousKey.y;
        //export function lerp(min, max, v) {
    }
    getParamVectorValue(paramName, particle, outVec = create$3()) {
        let parameter = this.#parameters[paramName];
        if (parameter) {
            let type = parameter.m_nType;
            if (type) {
                switch (type) {
                    case 'PVEC_TYPE_LITERAL':
                        return parameter.m_vLiteralValue;
                    case 'PVEC_TYPE_PARTICLE_VECTOR':
                        if (!Operator.PVEC_TYPE_PARTICLE_VECTOR) {
                            Operator.PVEC_TYPE_PARTICLE_VECTOR = true;
                            throw 'Code me';
                        }
                        break;
                    case 'PVEC_TYPE_FLOAT_INTERP_GRADIENT':
                        return this.#getParamVectorValueFloatInterpGradient(parameter, particle, outVec);
                    case 'PVEC_TYPE_FLOAT_COMPONENTS':
                        outVec[0] = this.#getParamScalarValue(parameter.m_FloatComponentX, particle);
                        outVec[1] = this.#getParamScalarValue(parameter.m_FloatComponentY, particle);
                        outVec[2] = this.#getParamScalarValue(parameter.m_FloatComponentZ, particle);
                        break;
                    case 'PVEC_TYPE_RANDOM_UNIFORM_OFFSET':
                        vec3RandomBox(outVec, parameter.m_vRandomMin, parameter.m_vRandomMax);
                        break;
                    case 'PVEC_TYPE_CP_VALUE':
                        const cp = this.system.getControlPoint(parameter.m_nControlPoint);
                        if (cp) {
                            copy$4(outVec, cp.currentWorldPosition);
                            if (parameter.m_vCPValueScale) {
                                mul$4(outVec, outVec, parameter.m_vCPValueScale);
                            }
                        }
                        break;
                    case 'PVEC_TYPE_RANDOM_UNIFORM':
                        //TODO
                        break;
                    default:
                        console.error('getParamVectorValue unknown type', parameter);
                        throw 'Code me';
                }
            }
            else {
                return parameter;
            }
        }
    }
    #getParamVectorValueFloatInterpGradient(parameter /*TODO: improve type*/, particle, outVec) {
        let interpInput0 = parameter.m_flInterpInput0;
        let interpInput1 = parameter.m_flInterpInput1;
        let inputValue = this.#getParamScalarValue(parameter.m_FloatInterp, particle);
        inputValue = RemapValClamped(inputValue, interpInput0, interpInput1, 0.0, 1.0);
        let stops = parameter.m_Gradient?.m_Stops;
        if (stops) {
            //m_Color
            let previousStop = stops[0];
            let stop = previousStop;
            if (inputValue < previousStop.m_flPosition) {
                return vec4Scale(outVec, previousStop.m_Color, COLOR_SCALE);
            }
            let index = 0;
            while (stop = stops[++index]) {
                if (inputValue < stop.m_flPosition) {
                    vec4Lerp(outVec, previousStop.m_Color, stop.m_Color, (inputValue - previousStop.m_flPosition) / (stop.m_flPosition - previousStop.m_flPosition));
                    return scale$4(outVec, outVec, COLOR_SCALE);
                }
                previousStop = stop;
            }
            return vec4Scale(outVec, previousStop.m_Color, COLOR_SCALE);
        }
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bDisableOperator':
                this.disableOperator = value;
                break;
            case 'm_nOpEndCapState':
                //TODO: do it properly
                if (value == 1 || value == 1n || value == 'PARTICLE_ENDCAP_ENDCAP_ON') {
                    this.disableOperator = true;
                }
                break;
            case 'm_flOpStartFadeInTime':
                this.opStartFadeInTime = value;
                break;
            case 'm_flOpEndFadeInTime':
                this.opEndFadeInTime = value;
                break;
            case 'm_flOpStartFadeOutTime':
                this.opStartFadeOutTime = value;
                break;
            case 'm_flOpEndFadeOutTime':
                this.opEndFadeOutTime = value;
                break;
            case 'm_flOpFadeOscillatePeriod':
                this.opFadeOscillatePeriod = value;
                break;
            case 'm_nControlPointNumber':
                this.controlPointNumber = Number(value);
                break;
            case 'm_nOrientationType':
                this.setOrientationType(value);
                break;
            case 'm_nFieldInput':
                this.fieldInput = Number(value);
                break;
            case 'm_nFieldOutput':
                this.fieldOutput = Number(value);
                break;
            case 'm_nOpScaleCP':
                this.scaleCp = Number(value);
                break;
            case 'm_flOpStrength':
                //TODO
                break;
            case 'm_ColorScale':
                let colorScale = create$4();
                colorScale[0] = Number(value[0]) * COLOR_SCALE;
                colorScale[1] = Number(value[1]) * COLOR_SCALE;
                colorScale[2] = Number(value[2]) * COLOR_SCALE;
                this.material?.setUniform('uColorScale', colorScale);
                break;
            case 'm_flAlphaScale':
                //handled in operator
                break;
            // Renderer parameters
            case 'm_nOutputBlendMode':
                this.setOutputBlendMode(value);
                break;
            case 'm_bAdditive':
                this.setOutputBlendMode('PARTICLE_OUTPUT_BLEND_MODE_ADD');
                break;
            case 'm_bMod2X':
                this.setOutputBlendMode('PARTICLE_OUTPUT_BLEND_MODE_MOD2X');
                break;
            default:
                console.warn(this.constructor.name + ' : unknown parameter : ' + paramName, value);
        }
    }
    initializeParticle(particles, elapsedTime) {
        if (!particles || this.disableOperator) {
            return;
        }
        let strength = 1;
        if (this.scaleCp) {
            strength = this.system.getControlPoint(this.scaleCp).currentWorldPosition[0];
        }
        this.doInit(particles, elapsedTime, strength);
    }
    operateParticle(particle, elapsedTime) {
        if (!particle || this.disableOperator) {
            return;
        }
        if (this.endCapState != 1) {
            let strength = 1;
            if (this.scaleCp) {
                strength = this.system.getControlPoint(this.scaleCp).currentWorldPosition[0];
            }
            this.doOperate(particle, elapsedTime, strength);
        }
    }
    forceParticle(particle, elapsedTime, accumulatedForces) {
        if (!particle || this.disableOperator) {
            return;
        }
        this.doForce(particle, elapsedTime, accumulatedForces);
    }
    constraintParticle(particle) {
        if (!particle || this.disableOperator) {
            return;
        }
        this.applyConstraint(particle);
    }
    emitParticle(creationTime, elapsedTime) {
        if (!this.system || this.disableOperator) {
            return;
        }
        return this.system.createParticle(creationTime, elapsedTime);
    }
    renderParticle(particleList, elapsedTime, material) {
        if (!particleList) {
            return;
        }
        this.doRender(particleList, elapsedTime, material);
    }
    checkIfOperatorShouldRun() {
        let strength = this.fadeInOut();
        return strength > 0;
    }
    fadeInOut() {
        if (this.currentTime < this.opStartFadeInTime) {
            return 0;
        }
        if (this.opEndFadeOutTime && this.currentTime > this.opEndFadeOutTime) {
            return 0;
        }
        if (this.currentTime < this.opEndFadeInTime) {
            return (this.currentTime - this.opStartFadeInTime) / (this.opEndFadeInTime - this.opStartFadeInTime);
        }
        if (this.currentTime < this.opStartFadeOutTime) {
            return 1;
        }
        if (this.currentTime < this.opEndFadeOutTime) {
            return (this.currentTime - this.opStartFadeOutTime) / (this.opEndFadeOutTime - this.opStartFadeOutTime);
        }
        return 1;
    }
    setMaterial(material) {
        this.material = material;
    }
    setParameter(parameter, type /*TODO: improve type*/, value) {
        if (parameter == '' || parameter == undefined) {
            return this;
        }
        if (parameter == 'operator end cap state') {
            this.endCapState = value;
        }
        if (this.#parameters[parameter] == undefined) {
            this.#parameters[parameter] = {};
        }
        this.#parameters[parameter].type = type;
        this.#parameters[parameter].value = value;
        //this.propertyChanged(parameter);
        return this;
    }
    getParameter(parameter) {
        const p = this.#parameters[parameter];
        if (p == undefined) {
            return null;
        }
        return p.value;
    }
    getParameters() {
        return this.#parameters;
    }
    setParameters(parameters) {
        for (let i in parameters) {
            const pair = parameters[i];
            this.setParameter(pair[0], pair[1], pair[2]);
        }
        return this;
    }
    doNothing() {
    }
    reset() {
    }
    getOperatorFade() {
        if (!this.system) {
            return 0;
        }
        let start_fadein = this.getParameter('operator start fadein') || 0;
        let end_fadein = this.getParameter('operator end fadein') || 0;
        let start_fadeout = this.getParameter('operator start fadeout') || 0;
        let end_fadeout = this.getParameter('operator end fadeout') || 0;
        const fade_oscillate = this.getParameter('operator fade oscillate') || 0;
        if (start_fadein == 0 && end_fadein == 0 && start_fadeout == 0 && end_fadeout == 0) {
            // if all parms at 0, return 1
            return 1;
        }
        let currentTime = this.system.currentTime;
        //	console.log(currentTime);
        if (fade_oscillate != 0) {
            currentTime = currentTime % fade_oscillate;
            start_fadein *= fade_oscillate;
            end_fadein *= fade_oscillate;
            start_fadeout *= fade_oscillate;
            end_fadeout *= fade_oscillate;
        }
        //	console.log(currentTime%fade_oscillate);
        switch (true) {
            case currentTime < start_fadein:
                return 0;
            case currentTime < end_fadein:
                return (currentTime - start_fadein) / (end_fadein - start_fadein);
            case currentTime < start_fadeout:
                return 1;
            case currentTime < end_fadeout:
                return 1 - (currentTime - start_fadeout) / (end_fadeout - start_fadeout);
            default:
                return 0;
        }
    }
    getInputValue(inputField, particle) {
        let input;
        switch (inputField) {
            case 0: //creation time
                input = clone$4(particle.position);
                break;
            case 8: //creation time
                input = particle.cTime;
                break;
        }
        return input;
    }
    getInputValueAsVector(inputField, particle, v) {
        switch (inputField) {
            case 0: //creation time
                copy$4(v, particle.position);
                break;
            case 4:
                v[0] = particle.rotationRoll;
                v[1] = particle.rotationRoll;
                v[2] = particle.rotationRoll;
                break;
            case 8: //creation time
                v[0] = particle.cTime;
                v[1] = particle.cTime;
                v[2] = particle.cTime;
                break;
        }
    }
    setOutputValue(outputField, value, particle) {
        particle.setInitialField(outputField, value /*TODO*/);
    }
    initMultipleOverride() {
        return false;
    }
    isPreEmission() {
        return false;
    }
    setOrientationType(orientationType) {
        //TODO: finish this
        switch (orientationType) {
            case 'PARTICLE_ORIENTATION_SCREEN_ALIGNED':
            case 0n:
            case 0:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED':
            case 1n:
            case 1:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_WORLD_Z_ALIGNED':
            case 2n:
            case 2:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL':
            case 3n:
            case 3:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL);
                break;
            case 'PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL':
            case 4n:
            case 4:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL);
                break;
            case 'PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION':
            case 5n:
            case 5:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION);
                break;
            default:
                console.error('Unknonw orientationType ', orientationType);
        }
    }
    setOutputBlendMode(outputBlendMode) {
        let blendMode = 0;
        switch (outputBlendMode) {
            case 'PARTICLE_OUTPUT_BLEND_MODE_ADD':
                blendMode = 1;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_BLEND_ADD':
                blendMode = 2;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_HALF_BLEND_ADD':
                blendMode = 3;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_NEG_HALF_BLEND_ADD':
                blendMode = 4;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_MOD2X':
                blendMode = 5;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_LIGHTEN':
                blendMode = 6;
                break;
            default:
                console.error('Unknonw outputBlendMode ', outputBlendMode);
        }
        this.material?.setOutputBlendMode(blendMode);
    }
    init() {
        //This function is called after parameters are set
    }
    dispose() {
    }
    doInit(particle, elapsedTime, strength) { }
    doOperate(particle, elapsedTime, strength) { }
    doForce(particle, elapsedTime, accumulatedForces, strength) { }
    applyConstraint(particle) { }
    doRender(particle, elapsedTime, material) { }
    initRenderer(particleSystem) { }
    updateParticles(particleSystem, particleList, elapsedTime) { }
}

let vec$7 = create$4();
class ConstrainDistance extends Operator {
    minDistance = 0;
    maxDistance = 100;
    scaleCP = -1;
    centerOffset = create$4();
    globalCenter = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_fMinDistance':
                this.minDistance = Number(value);
                break;
            case 'm_fMaxDistance':
                this.maxDistance = Number(value);
                break;
            case 'm_nScaleCP':
                this.scaleCP = Number(value);
                break;
            case 'm_CenterOffset':
                copy$4(this.centerOffset, value);
                break;
            case 'm_bGlobalCenter':
                this.globalCenter = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    applyConstraint(particle) {
        this.getParameter('minimum distance');
        this.getParameter('maximum distance');
        this.getParameter('offset of center');
        this.getParameter('control point number');
        let cp = this.system.getControlPoint(this.controlPointNumber);
        let v = clone$4(particle.position);
        if (cp) {
            sub$2(v, v, cp.getWorldPosition(vec$7));
        }
        let distance = length$5(v);
        if (distance > 0) {
            scale$5(v, v, 1 / distance);
            if (distance < this.minDistance) {
                scale$5(v, v, this.minDistance);
                add$5(particle.position, cp.getWorldPosition(vec$7), v);
            }
            else {
                if (distance > this.maxDistance) {
                    scale$5(v, v, this.maxDistance);
                    add$5(particle.position, cp.getWorldPosition(vec$7), v);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_ConstrainDistance', ConstrainDistance);

class ContinuousEmitter extends Operator {
    emitRate = 100;
    remainder = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flEmitRate':
                this.emitRate = value.m_flLiteralValue ?? value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doEmit(elapsedTime) {
        const emission_start_time = this.getParameter('emission_start_time') ?? 0;
        let emission_rate = this.emitRate;
        const emission_duration = this.getParameter('emission_duration') ?? 0;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        let currentTime = this.system.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.remainder + elapsedTime * emission_rate;
        this.remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_ContinuousEmitter', ContinuousEmitter);

class InstantaneousEmitter extends Operator {
    emitted = 0;
    initFromKilledParentParticles = 0;
    maxEmittedPerFrame = -1;
    snapshotControlPoint = -1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nParticlesToEmit':
            case 'm_flStartTime':
                break;
            case 'm_flInitFromKilledParentParticles':
                this.initFromKilledParentParticles = Number(value);
                break;
            case 'm_nMaxEmittedPerFrame':
                this.maxEmittedPerFrame = Number(value);
                break;
            case 'm_nSnapshotControlPoint':
                this.snapshotControlPoint = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doEmit(elapsedTime) {
        //todo: use snapshotControlPoint
        let particlesToEmit = this.getParamScalarValue('m_nParticlesToEmit') ?? 100;
        this.getParamScalarValue('m_flStartTime') ?? 0;
        let system = this.system;
        if (this.snapshotControlPoint != -1) {
            let snapshot = system.getControlPoint(this.snapshotControlPoint)?.snapshot;
            if (snapshot) {
                particlesToEmit = snapshot.particleCount;
            }
            else {
                particlesToEmit = 0; //yep no snapshot = no particle
            }
        }
        //TODO: check start timeout
        let nToEmit = particlesToEmit - this.emitted;
        if (this.maxEmittedPerFrame != -1) {
            nToEmit = Math.min(nToEmit, this.maxEmittedPerFrame);
        }
        let currentTime = system.currentTime;
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
            ++this.emitted;
        }
    }
    reset() {
        this.emitted = 0;
    }
}
RegisterSource2ParticleOperator('C_OP_InstantaneousEmitter', InstantaneousEmitter);

class MaintainEmitter extends Operator {
    particlesToMaintain = 100;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nParticlesToMaintain':
                this.particlesToMaintain = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doEmit(elapsedTime) {
        let nToEmit = this.particlesToMaintain - this.system.livingParticles.length;
        if (nToEmit > 0) {
            let currentTime = this.system.currentTime;
            const timeStampStep = elapsedTime / nToEmit;
            for (let i = 0; i < nToEmit; ++i) {
                const particle = this.emitParticle(currentTime, elapsedTime);
                if (particle == null) {
                    break; // Break if a particule can't emitted (max reached)
                }
                currentTime += timeStampStep;
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_MaintainEmitter', MaintainEmitter);

class NoiseEmitter extends Operator {
    emissionDuration = 0;
    startTime = 0;
    scaleControlPoint = -1;
    scaleControlPointField = 0;
    worldNoisePoint = -1;
    absVal = false;
    absValInv = false;
    offset = 0;
    outputMin = 0;
    outputMax = 100;
    noiseScale = 0.1;
    worldNoiseScale = 0.001;
    offsetLoc = create$4();
    worldTimeScale = 0;
    remainder = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flEmissionDuration':
                this.emissionDuration = value;
                break;
            case 'm_flStartTime':
                this.startTime = value;
                break;
            case 'm_nScaleControlPoint':
                this.scaleControlPoint = Number(value);
                break;
            case 'm_nScaleControlPointField':
                this.scaleControlPointField = Number(value);
                break;
            case 'm_nWorldNoisePoint':
                this.worldNoisePoint = Number(value);
                break;
            case 'm_bAbsVal':
                this.absVal = value;
                break;
            case 'm_bAbsValInv':
                this.absValInv = value;
                break;
            case 'm_flOffset':
                this.offset = value;
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                break;
            case 'm_flNoiseScale':
                this.noiseScale = value;
                break;
            case 'm_flWorldNoiseScale':
                this.worldNoiseScale = value;
                break;
            case 'm_vecOffsetLoc':
                copy$4(this.offsetLoc, value);
                break;
            case 'm_flWorldTimeScale':
                this.worldTimeScale = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doEmit(elapsedTime) {
        //TODO: code me
        const emission_start_time = this.startTime;
        let emission_rate = (this.outputMin + this.outputMax) * 0.5;
        const emission_duration = this.emissionDuration;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        let currentTime = this.system.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.remainder + elapsedTime * emission_rate;
        this.remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_NoiseEmitter', NoiseEmitter);

const vecCenter = create$4();
let vec$6 = create$4();
class AttractToControlPoint extends Operator {
    componentScale = fromValues$4(1, 1, 1);
    falloffPower = 0;
    scaleLocal = false;
    applyMinForce = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_fForceAmount':
            case 'm_fForceAmountMin':
                break;
            case 'm_vecComponentScale':
                copy$4(this.componentScale, value);
                break;
            case 'm_fFalloffPower':
                this.falloffPower = value;
                break;
            case 'm_bScaleLocal':
                this.scaleLocal = value;
                break;
            case 'm_bApplyMinForce':
                this.applyMinForce = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        let forceAmount = this.getParamScalarValue('m_fForceAmount') ?? 100;
        this.getParamScalarValue('m_fForceAmountMin') ?? 0;
        (-4.0 * this.falloffPower) << 0; // convert to what pow_fixedpoint_exponent_simd wants
        const fForceScale = -forceAmount * strength /*flStrength*/;
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        subtract$3(vecCenter, particle.position, cp.getWorldPosition(vec$6)); //TODO: add particle base cp
        let len = length$5(vecCenter);
        if (len === 0) {
            len = FLT_EPSILON;
        }
        scale$5(vecCenter, vecCenter, fForceScale / len * Math.pow(len, -this.falloffPower));
        add$5(accumulatedForces, accumulatedForces, vecCenter);
        //TODO: use m_vecComponentScale m_bScaleLocal m_bApplyMinForce
    }
}
RegisterSource2ParticleOperator('C_OP_AttractToControlPoint', AttractToControlPoint);

class CPVelocityForce extends Operator {
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flScale':
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        this.getParamScalarValue('m_flScale') ?? 1;
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_CPVelocityForce', CPVelocityForce);

class RandomForce extends Operator {
    minForce = create$4();
    maxForce = create$4();
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_MinForce':
                copy$4(this.minForce, value);
                break;
            case 'm_MaxForce':
                copy$4(this.maxForce, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces) {
        add$5(accumulatedForces, accumulatedForces, vec3RandomBox(create$4(), this.minForce, this.maxForce));
    }
}
RegisterSource2ParticleOperator('C_OP_RandomForce', RandomForce);

let va$2 = create$4();
let vb$1 = create$4();
class AddVectorToVector extends Operator {
    fieldOutput = PARTICLE_FIELD_POSITION;
    fieldInput = PARTICLE_FIELD_POSITION;
    scale = fromValues$4(1, 1, 1);
    offsetMin = create$4();
    offsetMax = fromValues$4(1, 1, 1);
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecScale':
                copy$4(this.scale, value);
                break;
            case 'm_vOffsetMin':
                copy$4(this.offsetMin, value);
                break;
            case 'm_vOffsetMax':
                copy$4(this.offsetMax, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        copy$4(va$2, particle.getField(this.fieldInput));
        vec3RandomBox(vb$1, this.offsetMin, this.offsetMax);
        va$2[0] = (va$2[0] * (1 + this.scale[0]) + vb$1[0]) * 0.5;
        va$2[1] = (va$2[1] * (1 + this.scale[1]) + vb$1[1]) * 0.5;
        va$2[2] = (va$2[2] * (1 + this.scale[2]) + vb$1[2]) * 0.5;
        if (this.fieldOutput == PARTICLE_FIELD_COLOR) {
            va$2[0] = ((va$2[0] % ONE_EPS) + ONE_EPS) % ONE_EPS;
            va$2[1] = ((va$2[1] % ONE_EPS) + ONE_EPS) % ONE_EPS;
            va$2[2] = ((va$2[2] % ONE_EPS) + ONE_EPS) % ONE_EPS;
        }
        particle.setField(this.fieldOutput, va$2);
    }
}
RegisterSource2ParticleOperator('C_INIT_AddVectorToVector', AddVectorToVector);

class CreateFromParentParticles extends Operator {
    velocityScale = 0;
    increment = 1;
    randomDistribution = false;
    randomSeed = 0;
    subFrame = true;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flVelocityScale':
                this.velocityScale = value;
                break;
            case 'm_flIncrement':
                this.increment = value;
                break;
            case 'm_bRandomDistribution':
                this.randomDistribution = value;
                break;
            case 'm_nRandomSeed':
                this.randomSeed = Number(value);
                break;
            case 'm_bSubFrame':
                this.subFrame = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        const parent = this.system.parentSystem;
        if (parent == null) {
            return;
        }
        const base = parent.getParticle(0 /*TODO: particle index*/);
        if (base == null) {
            particle.die();
            return;
        }
        base.getWorldPos(particle.position);
        base.getLocalPos(particle.position);
        copy$4(particle.prevPosition, particle.position);
        particle.PositionFromParentParticles = true;
        //TODO: fix this operator
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateFromParentParticles', CreateFromParentParticles);

let vec$5 = create$4();
class CreateOnModel extends Operator {
    forceInModel = 0;
    desiredHitbox = -1;
    hitboxValueFromControlPointIndex = -1;
    boneVelocity = 0;
    maxBoneVelocity = 0;
    directionBias = create$4();
    hitboxSetName = 'default';
    localCoords = false;
    useBones = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecHitBoxScale':
                break;
            case 'm_nForceInModel':
                this.forceInModel = Number(value);
                break;
            case 'm_nDesiredHitbox':
                this.desiredHitbox = Number(value);
                break;
            case 'm_nHitboxValueFromControlPointIndex':
                this.hitboxValueFromControlPointIndex = Number(value);
                break;
            case 'm_flBoneVelocity':
                this.boneVelocity = value;
                break;
            case 'm_flMaxBoneVelocity':
                this.maxBoneVelocity = value;
                break;
            case 'm_vecDirectionBias':
                copy$4(this.directionBias, value);
                break;
            case 'm_HitboxSetName':
                this.hitboxSetName = value;
                break;
            case 'm_bLocalCoords':
                this.localCoords = value;
                break;
            case 'm_bUseBones':
                this.useBones = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        this.getParamVectorValue('m_vecHitBoxScale');
        let controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            let controllingModel = controlPoint.parentModel;
            if (controllingModel?.getRandomPointOnModel) {
                let bones = [];
                particle.bones = bones;
                particle.initialVec = create$4();
                const position = controllingModel.getRandomPointOnModel(create$4(), particle.initialVec, bones);
                if (controlPoint) {
                    copy$4(particle.position, position);
                    copy$4(particle.prevPosition, position);
                }
            }
            else {
                if (controlPoint) {
                    copy$4(particle.position, controlPoint.getWorldPosition(vec$5));
                    copy$4(particle.prevPosition, particle.position);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateOnModel', CreateOnModel);

let vec$4 = create$4();
class CreateSequentialPath extends Operator {
    numToAssign = 100;
    step = 0.01;
    loop = true;
    maxDistance = 0;
    cpPairs = false;
    saveOffset = false;
    startControlPointNumber = 0;
    endControlPointNumber = 0;
    bulgeControl = 0;
    bulge = 0;
    midPoint = 0.5;
    startPointOffset = create$4();
    midPointOffset = create$4();
    endOffset = create$4();
    t = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flNumToAssign':
                this.numToAssign = value;
                this.step = 1 / value;
                break;
            case 'm_bLoop':
                this.loop = value;
                break;
            case 'm_PathParams':
                for (let subName of Object.keys(value)) {
                    this._paramChanged(subName, value[subName]);
                }
                break;
            case 'm_fMaxDistance':
                this.maxDistance = value;
                break;
            case 'm_bCPPairs':
                this.cpPairs = value;
                break;
            case 'm_bSaveOffset':
                this.saveOffset = value;
                break;
            case 'm_nStartControlPointNumber':
                this.startControlPointNumber = Number(value);
                break;
            case 'm_nEndControlPointNumber':
                this.endControlPointNumber = Number(value);
                break;
            case 'm_nBulgeControl':
                this.bulgeControl = Number(value);
                break;
            case 'm_flBulge':
                this.bulge = value;
                break;
            case 'm_flMidPoint':
                this.midPoint = value;
                break;
            case 'm_vStartPointOffset':
                copy$4(this.startPointOffset, value);
                break;
            case 'm_vMidPointOffset':
                copy$4(this.midPointOffset, value);
                break;
            case 'm_vEndOffset':
                copy$4(this.endOffset, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use other parameters
        let startControlPointNumber = this.startControlPointNumber;
        let endControlPointNumber = this.endControlPointNumber;
        let startControlPoint = this.system.getControlPoint(startControlPointNumber);
        let endControlPoint = this.system.getControlPoint(endControlPointNumber);
        if (startControlPoint && endControlPoint) {
            this.numToAssign;
            let delta = startControlPoint.deltaPosFrom(endControlPoint, vec$4);
            scale$5(delta, delta, this.t);
            add$5(particle.position, startControlPoint.currentWorldPosition, delta);
            copy$4(particle.prevPosition, particle.position);
            //++this.sequence;
            this.t += this.step;
            if (this.t > 1.0) { //TODO: handle loop
                this.t = 0;
            }
        }
    }
}
//TODO Not sure what the difference is between v1 and v2 ?
RegisterSource2ParticleOperator('C_INIT_CreateSequentialPath', CreateSequentialPath);
RegisterSource2ParticleOperator('C_INIT_CreateSequentialPathV2', CreateSequentialPath);

let tempQuat$2 = create$2();
let tempVec3$4 = create$4();
let tempVec3_2$1 = create$4();
class CreateWithinBox extends Operator {
    vecMin = create$4();
    vecMax = create$4();
    localSpace = false;
    scaleCP = -1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecMin':
                copy$4(this.vecMin, value);
                break;
            case 'm_vecMax':
                copy$4(this.vecMax, value);
                break;
            case 'm_bLocalSpace':
                this.localSpace = value;
                break;
            case 'm_nScaleCP':
                this.scaleCP = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        vec3RandomBox(tempVec3$4, this.vecMin, this.vecMax);
        if (this.scaleCP !== -1) {
            const scaleCp = this.system.getControlPointForScale(this.scaleCP);
            if (scaleCp) {
                scaleCp.getWorldPosition(tempVec3_2$1);
                scale$5(tempVec3$4, tempVec3$4, tempVec3_2$1[0]); //x position of the scale cp is used as scaling
            }
        }
        let controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            controlPoint.getWorldPosition(tempVec3_2$1);
            if (this.localSpace) {
                transformQuat$1(tempVec3$4, tempVec3$4, controlPoint.getWorldQuaternion(tempQuat$2));
                add$5(tempVec3$4, tempVec3$4, tempVec3_2$1);
            }
            else {
                add$5(tempVec3$4, tempVec3$4, tempVec3_2$1);
            }
        }
        copy$4(particle.position, tempVec3$4);
        copy$4(particle.prevPosition, tempVec3$4);
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateWithinBox', CreateWithinBox);

const DEFAULT_SPEED$1 = create$4();
const DEFAULT_DISTANCE_BIAS = fromValues$4(1, 1, 1);
create$4();
class CreateWithinSphere extends Operator {
    distanceBias = fromValues$4(1, 1, 1);
    distanceBiasAbs = create$4();
    speedRandExp = 1;
    localCoords = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_LocalCoordinateSystemSpeedMin':
            case 'm_LocalCoordinateSystemSpeedMax':
            case 'm_fRadiusMin':
            case 'm_fRadiusMax':
            case 'm_vecDistanceBias':
            case 'm_fSpeedMin':
            case 'm_fSpeedMax':
                break;
            case 'm_vecDistanceBiasAbs':
                copy$4(this.distanceBiasAbs, value);
                break;
            case 'm_fSpeedRandExp':
                this.speedRandExp = value;
                break;
            case 'm_bLocalCoords':
                this.localCoords = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let localCoordinateSystemSpeedMin = this.getParamVectorValue('m_LocalCoordinateSystemSpeedMin') ?? DEFAULT_SPEED$1;
        let localCoordinateSystemSpeedMax = this.getParamVectorValue('m_LocalCoordinateSystemSpeedMax') ?? DEFAULT_SPEED$1;
        let m_vecDistanceBias = this.getParamVectorValue('m_vecDistanceBias') ?? DEFAULT_DISTANCE_BIAS;
        let radiusMin = this.getParamScalarValue('m_fRadiusMin') ?? 0;
        let radiusMax = this.getParamScalarValue('m_fRadiusMax') ?? 0;
        let speedMin = this.getParamScalarValue('m_fSpeedMin') ?? 0;
        let speedMax = this.getParamScalarValue('m_fSpeedMax') ?? 0;
        const m_vecDistanceBiasAbs = this.distanceBiasAbs;
        //const controlPointNumber = this.getParameter('control_point_number');
        const m_bDistanceBias = (m_vecDistanceBias[0] != 1.0) || (m_vecDistanceBias[1] != 1.0) || (m_vecDistanceBias[2] != 1.0);
        const m_bDistanceBiasAbs = (m_vecDistanceBiasAbs[0] != 0.0) || (m_vecDistanceBiasAbs[1] != 0.0) || (m_vecDistanceBiasAbs[2] != 0.0);
        const speed = RandomFloatExp(speedMin, speedMax, this.speedRandExp); //(speedMax - speedMin) * Math.random() + speedMin;
        const randpos = create$4();
        let cp;
        //for(int nTryCtr = 0 ; nTryCtr < 10; nTryCtr++)
        {
            const flLength = RandomVectorInUnitSphere(randpos);
            // Absolute value and biasing for creating hemispheres and ovoids.
            if (m_bDistanceBiasAbs) {
                if (m_vecDistanceBiasAbs[0] != 0.0) {
                    randpos[0] = Math.abs(randpos[0]);
                }
                if (m_vecDistanceBiasAbs[1] != 0.0) {
                    randpos[1] = Math.abs(randpos[1]);
                }
                if (m_vecDistanceBiasAbs[2] != 0.0) {
                    randpos[2] = Math.abs(randpos[2]);
                }
            }
            mul$4(randpos, randpos, m_vecDistanceBias); //randpos *= m_vecDistanceBias;
            normalize$5(randpos, randpos); //randpos.NormalizeInPlace();
            clone$4(randpos);
            scale$5(randpos, randpos, lerp(radiusMin, radiusMax, flLength));
            if (!m_bDistanceBias || !this.localCoords) {
                /*Vector vecControlPoint;
                pParticles->GetControlPointAtTime(nCurrentControlPoint, *ct, &vecControlPoint);
                randpos += vecControlPoint;*/
                cp = particle.system.getControlPoint(this.controlPointNumber);
                if (cp) {
                    add$5(randpos, randpos, cp.currentWorldPosition);
                }
            }
            else {
                /*matrix3x4_t mat;
                pParticles->GetControlPointTransformAtTime(nCurrentControlPoint, *ct, &mat);
                Vector vecTransformLocal = vec3_origin;
                VectorTransform(randpos, mat, vecTransformLocal);
                randpos = vecTransformLocal;*/
                cp = particle.system.getControlPoint(this.controlPointNumber);
                if (cp) {
                    transformQuat$1(randpos, randpos, cp.currentWorldQuaternion);
                    add$5(randpos, randpos, cp.currentWorldPosition);
                }
            }
        }
        copy$4(particle.position, randpos);
        vec3RandomBox(particle.velocity, localCoordinateSystemSpeedMin, localCoordinateSystemSpeedMax);
        if (cp) {
            transformQuat$1(particle.velocity, particle.velocity, cp.currentWorldQuaternion);
        }
        if (speed) {
            const v = random$5(create$4(), speed);
            add$5(particle.velocity, particle.velocity, v);
            //vec3.add(randpos, randpos, v);
        }
        //quat.invert(particle.cpOrientationInvert, particle.cpOrientation);
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation);
        const vGrav = clone$4(particle.velocity);
        particle.velocity[0] = vGrav[2];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = -vGrav[0];
        particle.velocity[0] = vGrav[0];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = vGrav[2];
        //particle.velocity[2] = -vGrav[2];
        //vec3.add(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
        scaleAndAdd$2(randpos, randpos, particle.velocity, -elapsedTime);
        copy$4(particle.prevPosition, randpos);
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateWithinSphere', CreateWithinSphere);

class CreationNoise extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    absVal = false;
    absValInv = false;
    offset = 0;
    outputMin = 0;
    outputMax = 0;
    noiseScale = 0.1;
    noiseScaleLoc = 0.001;
    offsetLoc = create$4();
    worldTimeScale = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bAbsVal':
                this.absVal = Number(value) != 0;
                break;
            case 'm_bAbsValInv':
                this.absValInv = Number(value) != 0;
                break;
            case 'm_flOffset':
                this.offset = Number(value);
                break;
            case 'm_flOutputMin':
                this.outputMin = Number(value);
                break;
            case 'm_flOutputMax':
                this.outputMax = Number(value);
                break;
            case 'm_flNoiseScale':
                this.noiseScale = Number(value);
                break;
            case 'm_flNoiseScaleLoc':
                this.noiseScaleLoc = Number(value);
                break;
            case 'm_vecOffsetLoc':
                copy$4(this.offsetLoc, value);
                break;
            case 'm_flWorldTimeScale':
                this.worldTimeScale = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let fieldOutput = this.fieldOutput;
        //let nAbsVal = 0xffffffff;
        let flAbsScale = 0.5;
        if (this.absVal) {
            //nAbsVal = 0x7fffffff;
            flAbsScale = 1.0;
        }
        let fMin = this.outputMin;
        let fMax = this.outputMax;
        if (ATTRIBUTES_WHICH_ARE_ANGLES & (1 << fieldOutput)) {
            fMin *= DEG_TO_RAD;
            fMax *= DEG_TO_RAD;
        }
        let CoordScaleLoc = this.noiseScaleLoc;
        let ValueScale, ValueBase;
        ValueScale = (flAbsScale * (fMax - fMin));
        ValueBase = (fMin + ((1.0 - flAbsScale) * (fMax - fMin)));
        let CoordLoc, CoordBase;
        //let pCreationTime = particle.cTime;//pParticles->GetFloatAttributePtr( PARTICLE_ATTRIBUTE_CREATION_TIME, start_p );
        let Offset = this.offset;
        let a = (particle.cTime + Offset) * this.noiseScale + performance.now() * this.worldTimeScale;
        CoordBase = fromValues$4(a, a, a);
        CoordLoc = create$4();
        //CoordBase *= this.noiseScale;
        //CoordWorldTime = Vector( (Plat_MSTime() * m_flWorldTimeScale), (Plat_MSTime() * m_flWorldTimeScale), (Plat_MSTime() * m_flWorldTimeScale) );
        //CoordBase += CoordWorldTime;
        let Coord = create$4();
        //for( ; nParticleCount--; start_p++ )
        {
            copy$4(Coord, CoordBase);
            copy$4(CoordLoc, particle.position);
            add$5(CoordLoc, CoordLoc, this.offsetLoc);
            //CoordLoc += m_vecOffsetLoc;
            scale$5(CoordLoc, CoordLoc, CoordScaleLoc);
            //CoordLoc *= CoordScaleLoc;
            add$5(Coord, Coord, CoordLoc);
            //Coord += CoordLoc;
            //fltx4 flNoise128;
            //FourVectors fvNoise;
            //let fvNoise = vec3.clone(Coord);
            //fvNoise.DuplicateVector( Coord );
            //flNoise128 = NoiseSIMD( fvNoise , 0);
            //float flNoise = SubFloat( flNoise128, 0 );
            let flNoise = NoiseSIMD(Coord, 0, 0);
            //*( (int *) &flNoise)  &= nAbsVal;
            if (this.absVal) {
                flNoise = Math.abs(flNoise);
            }
            if (this.absValInv) {
                flNoise = 1.0 - flNoise;
            }
            let flInitialNoise = (ValueBase + (ValueScale * flNoise));
            /*
            //TODO
            if ( ATTRIBUTES_WHICH_ARE_0_TO_1 & (1 << m_nFieldOutput ) )
            {
                flInitialNoise = clamp(flInitialNoise, 0.0f, 1.0f );
            }*/
            //*( pAttr ) = flInitialNoise;
            particle.setInitialField(this.fieldOutput, flInitialNoise);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_CreationNoise', CreationNoise);

class InheritFromParentParticles extends Operator {
    scale = 1;
    fieldOutput = PARTICLE_FIELD_RADIUS;
    increment = 1;
    randomDistribution = false;
    randomSeed = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flScale':
                this.scale = value;
                break;
            case 'm_nIncrement':
                this.increment = Number(value);
                break;
            case 'm_bRandomDistribution':
                this.randomDistribution = value;
                break;
            case 'm_nRandomSeed':
                this.randomSeed = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use m_flScale m_nIncrement m_bRandomDistribution m_nRandomSeed
        let parentSystem = this.system.parentSystem;
        if (parentSystem) {
            let parentParticle = parentSystem.getParticle(particle.id - 1);
            if (parentParticle) {
                particle.setField(this.fieldOutput, parentParticle.getField(this.fieldOutput));
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InheritFromParentParticles', InheritFromParentParticles);

class InitFloat extends Operator {
    setMethod = null;
    constructor(system) {
        super(system);
        this.fieldOutput = PARTICLE_FIELD_RADIUS;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_InputValue':
                break;
            case 'm_nOutputField':
                this.fieldOutput = Number(value);
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let value = this.getParamScalarValue('m_InputValue', particle);
        //TODO: use setMethod
        particle.setField(this.fieldOutput, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE', true);
        //setField(field = 0, value, mulInitial = false, setInitial = false, additive = false) {
    }
}
RegisterSource2ParticleOperator('C_INIT_InitFloat', InitFloat);

const DEFAULT_PARTICLE_TEXTURE = 'materials/particle/base_sprite.vtex';
const ATTRIBUTE_NAME_PER_FIELD = ['position', 'lifespan', 'position', 'radius', , , 'color'];

/*
export const PARTICLE_FIELD_LIFETIME = 1;
export const PARTICLE_FIELD_POSITION_PREVIOUS = 2;
export const PARTICLE_FIELD_RADIUS = 3;
export const PARTICLE_FIELD_ROTATION_ROLL = 4;
export const PARTICLE_FIELD_ROTATION_ROLL_SPEED = 5;
export const PARTICLE_FIELD_COLOR = 6;
export const PARTICLE_FIELD_ALPHA = 7;
export const PARTICLE_FIELD_CREATION_TIME = 8;
export const PARTICLE_FIELD_SEQUENCE_NUMBER = 9;
export const PARTICLE_FIELD_TRAIL_LENGTH = 10;
export const PARTICLE_FIELD_PARTICLE_ID = 11;
export const PARTICLE_FIELD_YAW = 12;
export const PARTICLE_FIELD_SEQUENCE_NUMBER_2 = 13;
export const PARTICLE_FIELD_HITBOX_INDEX = 14;
export const PARTICLE_FIELD_HITBOX_OFFSET_POSITION = 15;
export const PARTICLE_FIELD_ALPHA_ALTERNATE = 16;
export const PARTICLE_FIELD_SCRATCH_VECTOR = 17;
export const PARTICLE_FIELD_SCRATCH_FLOAT = 18;
export const PARTICLE_FIELD_NONE = 19;
export const PARTICLE_FIELD_PITCH = 20;
export const PARTICLE_FIELD_NORMAL = 21;
export const PARTICLE_FIELD_GLOW_RGB = 22;
export const PARTICLE_FIELD_GLOW_ALPHA = 23;
export const PARTICLE_FIELD_SCRATCH_FLOAT_1 = 26;
export const PARTICLE_FIELD_SCRATCH_FLOAT_2 = 27;
export const PARTICLE_FIELD_SCRATCH_VECTOR2 = 30;
export const PARTICLE_FIELD_BONE_INDICE = 31;
export const PARTICLE_FIELD_BONE_WEIGHT = 32;
export const PARTICLE_FIELD_PARENT_PARTICLE_INDEX = 33;
export const PARTICLE_FIELD_FORCE_SCALE = 34;
export const PARTICLE_FIELD_MANUAL_ANIMATION_FRAME = 38;
export const PARTICLE_FIELD_SHADER_EXTRA_DATA_1 = 39;
export const PARTICLE_FIELD_SHADER_EXTRA_DATA_2 = 40;
*/
let v$e = create$4();
class InitFromCPSnapshot extends Operator {
    attributeToRead = -1;
    attributeToWrite = PARTICLE_FIELD_POSITION;
    localSpaceCP = 0;
    random = false;
    reverse = false;
    randomSeed = 0;
    localSpaceAngles = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nAttributeToRead':
                this.attributeToRead = Number(value);
                break;
            case 'm_nAttributeToWrite':
                this.attributeToWrite = Number(value);
                break;
            case 'm_nLocalSpaceCP':
                this.localSpaceCP = Number(value);
                break;
            case 'm_bRandom':
                this.random = value;
                break;
            case 'm_bReverse':
                this.reverse = value;
                break;
            case 'm_nRandomSeed':
                this.randomSeed = Number(value);
                break;
            case 'm_bLocalSpaceAngles':
                this.localSpaceAngles = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        if (this.attributeToRead == -1) {
            return;
        }
        let system = this.system;
        let snapshot = system.getControlPoint(this.controlPointNumber)?.snapshot;
        if (snapshot) {
            let attributeToReadName = ATTRIBUTE_NAME_PER_FIELD[this.attributeToRead];
            let attributeToRead = snapshot.attributes[attributeToReadName];
            if (attributeToRead) {
                let id;
                if (this.random) {
                    id = (snapshot.particleCount * Math.random() << 0) % snapshot.particleCount;
                }
                else {
                    id = (particle.id - 1) % snapshot.particleCount;
                }
                if (this.attributeToWrite == PARTICLE_FIELD_POSITION) {
                    let localSpaceCP = system.getControlPoint(this.localSpaceCP);
                    if (localSpaceCP) {
                        //TODO: check attributeToRead[id] is actually a vector
                        //TODO: only transform position when this.localSpaceAngles = true
                        {
                            transformMat4$2(v$e, attributeToRead[id], localSpaceCP.currentWorldTransformation);
                        }
                        particle.setInitialField(this.attributeToWrite, v$e);
                    }
                }
                else {
                    particle.setInitialField(this.attributeToWrite, attributeToRead[id]);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InitFromCPSnapshot', InitFromCPSnapshot);

create$4();
fromValues$4(1, 1, 1);
create$4();
fromValues$4(100000.5, 300000.25, 9000000.75);
fromValues$4(110000.25, 310000.75, 9100000.5);
create$4();
create$4();
create$4();
create$4();
create$4();
class InitialVelocityNoise extends Operator {
    absVal = create$4();
    absValInv = create$4();
    localSpace = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecOutputMin':
            case 'm_vecOutputMax':
            case 'm_vecOffsetLoc':
            case 'm_flOffset':
            case 'm_flNoiseScale':
            case 'm_flNoiseScaleLoc':
                break;
            case 'm_vecAbsVal':
                set$5(this.absVal, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_vecAbsValInv':
                set$5(this.absValInv, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_bLocalSpace':
                this.localSpace = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: fix this operator
        return;
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_InitialVelocityNoise', InitialVelocityNoise);

let mat$1 = create$5();
let nmat$2 = create$6();
const IDENTITY_MAT4$1 = create$5();
class InitSkinnedPositionFromCPSnapshot extends Operator {
    #rigidOnce = false;
    snapshotControlPointNumber = 1;
    random = false;
    randomSeed = 0;
    rigid = false;
    setNormal = false;
    ignoreDt = false;
    minNormalVelocity = 0;
    maxNormalVelocity = 0;
    increment = 1;
    fullLoopIncrement = 0;
    snapShotStartPoint = 0;
    boneVelocity = 0;
    boneVelocityMax = 0;
    copyColor = false;
    copyAlpha = false;
    copyRadius = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nSnapshotControlPointNumber':
                this.snapshotControlPointNumber = Number(value);
                break;
            case 'm_bRandom':
                this.random = value;
                break;
            case 'm_nRandomSeed':
                this.randomSeed = Number(value);
                break;
            case 'm_bRigid':
                this.rigid = value;
                break;
            case 'm_bSetNormal':
                this.setNormal = value;
                break;
            case 'm_bIgnoreDt':
                this.ignoreDt = value;
                break;
            case 'm_flMinNormalVelocity':
                this.minNormalVelocity = value;
                break;
            case 'm_flMaxNormalVelocity':
                this.maxNormalVelocity = value;
                break;
            case 'm_flIncrement':
                this.increment = value;
                break;
            case 'm_nFullLoopIncrement':
                this.fullLoopIncrement = Number(value);
                break;
            case 'm_nSnapShotStartPoint':
                this.snapShotStartPoint = Number(value);
                break;
            case 'm_flBoneVelocity':
                this.boneVelocity = value;
                break;
            case 'm_flBoneVelocityMax':
                this.boneVelocityMax = value;
                break;
            case 'm_bCopyColor':
                this.copyColor = value;
                break;
            case 'm_bCopyAlpha':
                this.copyAlpha = value;
                break;
            case 'm_bCopyRadius':
                this.copyRadius = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use all parameters
        let system = this.system;
        let snapshot = system.getControlPoint(this.snapshotControlPointNumber)?.snapshot;
        if (!snapshot) {
            return;
        }
        let cp = system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        /*let attributeToReadName = ATTRIBUTE_NAME_PER_FIELD[this.attributeToRead];
        if (TESTING && attributeToReadName === undefined) {
            throw 'Unknown field';
        }*/
        let attributeId;
        if (this.random) {
            attributeId = (snapshot.particleCount * Math.random() << 0) % snapshot.particleCount;
        }
        else {
            attributeId = (particle.id - 1) % snapshot.particleCount;
        }
        let positionAttribute = snapshot.attributes['position'];
        if (!positionAttribute) {
            return;
        }
        let position = positionAttribute[attributeId];
        particle.setInitialField(PARTICLE_FIELD_POSITION, position);
        particle.initialSkinnedPosition = position;
        let skinningAttribute = snapshot.attributes['skinning'];
        if (skinningAttribute) {
            particle.skinning = skinningAttribute[attributeId];
        }
        let hitboxAttribute = snapshot.attributes['hitbox'];
        if (hitboxAttribute) {
            particle.snapHitbox = hitboxAttribute[attributeId];
        }
        let hitboxOffsetAttribute = snapshot.attributes['hitbox_offset'];
        if (hitboxOffsetAttribute) {
            particle.snapHitboxOffset = hitboxOffsetAttribute[attributeId];
        }
        if (this.rigid) {
            return;
        }
        let bone, boneName, boneWeight, boneMat;
        let model = cp.model;
        if (!model) {
            return;
        }
        let skeleton = model.skeleton;
        if (!skeleton) {
            return;
        }
        let particleSkinning = particle.skinning;
        let particleInitialPosition = particle.initialSkinnedPosition;
        let particleInitialNormal = particle.initialSkinnedNormal ?? DEFAULT_PARTICLE_NORMAL;
        if (particleSkinning && particleInitialPosition) {
            mat$1[0] = 0;
            mat$1[1] = 0;
            mat$1[2] = 0;
            mat$1[4] = 0;
            mat$1[5] = 0;
            mat$1[6] = 0;
            mat$1[8] = 0;
            mat$1[9] = 0;
            mat$1[10] = 0;
            mat$1[12] = 0;
            mat$1[13] = 0;
            mat$1[14] = 0;
            for (let i = 0; i < 4; ++i) {
                boneName = particleSkinning.bones[i];
                if (boneName) {
                    bone = skeleton.getBoneByName(boneName);
                    boneWeight = particleSkinning.weights[i];
                    if (bone && boneWeight) {
                        boneMat = bone ? bone.boneMat : IDENTITY_MAT4$1;
                        mat$1[0] += boneWeight * boneMat[0];
                        mat$1[1] += boneWeight * boneMat[1];
                        mat$1[2] += boneWeight * boneMat[2];
                        mat$1[4] += boneWeight * boneMat[4];
                        mat$1[5] += boneWeight * boneMat[5];
                        mat$1[6] += boneWeight * boneMat[6];
                        mat$1[8] += boneWeight * boneMat[8];
                        mat$1[9] += boneWeight * boneMat[9];
                        mat$1[10] += boneWeight * boneMat[10];
                        mat$1[12] += boneWeight * boneMat[12];
                        mat$1[13] += boneWeight * boneMat[13];
                        mat$1[14] += boneWeight * boneMat[14];
                    }
                }
            }
            //console.error(mat);
            transformMat4$2(particle.position, particleInitialPosition, mat$1);
            normalFromMat4(nmat$2, mat$1);
            transformMat3$1(particle.normal, particleInitialNormal, nmat$2);
            copy$4(particle.prevPosition, particle.position);
        }
        else {
            //Probably should do it better, but it just works
            let particleHitbox = particle.snapHitbox;
            particle.snapHitboxOffset;
            if (particleHitbox) {
                bone = skeleton.getBoneByName(particleHitbox);
                if (bone) {
                    boneMat = bone ? bone.boneMat : IDENTITY_MAT4$1;
                    transformMat4$2(particle.position, particleInitialPosition, boneMat);
                    normalFromMat4(nmat$2, boneMat);
                    transformMat3$1(particle.normal, particleInitialNormal, nmat$2);
                    copy$4(particle.prevPosition, particle.position);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InitSkinnedPositionFromCPSnapshot', InitSkinnedPositionFromCPSnapshot);

const DEFAULT_INPUT_VALUE = create$4();
let v$d = create$3();
class InitVec extends Operator {
    setMethod = null;
    scaleInitialRange = false;
    fieldOutput = PARTICLE_FIELD_COLOR;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_InputValue':
                break;
            case 'm_nOutputField':
                this.fieldOutput = Number(value);
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_bScaleInitialRange':
                this.scaleInitialRange = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let inputValue = this.getParamVectorValue('m_InputValue', particle, v$d) ?? DEFAULT_INPUT_VALUE;
        particle.setField(this.fieldOutput, inputValue, this.scaleInitialRange || this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_INIT_InitVec', InitVec);

//Notice this is not the default particle normal.
//This operator change the default normal from +Z to +X
const DEFAULT_NORMAL = fromValues$4(1, 0, 0);
class NormalAlignToCP extends Operator {
    _paramChanged(paramName, value) {
        switch (paramName) {
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //This operator overrides the normal
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            //cp.getWorldTransformation(particle.cpPreviousTransform);
            transformQuat$1(particle.normal, DEFAULT_NORMAL, cp.currentWorldQuaternion);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_NormalAlignToCP', NormalAlignToCP);

const v$c = create$4();
class NormalOffset extends Operator {
    offsetMin = create$4();
    offsetMax = create$4();
    localCoords = false;
    normalize = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_OffsetMin':
                copy$4(this.offsetMin, value);
                break;
            case 'm_OffsetMax':
                copy$4(this.offsetMax, value);
                break;
            case 'm_bLocalCoords':
                this.localCoords = value;
                break;
            case 'm_bNormalize':
                this.normalize = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        vec3RandomBox(v$c, this.offsetMin, this.offsetMax);
        if (this.localCoords) {
            let cp = this.system.getControlPoint(this.controlPointNumber);
            transformQuat$1(v$c, v$c, cp.currentWorldQuaternion);
        }
        add$5(particle.normal, particle.normal, v$c);
        if (this.normalize) {
            normalize$5(particle.normal, particle.normal);
        }
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_NormalOffset', NormalOffset);

let v$b = create$4();
class OffsetVectorToVector extends Operator {
    outputMin = create$4();
    outputMax = fromValues$4(1, 1, 1);
    fieldOutput = PARTICLE_FIELD_POSITION;
    fieldInput = PARTICLE_FIELD_POSITION;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecOutputMin':
                copy$4(this.outputMin, value);
                break;
            case 'm_vecOutputMax':
                copy$4(this.outputMax, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        vec3RandomBox(v$b, this.outputMin, this.outputMax);
        add$5(v$b, v$b, particle.getField(this.fieldInput));
        if (this.fieldOutput == PARTICLE_FIELD_COLOR) {
            v$b[0] = ((v$b[0] % ONE_EPS) + ONE_EPS) % ONE_EPS;
            v$b[1] = ((v$b[1] % ONE_EPS) + ONE_EPS) % ONE_EPS;
            v$b[2] = ((v$b[2] % ONE_EPS) + ONE_EPS) % ONE_EPS;
        }
        particle.setField(this.fieldOutput, v$b);
    }
}
RegisterSource2ParticleOperator('C_INIT_OffsetVectorToVector', OffsetVectorToVector);

const DEFAULT_OFFSET = create$4();
const offset = create$4();
class PositionOffset extends Operator {
    localCoords = false;
    proportional = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_OffsetMin':
            case 'm_OffsetMax':
                break;
            case 'm_bLocalCoords':
                this.localCoords = value;
                break;
            case 'm_bProportional':
                this.proportional = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let offsetMin = this.getParamVectorValue('m_OffsetMin') ?? DEFAULT_OFFSET;
        let offsetMax = this.getParamVectorValue('m_OffsetMax') ?? DEFAULT_OFFSET;
        vec3RandomBox(offset, offsetMin, offsetMax);
        if (this.localCoords) {
            const cp = particle.system.getControlPoint(this.controlPointNumber);
            if (cp) {
                transformQuat$1(offset, offset, cp.getWorldQuaternion());
            }
        }
        add$5(particle.position, particle.position, offset);
        add$5(particle.prevPosition, particle.prevPosition, offset);
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_PositionOffset', PositionOffset);

let v$a = create$4();
class PositionWarp extends Operator {
    warpMin = fromValues$4(1, 1, 1);
    warpMax = fromValues$4(1, 1, 1);
    scaleControlPointNumber = -1;
    radiusComponent = -1;
    warpTime = 0;
    warpStartTime = 0;
    prevPosScale = 1;
    invertWarp = false;
    useCount = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecWarpMin':
                copy$4(this.warpMin, value);
                break;
            case 'm_vecWarpMax':
                copy$4(this.warpMax, value);
                break;
            case 'm_nScaleControlPointNumber':
                this.scaleControlPointNumber = Number(value);
                break;
            case 'm_nRadiusComponent':
                this.radiusComponent = Number(value); //TODO: check [-1 0 1 2]
                break;
            case 'm_flWarpTime':
                this.warpTime = value;
                break;
            case 'm_flWarpStartTime':
                this.warpStartTime = value;
                break;
            case 'm_flPrevPosScale':
                this.prevPosScale = value;
                break;
            case 'm_bInvertWarp':
                this.invertWarp = value;
                break;
            case 'm_bUseCount':
                this.useCount = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use time parameters, m_bUseCount
        vec3RandomBox(v$a, this.warpMin, this.warpMax);
        if (this.scaleControlPointNumber != -1) {
            let scaleCp = this.system.getControlPoint(this.scaleControlPointNumber);
            if (scaleCp) {
                mul$4(v$a, v$a, scaleCp._position); //Not sure if it's position or world position
            }
        }
        if (this.radiusComponent != -1) {
            particle.radius *= v$a[this.radiusComponent];
        }
        mul$4(particle.position, particle.position, v$a);
        mul$4(particle.prevPosition, particle.prevPosition, v$a);
        if (this.prevPosScale != -1) {
            scale$5(particle.prevPosition, particle.prevPosition, this.prevPosScale);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_PositionWarp', PositionWarp);

class RadiusFromCPObject extends Operator {
    #controlPoint = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nControlPoint':
                this.#controlPoint = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        // I don't really know what it is supposed to do
    }
}
RegisterSource2ParticleOperator('C_INIT_RadiusFromCPObject', RadiusFromCPObject);

class SequenceLifeTime extends Operator {
    doInit(particles, elapsedTime) {
        //TODOv3
    }
}
RegisterSource2ParticleOperator('C_INIT_SequenceLifeTime', SequenceLifeTime);

class RandomAlpha extends Operator {
    alphaMin = 255;
    alphaMax = 255;
    alphaRandExponent = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nAlphaMin':
                this.alphaMin = Number(value);
                break;
            case 'm_nAlphaMax':
                this.alphaMax = Number(value);
                break;
            case 'm_flAlphaRandExponent':
                this.alphaRandExponent = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let alpha = RandomFloatExp(this.alphaMin, this.alphaMax, this.alphaRandExponent) / 255.0;
        particle.alpha = alpha;
        particle.startAlpha = alpha;
        //TODO: use fieldOutput
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomAlpha', RandomAlpha);

class RandomColor extends Operator {
    colorMin = fromValues$4(1, 1, 1);
    colorMax = fromValues$4(1, 1, 1);
    tintMin = fromValues$4(0, 0, 0);
    tintMax = fromValues$4(1, 1, 1);
    updateThreshold = 32;
    tintCP = 0;
    tintBlendMode = null;
    lightAmplification = 1;
    tintPerc = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_ColorMin':
                set$5(this.colorMin, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_ColorMax':
                set$5(this.colorMax, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_TintMin':
                set$5(this.tintMin, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_TintMax':
                set$5(this.tintMax, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_flUpdateThreshold':
                this.updateThreshold = value;
                break;
            case 'm_nTintCP':
                this.tintCP = value;
                break;
            case 'm_nTintBlendMode':
                this.tintBlendMode = value;
                break;
            case 'm_flLightAmplification':
                this.lightAmplification = value;
                break;
            case 'm_flTintPerc':
                this.tintPerc = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use tint
        let rand = Math.random();
        lerp$5(particle.color, this.colorMin, this.colorMax, rand);
        copy$4(particle.initialColor, particle.color);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomColor', RandomColor);

class RandomLifeTime extends Operator {
    lifetimeMin = 0;
    lifetimeMax = 0;
    lifetimeRandExponent = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_fLifetimeMin':
                this.lifetimeMin = Number(value);
                break;
            case 'm_fLifetimeMax':
                this.lifetimeMax = Number(value);
                break;
            case 'm_fLifetimeRandExponent':
                this.lifetimeRandExponent = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.setInitialTTL(RandomFloatExp(this.lifetimeMin, this.lifetimeMax, this.lifetimeRandExponent));
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomLifeTime', RandomLifeTime);

class RandomRadius extends Operator {
    radiusMin = 1;
    radiusMax = 1;
    radiusRandExponent = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flRadiusMin':
                this.radiusMin = value;
                break;
            case 'm_flRadiusMax':
                this.radiusMax = value;
                break;
            case 'm_flRadiusRandExponent':
                this.radiusRandExponent = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.setInitialRadius(RandomFloatExp(this.radiusMin, this.radiusMax, this.radiusRandExponent));
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomRadius', RandomRadius);

class RandomRotation extends Operator {
    radians = 0;
    radiansMin = 0;
    radiansMax = TWO_PI;
    rotationRandExponent = 1;
    randomlyFlipDirection = false; //TODO: actual default value
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flDegreesMin':
                this.radiansMin = DEG_TO_RAD * value;
                break;
            case 'm_flDegreesMax':
                this.radiansMax = DEG_TO_RAD * value;
                break;
            case 'm_flDegrees':
                this.radians = DEG_TO_RAD * value;
                break;
            case 'm_flRotationRandExponent':
                this.rotationRandExponent = value;
                break;
            case 'm_bRandomlyFlipDirection':
                this.randomlyFlipDirection = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let rotation = this.radians + RandomFloatExp(this.radiansMin, this.radiansMax, this.rotationRandExponent);
        if (this.randomlyFlipDirection && (RandomFloat(-1, 1) >= 0)) {
            rotation -= rotation;
        }
        particle.setInitialField(/*this.fieldOutput*/ PARTICLE_FIELD_ROTATION_ROLL, rotation);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomRotation', RandomRotation);

class RandomRotationSpeed extends Operator {
    radians = 0;
    radiansMin = 0;
    radiansMax = TWO_PI;
    rotationRandExponent = 1;
    randomlyFlipDirection = false; //TODO: actual default value ?
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flDegreesMin':
                this.radiansMin = DEG_TO_RAD * value;
                break;
            case 'm_flDegreesMax':
                this.radiansMax = DEG_TO_RAD * value;
                break;
            case 'm_flDegrees':
                this.radians = DEG_TO_RAD * value;
                break;
            case 'm_nFieldOutput':
                //NOTE : this parameter seems to have no effect. It's always roll speed
                //this.fieldOutput = Number(value);
                break;
            case 'm_flRotationRandExponent':
                this.rotationRandExponent = value;
                break;
            case 'm_bRandomlyFlipDirection':
                this.randomlyFlipDirection = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let rotation = this.radians + RandomFloatExp(this.radiansMin, this.radiansMax, this.rotationRandExponent);
        if (this.randomlyFlipDirection && (RandomFloat(-1, 1) >= 0)) {
            rotation -= rotation;
        }
        //particle.setInitialField(this.fieldOutput, rotation);
        particle.rotationSpeedRoll = rotation;
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomRotationSpeed', RandomRotationSpeed);

class RandomScalar extends Operator {
    min = 0;
    max = 0;
    exponent = 1;
    fieldOutput = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flMin':
                this.min = value;
                break;
            case 'm_flMax':
                this.max = value;
                break;
            case 'm_flExponent':
                this.exponent = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.setInitialField(this.fieldOutput, RandomFloatExp(this.min, this.max, this.exponent));
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomScalar', RandomScalar);

class RandomSecondSequence extends Operator {
    sequenceMin = 0;
    sequenceMax = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nSequenceMin':
                this.sequenceMin = Number(value);
                break;
            case 'm_nSequenceMax':
                this.sequenceMax = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.sequence2 = Math.round((this.sequenceMax - this.sequenceMin) * Math.random()) + this.sequenceMin;
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomSecondSequence', RandomSecondSequence);

class RandomSequence extends Operator {
    sequenceMin = 0;
    sequenceMax = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nSequenceMin':
                this.sequenceMin = Number(value);
                break;
            case 'm_nSequenceMax':
                this.sequenceMax = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.setInitialSequence(Math.round((this.sequenceMax - this.sequenceMin) * Math.random()) + this.sequenceMin);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomSequence', RandomSequence);

class RandomTrailLength extends Operator {
    minLength = 0.1;
    maxLength = 0.1;
    lengthRandExponent = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flMinLength':
                this.minLength = Number(value);
                break;
            case 'm_flMaxLength':
                this.maxLength = Number(value);
                break;
            case 'm_flLengthRandExponent':
                this.lengthRandExponent = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.trailLength = RandomFloatExp(this.minLength, this.maxLength, this.lengthRandExponent);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomTrailLength', RandomTrailLength);

let tempVec3$3 = create$4();
class RandomVector extends Operator {
    vecMin = create$4();
    vecMax = create$4();
    fieldOutput = PARTICLE_FIELD_POSITION;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecMin':
                copy$4(this.vecMin, value);
                break;
            case 'm_vecMax':
                copy$4(this.vecMax, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        vec3RandomBox(tempVec3$3, this.vecMin, this.vecMax);
        particle.setField(this.fieldOutput, tempVec3$3);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomVector', RandomVector);

class RandomYaw extends Operator {
    radians = 0;
    radiansMin = 0;
    radiansMax = TWO_PI;
    rotationRandExponent = 1;
    randomlyFlipDirection; //TODO: search default value
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flDegreesMin':
                this.radiansMin = DEG_TO_RAD * value;
                break;
            case 'm_flDegreesMax':
                this.radiansMax = DEG_TO_RAD * value;
                break;
            case 'm_flDegrees':
                this.radians = DEG_TO_RAD * value;
                break;
            case 'm_flRotationRandExponent':
                this.rotationRandExponent = value;
                break;
            case 'm_bRandomlyFlipDirection':
                this.randomlyFlipDirection = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let rotation = this.radians + RandomFloatExp(this.radiansMin, this.radiansMax, this.rotationRandExponent);
        if (this.randomlyFlipDirection && (RandomFloat(-1, 1) >= 0)) {
            particle.rotationYaw -= rotation;
        }
        else {
            particle.rotationYaw += rotation;
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomYaw', RandomYaw);

class RandomYawFlip extends Operator {
    percent = 0.5;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flPercent':
                this.percent = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        particle.rotationYaw += (Math.random() < this.percent) ? Math.PI : 0;
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomYawFlip', RandomYawFlip);

class RemapCPtoScalar$1 extends Operator {
    cpInput = 0;
    field = 0; //X
    inputMin = 0;
    inputMax = 1;
    outputMin = 0;
    outputMax = 1;
    startTime = -1;
    endTime = -1;
    setMethod = null;
    remapBias = 0.5;
    scaleInitialRange; // TODO: search default value
    fieldOutput = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nCPInput':
                this.cpInput = Number(value);
                break;
            case 'm_nField':
                this.field = Number(value); //TODO: check [0, 1, 2]
                break;
            case 'm_flInputMin':
                this.inputMin = value;
                break;
            case 'm_flInputMax':
                this.inputMax = value;
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                break;
            case 'm_flStartTime':
                this.startTime = value;
                break;
            case 'm_flEndTime':
                this.endTime = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_flRemapBias':
                this.remapBias = value;
                break;
            case 'm_bScaleInitialRange':
                this.scaleInitialRange = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime, strength) {
        let cpInputPos = this.system.getControlPoint(this.cpInput).currentWorldPosition;
        let value = cpInputPos[this.field];
        value = RemapValClampedBias(value, this.inputMin, this.inputMax, this.outputMin, this.outputMax, this.remapBias);
        let scaleInitial = this.scaleInitialRange || this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE'; //TODO: optimize
        if (scaleInitial) {
            value = lerp(1, value, strength);
        }
        else {
            value = lerp(particle.getField(this.fieldOutput), value, strength);
        }
        particle.setField(this.fieldOutput, value, scaleInitial);
    }
}
RegisterSource2ParticleOperator('C_INIT_RemapCPtoScalar', RemapCPtoScalar$1);

let v$9 = create$4();
let v1 = fromValues$4(1, 1, 1);
class RemapCPtoVector extends Operator {
    cpInput = 0;
    inputMin = create$4();
    inputMax = create$4();
    outputMin = create$4();
    outputMax = create$4();
    startTime = -1;
    endTime = -1;
    setMethod = null;
    offset = false;
    accelerate = false;
    localSpaceCP = -1;
    remapBias = 0.5;
    scaleInitialRange; // TODO: search default value
    fieldOutput = PARTICLE_FIELD_POSITION;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nCPInput':
                this.cpInput = Number(value);
                break;
            case 'm_vInputMin':
                copy$4(this.inputMin, value);
                break;
            case 'm_vInputMax':
                copy$4(this.inputMax, value);
                break;
            case 'm_vOutputMin':
                copy$4(this.outputMin, value);
                break;
            case 'm_vOutputMax':
                copy$4(this.outputMax, value);
                break;
            case 'm_flStartTime':
                this.startTime = value;
                break;
            case 'm_flEndTime':
                this.endTime = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_bOffset':
                this.offset = value;
                break;
            case 'm_bAccelerate':
                this.accelerate = value;
                break;
            case 'm_nLocalSpaceCP':
                this.localSpaceCP = Number(value);
                break;
            case 'm_flRemapBias':
                this.remapBias = value;
                break;
            case 'm_bScaleInitialRange':
                this.scaleInitialRange = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime, strength) {
        let inputMin = this.inputMin;
        let inputMax = this.inputMax;
        let outputMin = this.outputMin;
        let outputMax = this.outputMax;
        let input = this.system.getControlPoint(this.cpInput).currentWorldPosition;
        v$9[0] = RemapValClampedBias(input[0], inputMin[0], inputMax[0], outputMin[0], outputMax[0], this.remapBias);
        v$9[1] = RemapValClampedBias(input[1], inputMin[1], inputMax[1], outputMin[1], outputMax[1], this.remapBias);
        v$9[2] = RemapValClampedBias(input[2], inputMin[2], inputMax[2], outputMin[2], outputMax[2], this.remapBias);
        let scaleInitial = this.scaleInitialRange || this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE'; //TODO: optimize
        if (scaleInitial) {
            lerp$5(v$9, v1, v$9, strength);
        }
        else {
            lerp$5(v$9, particle.getField(this.fieldOutput), v$9, strength);
        }
        particle.setField(this.fieldOutput, v$9, scaleInitial);
    }
}
RegisterSource2ParticleOperator('C_INIT_RemapCPtoVector', RemapCPtoVector);

class RemapParticleCountToScalar extends Operator {
    inputMin = 0;
    inputMax = 10;
    scaleControlPoint = -1;
    scaleControlPointField = -1;
    outputMin = 0;
    outputMax = 1;
    setMethod = null;
    activeRange = false;
    invert = false;
    wrap = false;
    remapBias = 0.5;
    fieldOutput = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nInputMin':
                this.inputMin = Number(value);
                break;
            case 'm_nInputMax':
                this.inputMax = Number(value);
                break;
            case 'm_nScaleControlPoint':
                this.scaleControlPoint = Number(value);
                break;
            case 'm_nScaleControlPointField':
                this.scaleControlPointField = Number(value);
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_bActiveRange':
                this.activeRange = value;
                break;
            case 'm_bInvert':
                this.invert = value;
                break;
            case 'm_bWrap':
                this.wrap = value;
                break;
            case 'm_flRemapBias':
                this.remapBias = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use bias, invert m_nScaleControlPointField parameters
        let value = particle.id;
        if (this.wrap) {
            value = value % (this.inputMax + 1);
        }
        if (this.activeRange && (value < this.inputMin || value > this.inputMax)) {
            return;
        }
        value = RemapValClampedBias(value, this.inputMin, this.inputMax, this.outputMin, this.outputMax, this.remapBias);
        particle.setField(this.fieldOutput, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_INIT_RemapParticleCountToScalar', RemapParticleCountToScalar);

let va$1 = create$4();
let o = create$4();
class RingWave extends Operator {
    evenDistribution = false;
    xyVelocityOnly = true;
    t = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flParticlesPerOrbit':
            case 'm_flInitialRadius':
            case 'm_flThickness':
            case 'm_flInitialSpeedMin':
            case 'm_flInitialSpeedMax':
            case 'm_flRoll':
            case 'm_flPitch':
            case 'm_flYaw':
                break;
            case 'm_bEvenDistribution':
                this.evenDistribution = value;
                break;
            case 'm_bXYVelocityOnly':
                this.xyVelocityOnly = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: use all parameters
        let particlesPerOrbit = this.getParamScalarValue('m_flParticlesPerOrbit') ?? -1; //even distribution count
        let initialRadius = this.getParamScalarValue('m_flInitialRadius') ?? 0;
        this.getParamScalarValue('m_flThickness') ?? 0;
        this.getParamScalarValue('m_flInitialSpeedMin') ?? 0;
        this.getParamScalarValue('m_flInitialSpeedMax') ?? 0;
        let roll = this.getParamScalarValue('m_flRoll') ?? 0;
        let pitch = this.getParamScalarValue('m_flPitch') ?? 0;
        let yaw = this.getParamScalarValue('m_flYaw') ?? 0;
        let theta;
        if (this.evenDistribution) {
            let step = particlesPerOrbit == -1 ? TWO_PI / this.system.livingParticles.length : TWO_PI / particlesPerOrbit;
            this.t += step;
            theta = this.t;
        }
        else {
            theta = Math.random() * TWO_PI;
        }
        set$5(va$1, initialRadius * Math.cos(theta), initialRadius * Math.sin(theta), 0);
        if (roll) {
            rotateX$2(va$1, va$1, o, roll * DEG_TO_RAD);
        }
        if (pitch) {
            rotateY$2(va$1, va$1, o, pitch * DEG_TO_RAD);
        }
        if (yaw) {
            rotateZ$2(va$1, va$1, o, yaw * DEG_TO_RAD);
        }
        let controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            transformMat4$2(va$1, va$1, controlPoint.currentWorldTransformation);
        }
        copy$4(particle.position, va$1);
        copy$4(particle.prevPosition, va$1);
    }
}
RegisterSource2ParticleOperator('C_INIT_RingWave', RingWave);

let v$8 = create$4();
class SetRigidAttachment extends Operator {
    localSpace = true;
    fieldOutput = PARTICLE_FIELD_POSITION_PREVIOUS;
    fieldInput = PARTICLE_FIELD_POSITION;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bLocalSpace':
                this.localSpace = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO : use m_bLocalSpace
        if (!this.localSpace) {
            throw 'code me';
        }
        sub$2(v$8, particle.getField(this.fieldInput), this.system.getControlPoint(this.controlPointNumber).currentWorldPosition);
        particle.setField(this.fieldOutput, v$8);
    }
}
RegisterSource2ParticleOperator('C_INIT_SetRigidAttachment', SetRigidAttachment);

const DEFAULT_SPEED = create$4();
const randomVector = create$4();
const tempVec3$2 = create$4();
class VelocityRandom extends Operator {
    ignoreDT = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_LocalCoordinateSystemSpeedMin':
            case 'm_LocalCoordinateSystemSpeedMax':
            case 'm_fSpeedMin':
            case 'm_fSpeedMax':
                break;
            case 'm_bIgnoreDT':
                this.ignoreDT = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doInit(particle, elapsedTime) {
        let localCoordinateSystemSpeedMin = this.getParamVectorValue('m_LocalCoordinateSystemSpeedMin') ?? DEFAULT_SPEED;
        let localCoordinateSystemSpeedMax = this.getParamVectorValue('m_LocalCoordinateSystemSpeedMax') ?? DEFAULT_SPEED;
        let speedMin = this.getParamScalarValue('m_fSpeedMin') ?? 0;
        let speedMax = this.getParamScalarValue('m_fSpeedMax') ?? 0;
        const randomSpeed = (speedMax - speedMin) * Math.random() + speedMin;
        if (exactEquals$4(localCoordinateSystemSpeedMin, DEFAULT_SPEED) &&
            exactEquals$4(localCoordinateSystemSpeedMax, DEFAULT_SPEED)) {
            random$5(randomVector);
        }
        else {
            vec3RandomBox(randomVector, localCoordinateSystemSpeedMin, localCoordinateSystemSpeedMax);
        }
        if (randomSpeed != 0) {
            random$5(tempVec3$2, randomSpeed);
            add$5(randomVector, randomVector, tempVec3$2);
        }
        const cp = particle.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            transformQuat$1(randomVector, randomVector, cp.getWorldQuaternion());
        }
        if (!this.ignoreDT) {
            scale$5(randomVector, randomVector, -elapsedTime);
        }
        add$5(particle.prevPosition, particle.prevPosition, randomVector);
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_VelocityRandom', VelocityRandom);

class BasicMovement extends Operator {
    gravity = create$4();
    drag = 0;
    maxConstraintPasses = 3;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_Gravity':
                copy$4(this.gravity, value);
                break;
            case 'm_fDrag':
                this.drag = value;
                break;
            case 'm_nMaxConstraintPasses':
                this.maxConstraintPasses = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        /*if (particle.id == 5) {
            console.error(particle.prevPosition, particle.position);
        }*/
        let adj_dt = (elapsedTime / this.system.previousElapsedTime) * ExponentialDecay((1.0 - Math.max(0.0, this.drag)), (1.0 / 30.0), elapsedTime);
        const accumulatedForces = clone$4(this.gravity);
        for (let force of this.system.forces.values()) {
            force.forceParticle(particle, elapsedTime, accumulatedForces);
        }
        const accFactor = scale$5(create$4(), accumulatedForces, elapsedTime * elapsedTime);
        let vecTemp = sub$2(create$4(), particle.position, particle.prevPosition);
        scale$5(vecTemp, vecTemp, adj_dt);
        add$5(vecTemp, vecTemp, accFactor);
        copy$4(particle.prevPosition, particle.position);
        add$5(particle.position, particle.position, vecTemp);
        this.system.stepConstraints(particle);
    }
}
RegisterSource2ParticleOperator('C_OP_BasicMovement', BasicMovement);

class ColorInterpolate extends Operator {
    colorFade = fromValues$4(1, 1, 1);
    fadeStartTime = 0;
    fadeEndTime = 1;
    easeInAndOut = false;
    fieldOutput = null;
    invTime;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        this.invTime = 1.0 / (this.fadeEndTime - this.fadeStartTime);
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_ColorFade':
                set$5(this.colorFade, Number(value[0]) / 255, Number(value[1]) / 255, Number(value[2]) / 255);
                break;
            case 'm_flFadeStartTime':
                this.fadeStartTime = value;
                this._update();
                break;
            case 'm_flFadeEndTime':
                this.fadeEndTime = value;
                this._update();
                break;
            case 'm_bEaseInAndOut':
                this.easeInAndOut = value;
                break;
            case 'm_bEaseInOut':
                this.easeInAndOut = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        clone$4(particle.initialColor);
        let proportionOfLife = Math.min(particle.currentTime / particle.timeToLive, 1.0);
        if (proportionOfLife < this.fadeStartTime) {
            return;
        }
        if (proportionOfLife < this.fadeEndTime) {
            const a = (proportionOfLife - this.fadeStartTime) * this.invTime;
            lerp$5(particle.color, particle.initialColor, this.colorFade, a);
            return;
        }
        copy$4(particle.color, this.colorFade);
    }
}
RegisterSource2ParticleOperator('C_OP_ColorInterpolate', ColorInterpolate);

let v$7 = create$4();
class DampenToCP extends Operator {
    range = 100;
    scale = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flRange':
                this.range = value;
                break;
            case 'm_flScale':
                this.scale = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.controlPointNumber);
        let distance = distance$3(particle.position, cp.currentWorldPosition);
        if (distance > this.range) {
            return;
        }
        else {
            let dampenAmount = distance / this.range;
            sub$2(v$7, particle.position, particle.prevPosition);
            scale$5(v$7, v$7, dampenAmount);
            add$5(particle.position, particle.prevPosition, v$7);
            //TODO: operator strength
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DampenToCP', DampenToCP);

class DistanceBetweenCPs extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    startCP = 0;
    endCP = 1;
    maxTraceLength = -1;
    losScale = 0;
    collisionGroupName = 'NONE';
    los = false;
    setMethod = null;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nStartCP':
                this.startCP = Number(value);
                break;
            case 'm_nEndCP':
                this.endCP = Number(value);
                break;
            case 'm_flInputMin':
            case 'm_flInputMax':
            case 'm_flOutputMin':
            case 'm_flOutputMax':
                break;
            case 'm_flMaxTraceLength':
                this.maxTraceLength = value;
                break;
            case 'm_flLOSScale':
                this.losScale = value;
                break;
            case 'm_CollisionGroupName':
                this.collisionGroupName = value;
                break;
            case 'm_bLOS':
                this.los = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let inputMin = this.getParamScalarValue('m_flInputMin') ?? 0;
        let inputMax = this.getParamScalarValue('m_flInputMax') ?? 128;
        let outputMin = this.getParamScalarValue('m_flOutputMin') ?? 0;
        let outputMax = this.getParamScalarValue('m_flOutputMax') ?? 1;
        //TODO: los and other parameters
        let startCpPos = this.system.getControlPoint(this.startCP).currentWorldPosition;
        let endCPPos = this.system.getControlPoint(this.endCP).currentWorldPosition;
        let value = distance$3(startCpPos, endCPPos);
        value = RemapValClamped(value, inputMin, inputMax, outputMin, outputMax);
        particle.setField(this.fieldOutput, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_DistanceBetweenCPs', DistanceBetweenCPs);

let vec$3 = create$4();
class DistanceCull extends Operator {
    pointOffset = create$4();
    distance = 0;
    cullInside = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nControlPoint':
                this.controlPointNumber = Number(value);
                break;
            case 'm_vecPointOffset':
                copy$4(this.pointOffset, value);
                break;
            case 'm_flDistance':
                this.distance = value;
                break;
            case 'm_bCullInside':
                this.cullInside = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            let origin = cp.getWorldPosition(vec$3);
            add$5(origin, origin, this.pointOffset);
            if (this.cullInside) { //TODO: improve this
                if (distance$3(particle.position, origin) < this.distance) {
                    particle.die();
                }
            }
            else {
                if (distance$3(particle.position, origin) > this.distance) {
                    particle.die();
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DistanceCull', DistanceCull);

const DEFAULT_COMPONENT_SCALE = fromValues$4(1, 1, 1);
class DistanceToCP extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    inputMin = 0;
    inputMax = 128;
    outputMin = 0;
    outputMax = 1;
    startCP = 0;
    los = true;
    collisionGroupName = '';
    maxTraceLength = -1;
    losScale = 0;
    setMethod = null;
    activeRange = false;
    ;
    additive = false;
    scaleInitialRange = false;
    outputMin1;
    outputMax1;
    _update() {
        if (ATTRIBUTES_WHICH_ARE_0_TO_1 & (1 << this.fieldOutput)) {
            this.outputMin1 = clamp(this.outputMin, 0, 1);
            this.outputMax1 = clamp(this.outputMax, 0, 1);
        }
        else {
            this.outputMin1 = this.outputMin;
            this.outputMax1 = this.outputMax;
        }
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecComponentScale':
                break;
            case 'm_nFieldOutput':
                this.fieldOutput = Number(value);
                this._update();
                break;
            case 'm_flInputMin':
                this.inputMin = value;
                break;
            case 'm_flInputMax':
                this.inputMax = value;
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                this._update();
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                this._update();
                break;
            case 'm_nStartCP':
                this.startCP = Number(value);
                break;
            case 'm_bLOS':
                this.los = value;
                break;
            case 'm_CollisionGroupName':
                this.collisionGroupName = value;
                break;
            case 'm_flMaxTraceLength':
                this.maxTraceLength = value;
                break;
            case 'm_flLOSScale':
                this.losScale = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_bActiveRange':
                this.activeRange = value;
                break;
            case 'm_bAdditive':
                this.additive = value;
                break;
            case 'm_bScaleInitialRange':
                this.scaleInitialRange = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime, flStrength = 1) {
        this.getParamVectorValue('m_vecComponentScale') ?? DEFAULT_COMPONENT_SCALE;
        let flMin = this.outputMin1;
        let flMax = this.outputMax1;
        /*if ( ATTRIBUTES_WHICH_ARE_0_TO_1 & ( 1 << m_nFieldOutput ) )
        {
            flMin = clamp(m_flOutputMin, 0.0f, 1.0f );
            flMax = clamp(m_flOutputMax, 0.0f, 1.0f );
        }*/
        //Vector vecControlPoint1 = pParticles->GetControlPointAtCurrentTime( m_nStartCP );
        const vecControlPoint1 = this.system.getControlPointPosition(this.startCP);
        //let vecPosition2 = vec3.create();
        let vecDelta = create$4();
        let vecEndPoint = create$4();
        // FIXME: SSE-ize
        //for ( int i = 0; i < pParticles->m_nActiveParticles; ++i )
        {
            //Vector vecPosition2;
            //const float *pXYZ = pParticles->GetFloatAttributePtr(PARTICLE_ATTRIBUTE_XYZ, i );
            //vecPosition2 = Vector(pXYZ[0], pXYZ[4], pXYZ[8]);
            //vec3.copy(vecPosition2, particle.position);
            //Vector vecDelta = vecControlPoint1 - vecPosition2;
            sub$2(vecDelta, vecControlPoint1, particle.position);
            let flDistance = length$5(vecDelta); //vecDelta.Length();
            if (this.activeRange && (flDistance < this.inputMin || flDistance > this.inputMax)) {
                return; //continue;
            }
            if (this.los) {
                //Vector vecEndPoint = vecPosition2;
                copy$4(vecEndPoint, particle.position);
                if (this.maxTraceLength != -1.0 && this.maxTraceLength < flDistance) {
                    //VectorNormalize(vecEndPoint);
                    normalize$5(vecEndPoint, vecEndPoint);
                    //vecEndPoint *= m_flMaxTraceLength;
                    scale$5(vecEndPoint, vecEndPoint, this.maxTraceLength);
                    //vecEndPoint += vecControlPoint1;
                    add$5(vecEndPoint, vecEndPoint, vecControlPoint1);
                }
                /*CBaseTrace tr;
                g_pParticleSystemMgr->Query()->TraceLine( vecControlPoint1, vecEndPoint, MASK_OPAQUE_AND_NPCS, NULL , m_nCollisionGroupNumber, &tr );
                if (tr.fraction != 1.0f)
                {
                    flDistance *= tr.fraction * m_flLOSScale;
                }*/
                //TODO
            }
            let flOutput = RemapValClamped(flDistance, this.inputMin, this.inputMax, flMin, flMax);
            /*if ( m_bScaleInitialRange )
            {
                const float *pInitialOutput = pParticles->GetInitialFloatAttributePtr( m_nFieldOutput, i );
                flOutput = *pInitialOutput * flOutput;
            }*/
            //float *pOutput = pParticles->GetFloatAttributePtrForWrite( m_nFieldOutput, i );
            //TODO: use m_nSetMethod m_bActiveRange m_bAdditive m_bScaleInitialRange
            let output = particle.getField(this.fieldOutput);
            //*pOutput = Lerp (flStrength, *pOutput, flOutput);
            output = lerp(output, flOutput, flStrength);
            particle.setField(this.fieldOutput, output);
            //float *pOutput = pParticles->GetFloatAttributePtrForWrite( m_nFieldOutput, i );
            //float flOutput = RemapValClamped( flDistance, m_flInputMin, m_flInputMax, flMin, flMax  );
            //*pOutput = Lerp (flStrength, *pOutput, flOutput);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DistanceToCP', DistanceToCP);

class FadeAndKill extends Operator {
    startAlpha = 1;
    startFadeInTime = 0;
    endFadeInTime = 0.5;
    startFadeOutTime = 0.5;
    endFadeOutTime = 1.0;
    endAlpha = 0;
    forcePreserveParticleOrder = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flStartAlpha':
                this.startAlpha = value;
                break;
            case 'm_flStartFadeInTime':
                this.startFadeInTime = value;
                break;
            case 'm_flEndFadeInTime':
                this.endFadeInTime = value;
                break;
            case 'm_flStartFadeOutTime':
                this.startFadeOutTime = value;
                break;
            case 'm_flEndFadeOutTime':
                this.endFadeOutTime = value;
                break;
            case 'm_flEndAlpha':
                this.endAlpha = value;
                break;
            case 'm_bForcePreserveParticleOrder':
                this.forcePreserveParticleOrder = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO:use forcePreserveParticleOrder
        const startAlpha = this.startAlpha;
        const endAlpha = this.endAlpha;
        const startFadeInTime = this.startFadeInTime;
        const endFadeInTime = this.endFadeInTime;
        const startFadeOutTime = this.startFadeOutTime;
        const endFadeOutTime = this.endFadeOutTime;
        const proportionOfLife = particle.currentTime / particle.timeToLive;
        const fl4FadeInDuration = endFadeInTime - startFadeInTime;
        const fl4OOFadeInDuration = 1.0 / fl4FadeInDuration;
        const fl4FadeOutDuration = endFadeOutTime - startFadeOutTime;
        const fl4OOFadeOutDuration = 1.0 / fl4FadeOutDuration;
        let fl4Goal, fl4NewAlpha;
        switch (true) {
            case proportionOfLife <= startFadeInTime:
                break;
            case proportionOfLife < endFadeInTime:
                fl4Goal = particle.startAlpha * startAlpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, startFadeInTime, fl4FadeInDuration, fl4OOFadeInDuration, fl4Goal, particle.startAlpha - fl4Goal);
                particle.alpha = fl4NewAlpha;
                break;
            case proportionOfLife < startFadeOutTime:
                break;
            case proportionOfLife < endFadeOutTime:
                fl4Goal = particle.startAlpha * endAlpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, startFadeOutTime, fl4FadeOutDuration, fl4OOFadeOutDuration, particle.startAlpha, fl4Goal - particle.startAlpha);
                particle.alpha = fl4NewAlpha;
                break;
        }
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
RegisterSource2ParticleOperator('C_OP_FadeAndKill', FadeAndKill);

class FadeIn extends Operator {
    fadeInTimeMin = 0.25;
    fadeInTimeMax = 0.25;
    fadeInTimeExp = 1;
    proportional = true;
    fadeInTime;
    invFadeInTime;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        //TODO: this is wrong: must be done per particle
        this.fadeInTime = RandomFloatExp(this.fadeInTimeMin, this.fadeInTimeMax, this.fadeInTimeExp);
        this.invFadeInTime = 1.0 / this.fadeInTime;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flFadeInTimeMin':
                this.fadeInTimeMin = value;
                this._update();
                break;
            case 'm_flFadeInTimeMax':
                this.fadeInTimeMax = value;
                this._update();
                break;
            case 'm_flFadeInTimeExp':
                this.fadeInTimeExp = value;
                this._update();
                break;
            case 'm_bProportional':
                this.proportional = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, 0, this.fadeInTime, this.invFadeInTime, 0, particle.startAlpha);
    }
}
RegisterSource2ParticleOperator('C_OP_FadeIn', FadeIn);

class FadeInSimple extends Operator {
    fadeInTime = 0.25;
    invFadeInTime = 0.25;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        this.invFadeInTime = 1.0 / this.fadeInTime;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flFadeInTime':
                this.fadeInTime = value;
                this._update();
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let proportionOfLife = particle.currentTime / particle.timeToLive;
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, 0, this.fadeInTime, this.invFadeInTime, 0, particle.startAlpha);
        //TODO: use fieldOutput
    }
}
RegisterSource2ParticleOperator('C_OP_FadeInSimple', FadeInSimple);

class FadeOut extends Operator {
    #fadeOutTimeMin = 0.25;
    #fadeOutTimeMax = 0.25;
    #fadeOutTimeExp = 1;
    #proportional = true;
    #fadeOutTime = 0;
    #startFadeOutTime = 0;
    #invFadeOutTime = 0;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        //TODO: this is wrong: must be done per particle
        this.#fadeOutTime = RandomFloatExp(this.#fadeOutTimeMin, this.#fadeOutTimeMax, this.#fadeOutTimeExp);
        this.#startFadeOutTime = 1.0 - this.#fadeOutTime;
        this.#invFadeOutTime = 1.0 / this.#fadeOutTime;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flFadeOutTimeMin':
                this.#fadeOutTimeMin = value;
                this._update();
                break;
            case 'm_flFadeOutTimeMax':
                this.#fadeOutTimeMax = value;
                this._update();
                break;
            case 'm_flFadeOutTimeExp':
                this.#fadeOutTimeExp = value;
                this._update();
                break;
            case 'm_bProportional':
                this.#proportional = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, 0, this.fadeInTime, this.invFadeInTime, 0, particle.startAlpha);
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.#proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, this.#startFadeOutTime, this.#fadeOutTime, this.#invFadeOutTime, particle.startAlpha, -particle.startAlpha);
        //TODO: if not proportional, set start time per particle
    }
}
RegisterSource2ParticleOperator('C_OP_FadeOut', FadeOut);

class FadeOutSimple extends Operator {
    fadeOutTime = 0.25;
    startFadeOutTime;
    invFadeOutTime;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        this.startFadeOutTime = 1.0 - this.fadeOutTime;
        this.invFadeOutTime = 1.0 / this.fadeOutTime;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flFadeOutTime':
                this.fadeOutTime = value;
                this._update();
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(particle.proportionOfLife, this.startFadeOutTime, this.fadeOutTime, this.invFadeOutTime, particle.startAlpha, -particle.startAlpha);
        //TODO: use fieldOutput
    }
}
RegisterSource2ParticleOperator('C_OP_FadeOutSimple', FadeOutSimple);

class InterpolateRadius extends Operator {
    startTime = 0;
    endTime = 1;
    startScale = 1;
    endScale = 1;
    easeInAndOut = false;
    bias = 0.5;
    invTime;
    biasParam;
    scaleWidth;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        this.invTime = 1.0 / (this.endTime - this.startTime);
        this.biasParam = 1.0 / this.bias - 2;
        this.scaleWidth = this.endScale - this.startScale;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flStartTime':
                this.startTime = value;
                this._update();
                break;
            case 'm_flEndTime':
                this.endTime = value;
                this._update();
                break;
            case 'm_flStartScale':
                this.startScale = value;
                this._update();
                break;
            case 'm_flEndScale':
                this.endScale = value;
                this._update();
                break;
            case 'm_bEaseInAndOut':
                this.easeInAndOut = value;
                break;
            case 'm_flBias':
                this.bias = value;
                this._update();
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        const fl4LifeDuration = particle.timeToLive;
        let fl4GoodMask = CmpGtSIMD(fl4LifeDuration, 0);
        const fl4CurTime = this.system.currentTime;
        const fl4LifeTime = MulSIMD(SubSIMD(fl4CurTime, particle.cTime), ReciprocalEstSIMD(fl4LifeDuration)); // maybe need accurate div here?
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpGeSIMD(fl4LifeTime, this.startTime));
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpLtSIMD(fl4LifeTime, this.endTime));
        fl4GoodMask = (fl4LifeDuration > 0) && (fl4LifeTime >= this.startTime) && (fl4LifeTime < this.endTime);
        if (fl4GoodMask /* IsAnyNegative(fl4GoodMask) */) {
            let fl4FadeWindow = MulSIMD(SubSIMD(fl4LifeTime, this.startTime), this.invTime);
            if (this.easeInAndOut) {
                fl4FadeWindow = AddSIMD(this.startScale, MulSIMD(SimpleSpline(fl4FadeWindow), this.scaleWidth));
            }
            else {
                if (this.bias != 0.5) {
                    fl4FadeWindow = AddSIMD(this.startScale, MulSIMD(BiasSIMD(fl4FadeWindow, this.biasParam), this.scaleWidth));
                }
                else {
                    fl4FadeWindow = AddSIMD(this.startScale, MulSIMD(fl4FadeWindow, this.scaleWidth));
                }
            }
            if (fl4GoodMask) {
                particle.radius = fl4FadeWindow * particle.initialRadius;
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_InterpolateRadius', InterpolateRadius);

class LifespanDecay extends Operator {
    _paramChanged(paramName, value) {
        switch (paramName) {
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
RegisterSource2ParticleOperator('C_OP_Decay', LifespanDecay);

class LockToBone extends Operator {
    hitboxSetName = 'default';
    lifeTimeFadeStart = 0;
    lifeTimeFadeEnd = 0;
    jumpThreshold = 100;
    prevPosScale = 1;
    rigid = false;
    useBones = false;
    rotationSetType = null;
    rigidRotationLock = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_HitboxSetName':
                this.hitboxSetName = value;
                break;
            case 'm_flLifeTimeFadeStart':
                this.lifeTimeFadeStart = value;
                break;
            case 'm_flLifeTimeFadeEnd':
                this.lifeTimeFadeEnd = value;
                break;
            case 'm_flJumpThreshold':
                this.jumpThreshold = value;
                break;
            case 'm_flPrevPosScale':
                this.prevPosScale = value;
                break;
            case 'm_bRigid':
                this.rigid = value;
                break;
            case 'm_bUseBones':
                this.useBones = value;
                break;
            case 'm_nRotationSetType':
                this.rotationSetType = Number(value);
                break;
            case 'm_bRigidRotationLock':
                this.rigidRotationLock = value;
                break;
            case 'm_vecRotation':
            case 'm_flRotLerp':
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //console.error('TODO');
    }
}
RegisterSource2ParticleOperator('C_OP_LockToBone', LockToBone);

let vec$2 = create$4();
class MaintainSequentialPath extends Operator {
    numToAssign = 100;
    assignedSoFar = 0;
    step = 0.01;
    loop = true;
    bounceDirection = 1;
    maxDistance = 0;
    cpPairs = false;
    saveOffset = false;
    startControlPointNumber = 0;
    endControlPointNumber = 0;
    bulgeControl = 0;
    bulge = 0;
    midPoint = 0.5;
    startPointOffset = create$4();
    midPointOffset = create$4();
    endOffset = create$4();
    operateAllParticlesRemoveme = true;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flNumToAssign':
                this.numToAssign = value;
                this.step = 1 / (value - 1);
                break;
            case 'm_bLoop':
                this.loop = value;
                break;
            case 'm_PathParams':
                for (let subName of Object.keys(value)) {
                    this._paramChanged(subName, value[subName]);
                }
                break;
            case 'm_fMaxDistance':
                this.maxDistance = value;
                break;
            case 'm_bCPPairs':
                this.cpPairs = value;
                break;
            case 'm_bSaveOffset':
                this.saveOffset = value;
                break;
            case 'm_nStartControlPointNumber':
                this.startControlPointNumber = Number(value);
                break;
            case 'm_nEndControlPointNumber':
                this.endControlPointNumber = Number(value);
                break;
            case 'm_nBulgeControl':
                this.bulgeControl = Number(value);
                break;
            case 'm_flBulge':
                this.bulge = value;
                break;
            case 'm_flMidPoint':
                this.midPoint = value;
                break;
            case 'm_vStartPointOffset':
                copy$4(this.startPointOffset, value);
                break;
            case 'm_vMidPointOffset':
                copy$4(this.midPointOffset, value);
                break;
            case 'm_vEndOffset':
                copy$4(this.endOffset, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particles, elapsedTime) {
        let t = create$4();
        //TODO: use other parameters
        let startControlPointNumber = this.startControlPointNumber;
        let endControlPointNumber = this.endControlPointNumber;
        let startControlPoint = this.system.getControlPoint(startControlPointNumber);
        let endControlPoint = this.system.getControlPoint(endControlPointNumber);
        if (startControlPoint && endControlPoint) {
            let numToAssign = this.numToAssign;
            let assignedSoFar = this.assignedSoFar;
            let particle;
            let delta = startControlPoint.deltaPosFrom(endControlPoint, vec$2);
            for (let i = 0; i < particles.length; ++i) {
                particle = particles[i];
                scale$5(t, delta, assignedSoFar * this.step);
                add$5(particle.position, startControlPoint.currentWorldPosition, t);
                copy$4(particle.prevPosition, particle.position);
                assignedSoFar += this.bounceDirection;
                if (assignedSoFar >= numToAssign || assignedSoFar < 0) {
                    if (this.loop) {
                        assignedSoFar = 0;
                        this.bounceDirection = 1;
                    }
                    else {
                        this.bounceDirection = -this.bounceDirection;
                    }
                }
            }
            this.assignedSoFar = assignedSoFar;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_MaintainSequentialPath', MaintainSequentialPath);

//const tempMat4 = mat4.create();
create$4();
create$4();
let v$6 = create$4();
class MovementRigidAttachToCP extends Operator {
    scaleControlPoint = -1;
    scaleCPField = 0; //-1: disabled, 0: X, 1: Y, 2 :Z
    fieldInput = PARTICLE_FIELD_POSITION_PREVIOUS;
    fieldOutput = PARTICLE_FIELD_POSITION;
    offsetLocal = true;
    constructor(system) {
        super(system);
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nScaleControlPoint':
                this.scaleControlPoint = Number(value);
                break;
            case 'm_nScaleCPField':
                this.scaleCPField = Number(value);
                break;
            case 'm_bOffsetLocal':
                this.offsetLocal = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: use scale cp and other parameters
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            /*if (!particle.initialCPPosition) {
                particle.initialCPPosition = vec3.clone(cp.getWorldPosition(vec));
            } else {
                vec3.copy(particle.initialCPPosition, particle.cpPosition);
            }

            particle.cpPosition = vec3.clone(cp.getWorldPosition(vec));

            const delta = vec3.subtract(vec3.create(), particle.cpPosition, particle.initialCPPosition);

            const deltaL = vec3.length(delta);
            particle.deltaL = particle.deltaL ?? 0;
            particle.deltaL += deltaL;

            //console.log(deltaL);
            if (this.range != 0 && particle.deltaL > this.range) {
                particle.posLockedToCP = -1;
            }

            mat4.invert(tempMat4, particle.cpPreviousTransform);

            let currentTransform = cp.getWorldTransformation(particle.cpPreviousTransform);//store the current tranform in the previous transform since we won't use it further
            mat4.mul(tempMat4, currentTransform, tempMat4);


            vec3.transformMat4(particle.position, particle.position, tempMat4);
            vec3.transformMat4(particle.prevPosition, particle.prevPosition, tempMat4);*/
            let delta;
            if (!particle.MovementRigidAttachToCP) {
                //TODO: this is dumb. try to do it better
                delta = cp.currentWorldTransformation;
                particle.MovementRigidAttachToCP = true;
            }
            else {
                delta = cp.deltaWorldTransformation;
            }
            //vec3.transformMat4(particle.position, particle.position, delta);
            //vec3.transformMat4(particle.prevPosition, particle.prevPosition, delta);
            transformMat4$2(v$6, particle.getField(this.fieldInput), delta);
            particle.setField(this.fieldInput, v$6);
            particle.setField(this.fieldOutput, v$6);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_MovementRigidAttachToCP', MovementRigidAttachToCP);

let m4 = create$5();
let q$1 = create$2();
let v$5 = create$4();
let a = create$3();
const DEFAULT_AXIS = fromValues$4(0, 0, 1);
class MovementRotateParticleAroundAxis extends Operator {
    localSpace = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecRotAxis':
            case 'm_flRotRate':
                break;
            case 'm_nCP':
                this.controlPointNumber = Number(value);
                break;
            case 'm_bLocalSpace':
                this.localSpace = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let axis = normalize$5(a, this.getParamVectorValue('m_vecRotAxis', particle, a) ?? DEFAULT_AXIS);
        let rotationRate = this.getParamScalarValue('m_flRotRate') ?? 180;
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (this.localSpace) {
            copy$2(q$1, cp.currentWorldQuaternion);
        }
        else {
            identity$1(q$1);
        }
        transformQuat$1(axis, axis, q$1);
        identity$2(m4);
        rotate$1(m4, m4, DEG_TO_RAD * rotationRate * elapsedTime * elapsedTime, axis);
        sub$2(v$5, particle.position, cp.currentWorldPosition);
        //TODO: should we do previous position too ?
        transformMat4$2(v$5, v$5, m4);
        add$5(particle.position, v$5, cp.currentWorldPosition);
    }
}
RegisterSource2ParticleOperator('C_OP_MovementRotateParticleAroundAxis', MovementRotateParticleAroundAxis);

const Coord$1 = create$4();
class Noise extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    outputMin = 0;
    outputMax = 1;
    noiseScale = 0.1;
    additive = false;
    noiseAnimationTimeScale = 0;
    outputMin1;
    outputMax1;
    valueScale;
    valueBase;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        if (ATTRIBUTES_WHICH_ARE_ANGLES & (1 << this.fieldOutput)) {
            this.outputMin1 = this.outputMin * DEG_TO_RAD;
            this.outputMax1 = this.outputMax * DEG_TO_RAD;
        }
        else {
            this.outputMin1 = this.outputMin;
            this.outputMax1 = this.outputMax;
        }
        this.valueScale = 0.5 * (this.outputMax1 - this.outputMin1);
        this.valueBase = this.outputMin1 + this.valueScale;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nFieldOutput':
                this.fieldOutput = Number(value);
                this._update();
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                this._update();
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                this._update();
                break;
            case 'm_fl4NoiseScale':
                this.noiseScale = value;
                break;
            case 'm_bAdditive':
                this.additive = value;
                break;
            case 'm_flNoiseAnimationTimeScale':
                this.noiseAnimationTimeScale = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        scale$5(Coord$1, particle.position, this.noiseScale);
        let noise = NoiseSIMD(Coord$1, 0, 0) * this.valueScale + this.valueBase;
        particle.setField(this.fieldOutput, noise);
        //TODO: use m_fl4NoiseScale m_bAdditive m_flNoiseAnimationTimeScale
    }
}
RegisterSource2ParticleOperator('C_OP_Noise', Noise);

let v$4 = create$4();
class NormalizeVector extends Operator {
    fieldOutput = PARTICLE_FIELD_POSITION;
    scale = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flScale':
                this.scale = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        copy$4(v$4, particle.getField(this.fieldOutput));
        normalize$5(v$4, v$4);
        scale$5(v$4, v$4, this.scale);
        particle.setField(this.fieldOutput, v$4);
    }
}
RegisterSource2ParticleOperator('C_OP_NormalizeVector', NormalizeVector);

//const mat = mat4.create();
const nmat$1 = create$6();
class NormalLock extends Operator {
    _paramChanged(paramName, value) {
        switch (paramName) {
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            //mat4.invert(mat, particle.cpPreviousTransform);
            //let currentTransform = cp.getWorldTransformation(particle.cpPreviousTransform);//store the current tranform in the previous transform since we won't use it further
            //mat4.mul(mat, currentTransform, mat);
            normalFromMat4(nmat$1, cp.deltaWorldTransformation);
            transformMat3$1(particle.normal, particle.normal, nmat$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_NormalLock', NormalLock);

class OscillateScalar extends Operator {
    rateMin = 0;
    rateMax = 0;
    frequencyMin = 1;
    frequencyMax = 1;
    field = PARTICLE_FIELD_ALPHA;
    proportional = true;
    proportionalOp = true;
    startTimeMin = 0;
    startTimeMax = 0;
    endTimeMin = 1;
    endTimeMax = 1;
    oscMult = 2;
    oscAdd = 0.5;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_RateMin':
                this.rateMin = value;
                break;
            case 'm_RateMax':
                this.rateMax = value;
                break;
            case 'm_FrequencyMin':
                this.frequencyMin = value;
                break;
            case 'm_FrequencyMax':
                this.frequencyMax = value;
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            case 'm_bProportional':
                this.proportional = value;
                break;
            case 'm_bProportionalOp':
                this.proportionalOp = value;
                break;
            case 'm_flStartTime_min':
                this.startTimeMin = value;
                break;
            case 'm_flStartTime_max':
                this.startTimeMax = value;
                break;
            case 'm_flEndTime_min':
                this.endTimeMin = value;
                break;
            case 'm_flEndTime_max':
                this.endTimeMax = value;
                break;
            case 'm_flOscMult':
                this.oscMult = value;
                break;
            case 'm_flOscAdd':
                this.oscAdd = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let fl4StartTimeWidth = this.startTimeMax - this.startTimeMin;
        let fl4EndTimeWidth = this.endTimeMax - this.endTimeMin;
        let fl4FrequencyWidth = this.frequencyMax - this.frequencyMin;
        let fl4RateWidth = this.rateMax - this.rateMin;
        let fl4ScaleFactor = /*flStrength * */ elapsedTime;
        let fl4CosFactor = this.oscMult * particle.currentTime + this.oscAdd;
        if (particle.timeToLive) {
            let fl4LifeTime;
            if (this.proportionalOp) {
                fl4LifeTime = particle.proportionOfLife;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            let fl4StartTime = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            fl4StartTime = this.startTimeMin + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            let fl4EndTime = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            fl4EndTime = this.endTimeMin + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                let fl4Frequency = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset);
                fl4Frequency = this.frequencyMin + fl4FrequencyWidth * fl4Frequency;
                //TODO: use random table
                let fl4Rate = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 1);
                fl4Rate = this.rateMin + fl4RateWidth * fl4Rate;
                let fl4Cos;
                if (this.proportional) {
                    fl4LifeTime = (particle.currentTime - particle.cTime) / particle.timeToLive;
                    fl4Cos = ((this.oscMult * (fl4LifeTime * fl4Frequency)) + this.oscAdd);
                }
                else {
                    fl4Cos = fl4CosFactor * fl4Frequency;
                }
                let fl4OscMultiplier = fl4Rate * fl4ScaleFactor;
                let fl4OscVal = particle.getField(this.field) + fl4OscMultiplier * Math.sin(fl4Cos * Math.PI);
                if (this.field == PARTICLE_FIELD_ALPHA) {
                    fl4OscVal = clamp(fl4OscVal, 0.0, 1.0);
                }
                particle.setField(this.field, fl4OscVal);
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateScalar', OscillateScalar);

class OscillateScalarSimple extends Operator {
    rate = 0;
    frequency = 1;
    field = PARTICLE_FIELD_ALPHA;
    oscMult = 2;
    oscAdd = 0.5;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_Rate':
                this.rate = value;
                break;
            case 'm_Frequency':
                this.frequency = value;
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            case 'm_flOscMult':
                this.oscMult = value;
                break;
            case 'm_flOscAdd':
                this.oscAdd = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let currentTime = this.system.currentTime;
        let sinFactor = (this.oscMult * currentTime + this.oscAdd) * this.frequency;
        let value = particle.getField(this.field) + this.rate * Math.sin(sinFactor * Math.PI) * DEG_TO_RAD; //DEG_TO_RAD seems to apply to all field even radius, alpha and so on. Valve style
        if (this.field == PARTICLE_FIELD_ALPHA) {
            value = clamp(value, 0.0, 1.0);
        }
        particle.setField(this.field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateScalarSimple', OscillateScalarSimple);

class OscillateVector extends Operator {
    rateMin = create$4();
    rateMax = create$4();
    frequencyMin = fromValues$4(1, 1, 1);
    frequencyMax = fromValues$4(1, 1, 1);
    field = 0;
    proportional = true;
    proportionalOp = true;
    offset = true;
    startTimeMin = 0;
    startTimeMax = 0;
    endTimeMin = 1;
    endTimeMax = 1;
    oscMult = 2;
    oscAdd = 0.5;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_RateMin':
                copy$4(this.rateMin, value);
                break;
            case 'm_RateMax':
                copy$4(this.rateMax, value);
                break;
            case 'm_FrequencyMin':
                copy$4(this.frequencyMin, value);
                break;
            case 'm_FrequencyMax':
                copy$4(this.frequencyMax, value);
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            case 'm_bProportional':
                this.proportional = value;
                break;
            case 'm_bProportionalOp':
                this.proportionalOp = value;
                break;
            case 'm_bOffset':
                this.offset = value;
                break;
            case 'm_flStartTime_min':
                this.startTimeMin = value;
                break;
            case 'm_flStartTime_max':
                this.startTimeMax = value;
                break;
            case 'm_flEndTime_min':
                this.endTimeMin = value;
                break;
            case 'm_flEndTime_max':
                this.endTimeMax = value;
                break;
            case 'm_flOscMult':
                this.oscMult = value;
                break;
            case 'm_flOscAdd':
                this.oscAdd = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        const m_nField = this.field;
        particle.cTime; //CM128AttributeIterator pCreationTime(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        const pLifeDuration = particle.timeToLive; //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //C4IAttributeIterator pParticleId (PARTICLE_ATTRIBUTE_PARTICLE_ID, pParticles);
        //C4VAttributeWriteIterator pOscField (m_nField, pParticles) ;
        const fl4CurTime = particle.currentTime;
        //const nRandomOffset = particle->OperatorRandomSampleOffset();
        const fvOscVal = create$4(); //todov3optimize
        const flStrength = 1;
        const fl4ScaleFactor = flStrength * elapsedTime;
        const fl4CosFactorMultiplier = this.oscMult;
        const fl4CosFactorAdd = this.oscAdd;
        const fl4CosFactor = fl4CosFactorMultiplier * fl4CurTime + fl4CosFactorAdd;
        const fl4CosFactorProp = fl4CosFactorMultiplier;
        const fl4StartTimeWidth = this.startTimeMax - this.startTimeMin;
        const fl4EndTimeWidth = this.endTimeMax - this.endTimeMin;
        const fvFrequencyMin = this.frequencyMin;
        const fvFrequencyWidth = sub$2(create$4(), this.frequencyMax, fvFrequencyMin); //todov3optimize
        const fvRateMin = this.rateMin;
        const fvRateWidth = sub$2(create$4(), this.rateMax, fvRateMin); //todov3optimize
        //int nCtr = pParticles->m_nPaddedActiveParticles;
        //do
        {
            const fl4LifeDuration = pLifeDuration;
            const fl4GoodMask = fl4LifeDuration > 0.0;
            let fl4LifeTime;
            if (this.proportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            let fl4StartTime = Math.random(); //pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            fl4StartTime = this.startTimeMin + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            let fl4EndTime = Math.random(); //pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            fl4EndTime = this.endTimeMin + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                let fvFrequency = fromValues$4(Math.random(), Math.random(), Math.random());
                //fvFrequency[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 8);
                //fvFrequency[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
                //fvFrequency[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 15);
                mul$4(fvFrequency, fvFrequency, fvFrequencyWidth);
                add$5(fvFrequency, fvFrequency, fvFrequencyMin);
                let fvRate = fromValues$4(Math.random(), Math.random(), Math.random());
                //fvRate[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 3);
                //fvRate[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 7);
                //fvRate[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 9);
                //fvRate = AddSIMD(fvRateMin, MulSIMD(fvRateWidth, fvRate));
                mul$4(fvRate, fvRate, fvRateWidth);
                add$5(fvRate, fvRate, fvRateMin);
                const fvCos = create$4(); //todov3optimize
                if (this.proportional) {
                    fl4LifeTime = particle.currentTime / particle.timeToLive;
                    fvCos[0] = fl4CosFactorProp * fvFrequency[0] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[1] = fl4CosFactorProp * fvFrequency[1] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[2] = fl4CosFactorProp * fvFrequency[2] * fl4LifeTime + fl4CosFactorAdd;
                }
                else {
                    scale$5(fvCos, fvFrequency, fl4CosFactor);
                }
                const fvOscMultiplier = create$4(); //todov3optimize
                scale$5(fvOscMultiplier, fvRate, fl4ScaleFactor);
                let fvOutput = create$3(); //TODO: perf//todov3optimize
                this.getInputValueAsVector(m_nField, particle, fvOutput); //*pOscField;
                fvOscVal[0] = AddSIMD(fvOutput[0], MulSIMD(fvOscMultiplier[0], SinEst01SIMD(fvCos[0])));
                fvOscVal[1] = AddSIMD(fvOutput[1], MulSIMD(fvOscMultiplier[1], SinEst01SIMD(fvCos[1])));
                fvOscVal[2] = AddSIMD(fvOutput[2], MulSIMD(fvOscMultiplier[2], SinEst01SIMD(fvCos[2])));
                const pOscField = create$4(); //todov3optimize
                if (m_nField == 6) {
                    pOscField[0] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[0], Four_Ones), Four_Zeros), fvOutput[0]);
                    pOscField[1] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[1], Four_Ones), Four_Zeros), fvOutput[1]);
                    pOscField[2] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[2], Four_Ones), Four_Zeros), fvOutput[2]);
                }
                else {
                    //pOscField[0] = MaskedAssign(fl4GoodMask, fvOscVal[0], fvOutput[0]);
                    //pOscField[1] = MaskedAssign(fl4GoodMask, fvOscVal[1], fvOutput[1]);
                    //pOscField[2] = MaskedAssign(fl4GoodMask, fvOscVal[2], fvOutput[2]);
                    pOscField[0] = fvOscVal[0];
                    pOscField[1] = fvOscVal[1];
                    pOscField[2] = fvOscVal[2];
                }
                this.setOutputValue(m_nField, pOscField, particle);
            }
            //++pCreationTime;
            //++pLifeDuration;
            //++pOscField;
            //++pParticleId;
            //} while (--nCtr);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateVector', OscillateVector);

let va = create$4();
let vb = create$4();
class PercentageBetweenCPs extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    inputMin = 0;
    inputMax = 1;
    outputMin = 0;
    outputMax = 1;
    startCP = 0;
    endCP = 1;
    setMethod = null;
    activeRange = false;
    radialCheck = true;
    scaleInitialRange = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flInputMin':
                this.inputMin = value;
                break;
            case 'm_flInputMax':
                this.inputMax = value;
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                break;
            case 'm_nStartCP':
                this.startCP = Number(value);
                break;
            case 'm_nEndCP':
                this.endCP = Number(value);
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            case 'm_bActiveRange':
                this.activeRange = value;
                break;
            case 'm_bRadialCheck':
                this.radialCheck = value;
                break;
            case 'm_bScaleInitialRange':
                this.scaleInitialRange = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let startCpPos = this.system.getControlPoint(this.startCP).currentWorldPosition;
        let endCPPos = this.system.getControlPoint(this.endCP).currentWorldPosition;
        let percentage;
        let dist = distance$3(startCpPos, endCPPos);
        if (this.radialCheck) {
            let dist2 = distance$3(startCpPos, particle.position);
            percentage = dist2 / dist;
        }
        else {
            sub$2(va, particle.position, startCpPos);
            sub$2(vb, endCPPos, startCpPos);
            //TODO: check dot product this is not right
            percentage = dot$4(va, vb) / (dist * dist);
        }
        if (percentage < this.inputMin || percentage > this.inputMax) {
            return;
        }
        let value = RemapValClamped(percentage, this.inputMin, this.inputMax, this.outputMin, this.outputMax);
        particle.setField(this.fieldOutput, value, this.scaleInitialRange || this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_PercentageBetweenCPs', PercentageBetweenCPs);

class PinParticleToCP extends Operator {
    offsetLocal = true;
    particleSelection = null; //PARTICLE_SELECTION_LAST
    pinBreakType = null; //PARTICLE_PIN_DISTANCE_NEIGHBOR
    breakControlPointNumber = -1;
    breakControlPointNumber2 = -1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecOffset':
            case 'm_nParticleNumber':
            case 'm_flBreakDistance':
            case 'm_flBreakSpeed':
            case 'm_flAge':
                break;
            case 'm_bOffsetLocal':
                this.offsetLocal = value;
                break;
            case 'm_nParticleSelection':
                this.particleSelection = value;
                break;
            case 'm_nPinBreakType':
                this.pinBreakType = value;
                break;
            case 'm_nBreakControlPointNumber':
                this.breakControlPointNumber = Number(value);
                break;
            case 'm_nBreakControlPointNumber2':
                this.breakControlPointNumber2 = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //m_nParticleNumber
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_PinParticleToCP', PinParticleToCP);

let vec$1 = create$4();
class PlaneCull extends Operator {
    planeControlPoint = 0;
    planeDirection = fromValues$4(0, 0, 1);
    localSpace = false;
    planeOffset = 0;
    planeDirectionOffset = create$4();
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        scale$5(this.planeDirectionOffset, this.planeDirection, this.planeOffset);
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nPlaneControlPoint':
                this.planeControlPoint = Number(value);
                break;
            case 'm_vecPlaneDirection':
                normalize$5(this.planeDirection, value);
                this._update();
                break;
            case 'm_bLocalSpace':
                this.localSpace = value;
                break;
            case 'm_flPlaneOffset':
                this.planeOffset = Number(value);
                this._update();
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.planeControlPoint);
        if (cp) {
            let origin = cp.getWorldPosition(vec$1);
            sub$2(origin, origin, this.planeDirectionOffset);
            sub$2(origin, particle.position, origin);
            if (dot$4(this.planeDirection, origin) < 0) {
                particle.die();
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_PlaneCull', PlaneCull);

create$4();
create$4();
//const tempQuat = quat.create();
create$4();
class PositionLock extends Operator {
    startTimeMin = 1;
    startTimeMax = 1;
    startTimeExp = 1;
    endTimeMin = 1;
    endTimeMax = 1;
    endTimeExp = 1;
    range = 0;
    jumpThreshold = 512;
    prevPosScale = 1;
    lockRot = false;
    startFadeOutTime;
    endFadeOutTime;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        //TODO: this is wrong: must be done per particle
        this.startFadeOutTime = RandomFloatExp(this.startTimeMin, this.startTimeMax, this.startTimeExp);
        this.endFadeOutTime = RandomFloatExp(this.endTimeMin, this.endTimeMax, this.endTimeExp);
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flStartTime_min':
                this.startTimeMin = value;
                this._update();
                break;
            case 'm_flStartTime_max':
                this.startTimeMax = value;
                this._update();
                break;
            case 'm_flStartTime_exp':
                this.startTimeExp = value;
                this._update();
                break;
            case 'm_flEndTime_min':
                this.endTimeMin = value;
                this._update();
                break;
            case 'm_flEndTime_max':
                this.endTimeMax = value;
                this._update();
                break;
            case 'm_flEndTime_exp':
                this.endTimeExp = value;
                this._update();
                break;
            case 'm_flRange':
                this.range = value;
                break;
            case 'm_flJumpThreshold':
                this.jumpThreshold = value;
                break;
            case 'm_flPrevPosScale':
                this.prevPosScale = value;
                break;
            case 'm_bLockRot':
                this.lockRot = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let proportionOfLife = clamp(particle.proportionOfLife, 0, 1);
        if (proportionOfLife > this.endFadeOutTime) {
            return;
        }
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            let delta;
            /*	if (!particle.initialCPPosition) {
                    particle.initialCPPosition = vec3.clone(cp.getWorldPosition(vec));
                } else {
                    vec3.copy(particle.initialCPPosition, particle.cpPosition);
                }
    
                particle.cpPosition = vec3.clone(cp.getWorldPosition(vec));
    
                let delta = vec3.subtract(vec3.create(), particle.cpPosition, particle.initialCPPosition);
    
                const deltaL = vec3.length(delta);
                particle.deltaL = particle.deltaL ?? 0;
                particle.deltaL += deltaL;
    
                //console.log(deltaL);
                if (this.range != 0 && particle.deltaL > this.range) {
                    particle.posLockedToCP = -1;
                }*/
            //TODO: use m_flRange and other parameters
            if (this.lockRot) {
                delta = cp.deltaWorldTransformation;
                transformMat4$2(particle.position, particle.position, delta);
                transformMat4$2(particle.prevPosition, particle.prevPosition, delta);
                //TODO: do LockStrength
            }
            else {
                delta = cp.deltaWorldPosition;
                add$5(particle.position, particle.position, delta);
                add$5(particle.prevPosition, particle.prevPosition, delta);
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_PositionLock', PositionLock);

class RampScalarLinear extends Operator {
    rateMin = 0;
    rateMax = 0;
    startTime_min = 0;
    startTime_max = 0;
    endTime_min = 1;
    endTime_max = 1;
    field = PARTICLE_FIELD_RADIUS;
    proportionalOp = true;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_RateMin':
                this.rateMin = value;
                break;
            case 'm_RateMax':
                this.rateMax = value;
                break;
            case 'm_flStartTime_min':
                this.startTime_min = value;
                break;
            case 'm_flStartTime_max':
                this.startTime_max = value;
                break;
            case 'm_flEndTime_min':
                this.endTime_min = value;
                break;
            case 'm_flEndTime_max':
                this.endTime_max = value;
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            case 'm_bProportionalOp':
                this.proportionalOp = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let context = particle.context.get(this);
        let rate, startTime, endTime;
        if (context == undefined) {
            //Init per particle parameters
            rate = RandomFloat(this.rateMin, this.rateMax);
            startTime = RandomFloat(this.startTime_min, this.startTime_max);
            endTime = RandomFloat(this.endTime_min, this.endTime_max);
            particle.context.set(this, { r: rate, s: startTime, e: endTime });
        }
        else {
            rate = context.r;
            startTime = context.s;
            endTime = context.e;
        }
        let particleTime = this.proportionalOp ? particle.proportionOfLife : particle.currentTime;
        if (particleTime < startTime || particleTime > endTime) {
            return;
        }
        let value = particle.getField(this.field) + rate * elapsedTime;
        particle.setField(this.field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarLinear', RampScalarLinear);

class RampScalarLinearSimple extends Operator {
    rate = 0;
    startTime = 0;
    endTime = 1;
    field = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_Rate':
                this.rate = value;
                break;
            case 'm_flStartTime':
                this.startTime = value;
                break;
            case 'm_flEndTime':
                this.endTime = value;
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let particleTime = particle.proportionOfLife;
        if (particleTime < this.startTime || particleTime > this.endTime) {
            return;
        }
        let value = particle.getField(this.field) + this.rate * elapsedTime;
        particle.setField(this.field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarLinearSimple', RampScalarLinearSimple);

class RampScalarSpline extends Operator {
    rateMin = 0;
    rateMax = 0;
    startTime_min = 0;
    startTime_max = 0;
    endTime_min = 1;
    endTime_max = 1;
    field = PARTICLE_FIELD_RADIUS;
    proportionalOp = true;
    bias = 0.5;
    easeOut = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_RateMin':
                this.rateMin = value;
                break;
            case 'm_RateMax':
                this.rateMax = value;
                break;
            case 'm_flStartTime_min':
                this.startTime_min = value;
                break;
            case 'm_flStartTime_max':
                this.startTime_max = value;
                break;
            case 'm_flEndTime_min':
                this.endTime_min = value;
                break;
            case 'm_flEndTime_max':
                this.endTime_max = value;
                break;
            case 'm_nField':
                this.field = Number(value);
                break;
            case 'm_bProportionalOp':
                this.proportionalOp = value;
                break;
            case 'm_flBias':
                this.bias = value;
                break;
            case 'm_bEaseOut':
                this.easeOut = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO : use m_flBias m_bEaseOut
        let context = particle.context.get(this);
        let rate, startTime, endTime;
        if (context == undefined) {
            //Init per particle parameters
            rate = RandomFloat(this.rateMin, this.rateMax);
            startTime = RandomFloat(this.startTime_min, this.startTime_max);
            endTime = RandomFloat(this.endTime_min, this.endTime_max);
            particle.context.set(this, { r: rate, s: startTime, e: endTime });
        }
        else {
            rate = context.r;
            startTime = context.s;
            endTime = context.e;
        }
        let particleTime = this.proportionalOp ? particle.proportionOfLife : particle.currentTime;
        if (particleTime < startTime || particleTime > endTime) {
            return;
        }
        let value = particle.getField(this.field) + rate * elapsedTime;
        particle.setField(this.field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarSpline', RampScalarSpline);

const DEFAULT_VECTOR = fromValues$4(1, 0, 0);
let v$3 = create$4();
class RemapControlPointDirectionToVector extends Operator {
    fieldOutput = PARTICLE_FIELD_POSITION;
    scale = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flScale':
                this.scale = value;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.controlPointNumber);
        transformQuat$1(v$3, DEFAULT_VECTOR, cp.currentWorldQuaternion);
        scale$5(v$3, v$3, this.scale);
        particle.setField(this.fieldOutput, v$3);
    }
}
RegisterSource2ParticleOperator('C_OP_RemapControlPointDirectionToVector', RemapControlPointDirectionToVector);

const tempQuat$1 = create$2();
create$2();
class RemapCPOrientationToRotations extends Operator {
    #vecRotation = create$4();
    #controlPointNumber = 0; //m_TransformInput
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecRotation':
                set$5(this.#vecRotation, Number(value[0]), Number(value[1]), Number(value[2])); // pitch yaw roll (Y Z X)
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.#controlPointNumber);
        if (cp) {
            cp.getWorldQuaternion(tempQuat$1);
            rotateY$1(tempQuat$1, tempQuat$1, this.#vecRotation[0] * DEG_TO_RAD);
            rotateZ$1(tempQuat$1, tempQuat$1, this.#vecRotation[1] * DEG_TO_RAD);
            rotateX$1(tempQuat$1, tempQuat$1, this.#vecRotation[2] * DEG_TO_RAD);
            copy$2(particle.quaternion, tempQuat$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RemapCPOrientationToRotations', RemapCPOrientationToRotations);

class RemapCPtoScalar extends Operator {
    fieldOutput = PARTICLE_FIELD_RADIUS;
    cpInput = 0;
    field = -1; //disabled
    inputMin = 0;
    inputMax = 1;
    outputMin = 0;
    outputMax = 1;
    startTime = -1;
    endTime = -1;
    interpRate = 0;
    setMethod = null;
    scaleInitialRange;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nCPInput':
                this.cpInput = Number(value);
                break;
            case 'm_nField':
                this.field = Number(value); //TODO check -1 / 0 / 1 / 2
                break;
            case 'm_flInputMin':
                this.inputMin = value;
                break;
            case 'm_flInputMax':
                this.inputMax = value;
                break;
            case 'm_flOutputMin':
                this.outputMin = value;
                break;
            case 'm_flOutputMax':
                this.outputMax = value;
                break;
            case 'm_flStartTime':
                this.startTime = value;
                break;
            case 'm_flEndTime':
                this.endTime = value;
                break;
            case 'm_flInterpRate':
                this.interpRate = value;
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use m_flInterpRate
        let cpInputPos = this.system.getControlPoint(this.cpInput).currentWorldPosition;
        let value = cpInputPos[this.field];
        value = RemapValClamped(value, this.inputMin, this.inputMax, this.outputMin, this.outputMax);
        let scaleInitial = this.scaleInitialRange || this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE'; //TODO: optimize
        if (scaleInitial) {
            value = lerp(1, value, strength);
        }
        else {
            value = lerp(particle.getField(this.fieldOutput), value, strength);
        }
        particle.setField(this.fieldOutput, value, scaleInitial);
    }
}
RegisterSource2ParticleOperator('C_OP_RemapCPtoScalar', RemapCPtoScalar);

class SetControlPointFromObjectScale extends Operator {
    cpInput = 0;
    cpOutput = 1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nCPInput':
                this.cpInput = Number(value);
                break;
            case 'm_nCPOutput':
                this.cpOutput = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        this.system.getControlPoint(this.cpInput);
        let cpOutput = this.system.getControlPoint(this.cpOutput);
        //TODO: use the actual scale
        cpOutput.position = fromValues$4(1, 1, 1);
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointFromObjectScale', SetControlPointFromObjectScale);

create$2();
class SetControlPointOrientation extends Operator {
    useWorldLocation = false;
    randomize = false;
    setOnce = false;
    cp = 1;
    headLocation = 0;
    rotation = create$4();
    rotationB = create$4();
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flInterpolation':
                break;
            case 'm_bUseWorldLocation':
                this.useWorldLocation = value;
                break;
            case 'm_bRandomize':
                this.randomize = value;
                break;
            case 'm_bSetOnce':
                this.setOnce = value;
                break;
            case 'm_nCP':
                this.cp = Number(value);
                break;
            case 'm_nHeadLocation':
                this.headLocation = Number(value);
                break;
            case 'm_vecRotation':
                copy$4(this.rotation, value);
                break;
            case 'm_vecRotationB':
                copy$4(this.rotationB, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        return;
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointOrientation', SetControlPointOrientation);

const v$2 = create$4();
class SetControlPointPositions extends Operator {
    useWorldLocation = false;
    orient = false;
    cp = [1, 2, 3, 4];
    cpPos = [fromValues$4(128, 0, 0), fromValues$4(0, 128, 0), fromValues$4(-128, 0, 0), fromValues$4(0, -128, 0)];
    headLocation = 0;
    setOnce;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bUseWorldLocation':
                this.useWorldLocation = value;
                break;
            case 'm_bOrient':
                this.orient = value;
                break;
            case 'm_bSetOnce':
                this.setOnce = value;
                break;
            case 'm_nCP1':
                this.cp[0] = Number(value);
                break;
            case 'm_nCP2':
                this.cp[1] = Number(value);
                break;
            case 'm_nCP3':
                this.cp[2] = Number(value);
                break;
            case 'm_nCP4':
                this.cp[3] = Number(value);
                break;
            case 'm_vecCP1Pos':
                copy$4(this.cpPos[0], value);
                break;
            case 'm_vecCP2Pos':
                copy$4(this.cpPos[1], value);
                break;
            case 'm_vecCP3Pos':
                copy$4(this.cpPos[2], value);
                break;
            case 'm_vecCP4Pos':
                copy$4(this.cpPos[3], value);
                break;
            case 'm_nHeadLocation':
                this.headLocation = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //const list = ['First', 'Second', 'Third', 'Fourth'];
        const useWorldLocation = this.useWorldLocation;
        this.system.getControlPointPosition(this.headLocation);
        let cpNumber;
        let cpLocation;
        let headLocation = this.system.getControlPoint(this.headLocation);
        for (let cpIndex = 0; cpIndex < 4; ++cpIndex) {
            cpNumber = this.cp[cpIndex];
            cpLocation = this.cpPos[cpIndex];
            let cp = this.system.getControlPoint(cpNumber);
            if (!useWorldLocation) {
                transformQuat$1(v$2, cpLocation, headLocation.currentWorldQuaternion);
                add$5(v$2, v$2, headLocation.currentWorldPosition);
                cp.position = v$2;
            }
            else {
                cp.position = cpLocation;
                this.system.setControlPointPosition(cpNumber, cpLocation);
            }
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointPositions', SetControlPointPositions);

class SetControlPointsToModelParticles extends Operator {
    #followAttachement = false;
    #attachmentName = '';
    hitboxSetName = 'default';
    firstControlPoint = 0;
    numControlPoints = 1;
    firstSourcePoint = 0;
    skin = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_HitboxSetName':
                this.hitboxSetName = value;
                break;
            case 'm_AttachmentName':
                this.#attachmentName = value;
                break;
            case 'm_nFirstControlPoint':
                this.firstControlPoint = Number(value);
                break;
            case 'm_nNumControlPoints':
                this.numControlPoints = Number(value);
                break;
            case 'm_nFirstSourcePoint':
                this.firstSourcePoint = Number(value);
                break;
            case 'm_bSkin':
                this.skin = value;
                break;
            case 'm_bAttachment':
                this.#followAttachement = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //todo: use m_bSkin m_bAttachment m_HitboxSetName m_AttachmentName
        let children = this.system.childSystems;
        let firstControlPoint = this.firstControlPoint;
        let firstSourcePoint = this.firstSourcePoint;
        for (let i = 0; i < this.numControlPoints; ++i) {
            let particle = this.system.livingParticles[firstSourcePoint + i];
            if (particle) {
                for (let child of children) {
                    let childCp = child.getOwnControlPoint(firstControlPoint + i);
                    childCp.position = particle.position;
                    if (this.#followAttachement) {
                        const model = this.system.getParentModel();
                        if (model) {
                            const attachement = model.getAttachement(this.#attachmentName);
                            if (attachement) {
                                childCp.quaternion = attachement.getWorldQuaternion();
                                childCp.quaternion = particle.quaternion;
                            }
                        }
                    }
                    if (childCp.lastComputed == -1) {
                        // Discard the delta if it's a newly create control point
                        childCp.resetDelta();
                    }
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointsToModelParticles', SetControlPointsToModelParticles);

const center = create$4();
class SetControlPointToCenter extends Operator {
    cp1 = 1;
    cp1Pos = create$4();
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nCP1':
                this.cp1 = Number(value);
                break;
            case 'm_vecCP1Pos':
                copy$4(this.cp1Pos, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        this.system.getBoundsCenter(center);
        add$5(center, center, this.cp1Pos);
        this.system.getOwnControlPoint(this.cp1).position = center;
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointToCenter', SetControlPointToCenter);

const UNIT_VEC3_X = fromValues$4(1, 0, 0);
const UNIT_VEC3_Z = fromValues$4(0, 0, 1);
let q = create$2();
class SetCPOrientationToGroundNormal extends Operator {
    m_flInterpRate = 0;
    maxTraceLength = 128;
    tolerance = 32;
    traceOffset = 64;
    collisionGroupName = 'NONE';
    inputCP = 0;
    outputCP = 1;
    includeWater = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_flInterpRate':
                this.m_flInterpRate = value;
                break;
            case 'm_flMaxTraceLength':
                this.maxTraceLength = value;
                break;
            case 'm_flTolerance':
                this.tolerance = value;
                break;
            case 'm_flTraceOffset':
                this.traceOffset = value;
                break;
            case 'm_CollisionGroupName':
                this.collisionGroupName = value;
                break;
            case 'm_nInputCP':
                this.inputCP = Number(value);
                break;
            case 'm_nOutputCP':
                this.outputCP = Number(value);
                break;
            case 'm_bIncludeWater':
                this.includeWater = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: do it properly
        let outputCP = this.system.getControlPoint(this.outputCP);
        if (outputCP) {
            rotationTo(q, UNIT_VEC3_X, UNIT_VEC3_Z);
            outputCP.quaternion = q;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetCPOrientationToGroundNormal', SetCPOrientationToGroundNormal);

class SetFloat extends Operator {
    normalizePerLiving = true;
    outputField = PARTICLE_FIELD_RADIUS;
    setMethod = 'PARTICLE_SET_VALUE';
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_InputValue':
                break;
            case 'm_nOutputField':
                this.outputField = Number(value);
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: use lerp
        let value = this.getParamScalarValue('m_InputValue', particle);
        //TODO: use setMethod
        particle.setField(this.outputField, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
        //particle.setField(this.outputField, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_SetFloat', SetFloat);

class SetParentControlPointsToChildCP extends Operator {
    childGroupID = 0;
    childControlPoint = 0;
    numControlPoints = 1;
    firstSourcePoint = 0;
    setOrientation = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nChildGroupID':
                this.childGroupID = Number(value);
                break;
            case 'm_nChildControlPoint':
                this.childControlPoint = Number(value);
                break;
            case 'm_nNumControlPoints':
                this.numControlPoints = Number(value);
                break;
            case 'm_nFirstSourcePoint':
                this.firstSourcePoint = Number(value);
                break;
            case 'm_bSetOrientation':
                this.setOrientation = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let children = this.system.childSystems;
        let childId = this.childGroupID;
        let cpId = this.firstSourcePoint;
        let count = this.numControlPoints;
        while (count--) {
            let child = children[childId];
            let cp = this.system.getControlPoint(cpId);
            if (child && cp) {
                let childCp = child.getOwnControlPoint(this.childControlPoint);
                childCp.position = cp.currentWorldPosition;
            }
            ++childId;
            ++cpId;
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetParentControlPointsToChildCP', SetParentControlPointsToChildCP);

class SetPerChildControlPoint extends Operator {
    childGroupID = 0;
    firstControlPoint = 0;
    numControlPoints = 1;
    setOrientation = false;
    numBasedOnParticleCount = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nChildGroupID':
                this.childGroupID = Number(value);
                break;
            case 'm_nFirstControlPoint':
                this.firstControlPoint = Number(value);
                break;
            case 'm_nNumControlPoints':
                this.numControlPoints = Number(value);
                break;
            case 'm_nParticleIncrement':
            case 'm_nFirstSourcePoint':
                break;
            case 'm_bSetOrientation':
                this.setOrientation = value;
                break;
            case 'm_bNumBasedOnParticleCount':
                this.numBasedOnParticleCount = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: set m_bSetOrientation
        let particleIncrement = this.getParamScalarValue('m_nParticleIncrement') ?? 1;
        let particleId = this.getParamScalarValue('m_nFirstSourcePoint') ?? 0;
        let children = this.system.childSystems;
        let childId = this.childGroupID;
        let count = this.numBasedOnParticleCount ? this.system.livingParticles.length : this.numControlPoints;
        while (count--) {
            let child = children[childId];
            let sourceParticle = this.system.livingParticles[particleId];
            if (child && sourceParticle) {
                let childCp = child.getOwnControlPoint(this.firstControlPoint);
                childCp.position = sourceParticle.position;
            }
            ++childId;
            particleId += particleIncrement;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetPerChildControlPoint', SetPerChildControlPoint);

const v$1 = create$4();
class SetRandomControlPointPosition extends Operator {
    useWorldLocation = false;
    orient = false;
    cp1 = 1;
    headLocation = 0;
    cpMinPos = create$4();
    cpMaxPos = create$4();
    lastRandomTime = -1;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bUseWorldLocation':
                this.useWorldLocation = value;
                break;
            case 'm_bOrient':
                this.orient = value;
                break;
            case 'm_nCP1':
                this.cp1 = Number(value);
                break;
            case 'm_nHeadLocation':
                this.headLocation = Number(value);
                break;
            case 'm_flReRandomRate':
            case 'm_flInterpolation':
                break;
            case 'm_vecCPMinPos':
                copy$4(this.cpMinPos, value);
                break;
            case 'm_vecCPMaxPos':
                copy$4(this.cpMaxPos, value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let reRandomRate = this.getParamScalarValue('m_flReRandomRate') ?? -1;
        this.getParamScalarValue('m_flInterpolation') ?? 1;
        //TODO: do interpolation
        if ((reRandomRate >= 0 || this.lastRandomTime < 0) && (this.system.currentTime - this.lastRandomTime > reRandomRate)) {
            this.lastRandomTime = this.system.currentTime;
            vec3RandomBox(v$1, this.cpMinPos, this.cpMaxPos);
            let headLocation = this.system.getControlPoint(this.headLocation);
            let cp1 = this.system.getControlPoint(this.cp1);
            transformQuat$1(v$1, v$1, headLocation.currentWorldQuaternion);
            add$5(v$1, v$1, headLocation.currentWorldPosition);
            cp1.position = v$1;
            if (this.orient) {
                cp1.setWorldQuaternion(headLocation.currentWorldQuaternion);
            }
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetRandomControlPointPosition', SetRandomControlPointPosition);

const DEFAULT_POSITION = fromValues$4(128, 0, 0);
let v = create$4();
let tempVec4 = create$3();
class SetSingleControlPointPosition extends Operator {
    useWorldLocation = false;
    setOnce = false;
    cp1 = 1;
    headLocation = 0;
    set = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecCP1Pos':
                break;
            case 'm_bUseWorldLocation':
                this.useWorldLocation = value;
                break;
            case 'm_bSetOnce':
                this.setOnce = value;
                break;
            case 'm_nCP1':
                this.cp1 = Number(value);
                break;
            case 'm_nHeadLocation':
                this.headLocation = Number(value);
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    reset() {
        this.set = false;
    }
    doOperate(particle, elapsedTime) {
        const cp1Pos = this.getParamVectorValue('m_vecCP1Pos', particle, tempVec4) ?? DEFAULT_POSITION;
        //TODO
        if (!this.setOnce || !this.set) {
            let cp = this.system.getOwnControlPoint(this.cp1);
            if (this.useWorldLocation) {
                cp.position = cp1Pos;
            }
            else {
                let headCp = this.system.getControlPoint(this.headLocation);
                transformQuat$1(v, cp1Pos, headCp.currentWorldQuaternion);
                add$5(v, v, headCp.currentWorldPosition);
                cp.position = v;
            }
            this.set = true;
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetSingleControlPointPosition', SetSingleControlPointPosition);

let tempQuat = create$2();
let tempVec3$1 = create$4();
let tempVec3_2 = create$4();
class SetToCP extends Operator {
    offset = create$4();
    offsetLocal = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecOffset':
                copy$4(this.offset, value);
                break;
            case 'm_bOffsetLocal':
                this.offsetLocal = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            cp.getWorldPosition(tempVec3_2);
            if (this.offsetLocal) {
                transformQuat$1(tempVec3$1, this.offset, cp.getWorldQuaternion(tempQuat));
                add$5(tempVec3$1, tempVec3$1, tempVec3_2);
            }
            else {
                add$5(tempVec3$1, this.offset, tempVec3_2);
            }
            copy$4(particle.position, tempVec3$1);
            copy$4(particle.prevPosition, tempVec3$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetToCP', SetToCP);

let DEFAULT_VECTOR_VALUE = create$3();
let vec = create$3();
class SetVec extends Operator {
    outputField = PARTICLE_FIELD_COLOR;
    setMethod = 'PARTICLE_SET_VALUE';
    normalizePerLiving = true;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_InputValue':
            case 'm_Lerp':
                break;
            case 'm_nOutputField':
                this.outputField = Number(value);
                break;
            case 'm_nSetMethod':
                this.setMethod = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: use lerp
        let inputValue = this.getParamVectorValue('m_InputValue', particle, vec) ?? DEFAULT_VECTOR_VALUE;
        this.getParamScalarValue('m_Lerp', particle) ?? 1;
        particle.setField(this.outputField, inputValue, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_SetVec', SetVec);

let mat = create$5();
let nmat = create$6();
const IDENTITY_MAT4 = create$5();
class SnapshotRigidSkinToBones extends Operator {
    transformNormals = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_bTransformNormals':
                //normal seems to be transformed whatever this parameter value is ?
                this.transformNormals = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        let bone, boneName, boneWeight, boneMat;
        let cp = this.system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        let model = cp.model;
        if (!model) {
            return;
        }
        let skeleton = model.skeleton;
        if (!skeleton) {
            return;
        }
        let particleSkinning = particle.skinning;
        let particleInitialPosition = particle.initialSkinnedPosition;
        let particleInitialNormal = particle.initialSkinnedNormal ?? DEFAULT_PARTICLE_NORMAL;
        if (particleSkinning && particleInitialPosition) {
            mat[0] = 0;
            mat[1] = 0;
            mat[2] = 0;
            mat[4] = 0;
            mat[5] = 0;
            mat[6] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = 0;
            mat[12] = 0;
            mat[13] = 0;
            mat[14] = 0;
            for (let i = 0; i < 4; ++i) {
                boneName = particleSkinning.bones[i];
                if (boneName) {
                    bone = skeleton.getBoneByName(boneName);
                    boneWeight = particleSkinning.weights[i];
                    if (bone && boneWeight) {
                        boneMat = bone ? bone.boneMat : IDENTITY_MAT4;
                        mat[0] += boneWeight * boneMat[0];
                        mat[1] += boneWeight * boneMat[1];
                        mat[2] += boneWeight * boneMat[2];
                        mat[4] += boneWeight * boneMat[4];
                        mat[5] += boneWeight * boneMat[5];
                        mat[6] += boneWeight * boneMat[6];
                        mat[8] += boneWeight * boneMat[8];
                        mat[9] += boneWeight * boneMat[9];
                        mat[10] += boneWeight * boneMat[10];
                        mat[12] += boneWeight * boneMat[12];
                        mat[13] += boneWeight * boneMat[13];
                        mat[14] += boneWeight * boneMat[14];
                    }
                }
            }
            //console.error(mat);
            transformMat4$2(particle.position, particleInitialPosition, mat);
            normalFromMat4(nmat, mat);
            transformMat3$1(particle.normal, particleInitialNormal, nmat);
            copy$4(particle.prevPosition, particle.position);
        }
        else {
            //Probably should do it better, but it just works
            let particleHitbox = particle.snapHitbox;
            particle.snapHitboxOffset;
            if (particleHitbox) {
                bone = skeleton.getBoneByName(particleHitbox);
                if (bone) {
                    boneMat = bone ? bone.boneMat : IDENTITY_MAT4;
                    transformMat4$2(particle.position, particleInitialPosition, boneMat);
                    normalFromMat4(nmat, boneMat);
                    transformMat3$1(particle.normal, particleInitialNormal, nmat);
                    copy$4(particle.prevPosition, particle.position);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SnapshotRigidSkinToBones', SnapshotRigidSkinToBones);
RegisterSource2ParticleOperator('C_OP_SnapshotSkinToBones', SnapshotRigidSkinToBones); //TODO: set proper operator

class Spin extends Operator {
    spinRateDegrees = 0;
    spinRateMinDegrees = 0;
    spinRateStopTime = 0;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_nSpinRateDegrees':
                this.spinRateDegrees = Number(value);
                break;
            case 'm_nSpinRateMinDegrees':
                this.spinRateMinDegrees = Number(value);
                break;
            case 'm_fSpinRateStopTime':
                this.spinRateStopTime = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
        let m_fSpinRateStopTime = this.spinRateStopTime;
        let m_fSpinRateRadians = (this.spinRateDegrees) * DEG_TO_RAD;
        let m_fSpinRateMinRadians = (this.spinRateMinDegrees) * DEG_TO_RAD;
        let fCurSpinRate = m_fSpinRateRadians /* * flStrength*/; //TODO
        if (fCurSpinRate == 0.0) {
            return;
        }
        let dt = elapsedTime;
        let drot = dt * Math.abs(fCurSpinRate * TWO_PI);
        if (m_fSpinRateStopTime == 0.0) {
            drot = drot % TWO_PI; //fmod(drot, (float)(2.0f * M_PI));
        }
        if (fCurSpinRate < 0.0) {
            drot = -drot;
        }
        //fltx4 Rot_Add = ReplicateX4(drot);
        let Rot_Add = drot;
        //fltx4 Pi_2 = ReplicateX4(2.0*M_PI);
        //fltx4 nPi_2 = ReplicateX4(-2.0*M_PI);
        // FIXME: This is wrong
        let minSpeedRadians = dt * Math.abs(m_fSpinRateMinRadians * TWO_PI); //fltx4 minSpeedRadians = ReplicateX4(dt * fabs(m_fSpinRateMinRadians * 2.0f * M_PI));
        let now = this.system.currentTime;
        let SpinRateStopTime = m_fSpinRateStopTime;
        //CM128AttributeIterator pCreationTimeStamp(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //CM128AttributeWriteIterator pRot(GetAttributeToSpin(), pParticles);
        // HACK: Rather than redo this, I'm simply remapping the stop time into the percentage of lifetime, rather than seconds
        let LifeSpan = particle.timeToLive;
        let SpinFadePerc = 0;
        let OOSpinFadeRate = 0;
        if (m_fSpinRateStopTime) {
            SpinFadePerc = LifeSpan * SpinRateStopTime;
            OOSpinFadeRate = 1.0 / SpinFadePerc;
        }
        let Age = now - particle.cTime;
        let RScale = Math.max(0, 1.0 - (Age * OOSpinFadeRate));
        // Cap the rotation at a minimum speed
        let deltaRot = Rot_Add * RScale;
        //fltx4 Tooslow = CmpLeSIMD(deltaRot, minSpeedRadians);
        //deltaRot = OrSIMD(AndSIMD(Tooslow, minSpeedRadians), AndNotSIMD(Tooslow, deltaRot));
        deltaRot = Math.max(minSpeedRadians, deltaRot);
        let NewRot = particle.rotationRoll + deltaRot;
        // now, cap at +/- 2*pi
        /*fltx4 Toobig =CmpGeSIMD(NewRot, Pi_2);
        fltx4 Toosmall = CmpLeSIMD(NewRot, nPi_2);

        NewRot = OrSIMD(AndSIMD(Toobig, SubSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toobig, NewRot));

        NewRot = OrSIMD(AndSIMD(Toosmall, AddSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toosmall, NewRot));*/
        //NewRot = Math.min(Math.max(-Math.TWO_PI, NewRot), Math.TWO_PI);
        particle.rotationRoll = NewRot;
    }
}
RegisterSource2ParticleOperator('C_OP_Spin', Spin);

class SpinUpdate extends Operator {
    //This operator has no parameters
    doOperate(particle, elapsedTime) {
        particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
    }
}
RegisterSource2ParticleOperator('C_OP_SpinUpdate', SpinUpdate);

const Coord = create$4();
const output = create$4();
const ofs_y = fromValues$4(100000.5, 300000.25, 9000000.75);
const ofs_z = fromValues$4(110000.25, 310000.75, 9100000.5);
class VectorNoise extends Operator {
    #outputMin = create$4();
    #outputMax = fromValues$4(1, 1, 1);
    fieldOutput = PARTICLE_FIELD_COLOR;
    noiseScale = 0.1;
    additive = false;
    offset = false;
    noiseAnimationTimeScale = 0;
    valueScale = create$4();
    valueBase = create$4();
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        sub$2(this.valueScale, this.#outputMax, this.#outputMin);
        scale$5(this.valueScale, this.valueScale, 0.5);
        add$5(this.valueBase, this.#outputMin, this.valueScale);
        /*if (this.fieldOutput == PARTICLE_FIELD_COLOR) {
            vec3.scale(this.valueScale, this.valueScale, 1 / 255);
            vec3.scale(this.valueBase, this.valueBase, 1 / 255);
        }*/
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecOutputMin':
                copy$4(this.#outputMin, value);
                this.#update();
                break;
            case 'm_vecOutputMax':
                copy$4(this.#outputMax, value);
                this.#update();
                break;
            case 'm_fl4NoiseScale':
                this.noiseScale = value;
                this.#update();
                break;
            case 'm_bAdditive':
                this.additive = value;
                break;
            case 'm_bOffset':
                this.offset = value;
                break;
            case 'm_flNoiseAnimationTimeScale':
                this.noiseAnimationTimeScale = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    doOperate(particle, elapsedTime) {
        //TODO: fix this operator ('particles/units/heroes/hero_dark_willow/dark_willow_head_ambient_smoke.vpcf_c')
        scale$5(Coord, particle.position, this.noiseScale * particle.currentTime * 0.001);
        output[0] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.valueScale[0] + this.valueBase[0]);
        add$5(Coord, Coord, ofs_y);
        output[1] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.valueScale[1] + this.valueBase[1]);
        add$5(Coord, Coord, ofs_z);
        output[2] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.valueScale[2] + this.valueBase[2]);
        particle.setField(this.fieldOutput, output, undefined, undefined, this.additive);
    }
}
RegisterSource2ParticleOperator('C_OP_VectorNoise', VectorNoise);

class RenderBlobs extends Operator {
    balls = [];
    metaballs;
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
    }
    _paramChanged(paramName, value) {
        /*
        cube_width
            This is the density of the matrix through which the blob is meshed. Smaller numbers give higher precision at higher performance cost, while larger number will cause more swimming with movement but at a much cheaper cost.

        cutoff_radius
            The distance at which particles will attempt to connect with other particles to create a continuous mesh. Larger distances are more expensive, should be balanced carefully with cube_width for best performance.

        render_radius
            The visual radius of each particle. Note that this should be kept smaller than the cutoff radius or multiple particles will potentially overlap each other visually, which may cause a variety of visual errors.

        scale CP
            Allows the other visual properties to be scaled via an external Control Point. X = cube_width / Y = cutoff radius / Z = render radius
        */
        switch (paramName) {
            case 'm_cubeWidth':
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    initRenderer(particleSystem) {
        /*this.geometry = new BufferGeometry();
        this.mesh = new StaticMesh(this.geometry, this.material);
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);

        this.maxParticles = particleSystem.maxParticles;*/
        this.metaballs = new Metaballs();
        particleSystem.addChild(this.metaballs);
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        this.metaballs.cubeWidth = this.getParamScalarValue('m_cubeWidth') ?? 1;
        let renderRadius = this.getParamScalarValue('m_renderRadius') ?? 1.3;
        this.getParamScalarValue('m_cutoffRadius') ?? 3.3;
        let balls = [];
        for (let i = 0; i < Math.min(particleList.length, 500); i++) {
            let particle = particleList[i];
            let ball = this.balls[i];
            if (!ball) {
                ball = new Metaball();
                this.balls.push(ball);
            }
            ball.setRadius(renderRadius);
            ball.position = particle.position;
            balls.push(ball);
        }
        this.metaballs.setBalls(balls);
        this.metaballs.updateGeometry();
    }
}
RegisterSource2ParticleOperator('C_OP_RenderBlobs', RenderBlobs);

class RenderDeferredLight extends Operator {
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            default:
                super._paramChanged(paramName, value);
        }
    }
    initRenderer(particleSystem) {
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
    }
}
RegisterSource2ParticleOperator('C_OP_RenderDeferredLight', RenderDeferredLight);

const tempVec3 = create$4();
class RenderModels extends Operator {
    #modelList = new Map();
    #models = new Map();
    #skin;
    #totalProbability;
    //#modelPool = new Map();
    #allModels = new Map();
    #animated = false;
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_ModelList':
                this.#modelList.clear();
                this.#totalProbability = 0;
                // Example of system with multiple models: muerta_ultimate_ambient_flowers
                for (const model of value) {
                    const modelName = model?.m_model;
                    const modelProbability = model?.m_flRelativeProbabilityOfSpawn ?? 1;
                    if (modelName) {
                        this.#totalProbability += modelProbability;
                        this.#modelList.set(modelName, this.#totalProbability);
                    }
                }
                break;
            case 'm_nSkin':
                this.#skin = value;
                this.#models.forEach(model => {
                    if (model) {
                        model.skin = this.#skin;
                    }
                });
                break;
            case 'm_bAnimated':
                this.#animated = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    initRenderer(particleSystem) {
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        const activity = particleSystem.getAttribute('activity');
        for (let i = 0, l = particleList.length; i < l; ++i) {
            this.#updateParticle(particleSystem, i, particleList[i], activity?.activity, activity?.modifiers);
        }
    }
    #pickRandomModel() {
        const random = Math.random() * this.#totalProbability;
        for (const [modelName, modelProbability] of this.#modelList) {
            if (random <= modelProbability) {
                return modelName;
            }
        }
    }
    async #getModel(repository, modelName) {
        for (const [model, datas] of this.#allModels) {
            if (!datas.used && (datas.modelName == modelName) && (datas.repository == repository)) {
                //this.#allModels.delete(model);
                datas.used = true;
                return model;
            }
        }
        const model = await Source2ModelManager.createInstance(repository, modelName, this.#animated);
        if (model) {
            this.#allModels.set(model, { repository: repository, modelName: modelName, used: true });
        }
        return model;
    }
    #returnModel(particle) {
        const model = this.#models.get(particle);
        if (model) {
            //previousModel.dispose();
            //console.log(previousModel)
            const datas = this.#allModels.get(model);
            if (datas) {
                datas.used = false;
            }
        }
    }
    async #updateParticle(particleSystem, particleIndex, particle, activityName, activityModifiers) {
        let model;
        if (!particle.modelName) {
            const modelName = this.#pickRandomModel();
            particle.modelName = modelName;
            this.#returnModel(particle);
            model = await this.#getModel(particleSystem.repository, particle.modelName);
            this.#models.set(particle, model);
            if (this.#skin && model) {
                model.skin = this.#skin;
            }
            particleSystem.addChild(model);
        }
        else {
            model = this.#models.get(particle);
        }
        /*if (model === undefined) {
            this.#models.push(null);

            model = await Source2ModelManager.createInstance(particleSystem.repository, this.#pickRandomModel(), true);

            if (this.#skin && model) {
                model.skin = this.#skin;
            }

            this.#models[particleIndex] = model;
            particleSystem.addChild(model);

            return
        }*/
        if (model) {
            model.position = particle.position;
            const radius = particle.radius;
            model.scale = set$5(tempVec3, radius, radius, radius);
            model.quaternion = particle.quaternion;
            model.playSequence(activityName, activityModifiers);
            if (particle.color[3] == 0) { //TODO: add an actual rendering tint / alpha on models
                model.visible = false;
            }
            else {
                model.visible = undefined;
            }
        }
    }
    dispose() {
        this.#allModels.forEach((_, model) => model.dispose());
    }
}
RegisterSource2ParticleOperator('C_OP_RenderModels', RenderModels);

const OPERATOR_PARAM_TEXTURE = 'm_hTexture';

const SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1 = 1;

class RenderRopes extends Operator {
    geometry;
    setDefaultTexture = true; //TODO: remove this property
    textureVWorldSize = 10;
    textureVScrollRate = 10;
    textureScroll = 0;
    #spriteSheet;
    #maxParticles = 1000; //TODO: default value
    #texture;
    #imgData;
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
        this.geometry = new BeamBufferGeometry();
        this.mesh = new Mesh(this.geometry, this.material);
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        this.setDefaultTexture = true;
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
        this.textureVWorldSize = 10;
        this.textureVScrollRate = 10;
        this.textureScroll = 0;
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecTexturesInput':
                this.setTexture(value[0].m_hTexture ?? DEFAULT_PARTICLE_TEXTURE); //TODO: check multiple textures ?
                break;
            case OPERATOR_PARAM_TEXTURE:
                this.setTexture(value);
                break;
            case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(value);
                break;
            case 'm_flTextureVWorldSize':
                this.textureVWorldSize = value;
                break;
            case 'm_flTextureVScrollRate':
                this.textureVScrollRate = value;
                break;
            case 'm_flFinalTextureScaleU':
            case 'm_flFinalTextureScaleV':
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    setSequenceCombineMode(sequenceCombineMode) {
        this.material?.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material?.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material?.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknonw sequenceCombineMode ', sequenceCombineMode);
        }
    }
    async setTexture(texturePath) {
        delete this.setDefaultTexture;
        this.material?.setTexturePath(texturePath);
        this.#spriteSheet = await Source2TextureManager.getTextureSheet(this.system.repository, texturePath);
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        this.textureScroll += elapsedTime * this.textureVScrollRate;
        this.getParameter('subdivision_count') ?? 3;
        let geometry = this.geometry;
        let segments = [];
        let particle;
        let ropeLength = 0.0;
        let previousSegment = null;
        let textureVWorldSize = 1 / this.textureVWorldSize;
        let textureScroll = this.textureScroll;
        let alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        for (let i = 0, l = particleList.length; i < l; i++) {
            //for (let i = 0, l = (particleList.length - 1) * subdivCount + 1; i < l; i++) {
            particle = particleList[i];
            let segment = new BeamSegment(particle.position, [particle.color[0], particle.color[1], particle.color[2], particle.alpha * alphaScale], 0.0, particle.radius);
            copy$4(segment.normal, particle.normal);
            if (previousSegment) {
                ropeLength += segment.distanceTo(previousSegment);
            }
            segment.texCoordY = (ropeLength + textureScroll) * textureVWorldSize;
            segments.push(segment);
            previousSegment = segment;
        }
        geometry.segments = segments;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = maxParticles;
        this.#createParticlesArray();
    }
    initRenderer(particleSystem) {
        if (this.mesh) {
            this.mesh.serializable = false;
            this.mesh.hideInExplorer = true;
            this.mesh.setDefine('IS_ROPE');
            this.mesh.setDefine('USE_VERTEX_COLOR');
            this.createParticlesTexture();
            this.mesh.setUniform('uParticles', this.#texture);
        }
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.#imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    createParticlesTexture() {
        this.#texture = TextureManager.createTexture();
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = new Graphics().glContext;
        if (!this.#imgData || !this.#texture) {
            return;
        }
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles) {
        const a = this.#imgData;
        if (!a) {
            return;
        }
        let index = 0;
        for (let particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            index++;
            index++;
            index++;
            index++;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderRopes', RenderRopes);

// Base renderer for common attributes like textures
class RenderBase extends Operator {
}

class RenderSprites extends RenderBase {
    geometry;
    setDefaultTexture = true; //TODO: remove this property
    #minSize = 0.0;
    #maxSize = 5000.0;
    spriteSheet;
    #maxParticles = 1000; //TODO: default value
    texture; //TODO: set private ?
    imgData; //TODO: set private ?
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
        this.geometry = new BufferGeometry();
        this.mesh = new Mesh(this.geometry, this.material);
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        this.setDefaultTexture = true;
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecTexturesInput':
                this.setTexture(value[0].m_hTexture ?? DEFAULT_PARTICLE_TEXTURE); //TODO: check multiple textures ?
                if (value[0].m_nTextureChannels) {
                    this.material.setDefine(value[0].m_nTextureChannels); //TODO: check values
                }
                break;
            case OPERATOR_PARAM_TEXTURE:
                this.setTexture(value);
                break;
            case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(value);
                break;
            case 'm_flMinSize':
                this.#minSize = Number(value) * 200.; //TODO: use the actual screen size
                break;
            case 'm_flMaxSize':
                this.#maxSize = Number(value) * 200.; //TODO: use the actual screen size
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    setSequenceCombineMode(sequenceCombineMode) {
        this.material.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknonw sequenceCombineMode ', sequenceCombineMode);
        }
    }
    async setTexture(texturePath) {
        delete this.setDefaultTexture;
        this.material.setTexturePath(texturePath);
        this.spriteSheet = await Source2TextureManager.getTextureSheet(this.system.repository, texturePath);
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        this.geometry.count = particleList.length * 6;
        let maxParticles = this.#maxParticles;
        this.setupParticlesTexture(particleList, maxParticles);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source2ParticleManager.visible);
        this.mesh.setUniform('uOverbrightFactor', this.getParamScalarValue('m_flOverbrightFactor') ?? 1);
        const uvs = this.geometry.attributes.get('aTextureCoord')._array;
        const uvs2 = this.geometry.attributes.get('aTextureCoord2')._array;
        let index = 0;
        let index2 = 0;
        for (let i = 0; i < particleList.length; i++) {
            let particle = particleList[i];
            const sequence = particle.sequence;
            if (m_bFitCycleToLifetime) {
                particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
            }
            else {
                if (useAnimRate) {
                    particle.frame += elapsedTime * rate;
                    this.material.getFrameSpan(sequence);
                }
            }
            particle.frame += elapsedTime;
            let spriteSheet = this.spriteSheet;
            if (spriteSheet) {
                let coords = spriteSheet.getFrame(particle.sequence, particle.frame * 10.0)?.coords; //sequences[particle.sequence].frames[particle.frame].coords;
                //coords = coords.m_TextureCoordData[0];
                if (coords) {
                    let uMin = coords[0];
                    let vMin = coords[1];
                    let uMax = coords[2];
                    let vMax = coords[3];
                    uvs[index++] = uMin;
                    uvs[index++] = vMin;
                    uvs[index++] = uMax;
                    uvs[index++] = vMin;
                    uvs[index++] = uMin;
                    uvs[index++] = vMax;
                    uvs[index++] = uMax;
                    uvs[index++] = vMax;
                }
                coords = spriteSheet.getFrame(particle.sequence2, particle.frame * 10.0)?.coords; //sequences[particle.sequence].frames[particle.frame].coords;
                //coords = coords.m_TextureCoordData[0];
                if (coords) {
                    let uMin = coords[0];
                    let vMin = coords[1];
                    let uMax = coords[2];
                    let vMax = coords[3];
                    uvs2[index2++] = uMin;
                    uvs2[index2++] = vMin;
                    uvs2[index2++] = uMax;
                    uvs2[index2++] = vMin;
                    uvs2[index2++] = uMin;
                    uvs2[index2++] = vMax;
                    uvs2[index2++] = uMax;
                    uvs2[index2++] = vMax;
                }
            }
            else {
                index += 8;
                index2 += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
        this.geometry.attributes.get('aTextureCoord2').dirty = true;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = new Graphics().isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this._initBuffers();
    }
    _initBuffers() {
        let geometry = this.geometry;
        const vertices = [];
        const uvs = [];
        const uvs2 = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            let indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            uvs2.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aTextureCoord2', new Float32BufferAttribute(uvs2, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer(particleSystem) {
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = new Graphics().glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles) {
        const a = this.imgData;
        let index = 0;
        let alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        for (let particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha * alphaScale;
            a[index++] = clamp(particle.radius, this.#minSize, this.#maxSize);
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            index++;
            index++;
            index++;
            index++;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderSprites', RenderSprites);
//RegisterSource2ParticleOperator('C_OP_RenderDeferredLight', RenderSprites);//TODO: set proper renderer
//RegisterSource2ParticleOperator('C_OP_RenderProjected', RenderSprites);//TODO: set proper renderer

const tempVec2 = create();
class RenderTrails extends Operator {
    geometry;
    setDefaultTexture = true; //TODO: remove this property
    minLength = 0;
    maxLength = 2000;
    lengthFadeInTime = 0;
    ignoreDT = false;
    lengthScale = 1;
    spriteSheet;
    #maxParticles = 1000; //TODO: default value
    texture; //TODO: set private ?
    imgData; //TODO: set private ?
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
        this.geometry = new BufferGeometry();
        this.mesh = new Mesh(this.geometry, this.material);
        this.material.setDefine('RENDER_SPRITE_TRAIL');
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
    }
    _paramChanged(paramName, value) {
        switch (paramName) {
            case 'm_vecTexturesInput':
                this.setTexture(value[0].m_hTexture ?? DEFAULT_PARTICLE_TEXTURE); //TODO: check multiple textures ?
                break;
            case OPERATOR_PARAM_TEXTURE:
                this.setTexture(value);
                break;
            /*case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(value);
                break;*/
            case 'm_flMinLength':
                this.minLength = value;
                break;
            case 'm_flMaxLength':
                this.maxLength = value;
                break;
            case 'm_flLengthFadeInTime':
                this.lengthFadeInTime = value;
                break;
            case 'm_bIgnoreDT':
                this.ignoreDT = value;
                break;
            case 'm_flRadiusScale':
            case 'm_flFinalTextureScaleU':
            case 'm_flFinalTextureScaleV':
                break;
            case 'm_flLengthScale':
                this.lengthScale = value;
                break;
            default:
                super._paramChanged(paramName, value);
        }
    }
    setSequenceCombineMode(sequenceCombineMode) {
        this.material.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknonw sequenceCombineMode ', sequenceCombineMode);
        }
    }
    async setTexture(texturePath) {
        delete this.setDefaultTexture;
        this.material.setTexturePath(texturePath);
        this.spriteSheet = await Source2TextureManager.getTextureSheet(this.system.repository, texturePath);
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        let geometry = this.geometry;
        geometry.count = particleList.length * 6;
        let maxParticles = this.#maxParticles;
        this.setupParticlesTexture(particleList, maxParticles, elapsedTime);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source2ParticleManager.visible);
        set$1(tempVec2, this.getParamScalarValue('m_flFinalTextureScaleU') ?? 1, this.getParamScalarValue('m_flFinalTextureScaleV') ?? 1);
        this.material.setUniform('uFinalTextureScale', tempVec2);
        geometry.attributes.get('aTextureCoord')._array;
        geometry.attributes.get('aTextureCoord2')._array;
        for (let i = 0; i < particleList.length; i++) {
            let particle = particleList[i];
            const sequence = particle.sequence;
            if (m_bFitCycleToLifetime) {
                particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
            }
            else {
                if (useAnimRate) {
                    particle.frame += elapsedTime * rate;
                    this.material.getFrameSpan(sequence);
                }
            }
            particle.frame += elapsedTime;
            this.spriteSheet;
            geometry.attributes.get('aTextureCoord').dirty = true;
            geometry.attributes.get('aTextureCoord2').dirty = true;
        }
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = new Graphics().isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this._initBuffers();
    }
    _initBuffers() {
        let geometry = this.geometry;
        const vertices = [];
        const uvs = [];
        const uvs2 = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            let indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            uvs2.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aTextureCoord2', new Float32BufferAttribute(uvs2, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer(particleSystem) {
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        const gl = new Graphics().glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = new Graphics().glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (new Graphics().isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setupParticlesTexture(particleList, maxParticles, elapsedTime) {
        const a = this.imgData;
        const m_flMaxLength = this.maxLength;
        const m_flMinLength = this.minLength;
        const m_flLengthFadeInTime = this.lengthFadeInTime;
        this.getParameter('animation rate') ?? 30;
        this.getParameter('animation_fit_lifetime') ?? 0;
        //const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;
        let flOODt;
        if (this.ignoreDT) {
            flOODt = 1;
        }
        else {
            flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
        }
        let radiusScale = this.getParamScalarValue('m_flRadiusScale') ?? 1;
        let alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        for (let particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = subtract$3(create$4(), particle.prevPosition, particle.position); //TODOv3: optimize
            const flMag = length$5(vecDelta);
            normalize$5(vecDelta, vecDelta);
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength * this.lengthScale;
            if (flLength <= 0.0) {
                return;
            }
            flLength = clamp(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3
            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius * radiusScale;
            if (flLength < rad) {
                rad = flLength;
            }
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha * alphaScale;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderTrails', RenderTrails);

var source2_fragment_compute_cs2_stickers = `
	#pragma unroll
	for ( int i = 0; i < 5; i ++ ) {

#ifdef ENABLE_STICKER{i}
#endif
	}
`;

var source2_fragment_declare_cs2_stickers = `
#pragma unroll
for ( int i = 0; i < 5; i ++ ) {
#ifdef ENABLE_STICKER{i}
	uniform float g_vSticker{i}Rotation;
	uniform float g_vSticker{i}Wear;
	uniform float g_fWearScratchesSticker{i};
	uniform vec4 g_vSticker{i}Offset;
	uniform vec4 g_vSticker{i}Scale;
	uniform vec4 g_vWearBiasSticker{i};

	uniform sampler2D sticker{i}Map;
	uniform sampler2D normalRoughnessSticker{i}Map;
	uniform sampler2D holoSpectrumSticker{i}Map;
	uniform sampler2D sfxMaskSticker{i}Map;
#endif
}

uniform sampler2D stickerWepInputsMap;
`;

var source2_varying_csgo_weapon_stattrak = `
#include varying_standard
`;

var source2_varying_csgo_weapon = `
#include varying_standard
`;

Includes['source2_fragment_compute_cs2_stickers'] = source2_fragment_compute_cs2_stickers;
Includes['source2_fragment_declare_cs2_stickers'] = source2_fragment_declare_cs2_stickers;
Includes['source2_varying_csgo_weapon_stattrak'] = source2_varying_csgo_weapon_stattrak;
Includes['source2_varying_csgo_weapon'] = source2_varying_csgo_weapon;

var source2_varying_hero_fluid = `
#include varying_standard
`;

var source2_varying_hero = `
#include varying_standard
`;

Includes['source2_varying_hero_fluid'] = source2_varying_hero_fluid;
Includes['source2_varying_hero'] = source2_varying_hero;

var source2_varying_crystal = `
#include varying_standard
`;

var source2_varying_global_lit_simple = `
#include varying_standard
`;

var source2_varying_pbr = `
#include varying_standard
`;

var source2_varying_spring_meteor = `
#include varying_standard
`;

var source2_varying_spritecard = `
#include varying_standard
varying vec4 vColor;
`;

var source2_varying_ui = `
#include varying_standard
`;

Includes['source2_varying_crystal'] = source2_varying_crystal;
Includes['source2_varying_global_lit_simple'] = source2_varying_global_lit_simple;
Includes['source2_varying_pbr'] = source2_varying_pbr;
Includes['source2_varying_spring_meteor'] = source2_varying_spring_meteor;
Includes['source2_varying_spritecard'] = source2_varying_spritecard;
Includes['source2_varying_ui'] = source2_varying_ui;

var source2_varying_vr_black_unlit = `
#include varying_standard
`;

var source2_varying_vr_complex = `
#include varying_standard
`;

var source2_varying_vr_eyeball = `
#include varying_standard
`;

var source2_varying_vr_glass = `
#include varying_standard
`;

var source2_varying_vr_simple_3layer_parallax = `
#include varying_standard
`;

var source2_varying_vr_simple = `
#include varying_standard
`;

var source2_varying_vr_skin = `
#include varying_standard
`;

var source2_varying_vr_xen_foliage = `
#include varying_standard
`;

Includes['source2_varying_vr_black_unlit'] = source2_varying_vr_black_unlit;
Includes['source2_varying_vr_complex'] = source2_varying_vr_complex;
Includes['source2_varying_vr_eyeball'] = source2_varying_vr_eyeball;
Includes['source2_varying_vr_glass'] = source2_varying_vr_glass;
Includes['source2_varying_vr_simple_3layer_parallax'] = source2_varying_vr_simple_3layer_parallax;
Includes['source2_varying_vr_simple'] = source2_varying_vr_simple;
Includes['source2_varying_vr_skin'] = source2_varying_vr_skin;
Includes['source2_varying_vr_xen_foliage'] = source2_varying_vr_xen_foliage;

var source2_detail_blend = `

#define DETAIL_BLEND_MODE_ADD 1
#define DETAIL_BLEND_MODE_ADD_SELF_ILLUM 2
#define DETAIL_BLEND_MODE_MOD2X 3
#define DETAIL_BLEND_MODE_WHAT 4

#ifdef USE_DETAIL1_MAP
	#ifdef DETAIL_BLEND_MODE
		vec4 detailColor;
		#if DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_ADD
			//diffuseColor = diffuseColor + detail1Color * g_flDetailBlendFactor * texelMask1.r;
			detailColor = diffuseColor + detail1Color;
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_ADD_SELF_ILLUM
			//diffuseColor = diffuseColor + detail1Color * g_flDetailBlendFactor * texelMask1.r;//TODO selfillum
			detailColor = diffuseColor + detail1Color;//TODO selfillum
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_MOD2X
			//diffuseColor = mix(diffuseColor, diffuseColor * detail1Color * g_flDetailBlendFactor, texelMask1.r);//TODO: this is not quite right
			detailColor = 2.0 * diffuseColor * detail1Color;//TODO: this is not quite right
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_WHAT
			detailColor = (diffuseColor + detail1Color) * 0.5;
		#endif

		//diffuseColor = mix(diffuseColor, diffuseColor * detail1Color * g_flDetailBlendFactor, texelMask1.r);//TODO: this is not quite right

		diffuseColor = mix(diffuseColor, detailColor, g_flDetailBlendFactor * texelMask1.r);
	#endif
#endif
`;

var source2_fragment_compute_detail = `
#ifdef USE_DETAIL1_MAP
	vec2 detail1Coord = vTextureCoord.xy * g_vDetailTexCoordScale.xy + g_vDetailTexCoordOffset.xy;
	vec4 detail1Color = g_vDetail1ColorTint * texture2D(detail1Map, detail1Coord);
#endif
#ifdef USE_DETAIL2_MAP
	vec2 detail2Coord = vTextureCoord.xy * g_vDetail2TexCoordOffset.xy + g_vDetail2TexCoordOffset.xy;
	vec4 detail2Color = g_vDetail2ColorTint * texture2D(detail2Map, detail2Coord);
#endif
`;

var source2_fragment_compute_mask = `
#include compute_fragment_mask_map
#include compute_fragment_mask1_map
#include compute_fragment_mask2_map
#ifndef USE_MASK_MAP
	vec4 texelMask = vec4(1.0);
#endif
#ifndef USE_MASK1_MAP
	vec4 texelMask1 = vec4(1.0);
#endif
#ifndef USE_MASK2_MAP
	vec4 texelMask2 = vec4(1.0);
#endif
`;

var source2_fragment_compute_separate_alpha_transform = `
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	#ifdef USE_COLOR_MAP
		texelColor.a = texture2D(colorMap, vTextureCoord.xy + g_vAlphaTexCoordOffset.st).a;
	#endif
#endif
`;

var source2_fragment_declare_detail_map = `
#ifdef USE_DETAIL1_MAP
	uniform vec4 g_vDetailTexCoordScale;
	uniform vec4 g_vDetailTexCoordOffset;
	uniform vec4 g_vDetail1ColorTint;
	uniform sampler2D detail1Map;
#endif
#ifdef USE_DETAIL2_MAP
	uniform vec4 g_vDetail2TexCoordScale;
	uniform vec4 g_vDetail2TexCoordOffset;
	uniform vec4 g_vDetail2ColorTint;
	uniform sampler2D detail2Map;
#endif
`;

var source2_fragment_declare_separate_alpha_transform = `
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	uniform vec4 g_vAlphaTexCoordOffset;
#endif
`;

Includes['source2_detail_blend'] = source2_detail_blend;
Includes['source2_fragment_compute_detail'] = source2_fragment_compute_detail;
Includes['source2_fragment_compute_mask'] = source2_fragment_compute_mask;
Includes['source2_fragment_compute_separate_alpha_transform'] = source2_fragment_compute_separate_alpha_transform;
Includes['source2_fragment_declare_detail_map'] = source2_fragment_declare_detail_map;
Includes['source2_fragment_declare_separate_alpha_transform'] = source2_fragment_declare_separate_alpha_transform;

var source2_csgo_environment_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_hero
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a


	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif

#ifdef USE_COLOR_1_MAP
	gl_FragColor = texture2D(color1Map, vTextureCoord.xy);
#endif
}
`;

var source2_csgo_environment_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_csgo_weapon_stattrak_fs = `
#include declare_fragment_color_map

#include source2_varying_csgo_weapon_stattrak
void main(void) {
#ifdef USE_COLOR_MAP
	gl_FragColor = texture2D(colorMap, vTextureCoord.xy * vec2(6. / 16., 0.08));
	//gl_FragColor = texture2D(colorMap, vTextureCoord.xy);
#endif
}
`;

var source2_csgo_weapon_stattrak_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_csgo_weapon_stattrak

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_csgo_weapon_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
#include source2_fragment_declare_cs2_stickers
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

#include source2_varying_csgo_weapon

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a

#ifdef ENABLE_CLOAK
	// TODO: fully code cloak, for now it's just a fix for io
	if (g_flMaterialCloakFactor == 1.0) {
		discard;
	}
#endif

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif

	#include source2_fragment_compute_cs2_stickers

	if (length (vVertexPositionModelSpace.xy - g_vSticker0Offset.xy*15.) < 15.) {
		gl_FragColor = vec4(1., 0., 0., 0.);
	}

	if (length (vVertexPositionModelSpace.xz - g_vSticker0Offset.xy * 15.) < 5.) {
		gl_FragColor = vec4(1., 0., 0., 0.);
	}

	gl_FragColor.a = 1.0;
	gl_FragColor = texture2D(stickerWepInputsMap, vTextureCoord.xy);

	gl_FragColor = vec4(vTextureCoord.xy, 0.0, 1.0);

//	gl_FragColor = texture2D(stickerWepInputsMap, vTextureCoord.xy);
//gl_FragColor = texture2D(colorMap, vTextureCoord.xy);



	#include compute_fragment_standard
}
`;

var source2_csgo_weapon_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source2_varying_csgo_weapon

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

Shaders['source2_csgo_environment.fs'] = source2_csgo_environment_fs;
Shaders['source2_csgo_environment.vs'] = source2_csgo_environment_vs;
Shaders['source2_csgo_weapon_stattrak.fs'] = source2_csgo_weapon_stattrak_fs;
Shaders['source2_csgo_weapon_stattrak.vs'] = source2_csgo_weapon_stattrak_vs;
Shaders['source2_csgo_weapon.fs'] = source2_csgo_weapon_fs;
Shaders['source2_csgo_weapon.vs'] = source2_csgo_weapon_vs;

var source2_hero_fluid_fs = `

#include declare_fragment_color_map
uniform sampler2D displacementMaskMap;
uniform sampler2D specularMap;
uniform sampler2D spiralNormalMap;
uniform sampler2D spiralOverlayMap;

#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_hero_fluid
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

#ifdef USE_DISPLACEMENT_MASK_MAP
	vec4 displacementMask = texture2D(displacementMaskMap, vTextureCoord.xy);
#else
	vec4 displacementMask = vec4(1.0);
#endif
#ifdef USE_SPECULAR_MAP
	vec4 specularColor = texture2D(specularMap, vTextureCoord.xy);
#else
	vec4 specularColor = vec4(1.0);
#endif
#ifdef USE_SPIRAL_NORMAL_MAP
	vec4 spiralNormal = texture2D(spiralNormalMap, vTextureCoord.xy);
#else
	vec4 spiralNormal = vec4(1.0);
#endif
#ifdef USE_SPIRAL_OVERLAY_MAP
	vec4 spiralOverlay = texture2D(spiralOverlayMap, vTextureCoord.xy);
#else
	vec4 spiralOverlay = vec4(1.0);
#endif

	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard

	vec4 finalcolor;
	finalcolor.rgb = mix(texelColor.rgb, spiralOverlay.rgb, spiralOverlay.a);
	finalcolor.a = texelColor.a;

	gl_FragColor = finalcolor;
}
`;

var source2_hero_fluid_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero_fluid

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_hero_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

#include source2_varying_hero
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a

#ifdef ENABLE_CLOAK
	// TODO: fully code cloak, for now it's just a fix for io
	if (g_flMaterialCloakFactor == 1.0) {
		discard;
	}
#endif

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif
	#include compute_fragment_standard
}
`;

var source2_hero_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

Shaders['source2_hero_fluid.fs'] = source2_hero_fluid_fs;
Shaders['source2_hero_fluid.vs'] = source2_hero_fluid_vs;
Shaders['source2_hero.fs'] = source2_hero_fs;
Shaders['source2_hero.vs'] = source2_hero_vs;

var source2_vr_black_unlit_fs = `
#include source2_varying_vr_black_unlit

void main(void) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	#include compute_fragment_standard
}
`;

var source2_vr_black_unlit_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_black_unlit

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_complex_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_vr_complex

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_complex_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_complex

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_eyeball_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_varying_vr_eyeball

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_eyeball_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_eyeball

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_glass_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

uniform sampler2D tintColorMap;

#include source2_varying_vr_complex

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
	vec4 tintColorTexel = texture2D(tintColorMap, vTextureCoord.xy);
	gl_FragColor.rgb = tintColorTexel.rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_glass_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_complex

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_2way_blend_fs = `
#ifdef USE_COLOR_A_MAP
	uniform sampler2D colorAMap;
#endif
#ifdef USE_COLOR_B_MAP
	uniform sampler2D colorBMap;
#endif
#include declare_fragment_normal_map
#include declare_fragment_mask_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_vr_simple

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map

#ifdef USE_COLOR_A_MAP
	vec4 texelColorA = texture2D(colorAMap, vTextureCoord.xy);
#else
	vec4 texelColorA = vec4(1.0);
#endif
#ifdef USE_COLOR_B_MAP
	vec4 texelColorB = texture2D(colorBMap, vTextureCoord.xy);
#else
	vec4 texelColorB = vec4(1.0);
#endif


#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test
	#include source2_fragment_compute_mask

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard


	gl_FragColor.rgb = texelColorA.rgb * 0.0 + texelColorB.rgb;
}
`;

var source2_vr_simple_2way_blend_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_3layer_parallax_fs = `
uniform sampler2D colorMap;
uniform sampler2D g_tAmbientOcclusion;
uniform sampler2D g_tColorA;
uniform sampler2D g_tColorB;
uniform sampler2D g_tColorC;
uniform sampler2D g_tMasks;
uniform sampler2D g_tNormalA;
uniform sampler2D g_tEmissiveB;
uniform sampler2D g_tEmissiveC;


uniform vec4 g_vColorTint;

#include source2_varying_vr_simple_3layer_parallax

void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		gl_FragColor = textureColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		gl_FragColor = vec4(textureColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;
		//if (gl_FragCoord.x < 0.5 * 800.0)
		{
			gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;
		}
		gl_FragColor.rgb = texture2D(g_tEmissiveC, vTextureCoord.xy).rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_simple_3layer_parallax_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple_3layer_parallax

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_fs = `
#include declare_lights
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_camera_position
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include compute_pbr

#include source2_varying_vr_simple

void main(void) {
	float metalness;
	float roughness;
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_color_map
	#include compute_fragment_normal_map

#ifdef USE_COLOR_MAP
	diffuseColor *= pow(texelColor, vec4(2.2));
	metalness = texelColor.a;
#endif


#ifdef USE_NORMAL_MAP
	roughness = texelNormal.b;
#endif

	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	float ao = texture2D(aoMap, vTextureCoord.xy).r;
#else
	float ao = 1.0;
#endif
	#include compute_fragment_standard
#if NUM_PBR_LIGHTS > 0

#ifdef USE_NORMAL_MAP
		vec3 N = normalize(vec3(texelNormal.rg, 1.) * 2.0 - 1.0);
#else
		vec3 N = vec3(0., 0., 1.);
#endif
	N = normalize(TBNMatrixWorldSpace * N);
	vec3 albedo = diffuseColor.rgb;
	vec3 F0 = mix(Fdielectric, albedo, metalness);
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, ao);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var source2_vr_simple_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_skin_fs = `
uniform sampler2D colorMap;
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_varying_vr_skin

void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		gl_FragColor = textureColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		gl_FragColor = vec4(textureColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

		gl_FragColor.rgb = textureColor.rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_skin_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_skin

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_xen_foliage_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#ifdef F_SELF_ILLUM
	uniform vec4 g_vSelfIllumTint;
	uniform float g_flSelfIllumOverallScale;
	uniform float g_flSelfIllumFlowSpeed;
	uniform float g_flSelfIllumFlowAmount;
#endif
#ifdef USE_MASK_PARAMETERS_MAP
	uniform sampler2D maskParametersMap;
	/*
	RED : self illum mask
	GREEN : ?
	BLUE : self illum flow phase
	*/
#endif

#ifdef USE_SIFW_MAP
	uniform sampler2D selfIllumFlowWaveformMap;
#endif

#include source2_varying_vr_xen_foliage

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_normal_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;


#ifdef F_SELF_ILLUM
/*
	//---- Self Illum ----
	g_flSelfIllumBrightness "1.000"
	g_flSelfIllumCustomFlowTimer "0.000"
	g_flSelfIllumFlowAmount "1.000"
	g_flSelfIllumFlowFrequency "1.000"
	g_flSelfIllumFlowSpeed "4.000"
	g_flSelfIllumOverallScale "1.000"
	g_vSelfIllumTint "[1.000000 1.000000 1.000000 0.000000]"
	TextureSelfIllumFlowPhase "materials/default/default.tga"
	TextureSelfIllumFlowWaveform "materials/workshop_examples/combine/blind_zombie_crushed_wave.png"
	TextureSelfIllumMask "materials/workshop_examples/combine/combine_monitor_screens_selfillum.tga"
	*/
#endif

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef F_SELF_ILLUM
	vec3 selfIllumColor = g_vSelfIllumTint.rgb;
	float deltaUV = 0.0;
	#ifdef USE_MASK_PARAMETERS_MAP
		vec4 maskParametersTexel = texture2D(maskParametersMap, vTextureCoord.xy);
		//gl_FragColor.rgb = maskParametersTexel.rgb;
		selfIllumColor *= maskParametersTexel.r;
		deltaUV = maskParametersTexel.b;
	#endif

	#ifdef USE_SIFW_MAP
		vec4 selfIllumFlowWaveformTexel = texture2D(selfIllumFlowWaveformMap, vec2(mod(uTime.r * g_flSelfIllumFlowSpeed + pow(deltaUV, 2.0), 1.0), 0.5));
		//selfIllumFlowWaveStrength *= ;
		selfIllumColor *= mix(1.0, selfIllumFlowWaveformTexel.r, g_flSelfIllumFlowAmount);
	#endif


	gl_FragColor.rgb += g_flSelfIllumOverallScale * 0.5 * selfIllumColor;//TODO: why 0.5 ?
#endif

	/*vec4 selfIllumFlowWaveformTexel = texture2D(selfIllumFlowWaveformMap, vTextureCoord);
	gl_FragColor.rgb = selfIllumFlowWaveformTexel.rgb;*/
#ifdef USE_MASK_PARAMETERS_MAP
	//gl_FragColor.rgb = maskParametersTexel.rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_xen_foliage_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_xen_foliage

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

Shaders['source2_vr_black_unlit.fs'] = source2_vr_black_unlit_fs;
Shaders['source2_vr_black_unlit.vs'] = source2_vr_black_unlit_vs;
Shaders['source2_vr_complex.fs'] = source2_vr_complex_fs;
Shaders['source2_vr_complex.vs'] = source2_vr_complex_vs;
Shaders['source2_vr_eyeball.fs'] = source2_vr_eyeball_fs;
Shaders['source2_vr_eyeball.vs'] = source2_vr_eyeball_vs;
Shaders['source2_vr_glass.fs'] = source2_vr_glass_fs;
Shaders['source2_vr_glass.vs'] = source2_vr_glass_vs;
Shaders['source2_vr_simple_2way_blend.fs'] = source2_vr_simple_2way_blend_fs;
Shaders['source2_vr_simple_2way_blend.vs'] = source2_vr_simple_2way_blend_vs;
Shaders['source2_vr_simple_3layer_parallax.fs'] = source2_vr_simple_3layer_parallax_fs;
Shaders['source2_vr_simple_3layer_parallax.vs'] = source2_vr_simple_3layer_parallax_vs;
Shaders['source2_vr_simple.fs'] = source2_vr_simple_fs;
Shaders['source2_vr_simple.vs'] = source2_vr_simple_vs;
Shaders['source2_vr_skin.fs'] = source2_vr_skin_fs;
Shaders['source2_vr_skin.vs'] = source2_vr_skin_vs;
Shaders['source2_vr_xen_foliage.fs'] = source2_vr_xen_foliage_fs;
Shaders['source2_vr_xen_foliage.vs'] = source2_vr_xen_foliage_vs;

var source2_crystal_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flOpacityScale;

uniform vec4 TextureTranslucency;

#include source2_varying_crystal

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = 1.0;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

//#ifdef TESTING
//	gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);
//	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
//		discard;
//	}
//#endif
/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/
	#include compute_fragment_standard
gl_FragColor.rgb *= TextureTranslucency.rgb;
}
`;

var source2_crystal_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_crystal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_error_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_crystal

void main(void) {
	gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);
	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0);
	}
}
`;

var source2_error_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_crystal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_global_lit_simple_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include declare_lights

#include source2_varying_global_lit_simple
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(0.0, 0.0, 1.0));

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif
/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard
}
`;

var source2_global_lit_simple_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_global_lit_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_pbr_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
#include declare_fragment_self_illum_mask_map

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

// Constant normal incidence Fresnel factor for all dielectrics.

struct AnalyticalLight {
	vec3 direction;
	vec3 radiance;
};
#include compute_pbr

const float Epsilon = 0.00001;
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);
const int NumLights = 1;
AnalyticalLight lights[NumLights] = AnalyticalLight[](AnalyticalLight(vec3(40., 0., 50.), vec3(1)));

#include source2_varying_pbr
void main(void) {
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_self_illum_mask_map


	// Sample input textures to get shading model params.
	vec3 albedo = texelColor.rgb;//vec3 albedo = texture(albedoTexture, vin.texcoord).rgb;
	float metalness = texelColor.a;//float metalness = texture(metalnessTexture, vin.texcoord).r;
	float roughness = 0.1;//float roughness = texture(roughnessTexture, vin.texcoord).r;

	// Outgoing light direction (vector from world-space fragment position to the "eye").
	vec3 Lo = normalize(vec3(40, 0., 50.) - vVertexPositionWorldSpace.xyz);//vec3 Lo = normalize(eyePosition - vin.position);

	// Get current fragment's normal and transform to world space.
#ifdef USE_NORMAL_MAP
	vec3 N = normalize(texelNormal.rgb);//vec3 N = normalize(2.0 * texture(normalTexture, vin.texcoord).rgb - 1.0);
#else
	vec3 N = normalize(defaultNormalTexel.rgb);//vec3 N = normalize(2.0 * texture(normalTexture, vin.texcoord).rgb - 1.0);
#endif
	N = normalize(TBNMatrixWorldSpace * N);//N = normalize(vin.tangentBasis * N);

	// Angle between surface normal and outgoing light direction.
	float cosLo = max(0.0, dot(N, Lo));


	// Specular reflection vector.
	vec3 Lr = 2.0 * cosLo * N - Lo;

	// Fresnel reflectance at normal incidence (for metals use albedo color).
	vec3 F0 = mix(Fdielectric, albedo, metalness);




	gl_FragColor.a = 1.0;

	#include compute_fragment_standard


	gl_FragColor.rgb = abs(N.rgb);
	gl_FragColor.rgb = abs(vVertexNormalModelSpace.rgb);
#if NUM_PBR_LIGHTS > 0
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, 1.);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var source2_pbr_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_pbr

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_spring_meteor_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_spring_meteor
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#include compute_fragment_render_mode
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard
}
`;

var source2_spring_meteor_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_spring_meteor

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_spritecard_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
uniform vec3 uColorScale;
#include declare_fragment_alpha_test

#include source2_varying_spritecard

#ifndef SEQUENCE_COMBINE_MODE
	#define SEQUENCE_COMBINE_MODE 0
#endif

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#ifdef USE_TEXTURE_COORD_2
		vec4 texelColor2 = texture2D(colorMap, vTexture2Coord.xy);
	#else
		vec4 texelColor2 = texelColor;
	#endif


#ifdef SPRITECARD_TEXTURE_CHANNEL_MIX_RGBA_RGBALPHA
	texelColor.a = texelColor.r;//TODO : use rgb luminance ?
#endif

	diffuseColor *= texelColor;


	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	blended_rgb.rgb *= uOverbrightFactor;
	//blended_rgb = pow(blended_rgb, vec4(2.2));
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= GammaToLinear(vColor.rgb);
	#else
		blended_rgb *= GammaToLinear(vColor);
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
	gl_FragColor = vec4(vTextureCoord.xy, 0.0, vColor.a) * vColor.a;
	gl_FragColor = texelColor * vColor * vColor.a;
	gl_FragColor = texelColor * pow(vColor, vec4(2.2)) * texelColor.a;
	gl_FragColor = texelColor * vColor * texelColor.a;
	//gl_FragColor = texelColor;
	//gl_FragColor.a = texelColor.a;
#if SEQUENCE_COMBINE_MODE == 0
	#define TEXEL_RGB texelColor.rgb
	#define TEXEL_ALPHA texelColor.a
#endif
#if SEQUENCE_COMBINE_MODE == 1//SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1
	#define TEXEL_RGB texelColor2.rgb
	#define TEXEL_ALPHA texelColor.a
#endif
	gl_FragColor.rgb = TEXEL_RGB * vColor.rgb * TEXEL_ALPHA * uColorScale;
	//gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(2.2));
	gl_FragColor.a = vColor.a * TEXEL_ALPHA;
	//gl_FragColor.a = TEXEL_ALPHA;
}`;

var source2_spritecard_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;
uniform vec2 uFinalTextureScale;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source2_varying_spritecard

void main(void) {
#ifdef HARDWARE_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
	vColor = GammaToLinear(p.color);
	vColor = p.color;

	vTextureCoord.xy = aTextureCoord * uFinalTextureScale;
#ifdef USE_TEXTURE_COORD_2
	vTexture2Coord.xy = aTextureCoord2;
#endif
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#else
		vColor = vec4(1.0);
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif



}
`;

var source2_ui_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_ui

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_ui_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_ui

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	vTextureCoord.y = 1.0 - vTextureCoord.y;
}
`;

Shaders['source2_crystal.fs'] = source2_crystal_fs;
Shaders['source2_crystal.vs'] = source2_crystal_vs;
Shaders['source2_error.fs'] = source2_error_fs;
Shaders['source2_error.vs'] = source2_error_vs;
Shaders['source2_global_lit_simple.fs'] = source2_global_lit_simple_fs;
Shaders['source2_global_lit_simple.vs'] = source2_global_lit_simple_vs;
Shaders['source2_pbr.fs'] = source2_pbr_fs;
Shaders['source2_pbr.vs'] = source2_pbr_vs;
Shaders['source2_spring_meteor.fs'] = source2_spring_meteor_fs;
Shaders['source2_spring_meteor.vs'] = source2_spring_meteor_vs;
Shaders['source2_spritecard.fs'] = source2_spritecard_fs;
Shaders['source2_spritecard.vs'] = source2_spritecard_vs;
Shaders['source2_ui.fs'] = source2_ui_fs;
Shaders['source2_ui.vs'] = source2_ui_vs;

class CubeTexture extends Texture {
    isCubeTexture;
    #images;
    constructor(parameters) {
        super(parameters);
        this.isCubeTexture = true;
        this.setImages(parameters.images);
    }
    setImages(images) {
        if (!images) {
            return;
        }
        this.#images = images;
    }
    getImages() {
        return this.#images;
    }
    getWidth() {
        return this.#images?.[0]?.width ?? 0;
    }
    getHeight() {
        return this.#images?.[0]?.height ?? 0;
    }
    is(type) {
        return type === 'CubeTexture';
    }
}

const LOD_MIN = 4;
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const flatCamera = new Camera({ projection: CameraProjection.Orthographic, position: fromValues$4(0, 0, 1) });
const clearColor = create$3();
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const axisDirections = [
    fromValues$4(1, 1, 1),
    fromValues$4(-1, 1, 1),
    fromValues$4(1, 1, -1),
    fromValues$4(-1, 1, -1),
    fromValues$4(0, PHI, INV_PHI),
    fromValues$4(0, PHI, -INV_PHI),
    fromValues$4(INV_PHI, 0, PHI),
    fromValues$4(-INV_PHI, 0, PHI),
    fromValues$4(PHI, INV_PHI, 0),
    fromValues$4(-PHI, INV_PHI, 0)
];
// Radiance Environment Map generator
class RemGenerator {
    #renderer;
    #pingPongRenderTarget;
    #blurMaterial;
    #cubemapMaterial;
    #equirectMaterial;
    #lodMax = 0;
    #cubeSize = 0;
    #lodPlanes = [];
    #sizeLods = [];
    #sigmas = [];
    constructor(renderer) {
        this.#renderer = renderer;
    }
    /*
    constructor(renderer) {

        this.#renderer = renderer;
        this.#pingPongRenderTarget = null;

        this.#lodMax = 0;
        this.#cubeSize = 0;
        this.#lodPlanes = [];
        this.#sizeLods = [];
        this.#sigmas = [];

        this.#blurMaterial = null;
        this.#cubemapMaterial = null;
        this.#equirectMaterial = null;

        this.#compileMaterial(this.#blurMaterial);
    }
        */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        /*
                _oldTarget = this.#renderer.getRenderTarget();
                _oldActiveCubeFace = this.#renderer.getActiveCubeFace();
                _oldActiveMipmapLevel = this.#renderer.getActiveMipmapLevel();
                */
        this.#setSize(256);
        const cubeUVRenderTarget = this.#allocateTargets();
        cubeUVRenderTarget.setDepthBuffer(true);
        this.#sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
            this.#blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this.#applyPMREM(cubeUVRenderTarget);
        this.#cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromEquirectangular(equirectangular, renderTarget) {
        if (!this.#equirectMaterial) {
            this.#equirectMaterial = getEquirectMaterial();
        }
        return this.#fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromCubemap(cubemap, renderTarget) {
        if (!this.#cubemapMaterial) {
            this.#cubemapMaterial = getCubemapMaterial();
        }
        return this.#fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileCubemapShader() {
        if (this.#cubemapMaterial === null) {
            this.#cubemapMaterial = getCubemapMaterial();
            this.#compileMaterial(this.#cubemapMaterial);
        }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileEquirectangularShader() {
        if (this.#equirectMaterial === null) {
            this.#equirectMaterial = getEquirectMaterial();
            this.#compileMaterial(this.#equirectMaterial);
        }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
    dispose() {
        this.#dispose();
        this.#cubemapMaterial?.dispose();
        this.#equirectMaterial?.dispose();
    }
    // private interface
    #setSize(cubeSize) {
        this.#lodMax = Math.floor(Math.log2(cubeSize));
        this.#cubeSize = Math.pow(2, this.#lodMax);
    }
    #dispose() {
        if (this.#blurMaterial) {
            this.#blurMaterial.removeUser(this);
        }
        if (this.#pingPongRenderTarget) {
            this.#pingPongRenderTarget.dispose();
        }
        for (let i = 0; i < this.#lodPlanes.length; i++) {
            this.#lodPlanes[i].dispose();
        }
        this.#lodPlanes = [];
    }
    #cleanup(outputTarget) {
        //this.#renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
        //new Graphics().pushRenderTarget();
        outputTarget.setScissorTest(false);
        //outputTarget.setViewport(0, 0, outputTarget.width, outputTarget.height);
    }
    #fromTexture(texture, renderTarget) {
        let size;
        if (texture.is('CubeTexture')) {
            size = texture.getWidth();
            this.#setSize(size);
        }
        else {
            size = texture.getWidth() * 0.25;
            this.#setSize(size);
        }
        /*
                _oldTarget = this.#renderer.getRenderTarget();
                _oldActiveCubeFace = this.#renderer.getActiveCubeFace();
                _oldActiveMipmapLevel = this.#renderer.getActiveMipmapLevel();

                */
        const cubeUVRenderTarget = renderTarget || this.#allocateTargets();
        this.#textureToCubeUV(texture, cubeUVRenderTarget);
        this.#applyPMREM(cubeUVRenderTarget);
        this.#cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    #allocateTargets() {
        const width = 3 * Math.max(this.#cubeSize, 16 * 7);
        const height = 4 * this.#cubeSize;
        const params = {
            //TODO
            /*
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            colorSpace: LinearSRGBColorSpace,
            depthBuffer: false
            */
            width: width,
            height: height,
        };
        const cubeUVRenderTarget = createRenderTarget(params);
        if (!this.#pingPongRenderTarget || this.#pingPongRenderTarget.getWidth() !== width || this.#pingPongRenderTarget.getHeight() !== height) {
            if (this.#pingPongRenderTarget) {
                this.#dispose();
            }
            this.#pingPongRenderTarget = createRenderTarget(params);
            ({ sizeLods: this.#sizeLods, lodPlanes: this.#lodPlanes, sigmas: this.#sigmas } = createPlanes(this.#lodMax));
            this.#blurMaterial = getBlurShader(this.#lodMax, width, height);
            this.#blurMaterial.addUser(this);
        }
        return cubeUVRenderTarget;
    }
    #compileMaterial(material) {
        new Mesh(this.#lodPlanes[0], material);
        //this.#renderer.compile(tmpMesh, flatCamera);
    }
    #sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov = 90;
        const aspect = 1;
        const cubeCamera = new Camera({ projection: CameraProjection.Perspective, fov: fov, aspect, near, far });
        const upSign = [1, -1, 1, 1, 1, 1];
        const forwardSign = [1, 1, 1, -1, -1, -1];
        const renderer = this.#renderer;
        const originalAutoClear = new Graphics().autoClear;
        const toneMapping = renderer.getToneMapping();
        new Graphics().getClearColor(clearColor);
        renderer.setToneMapping(ToneMapping.None);
        new Graphics().autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
            name: 'PMREM.Background',
            //side: BackSide,
            depthWrite: false,
            depthTest: false,
        });
        const scene2 = new Scene();
        const backgroundBox = new Box({ material: backgroundMaterial, parent: scene2 });
        const background = scene.background;
        /*
                if (background) {

                    if (background.isColor) {

                        //backgroundMaterial.color.copy(background);
                        vec4.copy(backgroundMaterial.color, background);
                        scene.background = undefined;
                        useSolidColor = true;

                    }

                } else {

                    //backgroundMaterial.color.copy(_clearColor);
                    vec4.copy(backgroundMaterial.color, clearColor);
                    useSolidColor = true;

                }*/
        for (let i = 0; i < 6; i++) {
            const col = i % 3;
            if (col === 0) {
                cubeCamera.upVector = fromValues$4(0, upSign[i], 0); //cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(fromValues$4(forwardSign[i], 0, 0));
            }
            else if (col === 1) {
                cubeCamera.upVector = fromValues$4(0, 0, upSign[i]); //cubeCamera.up.set(0, 0, upSign[i]);
                cubeCamera.lookAt(fromValues$4(0, forwardSign[i], 0));
            }
            else {
                cubeCamera.upVector = fromValues$4(0, upSign[i], 0); //cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(fromValues$4(0, 0, forwardSign[i]));
            }
            const size = this.#cubeSize;
            cubeUVRenderTarget.setViewport(col * size, i > 2 ? size : 0, size, size);
            new Graphics().pushRenderTarget(cubeUVRenderTarget);
            renderer.render(scene, cubeCamera, 0, { DisableToolRendering: true });
            new Graphics().popRenderTarget();
        }
        backgroundBox.dispose();
        //renderer.toneMapping = toneMapping;
        renderer.setToneMapping(toneMapping);
        new Graphics().autoClear = originalAutoClear;
        scene.background = background;
    }
    #textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this.#renderer;
        const isCubeTexture = texture.is('CubeTexture'); //(texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
        let material;
        if (isCubeTexture) {
            if (!this.#cubemapMaterial) {
                this.#cubemapMaterial = getCubemapMaterial();
            }
            this.#cubemapMaterial.uniforms.flipEnvMap = (texture.isRenderTargetTexture === false) ? -1 : 1;
            material = this.#cubemapMaterial;
        }
        else {
            if (!this.#equirectMaterial) {
                this.#equirectMaterial = getEquirectMaterial();
            }
            material = this.#equirectMaterial;
        }
        const mesh = new Mesh(this.#lodPlanes[0], material);
        const scene = new Scene();
        scene.addChild(mesh);
        const uniforms = material.uniforms;
        uniforms['envMap'] = texture;
        const size = this.#cubeSize;
        cubeUVRenderTarget.setViewport(0, 0, 3 * size, 2 * size);
        new Graphics().pushRenderTarget(cubeUVRenderTarget);
        renderer.render(scene, flatCamera, 0, { DisableToolRendering: true });
        new Graphics().popRenderTarget();
    }
    #applyPMREM(cubeUVRenderTarget) {
        this.#renderer;
        const autoClear = new Graphics().autoClear;
        new Graphics().autoClear = false;
        for (let i = 1; i < this.#lodPlanes.length; i++) {
            const sigma = Math.sqrt(this.#sigmas[i] * this.#sigmas[i] - this.#sigmas[i - 1] * this.#sigmas[i - 1]);
            const poleAxis = axisDirections[(i - 1) % axisDirections.length];
            this.#blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
        }
        new Graphics().autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    #blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        if (!this.#pingPongRenderTarget) {
            return;
        }
        this.#halfBlur(cubeUVRenderTarget, this.#pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this.#halfBlur(this.#pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    #halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this.#renderer;
        if (!this.#blurMaterial) {
            return;
        }
        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
            console.error('blur direction must be either latitudinal or longitudinal!');
        }
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(this.#lodPlanes[lodOut], this.#blurMaterial);
        const blurUniforms = this.#blurMaterial.uniforms;
        const scene = new Scene();
        scene.addChild(blurMesh);
        const pixels = this.#sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i = 0; i < MAX_SAMPLES; ++i) {
            const x = i / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i === 0) {
                sum += weight;
            }
            else if (i < samples) {
                sum += 2 * weight;
            }
        }
        for (let i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum;
        }
        blurUniforms['envMap'] = targetIn.getTexture();
        blurUniforms['samples'] = samples;
        blurUniforms['weights[0]'] = weights;
        blurUniforms['latitudinal'] = direction === 'latitudinal';
        if (poleAxis) {
            blurUniforms['poleAxis'] = poleAxis;
        }
        blurUniforms['dTheta'] = radiansPerPixel;
        blurUniforms['mipInt'] = this.#lodMax - lodIn;
        const outputSize = this.#sizeLods[lodOut];
        const x = 3 * outputSize * (lodOut > this.#lodMax - LOD_MIN ? lodOut - this.#lodMax + LOD_MIN : 0);
        const y = 4 * (this.#cubeSize - outputSize);
        targetOut.setViewport(x, y, 3 * outputSize, 2 * outputSize);
        new Graphics().pushRenderTarget(targetOut);
        renderer.render(scene, flatCamera, 0, { DisableToolRendering: true });
        new Graphics().popRenderTarget();
    }
}
function createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
        const sizeLod = Math.pow(2, lod);
        sizeLods.push(sizeLod);
        let sigma = 1.0 / sizeLod;
        if (i > lodMax - LOD_MIN) {
            sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
        }
        else if (i === 0) {
            sigma = 0;
        }
        sigmas.push(sigma);
        const texelSize = 1.0 / (sizeLod - 2);
        const min = -texelSize;
        const max = 1 + texelSize;
        const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        var indices = [];
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        let index = 0;
        for (let face = 0; face < cubeFaces; face++) {
            const x = (face % 3) * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x, y, 0,
                x + 2 / 3, y, 0,
                x + 2 / 3, y + 1, 0,
                x, y, 0,
                x + 2 / 3, y + 1, 0,
                x, y + 1, 0
            ];
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new BufferGeometry();
        planes.setIndex(new Uint16BufferAttribute(indices, 1));
        planes.setAttribute('aVertexPosition', new BufferAttribute(position, positionSize));
        planes.setAttribute('aTextureCoord', new BufferAttribute(uv, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
        planes.count = indices.length;
        lodPlanes.push(planes);
        if (lod > LOD_MIN) {
            lod--;
        }
    }
    return { lodPlanes, sizeLods, sigmas };
}
function createRenderTarget(params) {
    const cubeUVRenderTarget = new RenderTarget(params);
    const renderTargetTexture = cubeUVRenderTarget.getTexture();
    renderTargetTexture.mapping = TextureMapping.CubeUvMapping;
    //cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    //cubeUVRenderTarget.getTexture().name = 'PMREM.cubeUv';
    cubeUVRenderTarget.setScissorTest(true);
    return cubeUVRenderTarget;
}
function getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = fromValues$4(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': MAX_SAMPLES,
            'CUBEUV_TEXEL_WIDTH': 1.0 / width,
            'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
            'CUBEUV_MAX_MIP': `${lodMax}.0`,
        },
        uniforms: {
            'envMap': null,
            'samples': 1,
            'weights[0]': weights,
            'latitudinal': false,
            'dTheta': 0,
            'mipInt': 0,
            'poleAxis': poleAxis
        },
        vertex: getCommonVertexShader(),
        fragment: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			//#include <cube_uv_reflection_fragment>

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}


			vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

			float face = getFace( direction );

			float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

			mipInt = max( mipInt, cubeUV_minMipLevel );

			float faceSize = exp2( mipInt );

			highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

			if ( face > 2.0 ) {

				uv.y += faceSize;

				face -= 3.0;

			}

			uv.x += face * faceSize;

			uv.x += filterInt * 3.0 * cubeUV_minTileSize;

			uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

			uv.x *= CUBEUV_TEXEL_WIDTH;
			uv.y *= CUBEUV_TEXEL_HEIGHT;

			#ifdef texture2DGradEXT

				return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

			#else

				return texture2D( envMap, uv ).rgb;

			#endif

		}

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function getEquirectMaterial() {
    return new ShaderMaterial({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': null
        },
        vertex: getCommonVertexShader(),
        fragment: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include common

			vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_TAU + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );
				//gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
				//gl_FragColor = vec4(outputDirection, 1.0);

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
}
function getCubemapMaterial() {
    return new ShaderMaterial({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': null,
            'flipEnvMap': -1
        },
        vertexShader: getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
}
function getCommonVertexShader() {
    return /* glsl */ `

		#include declare_attributes
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( aTextureCoord, faceIndex );
			gl_Position = vec4( aVertexPosition, 1.0 );

		}
	`;
}

class ObjExporter {
    static #instance;
    #lines = [];
    #startIndex = 1;
    #fullScreenQuadMesh = new FullScreenQuad();
    scene = new Scene();
    camera = new Camera({ position: fromValues$4(0, 0, 100) });
    constructor() {
        if (ObjExporter.#instance) {
            return ObjExporter.#instance;
        }
        ObjExporter.#instance = this;
        this.scene.addChild(this.#fullScreenQuadMesh);
    }
    async #renderMeshes(files, meshes) {
        let [previousWidth, previousHeight] = new Graphics().setSize(1024, 1024); //TODOv3: constant
        new Graphics().setIncludeCode('EXPORT_TEXTURES', '#define EXPORT_TEXTURES');
        new Graphics().setIncludeCode('SKIP_PROJECTION', '#define SKIP_PROJECTION');
        new Graphics().setIncludeCode('SKIP_LIGHTING', '#define SKIP_LIGHTING');
        let previousClearColor = new Graphics().getClearColor();
        new Graphics().clearColor(fromValues$3(0, 0, 0, 0));
        let meshId = 0;
        let promises = [];
        for (let mesh of meshes) {
            if (!mesh.is('Mesh')) {
                continue;
            }
            if (mesh.parent?.isParticleSystem) {
                continue;
            }
            this.#fullScreenQuadMesh.material = mesh.material;
            this.#fullScreenQuadMesh.materialsParams = mesh.materialsParams;
            new Graphics().render(this.scene, this.camera, 0, { DisableToolRendering: true });
            //let file = await new Graphics().savePictureAsFile(`mat_${meshId}.png`);
            /*				let file = await new Graphics().savePictureAsFile(`mat_${meshId}.png`);
                        files.add(file);*/
            let promise = new Graphics().savePictureAsFile(`mat_${meshId}.png`);
            promise.then((file) => files.add(file));
            promises.push(promise);
            ++meshId;
        }
        new Graphics().setIncludeCode('EXPORT_TEXTURES', '');
        new Graphics().setIncludeCode('SKIP_PROJECTION', '');
        new Graphics().setIncludeCode('SKIP_LIGHTING', '');
        new Graphics().setSize(previousWidth, previousHeight);
        new Graphics().clearColor(previousClearColor);
        await Promise.all(promises);
    }
    #addLine(line) {
        this.#lines.push(line + '\n');
    }
    async exportMeshes({ meshes = new Set(), exportTexture = false, singleMesh = false, digits = 4, subdivisions = 0, mergeTolerance = 0.0001 } = {}) {
        let files = new Set();
        const loopSubdivision = new LoopSubdivision();
        if (exportTexture && subdivisions == 0) {
            await this.#renderMeshes(files, meshes);
        }
        this.#lines = [];
        let mtlLines = [];
        this.#addLine('mtllib export.mtl');
        let objectId = 0;
        this.#startIndex = 1;
        for (let mesh of meshes) {
            if (mesh.parent.isParticleSystem) {
                continue;
            }
            if (mesh.exportObj) {
                let m = mesh.exportObj();
                let faces;
                let vertices;
                let normals;
                let uvs;
                if (subdivisions > 0) {
                    const result = await loopSubdivision.subdivide(m.f, m.v, subdivisions, mergeTolerance);
                    faces = result.indices;
                    vertices = result.vertices;
                }
                else {
                    faces = m['f'];
                    vertices = m['v'];
                    normals = m['vn'];
                    uvs = m['vt'];
                }
                if (!singleMesh) {
                    this.#addLine('o ' + objectId);
                }
                mtlLines.push(`newmtl mat_${objectId}.png\n`);
                mtlLines.push(`map_Kd mat_${objectId}.png\n`);
                this.#addLine(`usemtl mat_${objectId}.png`);
                if (faces && vertices) {
                    this.#exportMesh(digits, faces, vertices, normals, uvs);
                }
                ++objectId;
            }
        }
        files.add(new File([new Blob([this.#lines.join('')])], 'export.obj'));
        if (exportTexture) {
            files.add(new File([new Blob([mtlLines.join('')])], 'export.mtl'));
        }
        return files;
    }
    async #exportMesh(digits, indices, vertices, normals, uvs) {
        let attributes = [
            { name: 'v', stride: 3, arr: vertices },
            { name: 'vn', stride: 3, arr: normals },
            { name: 'vt', stride: 2, arr: uvs },
        ];
        let line;
        let verticeCount = 0;
        let startIndex = this.#startIndex;
        for (const attribute of attributes) {
            const attributesLength = attribute.stride;
            const arr = attribute.arr;
            if (arr) {
                let vertexIndex = 0;
                for (let i = 0; i < arr.length; i += attributesLength, ++vertexIndex) {
                    line = attribute.name;
                    for (let j = 0; j < attributesLength; ++j) {
                        line += ' ' + arr[i + j].toFixed(digits);
                    }
                    this.#addLine(line);
                    if (attribute.name == 'v') {
                        ++verticeCount;
                    }
                }
            }
        }
        for (let i = 0; i < indices.length; i += 3) {
            let i0 = startIndex + indices[i];
            let i1 = startIndex + indices[i + 1];
            let i2 = startIndex + indices[i + 2];
            let uv0 = '';
            let uv1 = '';
            let uv2 = '';
            let normals0 = '';
            let normals1 = '';
            let normals2 = '';
            if (uvs) {
                uv0 = `/${i0}`;
                uv1 = `/${i1}`;
                uv2 = `/${i2}`;
            }
            if (normals) {
                normals0 = `/${i0}`;
                normals1 = `/${i1}`;
                normals2 = `/${i2}`;
            }
            this.#addLine(`f ${i0}${uv0}${normals0} ${i1}${uv1}${normals1} ${i2}${uv2}${normals2}`);
        }
        this.#startIndex += verticeCount;
    }
}

const DEFAULT_SIZE = 256;
class RenderTargetViewer {
    #scene = new Scene();
    #camera = new Camera({ projection: CameraProjection.Orthographic, position: [0, 0, 1] });
    #plane = new Plane();
    #renderTarget;
    #position = create();
    #size = fromValues(DEFAULT_SIZE, DEFAULT_SIZE);
    isRenderTargetViewer = true;
    #material;
    constructor(renderTarget) {
        ContextObserver.observe(GraphicsEvents, this.#camera);
        ContextObserver.observe(GraphicsEvents, this);
        this.#scene.addChild(this.#plane);
        this.#renderTarget = renderTarget;
        this.refreshPlane();
    }
    /**
     * @deprecated Please use `setMaterial` instead.
     */
    set material(material) {
        throw 'deprecated';
    }
    setRenderTarget(renderTarget) {
        this.#renderTarget = renderTarget;
        this.#plane.material.setColorMap(renderTarget?.getTexture());
    }
    setMaterial(material) {
        this.#material = material;
        this.#plane.setMaterial(material);
        material.setColorMap(this.#renderTarget?.getTexture());
    }
    getMaterial() {
        return this.#material;
    }
    /**
     * @deprecated Please use `getMaterial` instead.
     */
    get material() {
        throw 'deprecated';
    }
    setPosition(x, y) {
        set$1(this.#position, x, y);
        this.refreshPlane();
    }
    setSize(x, y) {
        set$1(this.#size, x, y);
        this.refreshPlane();
    }
    refreshPlane() {
        set$5(this.#plane._position, (this.#size[0] - new Graphics().getWidth()) * 0.5 + this.#position[0], (new Graphics().getHeight() - this.#size[1]) * 0.5 - this.#position[1], 0);
        this.#plane.setSize(this.#size[0], this.#size[1]);
    }
    render(renderer) {
        renderer.render(this.#scene, this.#camera, 0, { DisableToolRendering: true });
    }
    is(s) {
        return s == 'RenderTargetViewer';
    }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ATTRIBUTE_CHANGED: ATTRIBUTE_CHANGED,
  Add: Add,
  AddVectorToVector: AddVectorToVector,
  AlphaFadeAndDecay: AlphaFadeAndDecay,
  AlphaFadeInRandom: AlphaFadeInRandom,
  AlphaFadeOutRandom: AlphaFadeOutRandom,
  AlphaRandom: AlphaRandom,
  AmbientLight: AmbientLight,
  AnimatedTextureProxy: AnimatedTextureProxy,
  AnimatedWeaponSheen: AnimatedWeaponSheen,
  ApplySticker: ApplySticker,
  AttractToControlPoint: AttractToControlPoint,
  AudioGroup: AudioGroup,
  AudioMixer: AudioMixer,
  BackGround: BackGround,
  BasicMovement: BasicMovement,
  BeamBufferGeometry: BeamBufferGeometry,
  BeamSegment: BeamSegment,
  BenefactorLevel: BenefactorLevel,
  Bias: Bias,
  get BlendingEquation () { return BlendingEquation; },
  get BlendingFactor () { return BlendingFactor; },
  get BlendingMode () { return BlendingMode; },
  Bone: Bone,
  BoundingBox: BoundingBox,
  BoundingBoxHelper: BoundingBoxHelper,
  Box: Box,
  BufferAttribute: BufferAttribute,
  BufferGeometry: BufferGeometry,
  BuildingInvis: BuildingInvis,
  BuildingRescueLevel: BuildingRescueLevel,
  BurnLevel: BurnLevel,
  CHILD_ADDED: CHILD_ADDED,
  CHILD_REMOVED: CHILD_REMOVED,
  COLLISION_GROUP_DEBRIS: COLLISION_GROUP_DEBRIS,
  COLLISION_GROUP_NONE: COLLISION_GROUP_NONE,
  CPVelocityForce: CPVelocityForce,
  CParticleSystemDefinition: CParticleSystemDefinition,
  Camera: Camera,
  CameraControl: CameraControl,
  CameraFrustum: CameraFrustum,
  get CameraProjection () { return CameraProjection; },
  CharacterMaterial: CharacterMaterial,
  ChoreographiesManager: ChoreographiesManager,
  Circle: Circle,
  Clamp: Clamp,
  ClearPass: ClearPass,
  CollisionViaTraces: CollisionViaTraces,
  ColorBackground: ColorBackground,
  ColorFade: ColorFade,
  ColorInterpolate: ColorInterpolate,
  ColorRandom: ColorRandom,
  get ColorSpace () { return ColorSpace; },
  CombineAdd: CombineAdd,
  CombineLerp: CombineLerp,
  CommunityWeapon: CommunityWeapon,
  Composer: Composer,
  Cone: Cone,
  ConstrainDistance: ConstrainDistance,
  ConstrainDistanceToControlPoint: ConstrainDistanceToControlPoint,
  ConstrainDistanceToPathBetweenTwoControlPoints: ConstrainDistanceToPathBetweenTwoControlPoints,
  ContextObserver: ContextObserver,
  ContinuousEmitter: ContinuousEmitter,
  ControlPoint: ControlPoint,
  CopyPass: CopyPass,
  CreateFromParentParticles: CreateFromParentParticles,
  CreateOnModel: CreateOnModel,
  CreateSequentialPath: CreateSequentialPath,
  CreateWithinBox: CreateWithinBox,
  CreateWithinSphere: CreateWithinSphere,
  CreationNoise: CreationNoise,
  CrosshatchPass: CrosshatchPass,
  CubeBackground: CubeBackground,
  CubeEnvironment: CubeEnvironment,
  CubeTexture: CubeTexture,
  CubicBezierCurve: CubicBezierCurve,
  CustomSteamImageOnModel: CustomSteamImageOnModel,
  CustomWeaponMaterial: CustomWeaponMaterial,
  Cylinder: Cylinder,
  DEFAULT_TEXTURE_SIZE: DEFAULT_TEXTURE_SIZE,
  DEG_TO_RAD: DEG_TO_RAD,
  DampenToCP: DampenToCP,
  Decal: Decal,
  Detex: Detex,
  DistanceBetweenCPs: DistanceBetweenCPs,
  DistanceCull: DistanceCull,
  DistanceToCP: DistanceToCP,
  Divide: Divide,
  DrawCircle: DrawCircle,
  DummyEntity: DummyEntity,
  ENTITY_DELETED: ENTITY_DELETED,
  EPSILON: EPSILON$2,
  EmitContinuously: EmitContinuously,
  EmitInstantaneously: EmitInstantaneously,
  EmitNoise: EmitNoise,
  Entity: Entity,
  EntityObserver: EntityObserver,
  Environment: Environment,
  Equals: Equals,
  ExponentialDecay: ExponentialDecay,
  EyeRefractMaterial: EyeRefractMaterial,
  FLT_EPSILON: FLT_EPSILON,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING,
  FadeAndKill: FadeAndKill,
  FadeIn: FadeIn,
  FadeInSimple: FadeInSimple,
  FadeOut: FadeOut,
  FadeOutSimple: FadeOutSimple,
  FileNameFromPath: FileNameFromPath,
  FirstPersonControl: FirstPersonControl,
  Float32BufferAttribute: Float32BufferAttribute,
  FloatArrayNode: FloatArrayNode,
  FontManager: FontManager,
  get FrameBufferTarget () { return FrameBufferTarget; },
  Framebuffer: Framebuffer,
  FullScreenQuad: FullScreenQuad,
  GL_ALPHA: GL_ALPHA,
  GL_ALWAYS: GL_ALWAYS,
  GL_ARRAY_BUFFER: GL_ARRAY_BUFFER,
  GL_BACK: GL_BACK,
  GL_BLEND: GL_BLEND,
  GL_BLUE: GL_BLUE,
  GL_BOOL: GL_BOOL,
  GL_BOOL_VEC2: GL_BOOL_VEC2,
  GL_BOOL_VEC3: GL_BOOL_VEC3,
  GL_BOOL_VEC4: GL_BOOL_VEC4,
  GL_BYTE: GL_BYTE,
  GL_CCW: GL_CCW,
  GL_CLAMP_TO_EDGE: GL_CLAMP_TO_EDGE,
  GL_COLOR_ATTACHMENT0: GL_COLOR_ATTACHMENT0,
  GL_COLOR_ATTACHMENT1: GL_COLOR_ATTACHMENT1,
  GL_COLOR_ATTACHMENT10: GL_COLOR_ATTACHMENT10,
  GL_COLOR_ATTACHMENT11: GL_COLOR_ATTACHMENT11,
  GL_COLOR_ATTACHMENT12: GL_COLOR_ATTACHMENT12,
  GL_COLOR_ATTACHMENT13: GL_COLOR_ATTACHMENT13,
  GL_COLOR_ATTACHMENT14: GL_COLOR_ATTACHMENT14,
  GL_COLOR_ATTACHMENT15: GL_COLOR_ATTACHMENT15,
  GL_COLOR_ATTACHMENT16: GL_COLOR_ATTACHMENT16,
  GL_COLOR_ATTACHMENT17: GL_COLOR_ATTACHMENT17,
  GL_COLOR_ATTACHMENT18: GL_COLOR_ATTACHMENT18,
  GL_COLOR_ATTACHMENT19: GL_COLOR_ATTACHMENT19,
  GL_COLOR_ATTACHMENT2: GL_COLOR_ATTACHMENT2,
  GL_COLOR_ATTACHMENT20: GL_COLOR_ATTACHMENT20,
  GL_COLOR_ATTACHMENT21: GL_COLOR_ATTACHMENT21,
  GL_COLOR_ATTACHMENT22: GL_COLOR_ATTACHMENT22,
  GL_COLOR_ATTACHMENT23: GL_COLOR_ATTACHMENT23,
  GL_COLOR_ATTACHMENT24: GL_COLOR_ATTACHMENT24,
  GL_COLOR_ATTACHMENT25: GL_COLOR_ATTACHMENT25,
  GL_COLOR_ATTACHMENT26: GL_COLOR_ATTACHMENT26,
  GL_COLOR_ATTACHMENT27: GL_COLOR_ATTACHMENT27,
  GL_COLOR_ATTACHMENT28: GL_COLOR_ATTACHMENT28,
  GL_COLOR_ATTACHMENT29: GL_COLOR_ATTACHMENT29,
  GL_COLOR_ATTACHMENT3: GL_COLOR_ATTACHMENT3,
  GL_COLOR_ATTACHMENT30: GL_COLOR_ATTACHMENT30,
  GL_COLOR_ATTACHMENT31: GL_COLOR_ATTACHMENT31,
  GL_COLOR_ATTACHMENT4: GL_COLOR_ATTACHMENT4,
  GL_COLOR_ATTACHMENT5: GL_COLOR_ATTACHMENT5,
  GL_COLOR_ATTACHMENT6: GL_COLOR_ATTACHMENT6,
  GL_COLOR_ATTACHMENT7: GL_COLOR_ATTACHMENT7,
  GL_COLOR_ATTACHMENT8: GL_COLOR_ATTACHMENT8,
  GL_COLOR_ATTACHMENT9: GL_COLOR_ATTACHMENT9,
  GL_COLOR_BUFFER_BIT: GL_COLOR_BUFFER_BIT,
  GL_CONSTANT_ALPHA: GL_CONSTANT_ALPHA,
  GL_CONSTANT_COLOR: GL_CONSTANT_COLOR,
  GL_COPY_READ_BUFFER: GL_COPY_READ_BUFFER,
  GL_COPY_WRITE_BUFFER: GL_COPY_WRITE_BUFFER,
  GL_CULL_FACE: GL_CULL_FACE,
  GL_CW: GL_CW,
  GL_DEPTH24_STENCIL8: GL_DEPTH24_STENCIL8,
  GL_DEPTH32F_STENCIL8: GL_DEPTH32F_STENCIL8,
  GL_DEPTH_ATTACHMENT: GL_DEPTH_ATTACHMENT,
  GL_DEPTH_BUFFER_BIT: GL_DEPTH_BUFFER_BIT,
  GL_DEPTH_COMPONENT: GL_DEPTH_COMPONENT,
  GL_DEPTH_COMPONENT16: GL_DEPTH_COMPONENT16,
  GL_DEPTH_COMPONENT24: GL_DEPTH_COMPONENT24,
  GL_DEPTH_COMPONENT32: GL_DEPTH_COMPONENT32,
  GL_DEPTH_COMPONENT32F: GL_DEPTH_COMPONENT32F,
  GL_DEPTH_STENCIL: GL_DEPTH_STENCIL,
  GL_DEPTH_TEST: GL_DEPTH_TEST,
  GL_DITHER: GL_DITHER,
  GL_DRAW_FRAMEBUFFER: GL_DRAW_FRAMEBUFFER,
  GL_DST_ALPHA: GL_DST_ALPHA,
  GL_DST_COLOR: GL_DST_COLOR,
  GL_DYNAMIC_COPY: GL_DYNAMIC_COPY,
  GL_DYNAMIC_DRAW: GL_DYNAMIC_DRAW,
  GL_DYNAMIC_READ: GL_DYNAMIC_READ,
  GL_ELEMENT_ARRAY_BUFFER: GL_ELEMENT_ARRAY_BUFFER,
  GL_EQUAL: GL_EQUAL,
  GL_FALSE: GL_FALSE,
  GL_FLOAT: GL_FLOAT,
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GL_FLOAT_32_UNSIGNED_INT_24_8_REV,
  GL_FLOAT_MAT2: GL_FLOAT_MAT2,
  GL_FLOAT_MAT2x3: GL_FLOAT_MAT2x3,
  GL_FLOAT_MAT2x4: GL_FLOAT_MAT2x4,
  GL_FLOAT_MAT3: GL_FLOAT_MAT3,
  GL_FLOAT_MAT3x2: GL_FLOAT_MAT3x2,
  GL_FLOAT_MAT3x4: GL_FLOAT_MAT3x4,
  GL_FLOAT_MAT4: GL_FLOAT_MAT4,
  GL_FLOAT_MAT4x2: GL_FLOAT_MAT4x2,
  GL_FLOAT_MAT4x3: GL_FLOAT_MAT4x3,
  GL_FLOAT_VEC2: GL_FLOAT_VEC2,
  GL_FLOAT_VEC3: GL_FLOAT_VEC3,
  GL_FLOAT_VEC4: GL_FLOAT_VEC4,
  GL_FRAGMENT_SHADER: GL_FRAGMENT_SHADER,
  GL_FRAMEBUFFER: GL_FRAMEBUFFER,
  GL_FRONT: GL_FRONT,
  GL_FRONT_AND_BACK: GL_FRONT_AND_BACK,
  GL_FUNC_ADD: GL_FUNC_ADD,
  GL_FUNC_REVERSE_SUBTRACT: GL_FUNC_REVERSE_SUBTRACT,
  GL_FUNC_SUBTRACT: GL_FUNC_SUBTRACT,
  GL_GEQUAL: GL_GEQUAL,
  GL_GREATER: GL_GREATER,
  GL_GREEN: GL_GREEN,
  GL_HALF_FLOAT: GL_HALF_FLOAT,
  GL_HALF_FLOAT_OES: GL_HALF_FLOAT_OES,
  GL_INT: GL_INT,
  GL_INT_SAMPLER_2D: GL_INT_SAMPLER_2D,
  GL_INT_SAMPLER_2D_ARRAY: GL_INT_SAMPLER_2D_ARRAY,
  GL_INT_SAMPLER_3D: GL_INT_SAMPLER_3D,
  GL_INT_SAMPLER_CUBE: GL_INT_SAMPLER_CUBE,
  GL_INT_VEC2: GL_INT_VEC2,
  GL_INT_VEC3: GL_INT_VEC3,
  GL_INT_VEC4: GL_INT_VEC4,
  GL_INVALID_ENUM: GL_INVALID_ENUM,
  GL_INVALID_OPERATION: GL_INVALID_OPERATION,
  GL_INVALID_VALUE: GL_INVALID_VALUE,
  GL_LEQUAL: GL_LEQUAL,
  GL_LESS: GL_LESS,
  GL_LINEAR: GL_LINEAR,
  GL_LINEAR_MIPMAP_LINEAR: GL_LINEAR_MIPMAP_LINEAR,
  GL_LINEAR_MIPMAP_NEAREST: GL_LINEAR_MIPMAP_NEAREST,
  GL_LINES: GL_LINES,
  GL_LINE_LOOP: GL_LINE_LOOP,
  GL_LINE_STRIP: GL_LINE_STRIP,
  GL_LUMINANCE: GL_LUMINANCE,
  GL_LUMINANCE_ALPHA: GL_LUMINANCE_ALPHA,
  GL_MAX: GL_MAX,
  GL_MAX_COLOR_ATTACHMENTS: GL_MAX_COLOR_ATTACHMENTS,
  GL_MAX_EXT: GL_MAX_EXT,
  GL_MAX_RENDERBUFFER_SIZE: GL_MAX_RENDERBUFFER_SIZE,
  GL_MAX_VERTEX_ATTRIBS: GL_MAX_VERTEX_ATTRIBS,
  GL_MIN: GL_MIN,
  GL_MIN_EXT: GL_MIN_EXT,
  GL_MIRRORED_REPEAT: GL_MIRRORED_REPEAT,
  GL_NEAREST: GL_NEAREST,
  GL_NEAREST_MIPMAP_LINEAR: GL_NEAREST_MIPMAP_LINEAR,
  GL_NEAREST_MIPMAP_NEAREST: GL_NEAREST_MIPMAP_NEAREST,
  GL_NEVER: GL_NEVER,
  GL_NONE: GL_NONE,
  GL_NOTEQUAL: GL_NOTEQUAL,
  GL_NO_ERROR: GL_NO_ERROR,
  GL_ONE: GL_ONE,
  GL_ONE_MINUS_CONSTANT_ALPHA: GL_ONE_MINUS_CONSTANT_ALPHA,
  GL_ONE_MINUS_CONSTANT_COLOR: GL_ONE_MINUS_CONSTANT_COLOR,
  GL_ONE_MINUS_DST_ALPHA: GL_ONE_MINUS_DST_ALPHA,
  GL_ONE_MINUS_DST_COLOR: GL_ONE_MINUS_DST_COLOR,
  GL_ONE_MINUS_SRC_ALPHA: GL_ONE_MINUS_SRC_ALPHA,
  GL_ONE_MINUS_SRC_COLOR: GL_ONE_MINUS_SRC_COLOR,
  GL_OUT_OF_MEMORY: GL_OUT_OF_MEMORY,
  GL_PIXEL_PACK_BUFFER: GL_PIXEL_PACK_BUFFER,
  GL_PIXEL_UNPACK_BUFFER: GL_PIXEL_UNPACK_BUFFER,
  GL_POINTS: GL_POINTS,
  GL_POLYGON_OFFSET_FILL: GL_POLYGON_OFFSET_FILL,
  GL_R16I: GL_R16I,
  GL_R16UI: GL_R16UI,
  GL_R32I: GL_R32I,
  GL_R32UI: GL_R32UI,
  GL_R8: GL_R8,
  GL_R8I: GL_R8I,
  GL_R8UI: GL_R8UI,
  GL_R8_SNORM: GL_R8_SNORM,
  GL_RASTERIZER_DISCARD: GL_RASTERIZER_DISCARD,
  GL_READ_FRAMEBUFFER: GL_READ_FRAMEBUFFER,
  GL_RED: GL_RED,
  GL_RENDERBUFFER: GL_RENDERBUFFER,
  GL_REPEAT: GL_REPEAT,
  GL_RG16I: GL_RG16I,
  GL_RG16UI: GL_RG16UI,
  GL_RG32I: GL_RG32I,
  GL_RG32UI: GL_RG32UI,
  GL_RG8: GL_RG8,
  GL_RG8I: GL_RG8I,
  GL_RG8UI: GL_RG8UI,
  GL_RGB: GL_RGB,
  GL_RGB10: GL_RGB10,
  GL_RGB10_A2: GL_RGB10_A2,
  GL_RGB10_A2UI: GL_RGB10_A2UI,
  GL_RGB12: GL_RGB12,
  GL_RGB16: GL_RGB16,
  GL_RGB16I: GL_RGB16I,
  GL_RGB16UI: GL_RGB16UI,
  GL_RGB32F: GL_RGB32F,
  GL_RGB32I: GL_RGB32I,
  GL_RGB4: GL_RGB4,
  GL_RGB5: GL_RGB5,
  GL_RGB565: GL_RGB565,
  GL_RGB5_A1: GL_RGB5_A1,
  GL_RGB8: GL_RGB8,
  GL_RGBA: GL_RGBA,
  GL_RGBA12: GL_RGBA12,
  GL_RGBA16: GL_RGBA16,
  GL_RGBA16F: GL_RGBA16F,
  GL_RGBA16I: GL_RGBA16I,
  GL_RGBA16UI: GL_RGBA16UI,
  GL_RGBA2: GL_RGBA2,
  GL_RGBA32F: GL_RGBA32F,
  GL_RGBA32I: GL_RGBA32I,
  GL_RGBA32UI: GL_RGBA32UI,
  GL_RGBA4: GL_RGBA4,
  GL_RGBA8: GL_RGBA8,
  GL_RGBA8I: GL_RGBA8I,
  GL_RGBA8UI: GL_RGBA8UI,
  GL_SAMPLER_2D: GL_SAMPLER_2D,
  GL_SAMPLER_2D_ARRAY: GL_SAMPLER_2D_ARRAY,
  GL_SAMPLER_2D_ARRAY_SHADOW: GL_SAMPLER_2D_ARRAY_SHADOW,
  GL_SAMPLER_2D_SHADOW: GL_SAMPLER_2D_SHADOW,
  GL_SAMPLER_3D: GL_SAMPLER_3D,
  GL_SAMPLER_CUBE: GL_SAMPLER_CUBE,
  GL_SAMPLER_CUBE_SHADOW: GL_SAMPLER_CUBE_SHADOW,
  GL_SAMPLE_ALPHA_TO_COVERAGE: GL_SAMPLE_ALPHA_TO_COVERAGE,
  GL_SAMPLE_COVERAGE: GL_SAMPLE_COVERAGE,
  GL_SCISSOR_TEST: GL_SCISSOR_TEST,
  GL_SHORT: GL_SHORT,
  GL_SRC_ALPHA: GL_SRC_ALPHA,
  GL_SRC_ALPHA_SATURATE: GL_SRC_ALPHA_SATURATE,
  GL_SRC_COLOR: GL_SRC_COLOR,
  GL_SRGB: GL_SRGB,
  GL_SRGB8: GL_SRGB8,
  GL_SRGB8_ALPHA8: GL_SRGB8_ALPHA8,
  GL_SRGB_ALPHA: GL_SRGB_ALPHA,
  GL_STACK_OVERFLOW: GL_STACK_OVERFLOW,
  GL_STACK_UNDERFLOW: GL_STACK_UNDERFLOW,
  GL_STATIC_COPY: GL_STATIC_COPY,
  GL_STATIC_DRAW: GL_STATIC_DRAW,
  GL_STATIC_READ: GL_STATIC_READ,
  GL_STENCIL_ATTACHMENT: GL_STENCIL_ATTACHMENT,
  GL_STENCIL_BUFFER_BIT: GL_STENCIL_BUFFER_BIT,
  GL_STENCIL_INDEX8: GL_STENCIL_INDEX8,
  GL_STENCIL_TEST: GL_STENCIL_TEST,
  GL_STREAM_COPY: GL_STREAM_COPY,
  GL_STREAM_DRAW: GL_STREAM_DRAW,
  GL_STREAM_READ: GL_STREAM_READ,
  GL_TEXTURE0: GL_TEXTURE0,
  GL_TEXTURE_2D: GL_TEXTURE_2D,
  GL_TEXTURE_2D_ARRAY: GL_TEXTURE_2D_ARRAY,
  GL_TEXTURE_3D: GL_TEXTURE_3D,
  GL_TEXTURE_BASE_LEVEL: GL_TEXTURE_BASE_LEVEL,
  GL_TEXTURE_COMPARE_FUNC: GL_TEXTURE_COMPARE_FUNC,
  GL_TEXTURE_COMPARE_MODE: GL_TEXTURE_COMPARE_MODE,
  GL_TEXTURE_CUBE_MAP: GL_TEXTURE_CUBE_MAP,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
  GL_TEXTURE_CUBE_MAP_POSITIVE_X: GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  GL_TEXTURE_MAG_FILTER: GL_TEXTURE_MAG_FILTER,
  GL_TEXTURE_MAX_LEVEL: GL_TEXTURE_MAX_LEVEL,
  GL_TEXTURE_MAX_LOD: GL_TEXTURE_MAX_LOD,
  GL_TEXTURE_MIN_FILTER: GL_TEXTURE_MIN_FILTER,
  GL_TEXTURE_MIN_LOD: GL_TEXTURE_MIN_LOD,
  GL_TEXTURE_WRAP_R: GL_TEXTURE_WRAP_R,
  GL_TEXTURE_WRAP_S: GL_TEXTURE_WRAP_S,
  GL_TEXTURE_WRAP_T: GL_TEXTURE_WRAP_T,
  GL_TRANSFORM_FEEDBACK_BUFFER: GL_TRANSFORM_FEEDBACK_BUFFER,
  GL_TRIANGLES: GL_TRIANGLES,
  GL_TRIANGLE_FAN: GL_TRIANGLE_FAN,
  GL_TRIANGLE_STRIP: GL_TRIANGLE_STRIP,
  GL_TRUE: GL_TRUE,
  GL_UNIFORM_BUFFER: GL_UNIFORM_BUFFER,
  GL_UNPACK_COLORSPACE_CONVERSION_WEBGL: GL_UNPACK_COLORSPACE_CONVERSION_WEBGL,
  GL_UNPACK_FLIP_Y_WEBGL: GL_UNPACK_FLIP_Y_WEBGL,
  GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL: GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL,
  GL_UNSIGNED_BYTE: GL_UNSIGNED_BYTE,
  GL_UNSIGNED_INT: GL_UNSIGNED_INT,
  GL_UNSIGNED_INT_10F_11F_11F_REV: GL_UNSIGNED_INT_10F_11F_11F_REV,
  GL_UNSIGNED_INT_24_8: GL_UNSIGNED_INT_24_8,
  GL_UNSIGNED_INT_2_10_10_10_REV: GL_UNSIGNED_INT_2_10_10_10_REV,
  GL_UNSIGNED_INT_5_9_9_9_REV: GL_UNSIGNED_INT_5_9_9_9_REV,
  GL_UNSIGNED_INT_SAMPLER_2D: GL_UNSIGNED_INT_SAMPLER_2D,
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GL_UNSIGNED_INT_SAMPLER_2D_ARRAY,
  GL_UNSIGNED_INT_SAMPLER_3D: GL_UNSIGNED_INT_SAMPLER_3D,
  GL_UNSIGNED_INT_SAMPLER_CUBE: GL_UNSIGNED_INT_SAMPLER_CUBE,
  GL_UNSIGNED_INT_VEC2: GL_UNSIGNED_INT_VEC2,
  GL_UNSIGNED_INT_VEC3: GL_UNSIGNED_INT_VEC3,
  GL_UNSIGNED_INT_VEC4: GL_UNSIGNED_INT_VEC4,
  GL_UNSIGNED_SHORT: GL_UNSIGNED_SHORT,
  GL_UNSIGNED_SHORT_4_4_4_4: GL_UNSIGNED_SHORT_4_4_4_4,
  GL_UNSIGNED_SHORT_5_5_5_1: GL_UNSIGNED_SHORT_5_5_5_1,
  GL_UNSIGNED_SHORT_5_6_5: GL_UNSIGNED_SHORT_5_6_5,
  GL_VERTEX_ARRAY: GL_VERTEX_ARRAY,
  GL_VERTEX_SHADER: GL_VERTEX_SHADER,
  GL_ZERO: GL_ZERO,
  GRIDCELL: GRIDCELL,
  GrainPass: GrainPass,
  Graphics: Graphics,
  get GraphicsEvent () { return GraphicsEvent; },
  GraphicsEvents: GraphicsEvents,
  Grid: Grid,
  GridMaterial: GridMaterial,
  Group: Group,
  HALF_PI: HALF_PI,
  HeartbeatScale: HeartbeatScale,
  HitboxHelper: HitboxHelper,
  Includes: Includes,
  InheritFromParentParticles: InheritFromParentParticles,
  InitFloat: InitFloat,
  InitFromCPSnapshot: InitFromCPSnapshot,
  InitSkinnedPositionFromCPSnapshot: InitSkinnedPositionFromCPSnapshot,
  InitVec: InitVec,
  InitialVelocityNoise: InitialVelocityNoise,
  InstantaneousEmitter: InstantaneousEmitter,
  IntArrayNode: IntArrayNode,
  IntProxy: IntProxy,
  InterpolateRadius: InterpolateRadius,
  Intersection: Intersection,
  Invis: Invis,
  ItemTintColor: ItemTintColor,
  JSONLoader: JSONLoader,
  KeepOnlyLastChild: KeepOnlyLastChild,
  LessOrEqualProxy: LessOrEqualProxy,
  LifespanDecay: LifespanDecay$1,
  LifetimeFromSequence: LifetimeFromSequence,
  LifetimeRandom: LifetimeRandom,
  Light: Light,
  LightMappedGenericMaterial: LightMappedGenericMaterial,
  LightShadow: LightShadow,
  Line: Line,
  LineMaterial: LineMaterial,
  LineSegments: LineSegments,
  LinearBezierCurve: LinearBezierCurve,
  LinearRamp: LinearRamp,
  LockToBone: LockToBone$1,
  LoopSubdivision: LoopSubdivision,
  MATERIAL_BLENDING_NONE: MATERIAL_BLENDING_NONE,
  MATERIAL_BLENDING_NORMAL: MATERIAL_BLENDING_NORMAL,
  MATERIAL_CULLING_BACK: MATERIAL_CULLING_BACK,
  MATERIAL_CULLING_FRONT: MATERIAL_CULLING_FRONT,
  MATERIAL_CULLING_FRONT_AND_BACK: MATERIAL_CULLING_FRONT_AND_BACK,
  MATERIAL_CULLING_NONE: MATERIAL_CULLING_NONE,
  MAX_FLOATS: MAX_FLOATS,
  MOUSE: MOUSE,
  MaintainEmitter: MaintainEmitter,
  MaintainSequentialPath: MaintainSequentialPath,
  ManifestRepository: ManifestRepository,
  Manipulator: Manipulator,
  MapEntities: MapEntities,
  MateriaParameter: MateriaParameter,
  get MateriaParameterType () { return MateriaParameterType; },
  Material: Material,
  MergeRepository: MergeRepository,
  Mesh: Mesh,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshBasicPbrMaterial: MeshBasicPbrMaterial,
  MeshFlatMaterial: MeshFlatMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  Metaball: Metaball,
  Metaballs: Metaballs,
  ModelGlowColor: ModelGlowColor,
  ModelLoader: ModelLoader,
  MovementBasic: MovementBasic,
  MovementLocktoControlPoint: MovementLocktoControlPoint,
  MovementMaxVelocity: MovementMaxVelocity,
  MovementRigidAttachToCP: MovementRigidAttachToCP,
  MovementRotateParticleAroundAxis: MovementRotateParticleAroundAxis$1,
  Multiply: Multiply$1,
  Node: Node,
  NodeImageEditor: NodeImageEditor,
  NodeImageEditorGui: NodeImageEditorGui,
  NodeImageEditorMaterial: NodeImageEditorMaterial,
  Noise: Noise,
  NoiseEmitter: NoiseEmitter,
  NormalAlignToCP: NormalAlignToCP,
  NormalLock: NormalLock,
  NormalOffset: NormalOffset,
  NormalizeVector: NormalizeVector,
  OBJImporter: OBJImporter,
  ONE_EPS: ONE_EPS,
  ObjExporter: ObjExporter,
  OffsetVectorToVector: OffsetVectorToVector,
  OldMoviePass: OldMoviePass,
  OrbitControl: OrbitControl,
  OscillateScalar: OscillateScalar$1,
  OscillateScalarSimple: OscillateScalarSimple,
  OscillateVector: OscillateVector$1,
  OutlinePass: OutlinePass,
  OverrideRepository: OverrideRepository,
  PARENT_CHANGED: PARENT_CHANGED,
  PI: PI,
  PROPERTY_CHANGED: PROPERTY_CHANGED$1,
  PalettePass: PalettePass,
  ParametersNode: ParametersNode,
  ParticleRandomFloat: ParticleRandomFloat,
  ParticleRandomVec3: ParticleRandomVec3,
  Pass: Pass,
  Path: Path,
  PercentageBetweenCPs: PercentageBetweenCPs,
  PinParticleToCP: PinParticleToCP,
  PixelatePass: PixelatePass,
  Plane: Plane,
  PlaneCull: PlaneCull,
  PointLight: PointLight,
  PointLightHelper: PointLightHelper,
  Polygonise: Polygonise,
  PositionAlongPathRandom: PositionAlongPathRandom,
  PositionAlongPathSequential: PositionAlongPathSequential,
  PositionFromParentParticles: PositionFromParentParticles,
  PositionLock: PositionLock,
  PositionModifyOffsetRandom: PositionModifyOffsetRandom,
  PositionOffset: PositionOffset,
  PositionOnModelRandom: PositionOnModelRandom,
  PositionWarp: PositionWarp,
  PositionWithinBoxRandom: PositionWithinBoxRandom,
  PositionWithinSphereRandom: PositionWithinSphereRandom,
  Program: Program,
  ProxyManager: ProxyManager,
  PullTowardsControlPoint: PullTowardsControlPoint,
  QuadraticBezierCurve: QuadraticBezierCurve,
  RAD_TO_DEG: RAD_TO_DEG,
  RadiusFromCPObject: RadiusFromCPObject,
  RadiusRandom: RadiusRandom,
  RadiusScale: RadiusScale,
  RampScalarLinear: RampScalarLinear,
  RampScalarLinearSimple: RampScalarLinearSimple,
  RampScalarSpline: RampScalarSpline,
  RandomAlpha: RandomAlpha,
  RandomColor: RandomColor,
  RandomFloat: RandomFloat,
  RandomFloatExp: RandomFloatExp,
  RandomForce: RandomForce$1,
  RandomLifeTime: RandomLifeTime,
  RandomRadius: RandomRadius,
  RandomRotation: RandomRotation,
  RandomRotationSpeed: RandomRotationSpeed,
  RandomScalar: RandomScalar,
  RandomSecondSequence: RandomSecondSequence,
  RandomSequence: RandomSequence,
  RandomTrailLength: RandomTrailLength,
  RandomVector: RandomVector,
  RandomVectorInUnitSphere: RandomVectorInUnitSphere,
  RandomYaw: RandomYaw,
  RandomYawFlip: RandomYawFlip,
  Ray: Ray,
  Raycaster: Raycaster,
  RefractMaterial: RefractMaterial,
  RemGenerator: RemGenerator,
  RemapCPOrientationToRotations: RemapCPOrientationToRotations,
  RemapCPSpeedToCP: RemapCPSpeedToCP,
  RemapCPtoScalar: RemapCPtoScalar,
  RemapCPtoVector: RemapCPtoVector,
  RemapControlPointDirectionToVector: RemapControlPointDirectionToVector,
  RemapControlPointToScalar: RemapControlPointToScalar,
  RemapControlPointToVector: RemapControlPointToVector,
  RemapDistanceToControlPointToScalar: RemapDistanceToControlPointToScalar,
  RemapDistanceToControlPointToVector: RemapDistanceToControlPointToVector,
  RemapInitialScalar: RemapInitialScalar,
  RemapNoiseToScalar: RemapNoiseToScalar,
  RemapParticleCountToScalar: RemapParticleCountToScalar,
  RemapScalar: RemapScalar,
  RemapScalarToVector: RemapScalarToVector,
  RemapValClamped: RemapValClamped,
  RemapValClampedBias: RemapValClampedBias,
  RenderAnimatedSprites: RenderAnimatedSprites,
  RenderBlobs: RenderBlobs,
  get RenderBufferInternalFormat () { return RenderBufferInternalFormat; },
  RenderDeferredLight: RenderDeferredLight,
  get RenderFace () { return RenderFace; },
  RenderModels: RenderModels,
  RenderPass: RenderPass,
  RenderRope: RenderRope,
  RenderRopes: RenderRopes,
  RenderScreenVelocityRotate: RenderScreenVelocityRotate,
  RenderSpriteTrail: RenderSpriteTrail,
  RenderSprites: RenderSprites,
  RenderTarget: RenderTarget,
  RenderTargetViewer: RenderTargetViewer,
  RenderTrails: RenderTrails,
  Renderbuffer: Renderbuffer,
  Repositories: Repositories,
  RepositoryEntry: RepositoryEntry,
  get RepositoryError () { return RepositoryError; },
  RgbeImporter: RgbeImporter,
  RingWave: RingWave,
  RotationBasic: RotationBasic,
  RotationControl: RotationControl,
  RotationRandom: RotationRandom,
  RotationSpeedRandom: RotationSpeedRandom,
  RotationSpinRoll: RotationSpinRoll,
  RotationSpinYaw: RotationSpinYaw,
  RotationYawFlipRandom: RotationYawFlipRandom,
  RotationYawRandom: RotationYawRandom,
  SaturatePass: SaturatePass,
  Scene: Scene,
  SceneExplorer: SceneExplorer,
  Select: Select,
  SelectFirstIfNonZero: SelectFirstIfNonZero,
  SequenceLifeTime: SequenceLifeTime,
  SequenceRandom: SequenceRandom,
  SetCPOrientationToGroundNormal: SetCPOrientationToGroundNormal,
  SetChildControlPointsFromParticlePositions: SetChildControlPointsFromParticlePositions,
  SetControlPointFromObjectScale: SetControlPointFromObjectScale,
  SetControlPointOrientation: SetControlPointOrientation,
  SetControlPointPositions: SetControlPointPositions$1,
  SetControlPointToCenter: SetControlPointToCenter,
  SetControlPointToParticlesCenter: SetControlPointToParticlesCenter,
  SetControlPointsToModelParticles: SetControlPointsToModelParticles,
  SetFloat: SetFloat,
  SetParentControlPointsToChildCP: SetParentControlPointsToChildCP,
  SetPerChildControlPoint: SetPerChildControlPoint,
  SetRandomControlPointPosition: SetRandomControlPointPosition,
  SetRigidAttachment: SetRigidAttachment,
  SetSingleControlPointPosition: SetSingleControlPointPosition,
  SetToCP: SetToCP,
  SetVec: SetVec,
  get ShaderDebugMode () { return ShaderDebugMode; },
  ShaderEditor: ShaderEditor,
  ShaderManager: ShaderManager,
  ShaderMaterial: ShaderMaterial,
  get ShaderPrecision () { return ShaderPrecision; },
  get ShaderQuality () { return ShaderQuality; },
  ShaderToyMaterial: ShaderToyMaterial,
  Shaders: Shaders,
  ShadowMap: ShadowMap,
  SimpleSpline: SimpleSpline,
  Sine: Sine,
  SkeletalMesh: SkeletalMesh,
  Skeleton: Skeleton,
  SkeletonHelper: SkeletonHelper,
  SketchPass: SketchPass,
  SnapshotRigidSkinToBones: SnapshotRigidSkinToBones,
  Source1ModelInstance: Source1ModelInstance,
  Source1ModelManager: Source1ModelManager,
  Source1Multiply: Multiply,
  Source1ParticleControler: Source1ParticleControler,
  Source1SoundManager: Source1SoundManager,
  Source1TextureManager: Source1TextureManager,
  Source2Crystal: Source2Crystal,
  Source2CsgoCharacter: Source2CsgoCharacter,
  Source2CsgoComplex: Source2CsgoComplex,
  Source2CsgoEffects: Source2CsgoEffects,
  Source2CsgoEnvironment: Source2CsgoEnvironment,
  Source2CsgoEnvironmentBlend: Source2CsgoEnvironmentBlend,
  Source2CsgoFoliage: Source2CsgoFoliage,
  Source2CsgoGlass: Source2CsgoGlass,
  Source2CsgoSimple: Source2CsgoSimple,
  Source2CsgoStaticOverlay: Source2CsgoStaticOverlay,
  Source2CsgoUnlitGeneric: Source2CsgoUnlitGeneric,
  Source2CsgoVertexLitGeneric: Source2CsgoVertexLitGeneric,
  Source2CsgoWeapon: Source2CsgoWeapon,
  Source2CsgoWeaponStattrak: Source2CsgoWeaponStattrak,
  Source2EnvironmentBlend: Source2EnvironmentBlend,
  Source2Error: Source2Error,
  Source2FileLoader: Source2FileLoader,
  Source2Generic: Source2Generic,
  Source2GlobalLitSimple: Source2GlobalLitSimple,
  Source2Hero: Source2Hero,
  Source2HeroFluid: Source2HeroFluid,
  Source2InitRemapCPtoScalar: RemapCPtoScalar$1,
  Source2LifespanDecay: LifespanDecay,
  Source2LockToBone: LockToBone,
  Source2Material: Source2Material,
  Source2MaterialManager: Source2MaterialManager,
  Source2ModelInstance: Source2ModelInstance,
  Source2ModelLoader: Source2ModelLoader,
  Source2ModelManager: Source2ModelManager,
  Source2MovementRotateParticleAroundAxis: MovementRotateParticleAroundAxis,
  Source2OscillateScalar: OscillateScalar,
  Source2OscillateVector: OscillateVector,
  Source2ParticleLoader: Source2ParticleLoader,
  Source2ParticleManager: Source2ParticleManager,
  Source2ParticleSystem: Source2ParticleSystem,
  Source2Pbr: Source2Pbr,
  Source2RandomForce: RandomForce,
  Source2SetControlPointPositions: SetControlPointPositions,
  Source2SnapshotLoader: Source2SnapshotLoader,
  Source2SpringMeteor: Source2SpringMeteor,
  Source2SpriteCard: Source2SpriteCard,
  Source2TextureManager: Source2TextureManager,
  Source2UI: Source2UI,
  Source2Unlit: Source2Unlit,
  Source2VelocityRandom: VelocityRandom,
  Source2VrBlackUnlit: Source2VrBlackUnlit,
  Source2VrComplex: Source2VrComplex,
  Source2VrEyeball: Source2VrEyeball,
  Source2VrGlass: Source2VrGlass,
  Source2VrMonitor: Source2VrMonitor,
  Source2VrSimple: Source2VrSimple,
  Source2VrSimple2WayBlend: Source2VrSimple2WayBlend,
  Source2VrSimple3LayerParallax: Source2VrSimple3LayerParallax,
  Source2VrSkin: Source2VrSkin,
  Source2VrXenFoliage: Source2VrXenFoliage,
  SourceBSP: SourceBSP,
  SourceEngineBSPLoader: SourceEngineBSPLoader,
  SourceEngineMDLLoader: SourceEngineMDLLoader,
  SourceEngineMaterialManager: SourceEngineMaterialManager,
  SourceEnginePCFLoader: SourceEnginePCFLoader,
  SourceEngineParticleOperators: SourceEngineParticleOperators,
  SourceEngineParticleSystem: SourceEngineParticleSystem,
  SourceEngineVMTLoader: SourceEngineVMTLoader,
  SourceEngineVTXLoader: SourceEngineVTXLoader,
  SourceEngineVVDLoader: SourceEngineVVDLoader,
  SourceModel: SourceModel,
  Sphere: Sphere,
  Spin: Spin,
  SpinUpdate: SpinUpdate,
  SpotLight: SpotLight,
  SpotLightHelper: SpotLightHelper,
  SpriteCardMaterial: SpriteCardMaterial,
  SpriteMaterial: SpriteMaterial,
  SpyInvis: SpyInvis,
  StatTrakDigit: StatTrakDigit,
  StatTrakIllum: StatTrakIllum,
  StickybombGlowColor: StickybombGlowColor,
  TAU: TAU,
  TEXTURE_FORMAT_COMPRESSED_BPTC: TEXTURE_FORMAT_COMPRESSED_BPTC,
  TEXTURE_FORMAT_COMPRESSED_RGBA_BC4: TEXTURE_FORMAT_COMPRESSED_RGBA_BC4,
  TEXTURE_FORMAT_COMPRESSED_RGBA_BC5: TEXTURE_FORMAT_COMPRESSED_RGBA_BC5,
  TEXTURE_FORMAT_COMPRESSED_RGBA_BC7: TEXTURE_FORMAT_COMPRESSED_RGBA_BC7,
  TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1: TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1,
  TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3: TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3,
  TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5: TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5,
  TEXTURE_FORMAT_COMPRESSED_RGB_DXT1: TEXTURE_FORMAT_COMPRESSED_RGB_DXT1,
  TEXTURE_FORMAT_COMPRESSED_RGTC: TEXTURE_FORMAT_COMPRESSED_RGTC,
  TEXTURE_FORMAT_COMPRESSED_S3TC: TEXTURE_FORMAT_COMPRESSED_S3TC,
  TEXTURE_FORMAT_UNCOMPRESSED: TEXTURE_FORMAT_UNCOMPRESSED,
  TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888: TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888,
  TEXTURE_FORMAT_UNCOMPRESSED_R8: TEXTURE_FORMAT_UNCOMPRESSED_R8,
  TEXTURE_FORMAT_UNCOMPRESSED_RGB: TEXTURE_FORMAT_UNCOMPRESSED_RGB,
  TEXTURE_FORMAT_UNCOMPRESSED_RGBA: TEXTURE_FORMAT_UNCOMPRESSED_RGBA,
  TEXTURE_FORMAT_UNKNOWN: TEXTURE_FORMAT_UNKNOWN,
  TRIANGLE: TRIANGLE,
  TWO_PI: TWO_PI,
  Target: Target,
  Text3D: Text3D,
  Texture: Texture,
  TextureFactoryEventTarget: TextureFactoryEventTarget,
  get TextureFormat () { return TextureFormat; },
  TextureLookup: TextureLookup,
  TextureManager: TextureManager,
  get TextureMapping () { return TextureMapping; },
  TextureScroll: TextureScroll,
  get TextureTarget () { return TextureTarget; },
  TextureTransform: TextureTransform,
  get TextureType () { return TextureType; },
  Timeline: Timeline,
  TimelineChannel: TimelineChannel,
  TimelineClip: TimelineClip,
  TimelineElement: TimelineElement,
  get TimelineElementType () { return TimelineElementType; },
  TimelineGroup: TimelineGroup,
  get ToneMapping () { return ToneMapping; },
  TrailLengthRandom: TrailLengthRandom,
  TranslationControl: TranslationControl,
  Triangles: Triangles,
  TwistAroundAxis: TwistAroundAxis,
  Uint16BufferAttribute: Uint16BufferAttribute,
  Uint32BufferAttribute: Uint32BufferAttribute,
  Uint8BufferAttribute: Uint8BufferAttribute,
  UniformNoiseProxy: UniformNoiseProxy,
  UnlitGenericMaterial: UnlitGenericMaterial,
  UnlitTwoTextureMaterial: UnlitTwoTextureMaterial,
  Vec3Middle: Vec3Middle,
  VectorNoise: VectorNoise,
  VelocityNoise: VelocityNoise,
  VelocityRandom: VelocityRandom$1,
  VertexLitGenericMaterial: VertexLitGenericMaterial,
  VpkRepository: VpkRepository,
  WaterLod: WaterLod,
  WaterMaterial: WaterMaterial,
  WeaponDecalMaterial: WeaponDecalMaterial,
  WeaponInvis: WeaponInvis,
  WeaponLabelText: WeaponLabelText,
  WeaponSkin: WeaponSkin,
  WebGLRenderingState: WebGLRenderingState,
  WebGLShaderSource: WebGLShaderSource,
  WebGLStats: WebGLStats,
  WebRepository: WebRepository,
  Wireframe: Wireframe,
  World: World,
  WorldVertexTransitionMaterial: WorldVertexTransitionMaterial,
  YellowLevel: YellowLevel,
  ZipRepository: ZipRepository,
  Zstd: Zstd,
  addIncludeSource: addIncludeSource,
  ceilPowerOfTwo: ceilPowerOfTwo,
  clamp: clamp,
  createTexture: createTexture,
  customFetch: customFetch,
  decodeLz4: decodeLz4,
  degToRad: degToRad,
  deleteTexture: deleteTexture,
  exportToBinaryFBX: exportToBinaryFBX,
  fillCheckerTexture: fillCheckerTexture,
  fillFlatTexture: fillFlatTexture,
  fillNoiseTexture: fillNoiseTexture,
  fillTextureWithImage: fillTextureWithImage,
  flipPixelArray: flipPixelArray,
  generateRandomUUID: generateRandomUUID,
  getHelper: getHelper,
  getIncludeList: getIncludeList,
  getIncludeSource: getIncludeSource,
  getRandomInt: getRandomInt,
  getSceneExplorer: getSceneExplorer,
  imageDataToImage: imageDataToImage,
  initRandomFloats: initRandomFloats,
  isNumeric: isNumeric,
  lerp: lerp,
  loadAnimGroup: loadAnimGroup,
  pow2: pow2,
  quatFromEulerRad: quatFromEulerRad,
  quatToEuler: quatToEuler,
  quatToEulerDeg: quatToEulerDeg,
  radToDeg: radToDeg,
  setCustomIncludeSource: setCustomIncludeSource,
  setFetchFunction: setFetchFunction,
  setTextureFactoryContext: setTextureFactoryContext,
  stringToQuat: stringToQuat,
  stringToVec3: stringToVec3,
  vec3ClampScalar: vec3ClampScalar,
  vec3RandomBox: vec3RandomBox
});

class Range {
    low;
    high;
    constructor(low = 0, high = 0) {
        this.low = low;
        this.high = high;
    }
}

let blackTexture;
class Stage {
    static #textures = new Map();
    texturePath = '';
    specularTexturePath = '';
    node;
    #firstChild;
    #nextSibling;
    constructor(node) {
        this.node = node;
        if (!blackTexture) {
            new Graphics().ready.then(() => {
                blackTexture = TextureManager.createFlatTexture([0, 0, 0]);
                blackTexture.addUser(1);
            });
        }
    }
    computeRandomValues(currentIndexObject, pRNGs, nRNGCount) {
        if (this.computeRandomValuesThis(pRNGs[currentIndexObject.currentIndex])) {
            currentIndexObject.currentIndex = (currentIndexObject.currentIndex + 1) % nRNGCount;
        }
        if (this.#firstChild) {
            this.#firstChild.computeRandomValues(currentIndexObject, pRNGs, nRNGCount);
        }
        if (this.#nextSibling) {
            this.#nextSibling.computeRandomValues(currentIndexObject, pRNGs, nRNGCount);
        }
    }
    computeRandomValuesThis(s) {
        throw 'subclass me';
    }
    set firstChild(stage) {
        this.#firstChild = stage;
    }
    get firstChild() {
        return this.#firstChild;
    }
    set nextSibling(stage) {
        this.#nextSibling = stage;
    }
    get nextSibling() {
        return this.#nextSibling;
    }
    appendChildren(children) {
        for (let i = children.length - 1; i >= 0; --i) {
            let childStage = children[i];
            //console.error(childStage);
            childStage.nextSibling = this.firstChild;
            this.firstChild = childStage;
        }
    }
    get displayName() {
        return this.constructor.name;
    }
    toString(tabs = '') {
        let ret = [];
        let tabs1 = tabs + '\t';
        ret.push(tabs + this.displayName);
        if (this.#firstChild) {
            ret.push(this.#firstChild.toString(tabs1));
        }
        if (this.#nextSibling) {
            ret.push(this.#nextSibling.toString(tabs));
        }
        return ret.join('\n');
    }
    linkNodes() {
        let node = this.node;
        let inputs = node.inputs.keys();
        let childStage = this.firstChild;
        while (childStage) {
            childStage.linkNodes();
            let input = inputs.next().value;
            let subNode = childStage.node;
            node.setPredecessor(input, subNode, 'output');
            childStage = childStage.nextSibling;
        }
    }
    async _setupTextures() {
        let texturePath = this.texturePath;
        if (texturePath) {
            this.node.inputTexture = await Stage.getTexture(texturePath);
            this.node.setParam('path', texturePath);
            this.node.invalidate();
        }
        let specularTexturePath = this.specularTexturePath;
        if (specularTexturePath) {
            try {
                this.node.getInput('specular').value = await Stage.getSpecularTexture(texturePath);
            }
            catch (e) {
                console.log(e);
            }
        }
    }
    async setupTextures() {
        const promises = new Set();
        promises.add(this._setupTextures());
        let childStage = this.firstChild;
        while (childStage) {
            promises.add(childStage.setupTextures());
            childStage = childStage.nextSibling;
        }
        await Promise.all(promises);
    }
    static async getTexture(texturePath, def) {
        if (!Stage.#textures.has(texturePath)) {
            const promise = Source1TextureManager.getTextureAsync('tf2', texturePath, 0, false, def, false);
            promise.then(texture => {
                if (texture) {
                    texture.addUser(this);
                }
                else {
                    Stage.#textures.delete(texturePath);
                }
            });
            Stage.#textures.set(texturePath, promise);
        }
        return await Stage.#textures.get(texturePath);
    }
    static async getSpecularTexture(specularTexturePath) {
        return this.getTexture(specularTexturePath, blackTexture);
    }
}

class CombineStageParameters {
    adjustBlack = new Range();
    adjustOffset = new Range(1, 1);
    adjustGamma = new Range(1, 1);
}
class CombineStage extends Stage {
    combineMode;
    parameters = new CombineStageParameters();
    constructor(node, combineMode) {
        super(node);
        this.combineMode = combineMode;
    }
    computeRandomValuesThis(randomStream) {
        let parameters = this.parameters;
        let adjustBlack = randomStream.randomFloat(parameters.adjustBlack.low, parameters.adjustBlack.high);
        let adjustOffset = randomStream.randomFloat(parameters.adjustOffset.low, parameters.adjustOffset.high);
        let adjustGamma = randomStream.randomFloat(parameters.adjustGamma.low, parameters.adjustGamma.high);
        let adjustWhite = adjustBlack + adjustOffset;
        let node = this.node;
        /*node.params.adjustBlack = adjustBlack;
        node.params.adjustWhite = adjustWhite;
        node.params.adjustGamma = adjustGamma;*/
        node.setParam('adjust black', adjustBlack);
        node.setParam('adjust white', adjustWhite);
        node.setParam('adjust gamma', adjustGamma);
        return true;
    }
    get displayName() {
        return this.combineMode;
    }
}

class TextureStageParameters {
    adjustBlack = new Range();
    adjustOffset = new Range(1, 1);
    adjustGamma = new Range(1, 1);
    rotation = new Range();
    translateU = new Range();
    translateV = new Range();
    scaleUV = new Range(1, 1);
    allowFlipU = false;
    allowFlipV = false;
    texturePath = '';
}
class TextureStage extends Stage {
    texturePath = '';
    parameters = new TextureStageParameters();
    computeRandomValuesThis(randomStream) {
        let parameters = this.parameters;
        let shouldFlipU = parameters.allowFlipU ? randomStream.randomInt(0, 1) != 0 : false;
        let shouldFlipV = parameters.allowFlipV ? randomStream.randomInt(0, 1) != 0 : false;
        let translateU = randomStream.randomFloat(parameters.translateU.low, parameters.translateU.high);
        let translateV = randomStream.randomFloat(parameters.translateV.low, parameters.translateV.high);
        let rotation = randomStream.randomFloat(parameters.rotation.low, parameters.rotation.high);
        let scaleUV = randomStream.randomFloat(parameters.scaleUV.low, parameters.scaleUV.high);
        let adjustBlack = randomStream.randomFloat(parameters.adjustBlack.low, parameters.adjustBlack.high);
        let adjustOffset = randomStream.randomFloat(parameters.adjustOffset.low, parameters.adjustOffset.high);
        let adjustGamma = randomStream.randomFloat(parameters.adjustGamma.low, parameters.adjustGamma.high);
        let adjustWhite = adjustBlack + adjustOffset;
        let node = this.node;
        node.setParam('adjust black', adjustBlack);
        node.setParam('adjust white', adjustWhite);
        node.setParam('adjust gamma', adjustGamma);
        node.setParam('rotation', rotation * DEG_TO_RAD);
        node.setParam('translate u', translateU);
        node.setParam('translate v', translateV);
        node.setParam('scale u', scaleUV * (shouldFlipU ? -1 : 1));
        node.setParam('scale v', scaleUV * (shouldFlipV ? -1 : 1));
        node.setParam('path', parameters.texturePath);
        node.invalidate();
        return true;
    }
}

const TEXTURE_LOOKUP_NODE = 'texture lookup';
class SelectStageParameters {
}
class SelectStage extends Stage {
    nodeImageEditor;
    parameters = new SelectStageParameters();
    constructor(node, nodeImageEditor) {
        super(node);
        this.nodeImageEditor = nodeImageEditor;
    }
    computeRandomValuesThis(randomStream) {
        return false;
    }
    async _setupTextures() {
        let texturePath = this.texturePath;
        if (texturePath) {
            let lookupNode = this.nodeImageEditor.addNode(TEXTURE_LOOKUP_NODE);
            this.node.setPredecessor('input', lookupNode, 'output');
            lookupNode.inputTexture = await Stage.getTexture(texturePath);
            lookupNode.texturePath = texturePath;
            lookupNode.invalidate();
        }
    }
}

class ApplyStickerStageParameters {
    possibleStickers = [];
    adjustBlack = new Range();
    adjustOffset = new Range(1, 1);
    adjustGamma = new Range(1, 1);
    bl = create();
    tl = create();
    tr = create();
}
class Sticker {
    fileName = '';
    weight = 1.0;
}
class ApplyStickerStage extends Stage {
    parameters = new ApplyStickerStageParameters();
    choice;
    computeRandomValuesThis(randomStream) {
        let parameters = this.parameters;
        const computeWeight = (accumulator, currentValue) => accumulator + currentValue.weight;
        let totalWeight = parameters.possibleStickers.reduce(computeWeight, 0);
        //console.error(totalWeight);
        let weight = randomStream.randomFloat(0.0, totalWeight);
        for (let [i, possibleSticker] of parameters.possibleStickers.entries()) {
            let thisWeight = possibleSticker.weight;
            if (weight < thisWeight) {
                this.choice = i;
                this.texturePath = parameters.possibleStickers[i].fileName;
                this.specularTexturePath = parameters.possibleStickers[i].fileName.replace(/.vtf$/, '') + '_s';
                break;
            }
            else {
                weight -= thisWeight;
            }
        }
        if (this.choice == undefined) {
            throw 'error';
        }
        let adjustBlack = randomStream.randomFloat(parameters.adjustBlack.low, parameters.adjustBlack.high);
        let adjustOffset = randomStream.randomFloat(parameters.adjustOffset.low, parameters.adjustOffset.high);
        let adjustGamma = randomStream.randomFloat(parameters.adjustGamma.low, parameters.adjustGamma.high);
        let adjustWhite = adjustBlack + adjustOffset;
        let node = this.node;
        /*node.params.adjustBlack = adjustBlack;
        node.params.adjustWhite = adjustWhite;
        node.params.adjustGamma = adjustGamma;*/
        node.setParam('adjust black', adjustBlack);
        node.setParam('adjust white', adjustWhite);
        node.setParam('adjust gamma', adjustGamma);
        node.setParam('bottom left', parameters.bl);
        node.setParam('top left', parameters.tl);
        node.setParam('top right', parameters.tr);
        //vec2.copy(node.params.bl, parameters.bl);
        //vec2.copy(node.params.tl, parameters.tl);
        //vec2.copy(node.params.tr, parameters.tr);
        node.invalidate();
        return true;
    }
}

const legacyPaintKits = new Map();
function getLegacyPaintKit(id) {
    return legacyPaintKits.get(id) ?? id;
}

const TYPE_STRING_TO_INT = {
    'DEF_TYPE_PAINTKIT_VARIABLES': 6,
    'DEF_TYPE_PAINTKIT_OPERATION': 7,
    'DEF_TYPE_PAINTKIT_ITEM_DEFINITION': 8,
    'DEF_TYPE_PAINTKIT_DEFINITION': 9,
    'DEF_TYPE_HEADER_ONLY': 10,
};
class PaintKitDefinitions {
    static warpaintDefinitionsPromise;
    static warpaintDefinitions;
    static #warpaintDefinitionsURL = '';
    static setWarpaintDefinitionsURL(url) {
        this.#warpaintDefinitionsURL = url;
    }
    static getWarpaintDefinitions() {
        if (!this.warpaintDefinitionsPromise) {
            this.warpaintDefinitionsPromise = new Promise(async (resolve, reject) => {
                let reponse = await fetch(this.#warpaintDefinitionsURL);
                this.warpaintDefinitions = await reponse.json();
                resolve(this.warpaintDefinitions);
            });
        }
        return this.warpaintDefinitionsPromise;
    }
    static setWarpaintDefinitions(warpaintDefinitions) {
        this.warpaintDefinitionsPromise = new Promise(async (resolve) => {
            resolve(warpaintDefinitions);
        });
    }
    static async getDefinition(cMsgProtoDefID) {
        let warpaintDefinitions = await this.getWarpaintDefinitions();
        if (warpaintDefinitions) {
            let type = warpaintDefinitions[String(TYPE_STRING_TO_INT[String(cMsgProtoDefID.type)] ?? cMsgProtoDefID.type)];
            if (type) {
                return type[String(cMsgProtoDefID.defindex)];
            }
        }
        return null;
    }
}

const NTAB = 32;
const IA = 16807;
const IM = 2147483647;
const IQ = 127773;
const IR = 2836;
const NDIV = (1 + (IM - 1) / NTAB);
const MAX_RANDOM_RANGE = 0x7FFFFFFF;
const AM = (1.0 / IM);
const EPS = 1.2e-7;
const RNMX = (1.0 - EPS);
class UniformRandomStream {
    #m_idum = 0;
    #m_iy = 0;
    #m_iv = [];
    constructor(seed = 0) {
        this.seed = seed;
    }
    set seed(seed) {
        this.#m_idum = ((seed < 0) ? seed : -seed);
        this.#m_iy = 0;
        this.#m_iv = new Array(NTAB);
    }
    #generateRandomNumber() {
        let j;
        let k;
        if (this.#m_idum <= 0 || !this.#m_iy) {
            if (-(this.#m_idum) < 1)
                this.#m_idum = 1;
            else
                this.#m_idum = -(this.#m_idum);
            for (j = NTAB + 7; j >= 0; j--) {
                k = Math.trunc((this.#m_idum) / IQ);
                this.#m_idum = Math.trunc(IA * (this.#m_idum - k * IQ) - IR * k);
                if (this.#m_idum < 0)
                    this.#m_idum += IM;
                if (j < NTAB)
                    this.#m_iv[j] = this.#m_idum;
            }
            this.#m_iy = this.#m_iv[0];
        }
        k = Math.trunc((this.#m_idum) / IQ);
        this.#m_idum = Math.trunc(IA * (this.#m_idum - k * IQ) - IR * k);
        if (this.#m_idum < 0)
            this.#m_idum += IM;
        j = Math.trunc(this.#m_iy / NDIV);
        // We're seeing some strange memory corruption in the contents of s_pUniformStream.
        // Perhaps it's being caused by something writing past the end of this array?
        // Bounds-check in release to see if that's the case.
        if (j >= NTAB || j < 0) {
            //DebuggerBreakIfDebugging();
            //Warning("CUniformRandomStream had an array overrun: tried to write to element %d of 0..31. Contact Tom or Elan.\n", j);
            // Ensure that NTAB is a power of two.
            //COMPILE_TIME_ASSERT( ( NTAB & ( NTAB - 1 ) ) == 0 );
            // Clamp j.
            j &= NTAB - 1;
        }
        this.#m_iy = this.#m_iv[j];
        this.#m_iv[j] = this.#m_idum;
        return this.#m_iy;
    }
    randomFloat(low = 0.0, high = 1.0) {
        let fl = AM * this.#generateRandomNumber();
        if (fl > RNMX) {
            fl = RNMX;
        }
        return fl * (high - low) + low;
    }
    randomFloatExp(low = 0.0, high = 1.0) {
        return Math.random() * (high - low) + low;
    }
    randomInt(low, high) {
        let x = (high - low) + 1;
        let n;
        if (x <= 1 || MAX_RANDOM_RANGE < x - 1) {
            return low;
        }
        let maxAcceptable = MAX_RANDOM_RANGE - ((MAX_RANDOM_RANGE + 1) % x);
        do {
            n = this.#generateRandomNumber();
        } while (n > maxAcceptable);
        return low + (n % x);
    }
}

const texturePathPrefixRemoveMe = '../gamecontent/tf2/materials/'; //TODOv3 : put in constants
class TextureCombiner {
    static #instance;
    #textureSize = DEFAULT_TEXTURE_SIZE;
    #team = 0;
    paintIds = {};
    imageExtension = '.vtf';
    textureApplyStickerNode = 'apply_sticker';
    pixelArray = null;
    lookupNodes = new Map();
    nodeImageEditor = new NodeImageEditor();
    //static #nodeImageEditorGui?: NodeImageEditorGui;// = new NodeImageEditorGui(this.nodeImageEditor);
    variables = {};
    constructor() {
        if (TextureCombiner.#instance) {
            return TextureCombiner.#instance;
        }
        TextureCombiner.#instance = this;
    }
    /*
        static initNodeImageEditorGui(): NodeImageEditorGui {
            if (!this.#nodeImageEditorGui) {
                this.#nodeImageEditorGui = new NodeImageEditorGui(this.nodeImageEditor);
            }
            return this.#nodeImageEditorGui;
        }
            */
    setTextureSize(textureSize) {
        this.#textureSize = textureSize;
        this.nodeImageEditor.textureSize = textureSize;
    }
    set team(t) {
        this.#team = t;
    }
    get team() {
        return this.#team;
    }
    async _getDefindex(CMsgProtoDefID) {
        return PaintKitDefinitions.getDefinition(CMsgProtoDefID);
    }
    async combinePaint(paintKitDefId, wearLevel, weaponDefIndex, outputTextureName, outputTexture, seed = 0n) {
        this.lookupNodes = new Map();
        let combinePaintPromise = new Promise(async (resolve, reject) => {
            if (paintKitDefId != undefined && wearLevel != undefined && weaponDefIndex != undefined) {
                this.nodeImageEditor.removeAllNodes();
                this.nodeImageEditor.clearVariables();
                var paintKitDefinition = await this._getDefindex({ type: 9, defindex: paintKitDefId });
                if (paintKitDefinition) {
                    let item = null;
                    for (let itemDefinitionKey in paintKitDefinition) {
                        let itemDefinitionPerItem = paintKitDefinition[itemDefinitionKey];
                        let itemDefinitionTemplate = itemDefinitionPerItem.itemDefinitionTemplate ?? itemDefinitionPerItem.item_definition_template;
                        if (itemDefinitionTemplate) {
                            let itemDefinition = await this._getDefindex(itemDefinitionTemplate);
                            if ((itemDefinition?.itemDefinitionIndex ?? itemDefinition?.item_definition_index) == weaponDefIndex) {
                                item = itemDefinitionPerItem;
                                break;
                            }
                        }
                    }
                    if (!item) {
                        //For legacy warpaints
                        let items = paintKitDefinition['item'];
                        if (items) {
                            for (let it of items) {
                                let itemDefinition = await this._getDefindex(it.itemDefinitionTemplate ?? it.item_definition_template);
                                if (getLegacyPaintKit(itemDefinition?.itemDefinitionIndex ?? itemDefinition?.item_definition_index) == weaponDefIndex) {
                                    item = it;
                                    break;
                                }
                            }
                        }
                    }
                    if (item) {
                        let template = paintKitDefinition.operationTemplate ?? paintKitDefinition.operation_template; // || item.itemDefinitionTemplate;
                        if (!template) {
                            let itemDefinitionTemplate = await this._getDefindex(item.itemDefinitionTemplate ?? item.item_definition_template);
                            if (itemDefinitionTemplate && itemDefinitionTemplate.definition && itemDefinitionTemplate.definition[wearLevel]) {
                                template = itemDefinitionTemplate.definition[wearLevel].operationTemplate ?? itemDefinitionTemplate.definition[wearLevel].operation_template;
                            }
                        }
                        if (template) {
                            let operationTemplate = await this._getDefindex(template);
                            //console.error(operationTemplate);//removeme
                            if (operationTemplate && (operationTemplate.operationNode ?? operationTemplate.operation_node)) {
                                await this.#setupVariables(paintKitDefinition, wearLevel, item);
                                let stage = await this.#processOperationNode((operationTemplate.operationNode ?? operationTemplate.operation_node)[0]); //top level node has 1 operation
                                //console.error(stage.toString());
                                stage.linkNodes();
                                function GetSeed(seed) {
                                    let hilo = [];
                                    hilo.push(BigInt(0));
                                    hilo.push(BigInt(0));
                                    for (let i = 0n; i < 32n; ++i) {
                                        let i2 = 2n * i;
                                        for (let j = 0n; j < 2n; ++j) {
                                            hilo[Number(j)] |= (seed & (1n << (i2 + j))) >> (i + j);
                                        }
                                    }
                                    return hilo;
                                }
                                let hi, lo;
                                [hi, lo] = GetSeed(seed);
                                let randomStreams = [new UniformRandomStream(Number(hi) << 0), new UniformRandomStream(Number(lo) << 0)];
                                stage.computeRandomValues({ currentIndex: 0 }, randomStreams, randomStreams.length);
                                await stage.setupTextures();
                                let finalNode = stage.node;
                                finalNode.autoRedraw = true;
                                finalNode.getOutput('output')._value = outputTexture;
                                /*
                                                                let processPixelArray = (pixelArray) => {
                                                                    this.pixelArray = pixelArray;
                                                                    if (outputTextureName) {
                                                                        //Source1TextureManager.addInternalTexture(this.#textureSize, this.#textureSize, pixelArray, outputTextureName);
                                                                        resolve(true);
                                                                        return;
                                                                    }
                                                                    reject(false);
                                                                }*/
                                //let pixelArray = await node.getOutput('output').pixelArray;
                                //console.error(await node.toString());
                                //processPixelArray(pixelArray);
                                finalNode.redraw().then(() => resolve(true), () => reject(false));
                                return;
                            }
                        }
                    }
                    reject(false);
                }
            }
            else {
                reject(false);
            }
            /*if (!finalPromise) {
                reject(false);
            }*/
        });
        return combinePaintPromise;
    }
    async #setupVariables(paintKitDefinition, wearLevel, item) {
        this.variables = {};
        if (item) {
            if (item.data) {
                this.#addVariables(item.data.variable);
            }
            if (item.itemDefinitionTemplate ?? item.item_definition_template) {
                let itemDefinition = await this._getDefindex(item.itemDefinitionTemplate ?? item.item_definition_template);
                if (itemDefinition) {
                    if (itemDefinition.definition && itemDefinition.definition[wearLevel]) {
                        this.#addVariables(itemDefinition.definition[wearLevel].variable);
                    }
                    if (itemDefinition.header) {
                        this.#addVariables2(itemDefinition.header.variables);
                    }
                }
            }
        }
        if (paintKitDefinition.header) {
            this.#addVariables2(paintKitDefinition.header.variables);
        }
    }
    #addVariables(variableArray) {
        if (variableArray) {
            for (let i = 0; i < variableArray.length; i++) {
                let v = variableArray[i];
                this.variables[v.variable] = v.string;
            }
        }
    }
    #addVariables2(variableArray) {
        if (variableArray) {
            for (let i = 0; i < variableArray.length; i++) {
                let v = variableArray[i];
                if ((v.inherit == false) || (this.variables[v.name] === undefined)) {
                    this.variables[v.name] = v.value;
                }
            }
        }
    }
    async #processOperationNodeArray(operationNodeArray /*, parentStage: Stage*/) {
        let chidren = [];
        for (var i = 0; i < operationNodeArray.length; i++) {
            let child = await this.#processOperationNode(operationNodeArray[i] /*, parentStage*/);
            if (child instanceof Array) {
                chidren.push(...child);
            }
            else {
                if (child) {
                    chidren.push(child);
                }
            }
        }
        return chidren;
    }
    #getStageName(stage) {
        switch (true) {
            case stage.textureLookup != undefined:
            case stage.texture_lookup != undefined:
                return 'textureLookup';
            case stage.combineAdd != undefined:
            case stage.combine_add != undefined:
                return 'combine_add';
            case stage.combineLerp != undefined:
            case stage.combine_lerp != undefined:
                return 'combine_lerp';
            case stage.combineMultiply != undefined:
            case stage.combine_multiply != undefined:
                return 'multiply';
            case stage.select != undefined:
                return 'select';
            case stage.applySticker != undefined:
            case stage.apply_sticker != undefined:
                return 'applySticker';
            default:
                throw 'Unsuported stage';
        }
    }
    async #processOperationNode(operationNode /*, parentStage: Stage/*, parentStage*/ /*, inputs*/) {
        let subStage = null;
        if (operationNode.stage) {
            let stage = operationNode.stage;
            let stage2 = null;
            let s;
            switch (true) {
                case stage.textureLookup != undefined:
                case stage.texture_lookup != undefined:
                    s = stage.textureLookup ?? stage.texture_lookup;
                    subStage = this.#processTextureStage(s);
                    stage2 = s;
                    break;
                case stage.combineAdd != undefined:
                case stage.combine_add != undefined:
                case stage.combineLerp != undefined:
                case stage.combine_lerp != undefined:
                case stage.combineMultiply != undefined:
                case stage.combine_multiply != undefined:
                    s = stage.combineAdd || stage.combine_add || stage.combineLerp || stage.combine_lerp || stage.combineMultiply || stage.combine_multiply;
                    subStage = this.#processCombineStage(s, this.#getStageName(stage));
                    stage2 = s;
                    break;
                case stage.select != undefined:
                    s = stage.select;
                    subStage = this.#processSelectStage(s);
                    stage2 = s;
                    break;
                case stage.applySticker != undefined:
                case stage.apply_sticker != undefined:
                    s = stage.applySticker ?? stage.apply_sticker;
                    subStage = this.#processApplyStickerStage(s);
                    stage2 = s;
                    break;
                default:
                    throw 'Unsuported stage';
            }
            if (stage2.operationNode ?? stage2.operation_node) {
                let chidren = await this.#processOperationNodeArray(stage2.operationNode ?? stage2.operation_node /*, subStage/*, node*/);
                if (subStage) {
                    subStage.appendChildren(chidren);
                }
            }
        }
        else if (operationNode.operationTemplate ?? operationNode.operation_template) {
            let template = await this._getDefindex(operationNode.operationTemplate ?? operationNode.operation_template);
            if (template && (template.operationNode ?? template.operation_node)) {
                //console.error('template.operationNode', template.operationNode.length, template.operationNode);
                let chidren = await this.#processOperationNodeArray(template.operationNode ?? template.operation_node /*, parentStage/*, node, inputs*/);
                return chidren;
            }
            else {
                throw 'Invalid template';
            }
        }
        else {
            throw 'Unsuported operationNode.operation_template';
        }
        /*
                if (false && subStage && node) {
                    let input = inputs.next().value;
                    console.error(input);
                    node.setPredecessor(input, subNode, 'output');
                }*/ /* else {
console.error('node or subnode is null', node, subNode);
}*/
        return subStage;
    }
    #processCombineStage(stage, combineMode) {
        let node = this.nodeImageEditor.addNode(combineMode);
        let combineStage = new CombineStage(node, combineMode);
        return combineStage;
    }
    /*
        async processCombineMultiplyStage(stage) {
            let node = this.nodeImageEditor.addNode('multiply');
            console.error('multiply');
            node.predecessorIndex = 0;
            /*if (stage.operationNode) {
                await this.#processOperationNodeArray(stage.operationNode, node);
            } else {
                throw 'Invalid stage';
            }* /
            return node;
        }

        async processCombineAddStage(stage) {
            let node = this.nodeImageEditor.addNode('combine_add');
            console.error('combine_add');
            node.predecessorIndex = 0;
            /*if (stage.operationNode) {
                await this.#processOperationNodeArray(stage.operationNode, node);
            } else {
                throw 'Invalid stage';
            }* /
            return node;
        }

        async processCombineLerpStage(stage) {
            let node = this.nodeImageEditor.addNode('combine_lerp');
            console.error('combine_lerp');
            node.predecessorIndex = 0;
            /*if (stage.operationNode) {
                await this.#processOperationNodeArray(stage.operationNode, node);
            } else {
                throw 'Invalid stage';
            }* /
            return node;
        }*/
    #processTextureStage(stage) {
        let node = null;
        var texture;
        if (this.#team == 0) {
            texture = (stage.textureRed ?? stage.texture_red) || stage.texture;
        }
        else {
            texture = (stage.textureBlue ?? stage.texture_blue) || stage.texture;
        }
        let texturePath = this.#getVarField(texture);
        texturePath = texturePath.replace(/\.tga$/, '');
        if (texturePath) {
            texturePathPrefixRemoveMe + texturePath + this.imageExtension;
            if (!node) {
                node = this.nodeImageEditor.addNode(TEXTURE_LOOKUP_NODE);
                node.setParam('path', texturePath);
            }
        }
        if (!node) {
            return;
        }
        let textureStage = new TextureStage(node);
        textureStage.texturePath = texturePath;
        if (stage.adjustBlack ?? stage.adjust_black) {
            ParseRangeThenDivideBy(textureStage.parameters.adjustBlack, this.#getVarField(stage.adjustBlack ?? stage.adjust_black));
        }
        if (stage.adjustOffset ?? stage.adjust_offset) {
            ParseRangeThenDivideBy(textureStage.parameters.adjustOffset, this.#getVarField(stage.adjustOffset ?? stage.adjust_offset));
        }
        if (stage.adjustGamma ?? stage.adjust_gamma) {
            ParseInverseRange(textureStage.parameters.adjustGamma, this.#getVarField(stage.adjustGamma ?? stage.adjust_gamma));
        }
        if (stage.scaleUv ?? stage.scale_uv) {
            ParseRange(textureStage.parameters.scaleUV, this.#getVarField(stage.scaleUv ?? stage.scale_uv));
        }
        if (stage.rotation) {
            ParseRange(textureStage.parameters.rotation, this.#getVarField(stage.rotation));
        }
        if (stage.translateU ?? stage.translate_u) {
            ParseRange(textureStage.parameters.translateU, this.#getVarField(stage.translateU ?? stage.translate_u));
        }
        if (stage.translateV ?? stage.translate_v) {
            ParseRange(textureStage.parameters.translateV, this.#getVarField(stage.translateV ?? stage.translate_v));
        }
        if (stage.flipU ?? stage.flip_u) {
            textureStage.parameters.allowFlipU = this.#getVarField(stage.flipU ?? stage.flip_u) != 0;
        }
        if (stage.flipV ?? stage.flip_v) {
            textureStage.parameters.allowFlipV = this.#getVarField(stage.flipV ?? stage.flip_v) != 0;
        }
        return textureStage;
    }
    #processSelectStage(stage) {
        let selectParametersNode = this.nodeImageEditor.addNode('int array', { length: 16 });
        let selectNode = this.nodeImageEditor.addNode('select');
        let selectStage = new SelectStage(selectNode, this.nodeImageEditor);
        selectNode.setPredecessor('selectvalues', selectParametersNode, 'output');
        if (stage.groups) {
            selectStage.texturePath = this.#getVarField(stage.groups);
        }
        if (stage.select) {
            //selectNode.params.threshold = [];
            let arr = stage.select;
            for (let i = 0; i < arr.length; i++) {
                let varField = arr[i];
                let level = this.#getVarField(varField);
                selectParametersNode.setValue(i, parseInt(level));
            }
        }
        selectNode.invalidate();
        return selectStage;
    }
    #processApplyStickerStage(stage) {
        let applyStickerNode = this.nodeImageEditor.addNode(this.textureApplyStickerNode);
        let applyStickerStage = new ApplyStickerStage(applyStickerNode);
        if (stage.adjustBlack ?? stage.adjust_black) {
            ParseRangeThenDivideBy(applyStickerStage.parameters.adjustBlack, this.#getVarField(stage.adjustBlack ?? stage.adjust_black));
        }
        if (stage.adjustOffset ?? stage.adjust_offset) {
            ParseRangeThenDivideBy(applyStickerStage.parameters.adjustOffset, this.#getVarField(stage.adjustOffset ?? stage.adjust_offset));
        }
        if (stage.adjustGamma ?? stage.adjust_gamma) {
            ParseInverseRange(applyStickerStage.parameters.adjustGamma, this.#getVarField(stage.adjustGamma ?? stage.adjust_gamma));
        }
        if (stage.destBl ?? stage.dest_bl) {
            ParseVec2(applyStickerStage.parameters.bl, this.#getVarField(stage.destBl ?? stage.dest_bl));
        }
        if (stage.destTl ?? stage.dest_tl) {
            ParseVec2(applyStickerStage.parameters.tl, this.#getVarField(stage.destTl ?? stage.dest_tl));
        }
        if (stage.destTr ?? stage.dest_tr) {
            ParseVec2(applyStickerStage.parameters.tr, this.#getVarField(stage.destTr ?? stage.dest_tr));
        }
        if (stage.sticker) {
            let arr = stage.sticker;
            for (let i = 0; i < arr.length; i++) {
                let operationSticker = arr[i];
                let sticker = new Sticker();
                sticker.fileName = this.#getVarField(operationSticker.base);
                if (operationSticker.weight) {
                    sticker.weight = this.#getVarField(operationSticker.weight) * 1.0;
                }
                applyStickerStage.parameters.possibleStickers.push(sticker);
            }
        }
        else {
            throw 'No sticker defined';
        }
        applyStickerNode.invalidate();
        return applyStickerStage;
    }
    #getVarField(field) {
        if (!field) {
            return null;
        }
        if (field.variable) {
            let v = this.variables[field.variable];
            if (v) {
                return v;
            }
        }
        return field.string;
    }
}
function ParseRange(output, input) {
    input = input.trim();
    let range = input.split(/\s+/);
    switch (range.length) {
        case 1:
            output.low = Number(range[0]);
            output.high = output.low;
            break;
        case 2:
            output.low = Number(range[0]);
            output.high = Number(range[1]);
            break;
        default:
            console.error('Wrong range expression : ', input);
            break;
    }
}
function ParseVec2(output, input) {
    input = input.trim();
    let range = input.split(' ');
    if (range.length == 2) {
        output[0] = Number(range[0]);
        output[1] = Number(range[1]);
    }
}
function ParseInverseRange(output, input) {
    ParseRange(output, input);
    if (output.low) {
        output.low = 1.0 / output.low;
    }
    if (output.high) {
        output.high = 1.0 / output.high;
    }
}
function ParseRangeThenDivideBy(output, input, div = 255) {
    ParseRange(output, input);
    output.low /= div;
    output.high /= div;
}

class WarpaintEditor {
    static #instance;
    #nodeImageEditorGui = new NodeImageEditorGui();
    constructor() {
        if (WarpaintEditor.#instance) {
            return WarpaintEditor.#instance;
        }
        WarpaintEditor.#instance = this;
    }
    init(container) {
        container.append(this.#nodeImageEditorGui.htmlElement);
        this.#nodeImageEditorGui.setNodeImageEditor(new TextureCombiner().nodeImageEditor);
    }
    getGui() {
        return this.#nodeImageEditorGui;
    }
}

const WeaponManagerEventTarget = new EventTarget();
class WeaponManager {
    static #instance;
    #htmlWeaponsDiv;
    #htmlPaintsDiv;
    weapons = {};
    collections = {};
    weaponName = '';
    paintkitName = '';
    asyncRequestId = 0;
    _protoElements = {};
    protoDefs = null;
    shouldRequestItems = true;
    itemsDef = null;
    itemsReady = false;
    containerPerWeapon = {};
    #itemQueue = [];
    currentItem;
    weaponId = 0;
    constructor() {
        if (WeaponManager.#instance) {
            return WeaponManager.#instance;
        }
        WeaponManager.#instance = this;
    }
    async initPaintKitDefinitions(url) {
        let response = await fetch(url);
        this.protoDefs = await response.json();
        await this.refreshPaintKitDefinitions();
    }
    async refreshPaintKitDefinitions() {
        let definitions = await PaintKitDefinitions.getWarpaintDefinitions();
        if (definitions) {
            this._protoElements = definitions;
            let paintKitDefinitions = definitions[9];
            for (let paintKitDefId in paintKitDefinitions) {
                let definition = paintKitDefinitions[paintKitDefId];
                let token = this.protoDefs ? this.protoDefs[(definition.locDesctoken ?? definition.loc_desctoken)] || (definition.locDesctoken ?? definition.loc_desctoken) : (definition.locDesctoken ?? definition.loc_desctoken);
                this.#addPaintKit(definition, token);
            }
        }
    }
    initView(container) {
        this.#htmlWeaponsDiv = document.createElement('div');
        this.#htmlWeaponsDiv.className = 'weaponsDiv';
        this.#htmlPaintsDiv = document.createElement('div');
        this.#htmlPaintsDiv.className = 'paintsDiv';
        if (container) {
            container.appendChild(this.#htmlWeaponsDiv);
            container.appendChild(this.#htmlPaintsDiv);
        }
    }
    #addPaintKit(paintKit, descToken) {
        let cMsgPaintKit_Definition = this._protoElements[9][paintKit.header.defindex];
        let paintKitItemDefinitions = this._protoElements[8];
        if (cMsgPaintKit_Definition) {
            let itemList = this.getItemList(cMsgPaintKit_Definition);
            for (let weaponName in itemList) {
                let itemDefinition = paintKitItemDefinitions[itemList[weaponName]];
                if (itemDefinition) {
                    this.#addWeapon(paintKit, paintKit.header.defindex, weaponName, itemList[weaponName], itemDefinition.itemDefinitionIndex ?? itemDefinition.item_definition_index, descToken);
                }
            }
        }
        return;
    }
    #addWeapon(paintKit, weaponPaint, weapon, defindex, itemDefinitionIndex, descToken) {
        //let wep = this.itemsDef?.[itemDefinitionIndex] || this.itemsDef?.[itemDefinitionIndex + '~0'] ;
        let wep = { name: weapon };
        if (wep) {
            var weaponDiv = this.containerPerWeapon[wep.name];
            if (!weaponDiv) {
                weaponDiv = document.createElement('div');
                weaponDiv.className = 'weaponDiv';
                this.#htmlPaintsDiv?.appendChild(weaponDiv);
                this.containerPerWeapon[wep.name] = weaponDiv;
                //weaponDiv.innerHTML = wep.name;
                let input = document.createElement('input');
                input.className = 'displayNone';
                input.id = 'weapon-' + this.weaponId;
                input.name = 'accordion';
                input.type = 'radio';
                let label = document.createElement('label');
                label.htmlFor = 'weapon-' + this.weaponId;
                label.innerHTML = wep.name;
                let subContainer = document.createElement('div');
                subContainer.className = 'paintsDiv';
                weaponDiv.subContainer = subContainer;
                weaponDiv.appendChild(input);
                weaponDiv.appendChild(label);
                weaponDiv.appendChild(subContainer);
                ++this.weaponId;
            }
            weaponDiv.subContainer;
            //weaponDiv.weaponPaint = weaponPaint;
            weaponDiv.weapon = weapon;
            weaponDiv.itemDefinitionIndex = itemDefinitionIndex;
            this.#htmlWeaponsDiv?.appendChild(weaponDiv);
            //this.#addPaintKit2(paintKit, subContainer, weapon, itemDefinitionIndex);
            WeaponManagerEventTarget.dispatchEvent(new CustomEvent('addpaintkit', {
                detail: {
                    p1: itemDefinitionIndex,
                    p2: weaponPaint,
                    p3: weapon,
                    p4: descToken
                }
            }));
        }
    }
    /*
         #addPaintKit2(paintKit, parent, weapon, itemDefinitionIndex) {
            var paintKitDiv = document.createElement('div');
            parent.appendChild(paintKitDiv);
            paintKitDiv.className = 'paintDiv';
            //paintKitDiv.weaponPaint = paintKit.header.defindex;
            paintKitDiv.setAttribute('data-weapon-paint', paintKit.header.defindex);
            paintKitDiv.innerText = paintKit.header.name;
            //paintKitDiv.itemDefinitionIndex = itemDefinitionIndex;
            paintKitDiv.setAttribute('data-item-definition-index', itemDefinitionIndex);
            //paintKitDiv.weapon = weapon;
            paintKitDiv.setAttribute('data-weapon', weapon);
            /*paintKitDiv.modelplayer = paintKit.modelplayer;
            paintKitDiv.weaponName = paintKit.name;* /
            paintKitDiv.addEventListener('click', (event) => handlePaintClick());

        }
        /*
    /*
         handlePaintClick() {
            let currentModel = '';
            if (this.itemDefinitionIndex) {
                let itemDef = this.itemsDef[this.itemDefinitionIndex] || this.itemsDef[this.itemDefinitionIndex + '~0'];
                if (itemDef && itemDef.model_player) {
                    currentModel = itemDef.model_player;
                }
            }
            weaponName = this.weaponName;
            this.paintkitName = this.innerHTML;
            setupModels();
            weaponPaint = this.weaponPaint;
            weapon = this.weapon;
            this.refreshPaint();
        }*/
    /*
         handleWeaponClick() {
            currentModel = '';
            if (this.itemDefinitionIndex) {
                let itemDef = this.itemsDef[this.itemDefinitionIndex] || this.itemsDef[this.itemDefinitionIndex + '~0'];
                if (itemDef && itemDef.model_player) {
                    currentModel = itemDef.model_player;
                }
            }
            weaponName = this.weaponName;
            this.paintkitName = this.innerHTML;
            setupModels();
            weaponPaint = this.weaponPaint;
            weapon = this.weapon;
            this.refreshPaint();
        }
    */
    getItemList(cMsgPaintKit_Definition) {
        let itemList = {};
        for (let propertyName in cMsgPaintKit_Definition) {
            let paintKitDefinitionItem = cMsgPaintKit_Definition[propertyName];
            if (paintKitDefinitionItem) {
                if (propertyName == 'item') {
                    for (let i = 0; i < paintKitDefinitionItem.length; i++) {
                        let paintKitDefinitionItem2 = paintKitDefinitionItem[i];
                        if (paintKitDefinitionItem2.itemDefinitionTemplate ?? paintKitDefinitionItem2.item_definition_template) {
                            //itemList.push(paintKitDefinitionItem2.itemDefinitionTemplate.defindex);
                            itemList['item' + i] = (paintKitDefinitionItem2.itemDefinitionTemplate ?? paintKitDefinitionItem2.item_definition_template).defindex;
                        }
                    }
                }
                else {
                    if (paintKitDefinitionItem.itemDefinitionTemplate ?? paintKitDefinitionItem.item_definition_template) {
                        //itemList.push(paintKitDefinitionItem.itemDefinitionTemplate.defindex);
                        itemList[propertyName] = (paintKitDefinitionItem.itemDefinitionTemplate ?? paintKitDefinitionItem.item_definition_template).defindex;
                    }
                }
            }
        }
        return itemList;
    }
    refreshPaint(item) {
        this.refreshItem(item);
    }
    /*
         handleCollectionClick(event) {
            if (this.collectionBody.style.display == 'none') {
                this.collectionBody.style.display = null;
                this.collectionBody.style.display = '';
            } else {
                this.collectionBody.style.display = 'none';
            }
        }*/
    /*
         setWeapon(weapon) {
            this.weapon = weapon;
            this.refreshPaint();
        }*/
    refreshItem(item, clearQueue = false) {
        if (clearQueue) {
            this.#itemQueue = [];
        }
        this.#itemQueue.push(item);
        this.processNextItemInQueue();
    }
    processNextItemInQueue() {
        if (!this.currentItem && this.#itemQueue.length) {
            this.currentItem = this.#itemQueue.shift();
            let ci = this.currentItem;
            let { name: textureName, texture } = Source1TextureManager.addInternalTexture();
            texture.setAlphaBits(8);
            if (ci.paintKitId !== null) {
                let promise = new TextureCombiner().combinePaint(ci.paintKitId, ci.paintKitWear, ci.id.replace(/\~\d+/, ''), textureName, texture, ci.paintKitSeed);
                ci.sourceModel.materialsParams['WeaponSkin'] = textureName;
                //this._textureCombiner.nodeImageEditor.setOutputTextureName(textureName);
                promise.then((e) => {
                    //console.error('Promise processNextItemInQueue OK');
                    this.currentItem = null;
                    this.processNextItemInQueue();
                });
                promise.catch((e) => {
                    console.error('Promise processNextItemInQueue KO');
                    this.currentItem = null;
                    this.processNextItemInQueue();
                });
            }
            else {
                this.currentItem = null;
                this.processNextItemInQueue();
            }
        }
    }
}
/*
const collections = {
'concealedkiller':'Concealed Killer Collection',
'craftsmann':'Craftsmann Collection',
'teufort':'Teufort Collection',
'powerhouse':'Powerhouse Collection',
'harvest':'Harvest',
'pyroland':'Pyroland',
'gentlemanne':'Gentlemanne',
'warbird':'Warbird',
'weaponcase':'Weapon cases',
}*/
/*
const wearLevel = ['Factory New', 'Minimal Wear', 'Field-Tested', 'Well-Worn', 'Battle Scarred'];

WeaponManager.weapons = {
flamethrower : 7,
grenadelauncher : 8,
knife : 9,
medigun : 10,
minigun : 11,
pistol : 12,
revolver : 13,
rocketlauncher : 14,
scattergun : 15,
shotgun : 16,
smg : 17,
sniperrifle : 18,
stickybomb_launcher : 19,
ubersaw : 20,
wrench : 21,
amputator : 22,
atom_launcher : 23,
back_scratcher : 24,
battleaxe : 25,
bazaar_sniper : 26,
blackbox : 27,
claidheamohmor : 28,
crusaders_crossbow : 29,
degreaser : 30,
demo_cannon : 31,
demo_sultan_sword : 32,
detonator : 33,
gatling_gun : 34,
holymackerel : 35,
jag : 36,
lochnload : 37,
powerjack : 38,
quadball : 39,
reserve_shooter : 40,
riding_crop : 41,
russian_riot : 42,
scimitar : 43,
scorch_shot : 44,
shortstop : 45,
soda_popper : 46,
tele_shotgun : 47,
tomislav : 48,
trenchgun : 49,
winger_pistol : 50
}
*/

var timelineCSS = ":host {\n\tdisplay: flex;\n\twidth: 100%;\n\tbackground-color: black;\n\tflex-direction: column;\n\tuser-select: none;\n\t--group-padding: var(--harmony3d-timeline-group-padding, 0.5rem);\n\t--clip-height: var(--harmony3d-timeline-clip-height, 2rem);\n\t--time-scale: var(--harmony3d-timeline-time-scale, 2rem);\n\n\t--ruler-num-c: #888;\n\t--ruler-num-fz: 10px;\n\t--ruler-num-pi: 0.75ch;\n\t--ruler-unit: 1px;\n\t--ruler-x: 1;\n\t--ruler-y: 1;\n\n\t--ruler1-bdw: 1px;\n\t--ruler1-c: #BBB;\n\t--ruler1-h: 8px;\n\t--ruler1-space: 5;\n\n\t--ruler2-bdw: 1px;\n\t--ruler2-c: #BBB;\n\t--ruler2-h: 20px;\n\t--ruler2-space: 50;\n\n\t--timeline-offset-x: 0;\n}\n\n.timeline {\n\tbackground-color: blueviolet;\n\tposition: relative;\n}\n\n.group {\n\tbackground-color: chocolate;\n}\n\n.channel {\n\tbackground-color: darkgreen;\n}\n\n.group>.content {\n\t/*padding: 1rem;*/\n\tborder: 0.05rem solid;\n}\n\n.channel>.content {\n\theight: 2rem;\n\toverflow: auto;\n}\n\n.clip {\n\tbackground-color: darkmagenta;\n\tdisplay: inline-block;\n\tposition: absolute;\n}\n\n.clip .content {\n\toverflow: hidden;\n\twhite-space: nowrap;\n\ttext-overflow: ellipsis;\n\n}\n\n\n.ruler-x {\n\tcursor: grab;\n\tposition: relative;\n\t/* Low ticks */\n\t--ruler1-bdw: 1px;\n\t--ruler1-c: #BBB;\n\t--ruler1-h: 8px;\n\t--ruler1-space: 5;\n\n\t/* Tall ticks */\n\t--ruler2-bdw: 1px;\n\t--ruler2-c: #BBB;\n\t--ruler2-h: 20px;\n\t--ruler2-space: 50;\n\n\n\tbackground-image:\n\t\tlinear-gradient(90deg, var(--ruler1-c) 0 var(--ruler1-bdw), transparent 0),\n\t\tlinear-gradient(90deg, var(--ruler2-c) 0 var(--ruler2-bdw), transparent 0);\n\tbackground-repeat: repeat-x;\n\tbackground-size:\n\t\tcalc(var(--ruler-unit) * var(--ruler1-space)) var(--ruler1-h),\n\t\tcalc(var(--ruler-unit) * var(--ruler2-space)) var(--ruler2-h);\n\tbackground-position-x: calc(var(--ruler-unit) * var(--timeline-offset-x)), calc(var(--ruler-unit) * var(--timeline-offset-x));\n\t--offset-count: round(down, var(--timeline-offset-x), var(--ruler2-space));\n\t--offset-count: round(down, var(--timeline-offset-x) / var(--ruler2-space), 1);\n\n\tpadding-left: calc(var(--ruler-unit) * (var(--timeline-offset-x) - var(--offset-count) * var(--ruler2-space)));\n\tcolor: var(--ruler-num-c);\n\tcounter-reset: d calc(-1 - var(--offset-count));\n\tdisplay: flex;\n\tfont-size: var(--ruler-num-fz);\n\theight: var(--ruler2-h);\n\tinset-block-start: 0;\n\t/*inset-inline-start: calc(var(--ruler-unit) * var(--ruler2-space));*/\n\tline-height: 1;\n\tlist-style: none;\n\tmargin: 0;\n\topacity: var(--ruler-x);\n\toverflow: hidden;\n\t/*padding: 0;*/\n\tposition: relative;\n\twidth: 100%;\n}\n\n.ruler-x.grabbing {\n\tcursor: grabbing;\n}\n\n\n\n.ruler-x li {\n\talign-self: flex-end;\n\tcounter-increment: d;\n\tflex: 0 0 calc(var(--ruler-unit) * var(--ruler2-space));\n\tpointer-events: none;\n}\n\n.ruler-x li::after {\n\tcontent: counter(d);\n\tline-height: 1;\n\tpadding-inline-start: var(--ruler-num-pi);\n}\n\n.cursor {\n\tposition: absolute;\n\theight: 100%;\n\twidth: 1rem;\n}\n";

class HTMLTimelineElement extends HTMLElement {
    #shadowRoot;
    #htmlContainer;
    #htmlRuler;
    #htmlContent;
    #htmlCursor;
    #childs = new Map();
    #timeline;
    #timescale = 30;
    #timeOffset = 0;
    #startTimeOffset = 0;
    #dragRuler = false;
    #dragRulerStartOffsetX = 0;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, timelineCSS);
        this.#htmlContainer = createElement('div', {
            class: 'timeline',
            parent: this.#shadowRoot,
            childs: [
                this.#htmlRuler = createElement('ul', {
                    class: 'ruler-x',
                    innerHTML: '<li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li>',
                    events: {
                        mousedown: (event) => this.#startDragRuler(event),
                    }
                }),
                this.#htmlContent = createElement('div', { class: 'content' }),
                this.#htmlCursor = createElement('div', { class: 'cursor' }),
            ]
        });
        document.addEventListener('mousemove', (event) => this.#handleMouseMove(event));
        document.addEventListener('mouseup', (event) => this.#handleMouseUp(event));
    }
    setTimeline(timeline) {
        this.#timeline = timeline;
        this.#updateHTML();
    }
    #updateElement(element) {
        if (element == this.#timeline) {
            this.#updateHTML();
        }
        else {
            switch (element.type) {
                case TimelineElementType.Group:
                    this.#updateGroup(element);
                    break;
                case TimelineElementType.Channel:
                    this.#updateChannel(element);
                    break;
                case TimelineElementType.Clip:
                    this.#updateClip(element);
                    break;
                default:
                    //throw 'code this case ' + this.#timeline.type;
                    console.error('code this case ' + element.type);
            }
        }
    }
    #updateHTML() {
        //this.#htmlHeader.innerText = '';
        this.#htmlContent.innerText = '';
        if (!this.#timeline) {
            return;
        }
        this.#updateTime();
        //this.#htmlHeader.innerText = (this.#timeline as TimelineElement).getPropertyValue('name');
        const root = this.#timeline?.getRoot();
        if (!root) {
            return;
        }
        const h = this.#getChild(root);
        if (h) {
            this.#htmlContent.replaceChildren(h.html);
        }
        this.#updateElement(root);
    }
    #updateTime() {
        //const rect = this.#htmlTimeline.getBoundingClientRect();
        //const width = rect.width;
        //const ticks =
    }
    #updateGroup(group) {
        const htmlGroup = this.#getChild(group);
        if (!htmlGroup) {
            return;
        }
        //this.#htmlContainer.classList.add('group');
        const name = group.getName();
        if (name) {
            show(htmlGroup.htmlHeader);
            htmlGroup.htmlHeader.innerText = name;
        }
        else {
            hide(htmlGroup.htmlHeader);
        }
        for (const child of group.getChilds()) {
            const h = this.#getChild(child);
            if (h) {
                //this.#htmlContent.replaceChildren(h.html);
                htmlGroup.htmlContent.append(h.html);
                this.#updateElement(child);
            }
        }
    }
    #updateChannel(channel) {
        const htmlChannel = this.#getChild(channel);
        if (!htmlChannel) {
            return;
        }
        //this.#htmlContainer.classList.add('group');
        const name = channel.getName();
        if (name) {
            show(htmlChannel.htmlHeader);
            htmlChannel.htmlHeader.innerText = name;
        }
        else {
            hide(htmlChannel.htmlHeader);
        }
        for (const clip of channel.getClips()) {
            const h = this.#getChild(clip);
            if (h) {
                //this.#htmlContent.replaceChildren(h.html);
                htmlChannel.htmlContent.append(h.html);
                this.#updateElement(clip);
            }
        }
        /*
        this.#htmlContainer.classList.add('channel');
        const name = (this.#timeline as TimelineChannel).getPropertyValue('name') as string;
        if (name) {
            show(this.#htmlHeader);
            this.#htmlHeader.innerText = name;
        } else {
            hide(this.#htmlHeader);
        }
            */
    }
    #updateClip(clip) {
        const htmlClip = this.#getChild(clip);
        if (!htmlClip) {
            return;
        }
        htmlClip.html.innerText = clip.getName();
        htmlClip.html.style.left = `${clip.getStartTime()}px`;
        htmlClip.html.style.width = `${clip.getLength()}px`;
        /*
        this.#htmlContainer.classList.add('clip');
        const name = (this.#timeline as TimelineClip).getPropertyValue('name') as string;
        if (name) {
            show(this.#htmlHeader);
            this.#htmlHeader.innerText = name;
        } else {
            hide(this.#htmlHeader);
        }

        */
    }
    #getChild(element) {
        let html /*TODO: fix type*/ = this.#childs.get(element);
        if (!html) {
            //html = createElement('div') as HTMLTimelineElement;
            //html.setTimelineElement(element);
            html = this.#createChild(element);
            this.#childs.set(element, html);
        }
        return html;
    }
    #createChild(element) {
        let htmlHeader, htmlContent;
        switch (element.type) {
            case TimelineElementType.Group:
                const htmlGroup = createElement('div', {
                    class: 'group',
                    childs: [
                        htmlHeader = createElement('div', { class: 'header' }),
                        htmlContent = createElement('div', { class: 'content' }),
                    ]
                });
                return {
                    html: htmlGroup,
                    htmlHeader: htmlHeader,
                    htmlContent: htmlContent,
                };
            case TimelineElementType.Channel:
                const htmlChannel = createElement('div', {
                    class: 'channel',
                    childs: [
                        htmlHeader = createElement('div', { class: 'header' }),
                        htmlContent = createElement('div', { class: 'content' }),
                    ]
                });
                return {
                    html: htmlChannel,
                    htmlHeader: htmlHeader,
                    htmlContent: htmlContent,
                };
            case TimelineElementType.Clip:
                const htmlClip = createElement('div', {
                    class: 'clip',
                    childs: [
                        htmlHeader = createElement('div', { class: 'header' }),
                        htmlContent = createElement('div', { class: 'content' }),
                    ]
                });
                return {
                    html: htmlClip,
                    htmlHeader: htmlHeader,
                    htmlContent: htmlContent,
                };
            default:
                //throw 'code this case ' + this.#timeline.type;
                console.error('code this case ' + element.type);
        }
    }
    setTimeOffset(offset) {
        this.#htmlContainer.style.setProperty('--timeline-offset-x', String(offset));
        this.#timeOffset = offset;
    }
    #startDragRuler(event) {
        if (this.#dragRuler) {
            return;
        }
        this.#htmlRuler.classList.add('grabbing');
        this.#dragRuler = true;
        this.#dragRulerStartOffsetX = event.offsetX;
        this.#startTimeOffset = this.#timeOffset;
    }
    #handleMouseMove(event) {
        if (!this.#dragRuler) {
            return;
        }
        this.#moveRuler(event.offsetX);
    }
    #handleMouseUp(event) {
        if (!this.#dragRuler) {
            return;
        }
        this.#htmlRuler.classList.remove('grabbing');
        this.#dragRuler = false;
    }
    #moveRuler(offsetX) {
        this.setTimeOffset(this.#startTimeOffset + offsetX - this.#dragRulerStartOffsetX);
    }
}
let definedTimelineElement = false;
function defineTimelineElement() {
    if (window.customElements && !definedTimelineElement) {
        customElements.define('harmony3d-timeline', HTMLTimelineElement);
        definedTimelineElement = true;
    }
}

var repositoryEntryCSS = ":host {\n\t--harmony-2d-manipulator-shadow-hover-bg-color: var(--harmony-2d-manipulator-hover-bg-color, red);\n\tuser-select: none;\n}\n\n.header {\n\tdisplay: flex;\n}\n\n.header:hover {\n\tbackground-color: var(--harmony-2d-manipulator-shadow-hover-bg-color);\n}\n\n.self {\n\tflex: 1;\n}\n\n.custom {\n\tdisplay: block;\n\tflex: 0;\n}\n";

class HTMLRepositoryEntryElement extends HTMLElement {
    #shadowRoot;
    #repositoryEntry;
    #htmlSelf;
    #htmlChilds;
    #expanded = false;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, repositoryEntryCSS);
        createElement('div', {
            class: 'header',
            parent: this.#shadowRoot,
            childs: [
                this.#htmlSelf = createElement('div', {
                    class: 'self',
                    events: {
                        click: () => this.#click(),
                    },
                }),
                createElement('slot', {
                    class: 'custom',
                    name: 'custom',
                    parent: this.#shadowRoot,
                })
            ],
        });
        this.#htmlChilds = createElement('div', {
            class: 'childs',
            parent: this.#shadowRoot,
            hidden: true
        });
        I18n.observeElement(this.#shadowRoot);
    }
    setRepositoryEntry(repositoryEntry) {
        this.#repositoryEntry = repositoryEntry;
        this.#updateHTML();
    }
    #updateHTML() {
        this.#htmlSelf.innerText = this.#repositoryEntry?.getName() ?? '';
        this.#htmlChilds.innerText = '';
        if (this.#repositoryEntry) {
            for (const entry of this.#repositoryEntry.getChilds()) {
                const entryview = createElement('harmony3d-repository-entry', {
                    parent: this.#htmlChilds,
                });
                entryview.setRepositoryEntry(entry);
            }
        }
    }
    #click() {
        if (!this.#repositoryEntry) {
            return;
        }
        if (this.#repositoryEntry.isDirectory()) {
            this.#toggle();
            this.dispatchEvent(new CustomEvent('directoryclick', { detail: this.#repositoryEntry }));
        }
        else {
            this.dispatchEvent(new CustomEvent('fileclick', { detail: this.#repositoryEntry }));
        }
    }
    #toggle() {
        if (this.#expanded) {
            this.#collapse();
        }
        else {
            this.#expand();
        }
    }
    #collapse() {
        hide(this.#htmlChilds);
        this.#expanded = false;
        this.dispatchEvent(new CustomEvent('collapse', { detail: this.#repositoryEntry }));
    }
    #expand() {
        show(this.#htmlChilds);
        this.#expanded = true;
        this.dispatchEvent(new CustomEvent('expand', { detail: this.#repositoryEntry }));
    }
}
let definedRepositoryEntry = false;
function defineRepositoryEntry() {
    if (window.customElements && !definedRepositoryEntry) {
        customElements.define('harmony3d-repository-entry', HTMLRepositoryEntryElement);
        definedRepositoryEntry = true;
    }
}

var repositoryCSS = ":host {\n\tuser-select: none;\n\tpadding: 0.5rem;\n\tmargin: 0.5rem;\n\tdisplay: flex;\n\tflex-direction: column;\n\tborder: 0.1rem solid;\n}\n\n.header {\n\tdisplay: flex;\n}\n\n.title {\n\tflex: 1;\n}\n\n.close {\n\tcursor: pointer;\n}\n";

var RepositoryDisplayMode;
(function (RepositoryDisplayMode) {
    RepositoryDisplayMode["Flat"] = "flat";
    RepositoryDisplayMode["Tree"] = "tree";
})(RepositoryDisplayMode || (RepositoryDisplayMode = {}));
class HTMLRepositoryElement extends HTMLElement {
    #shadowRoot;
    #htmlTitle;
    #htmlEntries;
    #repository;
    #displayMode = RepositoryDisplayMode.Flat;
    #filter;
    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        shadowRootStyle(this.#shadowRoot, repositoryCSS);
        createElement('div', {
            parent: this.#shadowRoot,
            class: 'header',
            childs: [
                this.#htmlTitle = createElement('div', { class: 'title' }),
                createElement('div', {
                    class: 'close',
                    parent: this.#shadowRoot,
                    child: createElement('span', { innerHTML: closeSVG }),
                    events: {
                        click: () => {
                            this.remove();
                            this.dispatchEvent(new CustomEvent('close'));
                        },
                    },
                }),
            ]
        });
        this.#htmlEntries = createElement('div', {
            parent: this.#shadowRoot,
        });
    }
    setRepository(repository) {
        this.#repository = repository;
        this.#updateHTML();
    }
    setFilter(filter) {
        this.#filter = filter;
        this.#updateHTML();
    }
    setDisplayMode(mode) {
        this.#displayMode = mode;
        this.#updateHTML();
    }
    adoptStyleSheet(styleSheet) {
        this.#shadowRoot.adoptedStyleSheets.push(styleSheet);
    }
    async #updateHTML() {
        this.#htmlTitle.innerText = this.#repository?.name ?? '';
        this.#htmlEntries.innerText = '';
        if (!this.#repository) {
            return;
        }
        const response = await this.#repository.getFileList();
        if (response.error) {
            return;
        }
        if (!response.root) {
            return;
        }
        defineRepositoryEntry();
        switch (this.#displayMode) {
            case RepositoryDisplayMode.Flat:
                this.#updateFlat(response.root);
                break;
            case RepositoryDisplayMode.Tree:
                this.#updateTree(response.root);
                break;
        }
    }
    async #updateFlat(root) {
        defineRepositoryEntry();
        for (const entry of root.getAllChilds(this.#filter)) {
            const entryview = createElement('harmony3d-repository-entry', {
                parent: this.#htmlEntries,
                events: {
                    fileclick: (event) => this.dispatchEvent(cloneEvent(event)),
                    directoryclick: (event) => this.dispatchEvent(cloneEvent(event)),
                },
            });
            entryview.setRepositoryEntry(entry);
            this.dispatchEvent(new CustomEvent('entrycreated', { detail: { entry: entry, view: entryview } }));
        }
    }
    async #updateTree(root) {
        defineRepositoryEntry();
        const entryview = createElement('harmony3d-repository-entry', {
            parent: this.#htmlEntries,
            events: {
                fileclick: (event) => this.dispatchEvent(cloneEvent(event)),
                directoryclick: (event) => this.dispatchEvent(cloneEvent(event)),
            },
        });
        entryview.setRepositoryEntry(root);
        this.dispatchEvent(new CustomEvent('entrycreated', { detail: { entry: root, view: entryview } }));
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'display-mode':
                this.setDisplayMode(newValue);
                break;
        }
    }
    static get observedAttributes() {
        return ['display-mode'];
    }
}
let definedRepository = false;
function defineRepository() {
    if (window.customElements && !definedRepository) {
        customElements.define('harmony3d-repository', HTMLRepositoryElement);
        definedRepository = true;
    }
}

export { index$2 as GlMatrix, HTMLRepositoryElement, HTMLRepositoryEntryElement, HTMLTimelineElement, index as Harmony3D, index$1 as HarmonyUi, RepositoryDisplayMode, TextureCombiner, WarpaintEditor, WeaponManager, WeaponManagerEventTarget, defineRepository, defineRepositoryEntry, defineTimelineElement };
